// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "¿Confirmar?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Sí";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "Aceptar";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Cancelar";

// Name of an item (object, tool, etc)
item.name = "Nombre";
// Add a new item (object, tool, etc)
item.new = "Crear";
// Rename an item (object, tool, etc)
item.rename = "Renombrar";
// Add a new item (object, tool, project, etc)
item.add = "Añadir";
// Save an item (object, tool, etc)
item.save = "Guardar";
item.save.confirm = "¿Confirmar guardado?";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Último guardado";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "¿Cargar último guardado?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Restablecer";
item.reset.confirm = "¿Confirmar restablecido?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "Crear instancia";
// Uninstance the object, make the object real
item.uninstance = "Anular instancia";
// Clone an item (object, tool, etc)
item.clone = "Clonar";
// Delete an item (object, tool, etc)
item.delete = "Eliminar";
item.delete.confirm = "¿Confirmar eliminación?";
item.delete.confirm.yes = "Sí, eliminar";
// When we delete the item but the image is used somewhere
item.delete.imageUsed = "La usan las siguientes herramientas:";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "A nodo";
// Item visibility (object, layer, etc)
item.visible = "Visible";
// Show an item (object, layer, etc)
item.show = "Mostrar";
// Hide an item (object, layer, etc)
item.hide = "Ocultar";
// Select an item (object, layer, etc)
item.select = "Seleccionar";
// Unselect an item (object, layer, etc)
item.unselect = "Deseleccionar";
// Merge an item with another one below (layer)
item.mergeDown = "Fusionar hacia bajo";
// The order of an item in a list
item.order = "Orden";
// Focus on previous item
item.previous = "Anterior";
// Focus on next item
item.next = "Siguiente";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "Bloquear";

// Three-state toggle button (Auto, Off, On)
toggle.on = "Activado";
// Three-state toggle button (Auto, Off, On)
toggle.off = "No";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "Automático";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Faltan miniaturas, reprocesamiento de archivos... ($0/$1)

$2";
loading.reprocess.cancel = "Skip thumbnails generation?";

// Color of an object
material.color = "Color";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "Aspereza";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "Brillo";
// Whether the material is a metal or not
material.metalness = "Metalicidad";
// How much light a surface will reflect
material.specular = "Especular";
// Light that the surface can emit (glow)
material.emissive = "Emisivo";
// Normal map (synonym: detail, bump)
material.normal = "Normal";
// Ambient Occlusion (AO)
material.occlusion = "Oclusión";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "Texturas";

// Minify
about.minify = "Minimizar la interfaz de usuario";
about.minify.help = "También puedes pulsar la pantalla con 4 dedos, si el dispositivo lo admite.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Placa giratoria";
// Make the entire scene turn around (speed of the animation)
about.turntableSpeed = "Velocidad de la placa giratoria";
// Stuffs that I used to make the app
about.credits = "Créditos";
// Link to open source projects that I used for the app
about.credits.openSource = "Código abierto";
// Only translate the &
about.credits.arts = "MatCaps y Hdris";
// Change languages of the app
about.languages = "Idiomas";
about.languages.help = "El archivo de traducción está disponible en $0";
// Link to the App Website
about.website = "Sitio web";
// Link to the App Forum
about.forum = "Foro";
// Link to the App Manual
about.manual = "Manual";
// Link to the App Email
about.mail = "Soporte";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";

// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "¡El objeto no tiene agujeros!";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "¡La malla actual es invisible!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Nada que recortar.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Cancelar recorte: la malla está completamente recortada.";
// In order to extract something, the mesh needs to have painted mask
alert.mask.noExtract = "¡Nada que extraer!";
// In order to split something, the mesh needs to have painted mask
alert.mask.noSplit = "¡Nada que dividir!";
// List of disabled features when View Mode is selected
alert.view.disabled = "Funciones deshabilitadas en el modo de vista:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Widgets primitivos";
// The object needs to have two parts disconnected
alert.separate.fail = "No se pudo separar: ¡el objeto tiene una sola parte!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "¡Malla reforzada!";
alert.voxelRemesh.empty = "Cancelar refuerzo de malla: La malla resultante no tiene caras.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "¡Entrada no válida!";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "El objeto se duplicará";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "Se creará una instancia del objeto";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Modo de edición de pivote.";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "Modo de edición de objetos.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Dynamic topology ON";
// See Glossary (DynTopo)
alert.dynamic.disable = "Dynamic topology OFF";
alert.colorPicker = "Arrastra el dedo sobre la malla para elegir un color.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Pulsa para salir del modo de transformación.";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "Simple tap to exit edit symmetry mode.";
alert.view.reset = "Restablecer vista";
// Snap the view to the nearest aligned 90° angle
alert.view.snap = "Vista instantánea";
// Show the painted mask on the mesh
alert.mask.show = "Mostrar máscara";
// Hide the painted mask on the mesh
alert.mask.hide = "Ocultar máscara";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Selección de bloqueo";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Selección de desbloqueo";
// Hide the objects that are not selected
alert.selection.isolate = "Selección de aislado";
// Show the objects that are hidden
alert.selection.showAll = "Mostrar todo";
// Project quick saving
alert.quickSave = "Guardando...";
// Painting on the object was hidden but the user did paint the object
alert.forceShowPainting.fill = "Mostrar pintura activada, se utilizó [Pintar todo].";
// Painting on the object was hidden but the user started to paint on the object
alert.forceShowPainting.tool = "Mostrar pintura activada, el objeto fue pintado.";
// See Glossary (Multiresolution)
alert.multiresLost = "¡La multirresolución se perderá!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "El valor de detalle es alto y puede requerir mucha memoria";
// Autosave popup
alert.autoSave.auto = "Guardar automáticamente en... $0s";
// The selected object doesn't have any layers
alert.needLayer = "La herramienta actual requiere una capa activa.";
// The user decides to hide the painting on the objects
alert.paintingHidden = "Pintura oculta: muéstrela de nuevo en el panel de configuración.";
// The selected object doesn't have any layers
alert.noPartialWireframe = "El dibujo parcial se desactiva cuando se muestra el esquema de página.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Considera la posibilidad de utilizar una cámara ortográfica si quieres evitar la distorsión de tronco de perspectiva al utilizar el proyector de pantalla.";
// Trial version has a limited number of undo
alert.state.trial = "Deshacer cancelación: versión de prueba";

background = "Fondo";
// A flat color will be displayed in the background of the scene
background.color = "Color";
// The environment (HDRI) will be displayed in the background
background.environment = "Entorno";
background.blur = "Borroso";
background.exposure = "Exposición";

// Image that the artist uses as a reference
background.imageEnable = "Imagen de referencia";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Superposición";
// Opposite of transparency (Alpha)
background.imageAlpha = "Alfa";
background.imageReset = "Restablecer configuración";
background.imageTransform = "Transformar";
// X screen coordinate of the image reference
background.imageX = "Posición X";
// Y screen coordinate of the image reference
background.imageY = "Posición Y";
// Rotation of the reference image
background.imageRotation = "Rotación";
// Scale of the reference image
background.imageScale = "Escala";

// Camera (point of view in 3d)
camera = "Cámara";
// Copy the views
camera.updateView = "¿Actualizar el punto de vista?";
// Add a new camera
camera.addView = "Añadir vista";
// Focus on the camera
camera.focus = "Centrar";
// Add on the camera camera
camera.focusOn = "Centrar";
// Camera projection, Orthographic or Perspective
camera.projection = "Proyección";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Ortográfica";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Perspectiva";
// camera Vertical Field of View
camera.fov = "Campo de visión vertical";
// Camera Field of View hint
camera.focal = "distancia focal $0 mm (sensor de 35 mm)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Modo órbita";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "Placa giratoria";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Bola de desplazamiento";
camera.rotation.trackball.help = "La bola de desplazamiento te da más grados de libertad. También puedes rodar la cámara con 2 dedos.";
// Camera interaction mode, 1st person view
camera.firstPerson = "Primera persona";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Velocidad";
// Camera rotation sensitivity
camera.speed.rotation = "Rotación";
// Camera panning sensitivity
camera.speed.panning = "Hacer panorámica";
// Camera zooming sensitivity
camera.speed.zooming = "Zoom";
// Reset camera position
camera.resetView = "Restablecer vista";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Capturar vista";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "La cámara tiene ajuste (ortográfico)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "Ajuste ortográfico";
camera.snapOrthographic.help = "Esta opción también funciona al usar Capturar cubo en la esquina.";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Update pivot...";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Pulsar dos veces en la malla";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Pulsar dos veces en el fondo";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "Activar/desactivar";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "Selección";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "Escena";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "When double tapping";
camera.doubleTapPivot.help = "Actualiza el pivote de rotación al pulsar dos veces la superficie del objeto.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "Allow air pivot";
camera.airPivot.help = "Permite un nuevo pivote incluso al hacer zoom fuera de la superficie del objeto.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "When camera starts moving";
camera.autoPivot.help = "Actualiza el pivote cuando comiences a interactuar con la cámara.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Centrar";
camera.doubleTapFocus.help = "Al pulsar dos veces la malla, la cámara se desplazará y enfocará en el punto seleccionado.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "Multiselección";
// There is 0 nodes/items selected
context.noSelection = "No hay nada seleccionado";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "Ajustes prestablecidos";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "Spline";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "Display the falloff in a symmetric way.

This option is only a visual cue, it doesn't impact the falloff itself";

// set the desired FPS (frame per second, refresh rate)
debug.targetFPS = "Target FPS";
debug.targetFPS.help = "When disabled, the default value means it will sync with the display's refresh rate.";

// Debug option, the newly created primitives will contains texture coordinates (UVs)
debug.uvPrimitive = "Mantén los UV primitivos";
debug.uvPrimitive.warning = "Deshabilita esta opción si no necesitas UV (memoria adicional).";
debug.uvPrimitive.help = "Por ahora, solo se admiten Box y Sphere.

En el futuro se admitirán otros tipos.";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "Normalizar UV";
debug.uvNormalize.help = "Nomad normalizará los UV dentro del mosaico [0-1].";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "Añadir UV de BFF";
debug.uvBFF.help = "Agrega un método alternativo de desenvolver (primer aplanamiento de límites).

Ten en cuenta que BFF producirá superposiciones si tu topología de malla es diferente de un disco o una esfera.";
// Debug option, display an window with some debugging logs
debug.logs = "Registros";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Mapa de alturas";
// Debug options, graphical stuffs
debug.graphics = "Gráficos";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Crear miniaturas de tienda";

// Empty list: there is no projects
file.project.empty = "¡Aún no tienes ningún proyecto guardado!";
// The current opened project has some unsaved changes
file.project.unsaved = "¡Cambios no guardados!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "¡Perderá los cambios no guardados!";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Vista previa de lo último guardado manualmente";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "Versión de prueba: ¡No podrás volver a abrir el proyecto actual!";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "Versión de prueba: ¡Solo puedes volver a abrir el proyecto actual!";

file.project = "Proyecto";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Guardar";
// E.g: Save "my_project"?
file.project.save.confirm = "¿Guardar $0?";
// Save to another project (either new one or overriding existing one)
file.project.saveAs = "Guardar como";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "¿Sobrescribir $0?";
// Open a project
file.project.open = "Abrir";
// E.g: Open "my_project"?
file.project.open.confirm = "¿Abrir $0?";
// Load another project and add/append all its data to the current scene
file.project.add = "Añadir a la escena";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "¿Añadir $0 a la escena?";
// Reset the scene and create a new project
file.project.new = "Crear";
file.project.new.confirm = "¿Crear nueva escena?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "¿Eliminar $0?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "¿Eliminar $0?

¡Este es el proyecto activo actual!";

// Auto save section
file.project.autoSave = "Guardado automático";
file.project.autoSave.confirm = "¿Desactivar el guardado automático?";
file.project.autoSave.help = "Guarda el proyecto en un archivo separado a intervalos regulares.
El archivo de guardado automático se puede encontrar en:

$0";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "Tiempo de espera emergente";
// In minutes
file.project.autoSave.minutes = "Temporizador emergente";
// Delete the current autoSave data
file.project.autoSave.delete = "Descartar auto guardado";

// Load interface preference settings when opening a scene file
file.load.guiSettings = "Mantener la configuración de la gui (al importar)";
file.load.guiSettings.help = "Al abrir o importar un archivo de proyecto, se cargarán todas las configuraciones relacionadas con la gui integradas en el proyecto.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.load.objSplitByGroup = "Dividir OBJ por grupos";
file.load.objSplitByGroup.help = "Cuando está habilitado, Nomad dividirá el grupo de vértices OBJECT en objetos separados.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.load.mergeLayers = "Combinar capas (al importar)";
// Ignore the textures present in the file to load
file.load.skipTextures = "Omitir texturas (al importar)";
// Do not fiddle with the object topology when loading the file
file.load.keepTopology = "Mantener topología (al importar)";
file.load.keepTopology.help = "Utilice esta opción si no desea que Nomad juegue con la topología de la malla importada.

Deshabilitará el reordenamiento de vértices/caras, la eliminación de duplicados de vértices/caras y la eliminación de vértices no utilizados.";
// If the object has more vertices than this value, then we won't attemp to reverse (multiresolution) the object
file.load.reverseVertices = "Revertir umbral";
file.load.reverseVertices.help = "Para usar menos memoria, Nomad no guarda la resolución más baja de una malla.

Sin embargo, reconstruirá la resolución más baja si el número de vértices es menor que este umbral.";


// Configure imports option
file.importSettings = "Importar opciones";

// Import file section
file.import.title = "Importar";
file.import.title.help = "Formato compatible:
- Wavefront (.obj)
- glTF 2.0 (.glb .gltf)
- STL (.stl)";
// The user imports a scene file that will replace the current scene
file.import.open = "Abrir";
file.import.open.confirm = "¿Importar un nuevo archivo?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Añadir a escena";
file.import.add.confirm = "¿Importar un nuevo archivo?";

// Export scene file
file.export.title = "Exportar";
file.export.title.help = "Si es posible, usa la exportación glTF, ya que admite más funciones que otros formatos.";

// Export the current selected objects instead of the entire scene
file.onlySelection = "Exportar selección únicamente";
file.onlySelection.help = "Exportar la malla seleccionada actual en lugar de toda la escena.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Reconstruir quad";
file.convertToQuad.help = "Reconstruye quads a partir de triángulos emparejando triángulos (si son adyacentes en los archivos).";

// Whether we include the textures in the exported file
file.export.texture = "Exportar texturas";
// Baking means transfering/converting
file.export.texture.help = "Esta opción no integra colores de vértices en texturas.";
// Whether we include normals vector in the exported file
file.export.normal = "Exportar normales";
file.export.normal.help = "Marca esta opción si deseas abrir el archivo en otro software.

Nomad siempre ignora las normales, ya que las volverá a calcular.";

file.export.gltf = "Exportar glTF 2.0";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Exportar capas";
file.export.gltf.layer.help = "Exportar capas como transformaciones. Oficialmente compatible con glTF, por lo que también debería funcionar en otros softwares.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Exportar pintura de capa";
file.export.gltf.layerPaint.help = "Exportar pintura de capa. Por lo general, es ignorado por otros softwares.";
// Whether the exported layer will use the non-standard Nomad encoding (smaller size)
file.export.gltf.layerNomad = "Codificación de capa Nomad";
file.export.gltf.layerNomad.help = "Puedes hacer que el archivo sea más pequeño escribiendo la capa de pintura en 8 bits en lugar de 16 bits.

Esta codificación solo funciona en Nomad, ya que utilizará pintura absoluta.
Otros softwares tendrán un resultado incorrecto, ya que glTF requiere una codificación relativa.";
// Whether we include the vertex color in the exported file
file.export.gltf.color0 = "Exportar colores de vértices";
file.export.gltf.color0.help = "Exportar colores de vértices. Oficialmente compatible con glTF, por lo que también debería funcionar en otros softwares.";
// Whether we include the vertex roughness and vertex metalness in the exported file
file.export.gltf.color1 = "Exportar pintura PBR";
file.export.gltf.color1.help = "Exportar rugosidad, metalidad y pintura de máscaras. Esto será ignorado por otros softwares.";

file.export.obj = "Exportar OBJ";
file.export.obj.warning = "Se perderán las capas y la pintura adicional (rugosidad, metalicidad y máscara).";
// Whether we include the vertex color in the exported file
file.export.obj.colorAppend = "Exportar colores de vértices";
file.export.obj.colorAppend.help = "Agregar información de color después de los vértices

Algunos softwares 3D podrán leerlo, pero no todos.";

file.export.stl = "Exportar STL";
file.export.stl.warning = "Se perderán las capas y la pintura pintura (rugosidad, metalicidad y máscara).";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Exportar colores de vértices";
file.export.stl.color.help = "Algunos softwares 3D podrán leerlo, pero no todos.";
file.export.stl.ascii = "Por defecto, el formato es binario.

Puedes exportarlo a formato de texto (ASCII), pero el archivo será más grande.";

// Advanced settings
settings.advanced = "Avanzado";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "Estas opciones no se guardan en la configuración.";
settings.reset.title = "Configuración";
settings.reset.title.help = "Restablecerá los ajustes de la app.

Ciertos recursos se guardan por separado y NO se restablecerán, entre ellos:
- Proyectos
- Atajos de teclado
- Preajustes de herramientas
- Entornos HDR
- MatCaps
- Alfas
- Texturas (pincel)
- Imágenes de referencia

Importante: todo lo vinculado con el proyecto permanecerá intacto, como la iluminación, posprocesado, vistas de cámara, etc.";

// Reset preference settings button
settings.reset = "Restablecer a los valores predeterminados";
settings.reset.confirm = "¿Restablecer las preferencias?";

// Render a screenshot of the scene
file.render = "Renderizar";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Mostrar interfaz";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Render proporción";
file.render.renderRatio.help = "Un valor de 1.0 significa que Nomad se renderizará con la misma resolución que el tamaño de imagen solicitado a continuación.

Utiliza esta opción si no puedes renderizar a una resolución determinada (se bloquea por falta de memoria).";
// Desired size of the exported screenshot
file.render.size = "Tamaño final";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Personalizar";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "pantalla";
// width of exported screenshot
file.render.width = "Ancho";
// height of exported screenshot
file.render.height = "Altura";
// export screenshot of the scene
file.render.export = "Exportar png";
file.render.warn = "¡La resolución de exportación es alta ($0x$1)!

Asegúrate de guardar el proyecto en caso de que el dispositivo se quede sin VRAM y se bloquee.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Fondo transparente";
file.render.transparent.help = "Esta opción puede ser útil si quieres insertar la malla en un software de creación 2D.

Por el momento, no se admite la transparencia parcial de objetos.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Utilizar configuración global";
pressure.useGlobal.help = "De forma predeterminada, las herramientas comparten los mismos ajustes de presión.

Desmarca esta opción si quieres la configuración de presión específica para esta herramienta.";

// Pencil pressure
pressure.title = "Presión";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "Esta herramienta no usa presión de lápiz.";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "El tipo de pincel de agarre ignorará los ajustes de presión.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Radio";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Intensidad";

// Customize whether finger and/or stylus can move the Camera
gesture.cameraInteraction = "Cámara:";
// Customize whether finger and/or stylus can sculpt on object
gesture.sculptInteraction = "Esculpir:";
// Both the finger and the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.fingerAndStylus = "Dedo y Stylus";
// Only the finger can perform a certain action (move camera, sculpt, etc)
gesture.interaction.finger = "Dedo";
// Only the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.stylus = "Lápiz";
// Disable the action
gesture.interaction.none = "Ninguno";
// Allow the action for any inputs
gesture.interaction.any = "Cualquiera";

// long press to pick the color/material under the cursor
gesture.materialPicking = "Selección de material";
gesture.materialPicking.help = "";

// Three fingers on screen
gesture.three.title = "3 dedos";
// Drag 3 fingers horizontally on the canvas to rotate the environment, lights and MatCap
gesture.fingerLighting = "Rotar la iluminación (3 dedos)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerLighting.help = "Arrastra 3 dedos horizontalmente sobre el lienzo para rotar el entorno, las luces y el MatCap.";
// Drag 3 fingers vertically to edit the tool radius
gesture.fingerRadius = "Radio de la herramienta de edición (3 dedos)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerRadius.help = "Arrastra 3 dedos verticalmente para editar el radio.";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.fingerSmooth = "El dedo siempre suaviza";
gesture.fingerSmooth.help = "This option is only active if a sculpting tool is active.";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Permitir presión no reconocida";
gesture.unknownPressure.help = "Marca esta opción si la presión no funciona con el lápiz o si necesitas presionar con el dedo.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Botón de lápiz";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Pulsar dos veces con el lápiz";
gesture.pencilAction.ios.help = "Solo activo para el Apple Pencil de 2.ª gen.";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "Ninguno";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Añadir/Restar";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "Atajos de un toque";
gesture.mask.oneTap.help = "Permite usar el atajo de Máscara tocando una vez la pantalla, sin necesidad de mantener pulsado el atajo del botón de máscara.

Permite el siguiente gesto:
- tocar en el fondo para invertir la máscara
- tocar en una zona con máscara para desenfocar la máscara
- tocar en una zona sin máscara para enfocar la máscara";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress = "Pulsación larga (Máscara ↔ Sel. máscara)";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress.help = "Cuando está activa Máscara o Sel. máscara, deje pulsado con el dedo para cambiar de una herramienta a otra.

Si deja pulsado sin mover el dedo, la nueva herramienta se usará como atajo predeterminado de máscara.";
// Indicator that the tool has been set as the new shortcut
gesture.mask.infoShortcut = "$0 ahora es el atajo de máscara.";

// Shortcuts to undo/redo
gesture.history = "Atajos del historial";
gesture.history.help = "- Deshacer: pulsa con 2 dedos
- Rehacer: pulsa con 3 dedos
- Deshacer/Rehacer: mantén 2/3 dedos hacia abajo (continuo)";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Utilizar rechazo de tamaño";
gesture.palmRejection.confirm = "Asegúrate de desactivar esta opción si tienes problemas para interactuar con el lienzo";
gesture.palmRejection.help = "Rechaza la entrada si el área de contacto es mayor que este valor.

Es posible que no funcione en todos los dispositivos.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Umbral de tamaño máximo";

// History, list of undo/redo
history = "Historial";
// First "undo" state
history.root = "Raíz";
history.undoConfirm = "¿Confirmas deshacer todas estas operaciones?";
history.undoWarning = "Si realizas una edición después, es posible que pierdas muchos cambios.";
// Settings concerning the history stack of undo/redo
history.stack = "Pila";
// Actions to include in the undo/redo stack
history.include = "Incluir acciones";
// include lighting editing in the undo/redo
history.includeLights = "Luces";
history.includeLights.help = "Si esta opción está desactivada, mover las luces con el Gizmo seguirá estando incluido, ya que puede afectar a otros objetos en la jerarquía de la escena.";
// include postProcess editing in the undo/redo
history.includePostProcess = "Posprocesado";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCaps y Hdris";
// Can limit the stack of undo/redo size
history.limitSize = "Límite de historial (Mb)";
history.limitSize.help = "Tamaño máximo (en Mb) del historial.

El historial se actualizará en la siguiente operación registrada.";
// Limit the number of undo in the history stack
history.limitStack = "Límite de pila";
history.limitStack.help = "Número máximo de operaciones que la aplicación puede mantener.

El historial se actualizará en la siguiente operación registrada.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Protección de rango";
history.rangeProtect.help = "Si retrocedes mucho en el historial, aparecerá un cuadro de diálogo de confirmación antes de deshacer las operaciones.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Restaurar cámara";
history.restoreCamera.help = "Habilita esta opción para restaurar el punto de vista de la cámara guardado al deshacer/rehacer una acción.";
// Undo
history.undo = "Deshacer";
// Redo
history.redo = "Rehacer";
// Shown during undo
history.state.undo = "Deshacer: $0";
// Shown during redo
history.state.redo = "Rehacer: $0";
// Shown during undo/redo
history.state.symmetrySplit = "División de simetría";
// Shown during undo/redo
history.state.voxelRemesh = "Reforzar malla de Voxel";
// Shown during undo/redo
history.state.surfaceRemesh = "Reforzar malla de superficie";
// Shown during undo/redo
history.state.multiresLevel = "Cambio de resolución";
// Shown during undo/redo
history.state.multiresToDynamic = "De multires a DynTopo";
// Shown during undo/redo (mesh type conversion)
history.state.meshDynamicToStatic = "De DynTopo a estático";
// Shown during undo/redo (mesh type conversion)
history.state.meshStaticToDynamic = "De estático a DynTopo";

// Interface customization
interface = "Interfaz";

// UI customization: each row of the list will be bigger
interface.expandList = "Interfaz de usuario: Expandir lista";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Solo una opción de interfaz de usuario para una administración de listas más fácil.";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "Añadir accesos directos (abajo)...";

// Interface option (main base color)
interface.colorBase = "Base de color";
// Interface option (accent widget color)
interface.colorSelect = "Widget de color";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Panel transparente";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Fuerza de difuminado";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Panel de control";

// Interface color style
interface.preset.title = "Ajustes prestablecidos de color";
// Interface color style (original color of Nomad Sculpt)
interface.preset.classic = "Clásico";
// Interface color style
interface.preset.orange = "Naranja";
// Interface color style (~red)
interface.preset.cardinal = "Rojo cardenal";
// Interface Color style (~pink)
interface.preset.mulberry = "Rosa morado";
// Interface color style
interface.preset.brown = "Marrón";
// Interface color style (~green)
interface.preset.emerald = "Verde esmeralda";
// Interface color style (~blue)
interface.preset.neon = "Neon";
// Interface color style
interface.preset.violet = "Violeta";
// Interface color style
interface.preset.grey = "Gris";
// Interface color style
interface.preset.black = "Negro";
// Interface color style
interface.preset.white = "Blanco";

// Reset interface settings
interface.resetAll = "Restablecer interfaz";
interface.resetAll.confirm = "¿Restablecer la configuración de la interfaz?";
// Interface option (main base color)
interface.iconSupport = "High-contrast button";
interface.iconSupport.help = "An alternative style for buttons that makes them more visible when they are enabled.

If set on Auto, Nomad will use this mode when the UI color contrast between enabled/disabled is low.";
// Interface customization
interface.flipTop = "voltear superior";
// Interface customization
interface.flipBottom = "voltear inferior";
// Interface customization
interface.flipMiddle = "voltear medio";
// Interface customization (preview material in the viewport when editing material color)
interface.materialPreview = "Vista previa del Selector de materiales";
// Interface customization
interface.materialPreview.help = "Al seleccionar un color para un material, se muestra una previsualización del material en el objeto seleccionado.";
interface.toolbox.hide = "Ocultar la caja de herramientas";
interface.toolboxHide.help = "Activa esta opción si quieres ocultar la caja de herramientas.";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.maxColumn = "Caja de herramientas de columna máxima";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Restablecer el orden de la caja de herramientas";
// Scale the interface
interface.scale = "Escala general";
// Spacing between widgets
interface.cursorStep = "Espaciado vertical";
// Width of the interface panels
interface.panelWidth = "Ancho del panel";
// Size of fonts
interface.fontScale = "Escala frontal";
// Inset
interface.inset.title = "Desplazamientos de borde";
interface.inset.title.help = "You can change these values only if you have issues interacting with the buttons on the screen edges.

If the slider is disabled, Nomad will use the safe area values returned by the device itself.";
interface.inset.left = "Izquierdo";
interface.inset.right = "Derecho";
interface.inset.bottom = "Inferior";
interface.inset.top = "Superior";

// (see Glossary for Layer)
layer = "Capa";
// (see Glossary for Layer)
layers.lock = "Conservar detalles de capas superiores";
// (see Glossary for Layer)
layers.lock.yes = "¿Bloquear las capas superiores?";
// (see Glossary for Layer)
layers.lock.warning = "Al esculpir, se ignorará la deformación proveniente de las capas superiores.

No obstante, los detalles de dichas capas seguirán siendo visibles.

Esta opción solo funciona si las capas superiores tienen detalles de escala relativamente pequeños.";
// (see Glossary for Layer)
layers.addLayer = "Añadir capa";
// (see Glossary for Layer)
layer.factors = "Factores de canal";
// (see Glossary for Layer)
layer.factor = "Factor";
// (see Glossary for Layer)
layer.offset = "Desplazamiento";
// (see Glossary for Layer)
layers.title = "Capas";
// (see Glossary for Layer)
layers.title.help = "Layers can record position offsets and painting, it can be useful for non-linear workflow.
For example by experimenting different facial expression without relying on the history stack to undo the changes.

For painting data, layers are sorted in a top-down fashion; so layers on top will mask the lower ones.

You can erase part of the layer by using the 'DelLayer' tool.";
layers.primitive = "Las capas no están disponibles para las primitivas.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "Ninguno";

light = "Luz";
// Intensity of light
light.intensity = "Intensidad";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "Temperatura";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Adjunto";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Fijado";
// The light will move along the camera
light.attachment.camera = "Cámara";
light.attachment.help = "-- Fijado
La orientación de la luz no cambiará.

-- Cámara
La orientación de la luz depende de la vista de la cámara.";
// Light type (directional, spot, point)
light.type = "Tipo";
// Directional light (synonym: sun light)
light.type.directional = "Direccional";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Marca";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Punto";
// Cone angle for spot angles
light.spot.angle = "Ángulo de cono";
// Softness of the spot light
light.spot.softness = "Suavidad";
// Position of the light
light.position = "Posición";
// Enable or disable shadows for a light
light.shadow.cast = "Sombra";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "La luz puntual solo admite sombras del espacio de pantalla.";
light.shadow.type = "Tipo de sombra";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "Mapa de sombras";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "Espacio de pantalla";
light.shadow.type.screenspace.help = "Esta función es experimental y podría retirarse en las versiones futuras.

Esta opción está pensada para usarse con la función de suavidad de sombra.";
// Adjustment to fix artefacts
light.shadow.bias = "Sesgo";
// How blurry the shadow is
light.shadow.softness = "Suavidad";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "Contacto";
light.contact.help = "Si se selecciona automático, solo la luz más dominante tendrá sombra de contacto.";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "Tolerancia";
// Activated the light
light.visible = "Mostrar";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Volver a centrar";

// Object's material
material = "Material";
// See glossary
material.pbrRoughnessMetalness.warning = "La rugosidad y la metalicidad requieren el modo de sombreado PBR.";
// See glossary
material.pbrReflectance.warning = "La reflectancia requiere el modo de sombreado PBR.";
// See glossary
material.pbrRefraction.warning = "La refracción requiere el modo de sombreado PBR.";
// See glossary
material.pbrSubsurface.warning = "La subsuperficie requiere el modo de sombreado PBR.";
// Value that says how much light will change direction when hitting the surface
material.ior = "Índice de refracción";
// an object-level value that overrides the painting of the mesh
material.paintingOverride = "Anular pintura";
// The roughness in the inside is turbidity
material.paintingOverride.help = "Hay dos rugosidades en juego, la que impulsa la superficie y la que está en el interior.

Sin embargo, solo hay una rugosidad que se puede pintar, por lo que las dos rugosidades tienen los mismos valores.

Puede usar este control deslizante para anular la rugosidad de la superficie para que tenga más brillo.";
// Glossiness is simply the opposite of roughness
material.refractionSurfaceGlossiness = "Brillo de la superficie";
material.refractionSurfaceGlossiness.help = "- en 0, la superficie está utilizando la rugosidad pintada
- en 1, la superficie es completamente lisa";
// Synonym: turbidity
material.refractionInteriorRoughness = "Rugosidad del interior";
material.refractionInteriorRoughness.help = "- en 0, el interior está utilizando la rugosidad pintada
- en 1, el interior es completamente áspero";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Pintura brillante";
material.paintGlossy.help = "Pintará el objeto con una rugosidad y metalicidad de 0, lo que permitirá una refracción nítida.

Esto es lo mismo que ir al menú pintar y usar la función pintar todo con el color y el metal desactivados.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Absorción";
material.absorptionEnable.help = "Simule la luz que se absorbe cuando viaja a través del volumen.

Las partes delgadas brillarán a medida que deja pasar más luz, mientras que las áreas gruesas serán más oscuras.

El efecto depende en gran medida de la geometría de la malla, solo se utiliza una aproximación del grosor de la malla.";
material.absorptionFactor = "Factor";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "Profundidad";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "Translucidez";
material.translucency.help = "Necesitas tener una luz que proyecte sombras para ver la translucidez.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Opacidad";
// Fully opaque material
material.type.opaque = "Opaco";
// See glossary
material.type.subsurface = "Subsuperficie";
material.type.subsurface.help = "Para obtener el mejor resultado, puedes cambiar al modo de sombreado PBR y usar al menos una luz direccional, idealmente con un entorno tenue.";
// Transparency mode, alpha blending
material.type.blending = "Mezcla";
material.type.blending.help = "Haz que la malla sea semitransparente ajustando el valor de opacidad

Ten en cuenta que, debido a las limitaciones en tiempo real, puedes tener artefactos visuales notables si tu objeto tiene una forma compleja.";
// Transparency mode
material.type.additive = "Aditivo";
material.type.additive.help = "Haz que la malla sea semitransparente ajustando el valor de opacidad.

Este método tiende a tener menos artefactos que el método de fusión, pero el objeto será más brillante.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Tramado";
material.type.dithering.help = "Haz que el objeto sea semitransparente descartando algunos píxeles de forma aleatoria.";
// Simulate glass-like material
material.type.refraction = "Refracción";
material.type.refraction.help = "Este modo se puede utilizar para simular material de vidrio

Debido a las limitaciones de tiempo real, la autorrefracción o la refracción multicapa es limitada.";
material.castShadows = "Proyectar sombras";
material.receiveShadows = "Recibir sombras";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Siempre apagado";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Culling inverso";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Reflectancia";
material.reflectance.help = "Controla la cantidad de reflexión que recibirá el material para materiales no metálicos

La mayoría de las veces, se debe usar el valor predeterminado (0,5, que corresponde al 4 % de luz reflejada estándar en ángulo normal).";

// Menu name
menu.files = "Archivos";
// Menu name
menu.scene = "Escena";
// Menu name
menu.multires = "Multiresolución";
// Menu name
menu.voxel = "Voxel";
// Menu name
menu.dynTopo = "DynTopo";
// Menu name
menu.topology = "Deci/UV...";
// Menu name
menu.primitive = "Primitivo";
// Menu name
menu.render = "Renderizado";
// Menu name
menu.material = "Material";
// Menu name
menu.postProcess = "Posprocesado";
// Menu name
menu.camera = "Cámara";
// Menu name
menu.background = "Fondo";
// Menu name
menu.tool = "Herramienta";
// Menu name
menu.stroke = "Trazo";
// Menu name
menu.paint = "Pintura";
// Menu name
menu.symmetry = "Simetría";
// Menu name (pencil pressure)
menu.pressure = "Presión";
// Menu name
menu.gesture = "Gesto";
// Menu name
menu.layers = "Capas";
// Menu name
menu.settings = "Configuración";
// Menu name
menu.interface = "Interfaz";
// Menu name
menu.bindings = "Atajos";
// Menu name
menu.history = "Historia";
// Menu name
menu.historySettings = "Configuración";
// Menu name
menu.about = "Acerca de";
// Menu name
menu.debug = "Depurar";

// Operation on the object (action)
mesh.action = "Acción";
// If the object has holes, the algorithm will close them
mesh.holeClose = "Cerrar agujeros";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holeDetail = "Detalle";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Separado";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "Se perderán las capas, la pintura y la multirresolución.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Resolucion";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Fuerza cúbica";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Convertir";
// Static object means "static topology"
mesh.typeStatic = "Malla";
// See glossary
mesh.typeMultiresolution = "Multiresolución";
// Dynamic topology
mesh.typeDynamic = "DynTopo";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Material globacl";
paint.useGlobal.help = "Si esta opción está habilitada, el material seleccionado será el mismo que el de las otras herramientas.

Ten en cuenta que solo toma en cuenta la rugosidad, la metalicidad y los ajustes de color.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Pintura de trazo";
// Factor/Opacity of paint tool
paint.intensity = "Intensidad de pintura";
// Apply the paint on the object
paint.paintAll = "Pintar todo";
paint.paintAll.help = "Aplicar el material actual a la malla.

El área enmascarada y los canales deshabilitados no se pintarán.";
// Apply the paint on the object but ignore painting intensity (force full intensity)
paint.paintAllForce = "Forzar pintura en todo";
paint.strokePainting.title = "Pintura";
// Brush stroke texture
paint.texture.title = "Textura";
paint.texture.title.help = "Una imagen que coloreará tu trazo.

Ten en cuenta que compartirás la configuración de mosaico y escala del alfa.";
paint.texture.warningEnable = "La pintura de trazos debe estar habilitada para permitir la proyección de texturas (casilla de verificación en la parte superior)";
paint.texture.warningIgnored = "¡La herramienta actual no puede usar texturas!";
// Whether the Brush Alpha will be used to module painting
paint.useAlpha = "Usar trazo alfa";
paint.useAlpha.help = "Uso del conjunto alfa en el menú trazo para modular la pintura.";
// Whether the Brush Falloff will be used to module painting
paint.useFalloff = "Utilizar trazo de disminución";
paint.useFalloff.help = "Usar del set de disminución en el menú trazo para modular la pintura.";

// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "Nombre";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "Valor";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "Color hexadecimal";

// Post process effect
postprocess = "posprocesado";
// Quality vs performance
postprocess.quality = "Calidad";
postprocess.quality.help = "Activa estas opciones para mejorar la calidad en detrimento del rendimiento.";
// More samples means better quality but slower performance
postprocess.maxSamples = "Muestras máx.";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Resolución completa";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "Máx. muestreo de fotogramas";
postprocess.accumulateCount.help = "Maximum number of frames to accumulate before the rendering stops.

When the rendering stops, Nomad won't do anything, thus saving battery life.

Many rendering features benefit from frame accumulation, notably:
- Soft Shadows
- Global Illumination
- Reflection (SSR)
- Ambient Occlusion
- Subsurface
- Depth Of Field

High frame counts are mostly necessary for Soft Shadows and Global Illumination.
Nomad can stop the rendering sooner if the features mentioned aboved are disabled.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Renderizar resolución";
postprocess.renderRatio.warning = "Anulado por el efecto Pixel Art.";
postprocess.renderRatio.help = "Esta opción impacta mucho en el rendimiento.
Se recomienda mantener un valor inferior a x1.25.

Esta opción no se guarda en la configuración.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "Suavizado (TAA)";
postprocess.taa.help = "Reduce el parpadeo al mover la cámara.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "Reflexión (SSR)";
postprocess.ssr.warning = "SSR requiere el modo de sombreado PBR.";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "Iluminación global (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "Tolerancia";
postprocess.ssgi.experimental = "¡Experimental!";
postprocess.ssgi.warning = "SSGI requiere el modo de sombreado PBR.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "Oclusión ambiental";
// How far the effect spreads
postprocess.ssao.radius = "Tamaño";
// How strong the effect is
postprocess.ssao.factor = "Fuerza";
// Adjustment to fix artefacts
postprocess.ssao.bias = "Sesgo de curvatura";
postprocess.ssao.bias.help = "La sensibilidad del efecto depende de la curvatura de la superficie.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "Profundidad de campo";
// The blur factor behind the focused point
postprocess.dof.blurFar = "Borrosidad lejana";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "Borrosidad cercana";
postprocess.dof.focusTip = "Pulsa un objeto para cambiar el punto de enfoque.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "Resplandor";
// Intensity of the effect
postprocess.bloom.intensity = "Intensidad";
// How far the effect spreads
postprocess.bloom.radius = "Radio";
postprocess.bloom.radius.help = "Qué tan extendido está el resplandor.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "Umbral";
postprocess.bloom.threshold.help = "Umbral de luminosidad para decidir si un píxel emitirá resplandor o no.
Si el valor es 0, todo tendrá resplandor.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "Mapeo de tonos";
postprocess.tone.exposure = "Exposición";
postprocess.tone.contrast = "Contraste";
postprocess.tone.saturation = "Saturación";
// No tonemapping operator is used
postprocess.tone.mapping.none = "Ninguno";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "Neutral";
// Color curves
postprocess.curve = "Graduación de color";
// Curve for pixel luminance
postprocess.curve.luminance = "Principal";
postprocess.curve.red = "Rojo";
postprocess.curve.green = "Verde";
postprocess.curve.blue = "Azul";
postprocess.curve.reset = "Restablecer";
// Reset color grading curves
postprocess.curve.resetAll = "Restablecer todo";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "Aberración cromática";
postprocess.chromatic.factor = "Fuerza";
// Darking on the edges
postprocess.vignette = "Viñeta";
// How far the effect spreads
postprocess.vignette.size = "Tamño";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "Dureza";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "Nitidez";
postprocess.sharpness.factor = "Fuerza";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "Ruido";
postprocess.grain.factor = "Fuerza";
// Accentuate the edges of the model
postprocess.curvature = "Curvatura";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "Cavidad";
// Color/Strength of convex curvature
postprocess.curvature.bump = "Relieve";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "Arte pixelado";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "Permitir muestreo de fotogramas";
// Simulate scanline rendering (horizonal line)
postprocess.scanline = "Scanline";
postprocess.scanline.factor = "Factor";
// Spacing between lines
postprocess.scanline.spacing = "Espaciado";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Primitivo";
primitive.box = "Caja";
primitive.sphereCube = "Esfera";
primitive.sphereUV = "Esfera UV";
primitive.icosahedron = "Icosaedro";
primitive.cylinder = "Cilindro";
primitive.cone = "Cono";
primitive.torus = "Toro";
primitive.lathe = "Torno";
primitive.tube = "Tubo";
primitive.plane = "Plano";
primitive.triplanar = "Triplanar";
primitive.faceXYZ = "Cara XYZ";
primitive.faceXYZ.help = "Malla base sin envolver UV proporcionada por https://texturing.xyz/";
primitive.needValidate = "Las primitivas deben ser validadas para ser esculpidas.";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Editar";
primitive.edit.help = "Permitir la edición 3D en la ventana gráfica.

Puedes desactivar esta función si deseas interactuar con el Gizmo o la herramienta de transformar sin modificando la primitiva.";

// Primitive configuration
primitive.mainConfig = "Parámetro";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Topología";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Geometría";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Validar";
// Maximum number of faces of the primitives
primitive.maxFaces = "Caras máx.";
primitive.maxFaces.help = "El número máximo de caras que puede tener una primitiva.

Este límite solo está activo mientras la primitiva no está validada, después la salvaguarda desaparece.";
// Synonym: Flat subdivision
primitive.linear = "Subdivisión lineal";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Postsubdivisión";

// Radius (of a sphere, torus, etc)
primitive.radius = "Radio";
// Size (of cube x dimension)
primitive.size = "Tamaño";
primitive.sizeX = "Tamaño X";
primitive.sizeY = "Tamaño Y";
primitive.sizeZ = "Tamaño Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "División";
primitive.divisionX = "División X";
primitive.divisionY = "División Y";
primitive.divisionZ = "División Z";
// Angle of torus, etc
primitive.angleX = "Ángulo X";
primitive.angleY = "Ángulo Y";
primitive.angleZ = "Ángulo Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Densidad constante";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Proyecto sobre esfera";
primitive.projectOnSphere.help = "Ajustar los puntos en una esfera perfecta.";

// triplanar
primitive.triplanar.title = "Triplanar";
primitive.triplanar.title.help = "Triplanar utiliza la información de máscara de 3 planos para rellenar una cuadrícula de Voxel que luego se poligoniza.

Si interactúas con los controles deslizantes de división o tamaño, la información de pintura se restablecerá (la suavidad está bien).

Probablemente deberías deshabilitar la simetría, ya que podría no funcionar como cabría esperar.

Puedes usar la opción 'Conectado topológicamente' en el panel máscara para pintar un plano que impacte en los otros planos.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanarSameSize = "Mismo tamaño (cubo)";
primitive.triplanarPolish = "Suavidad";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanarResetMask = "Restablecer máscara";
// One side of a cube (the back plane)
primitive.isolate.back = "Atrás";
// One side of a cube (the right plane)
primitive.isolate.right = "Derecho";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Inferior";
// Plane
primitive.planeSameSize = "Mismo tamaño (cuadrado)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "Disco";
// Box
primitive.boxRegular = "Mismo tamaño (cuba)";
// Distance to the snapping point
primitive.tubeSnapOffset = "Capturar desplazamiento";
primitive.tubeSnapOffset.help = "Un valor de 1.0 es igual radio del tubo.";
// Radius of the tube (starting end-point of the tube)
primitive.tubeThicknessStart = "Inicio del radio";
// Radius of the tube (ending end-point of the tube)
primitive.tubeThicknessEnd = "Fin del radio";
primitive.tubeTwist = "Retorcer";
primitive.tubeTwistRotate = "Rotación";
primitive.tubeTwistRadius = "Magnitud";
primitive.tubeTwistOffset = "Desplazamiento";
primitive.tubeSnap = "Capturar";
primitive.torusRadiusOuter = "Radio exterior";
primitive.torusRadiusInner = "Radio interior";
primitive.torusAngle = "Ángulo";
primitive.torusAngleOffset = "Desplazamiento de ángulo";
primitive.cylinderHeight = "Altura";
primitive.coneRadius = "Radio";
primitive.coneHeight = "Altura";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Agujero";
// Make a hole in the primtive to make it hollow
primitive.hasHole = "Tiene un agujero";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radiusSync = "El mismo radio";
primitive.radiusStart = "Inicio del radio";
primitive.radiusEnd = "Fin del radio";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Importar";

scene.title = "Escena";
scene.title.help = "Cuando uses la casilla de verificación de selección, mantén presionado y arrastra el dedo para seleccionar otros objetos fácilmente.";
// The view will focus on the item when we click on it
scene.focus = "Centrar en elemento";
// Icon size in pixel (min/max)
scene.iconSize = "Icon size";
// Min size of icon
scene.iconSize.min = "Mín.";
// Max size of icon
scene.iconSize.max = "Máx.";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "Hierarchy lines";
scene.showHierarchy.help = "Display a line between parent and its children in the viewport.";
scene.showHierarchyNomadPivot = "Use Nomad pivot";
scene.showHierarchyNomadPivot.help = "The Nomad pivot is the pivot used by the Transform and Gizmo tools.

If this option is disabled, it will use the natural base pivot.
In some case this base pivot can be far away from the object center itself!";
// The view will focus on the item when we click on it
scene.syncVisible = "Sync visibility";
scene.syncVisible.help = "When enabled, using the visible (eye) icon will impact all the selected items.";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "Unir";
// Group the selected object with a new created Empty Node as a parent
scene.group = "Agrupar";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "Espejo";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "Curva";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "Matriz";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "Radial";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "Repeaters";
scene.repeaters.help = "Repeater nodes that make instances of any geometries below it in the scene hierarchy.";
// Validate button
scene.validateGroup = "Validar";
// If we should join children
scene.validateGroup.joinChildren = "Unir hijos";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Combinar Voxel";
scene.voxelResolution = "Resolución";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Resta  : ocultar malla (icono de ojo)";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Intersección: Todas las mallas ocultas";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "No hay malla seleccionada.";
// Need to select one object only
scene.noneButNeedOne = "No hay objetos seleccionados, seleccione uno.";
// Need to select one object only
scene.onlyOneObject = "Se seleccionaron varias mallas, selecciona solo una malla.";

// General scene display settings
settings.display.title = "Configuración de pantalla";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Malla";
// Display UV
settings.debugUV = "Depurar UV";
settings.debugUV.help = "Esta opción solo es relevante si el modelo tiene UV.

Mostrará la estructura metálica UV en segundo plano.

También mostrará una textura de tablero de ajedrez de color en el modelo.";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Dos cara";
settings.twoSided.help = "Las caras serán visibles desde ambos lados.";
// If we colorize the inverted side of faces
settings.backface.color = "Color de cara posterior";
// Color of the inverted side of faces
settings.backface.colored = "Cara posterior coloreada";
// Outline (contour highlight around the selected object)
settings.outline = "Contorno";
// Outline (contour highlight around the selected object)
settings.outline.help = "Se aplicará contorno a los objetos seleccionados.";
settings.outline.thickness = "Espesor";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Capturar cubo";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "Inferior";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "Izquierdo";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Estadísticas";
settings.stats.right = "Derecho";
settings.stats.all = "Mostrar escena completa";
// Grid
settings.grid = "Cuadrícula";
// Cursor
settings.cursor.whileSculpting = "Mostrar círculo mientras esculpes";
// A small indicator dot
settings.cursor.showDot = "Mostrar punto pequeño";
settings.cursor.showDot.help = "El punto puede aparecer como el punto de pivote de la cámara o cuando estás esculpiendo.";
settings.cursor.showRope = "Mostrar estabilizador de cuerda";
// Highlight (the object glows when we select it)
settings.highlight.selection = "Resaltar mallas seleccionadas";
// Highlight settings
settings.highlight = "Selección de resaltado";
settings.highlight.duration = "Duración";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Oscurecer mallas no seleccionadas";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Sombreado suave";
// Experimental feature
settings.partialDraw = "Dibujo parcial";
settings.partialDraw.help = "¡Característica no pulida!

Úsela si estás esculpiendo una parte relativamente pequeña de una malla de polietileno alto.

Debería hacer que la escultura sea más suave, pero no debes habilitar la malla.

También puede agregar artefactos visuales durante los trazados";
settings.partialDraw.warning = "¡No olvides desactivar esta opción si los artefactos visuales son demasiado molestos!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Mostrar pintura";
// Display the light icons in the viewport
settings.lightIcon = "Iconos de luz";
// Display the camera icons in the viewport
settings.cameraIcon = "Iconos de cámara";
// Show icon on the canvas
settings.icon = "Icono";
// Show icons on the canvas
settings.icons = "Iconos";
// Tooltip
settings.icons.help = "Mostrar un icono en el lienzo para que se puedan seleccionar y editar directamente.";
// Hole filling settings
settings.hole = "Relleno de agujero";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Rellenar espacio no topológico";
settings.hole.nonManifold.help = "Intenta llenar el agujero del espacio topológico.
Esta opción no se guarda en la configuración.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Recuento máximo de vértices";
settings.multires.maxVertices.help = "Nomad no realiza una comprobación de memoria antes de la subdivisión, un recuento alto de poli puede provocar bloqueos fácilmente.";
settings.multires.lowResVertices = "Umbral de baja resolución";
settings.multires.lowResVertices.help = "Se puede mostrar una resolución más baja de la malla cuando mueve la cámara.

Puedes aumentar este valor si deseas mostrar una resolución más alta de la malla.";

// The main rendering mode
shading = "Sombreado";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "Encendido (PBR)";
shading.pbr.help = "En este modo, puede agregar luces (con sombras), junto con un entorno HDR.

También puede pintar metal y rugosidad, lo que permite un control más fino sobre el aspecto de tu material.";
// Fast rendering mode for sculpting purpose (do not translate)
shading.matcap = "MatCap";
shading.matcap.help = "MatCap significa captura de material (MATerial CAPture) y se encarga de la iluminación y la información del material en una sola imagen.

Este es un modo de renderizado rápido, adecuado principalmente para esculpir en bruto.";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "Apagado";
shading.unlit.help = "Modo de sombreado de color sólido, apagado.";
// Helper rendering mode that display a (do not translate)
shading.id = "ID";
shading.id.help = "Modo de renderizado sin iluminación: cada objeto tiene un color aleatorio asignado.

Esto resulta especialmente útil si la escena contiene muchos objetos.";
// Randomize colors
shading.id.randomize = "ID aleatorio";
shading.textures = "Utilizar texturas";
shading.textures.help = "Por el momento, no puedes crear ni editar texturas dentro de Nomad.

Pero si importas un archivo con texturas, debería funcionar.

-- Texturas compatibles --
Opacidad: Iluminado, MatCap, apagado
Normal: Encendido, MatCap
Color: Encendido, Apagado
Emisor: Encendido
Rugosidad: Encendido
Metalidad: Encendido";
// Lights
shading.lights = "Luces";
shading.lights.addLight = "Agregar luz";
shading.lights.warning = "Las luces requieren el modo de sombreado PBR.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Entorno";
shading.environment.import = "Importar HDR";
shading.environment.exposure = "Exposición";
shading.environment.backgroundBlur = "Borroso (fondo)";
shading.environment.rotation = "Rotación";
shading.environment.rotation.help = "Puedes rotar el entorno arrastrando 3 dedos horizontalmente en la ventana gráfica.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "Conectado a la cámara";
shading.environment.attachedToCamera.help = "Conecte el entorno a la cámara.

Obligará a que la iluminación sea consistente, lo que puede ser útil para esculpir.";
shading.matcap.rotation = "Rotación";
shading.matcap.rotation.help = "Puedes girar el MatCap arrastrando 3 dedos horizontalmente en la ventana gráfica.";
shading.matcap.global = "Utilizar el MatCap global";
shading.matcap.global.help = "Desmarca esta opción para usar un MatCap diferente para esta malla en particular.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible.short = "Máscara";
shortcut.maskVisible.long = "Máscara";
// bottom shortcut buttons (should be SHORT)
shortcut.solo.short = "Individual";
shortcut.solo.long = "Individual";
// bottom shortcut buttons (should be SHORT)
shortcut.voxelRemesh.short = "Voxel";
shortcut.voxelRemesh.long = "Reforzar malla Voxel";
// bottom shortcut buttons (should be SHORT)
shortcut.wireframe.short = "Malla";
shortcut.wireframe.long = "Malla";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraReset.short = "Restablecer";
shortcut.cameraReset.long = "Restablecer cámara";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraSnap.short = "Capturar";
shortcut.cameraSnap.long = "Captura de cámara";
// bottom shortcut buttons (should be SHORT)
shortcut.lockSelection.short = "Bloquear";
shortcut.lockSelection.long = "Selección de bloqueo";
shortcut.lockSelection.long.help = "Cuando está habilitado, no puedes cambiar la selección pulsando una malla.";
// bottom shortcut buttons (should be SHORT)
shortcut.perspective.short = "Persp";
shortcut.perspective.long = "Perspectiva";
// bottom shortcut buttons (should be SHORT)
shortcut.grid.short = "Cuadrícula";
shortcut.grid.long = "Cuadrícula";
// bottom shortcut buttons (should be SHORT)
shortcut.uv.short = "uv";
shortcut.uv.long = "uv";

// Memory taken by the scene
stat.ramScene = "Escena";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Escena Vram";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "Renderizar Vram";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "Texturas Vram";
// Memory taken by the undo/redo history
stat.ramHistory = "Historial";
// Memory taken by other stuffs
stat.ramOther = "Otro";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "Memoria usada";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "Memoria libre";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "Usado: $0 MB";
stat.free = "Libre: $0 MB";
stat.faces = "Caras";
stat.triangles = "Triángulos";
stat.vertices = "Vértices";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Quads";
stat.sceneFaces = "Caras de escena";
stat.sceneVertices = "Vértices de escena";

// Brush stroke
stroke = "Trazo";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "Radio mundo-espacio";
// The settings is shared among every tools
stroke.useWorldRadius.help = "Es compartido entre todas las herramientas.";
// Share the radius value among every tools.
stroke.useShareRadius = "Compartir radio";
stroke.useShareRadius.help = "Comparte el valor del radio entre todas las herramientas.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.minSpacing = "Espaciado de trazos";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.minSpacing.adjustIntensity = "Ajusta la intensidad del espaciado";
stroke.minSpacingAdjustIntensity.help = "Ajusta la intensidad de la brocha para garantizar una deformación uniforme en función de la separación entre trazos.";
stroke.minSpacing.help = "Espaciado entre cada trazo, en relación con el radio de la herramienta.

Un valor más bajo permitirá un trazo más suave, pero el rendimiento se degradará.";
// Brush stroke smoothing
stroke.lazySmooth = "Suavidad del trazo";
stroke.lazySmooth.help = "Promedia la posición de varios punteros para obtener un trazo más suave

Con valores altos, el trazo se retrasará detrás del puntero, pero eventualmente lo alcanzará.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Estabilizador de cuerda perezoso";
stroke.lazyRadius.help = "Los trazos se retrasarán detrás de la posición del puntero de acuerdo con una cierta distancia.

Esto se puede usar para dibujar líneas suaves.";
// It is not a per-tool settings
stroke.globalSettings = "Este es una configuración global";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Capturar radio";
stroke.snapRadius.help = "Carturar el trazo si el puntero se encuentra cerca del último trazo grabado

Esto puede ser útil al dibujar líneas largas y continuas, mientras se hacen pausas frecuentes.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Desplazamiento de trazo";
stroke.sculptOffset.help = "Aplica un desplazamiento constante en el trazo.

Esta opción está ahí para ayudar con la pantalla pequeña cuando se usan los dedos para no cubrir el trazo.";
stroke.accumulate = "Acumular trazo";
stroke.accumulate.help = "Si esta opción está habilitada, no hay límite en la cantidad de material que puedas agregar/eliminar por trazo.";
// The tool can use DynTopo
stroke.useDynamicTopology = "Permitir topología dinámica";
// Only sculpt the part that are linked topologically
stroke.connectedTopology = "Topología conectada";
stroke.connectedTopology.help = "Esta opción solo esculpirá los vértices que están vinculados a la superficie seleccionada.

Por lo general, se utiliza para la herramienta Mover, por ejemplo, si quieres mover exclusivamente una parte que se interseca automáticamente con otra parte.";
// Only sculpt the vertex that points toward the camera
stroke.onlyFrontFace = "Solo vértice frontal";
stroke.onlyFrontFace.help = "Esta opción ignorará los vértices orientados hacia atrás.

Puede ser útil si quieres pintar parte de una geometría fina sin afectar al otro lado.

También funciona para esculpir, pero es posible que experimentes algunos artefactos.";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.onlySameSide = "Solo vértice del mismo lado";
stroke.onlySameSide.help = "Ignora los vértices que apuntan en la dirección opuesta a la deformación.";
// Module the intensity of the sculpting operation by using a falloff curve
stroke.curveFalloff = "Disminución";
stroke.onlyLasso = "La configuración solo está activa para la herramienta lazo.";
// Alpha
stroke.alpha = "Alfa";
// Invert the pixel (black <-> white)
stroke.alphaInvert = "invertir valor";
// Repeat the alpha image (pattern)
stroke.alphaWrap = "Mosaico";
// No repeat pattern
stroke.alphaWrap.none = "Ninguno";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alphaWrap.repeat = "Repetir";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alphaWrap.mirror = "Espejo";
stroke.alphaProject = "Método";
// Project the alpha perpendicularly onto the surface
stroke.alphaProject.surfaceContinuous = "Superficie";
// Project the alpha onto the surface in the direction of the camera view
stroke.alphaProject.screenFixed = "Proyecto de pantalla";
stroke.alphaRotation = "Rotación";
stroke.alphaRotation.lock.help = "Lock the alpha orientation.

If the rotation is unlocked, the orientation will follow the stroke direction in real-time.";
// Repeat the image
stroke.alphaTiling = "Mosaico";
// Scale the image (make it bigger or smaller)
stroke.alphaScale = "Escalar";
stroke.alphaScale.help = "En el valor mínimo, el cuadrado alfa está dentro del radio del círculo de la herramienta.";
// Middle-point value at which no deformation occurs
stroke.alphaMidValue = "Valores medios";
stroke.alphaMidValue.help = "Valor de punto medio en el que no se produce deformación.

(Valor medio = 0)
- Negro: sin desplazamiento
- Blanco: desplazamiento positivo

(Valor medio = 0.5)
- Negro: desplazamiento negativo
- Blanco: desplazamiento positivo

(Valor medio = 1)
- Negro: desplazamiento negativo
- Blanco: sin desplazamiento";
// Stroke type
stroke.strokeType = "Tipo de trazo";
// Sculpt and paint along the brush stroke at regular spacing
stroke.strokeTypeDot = "Punto";
// Sculpt continuously
stroke.strokeTypeDrag = "Arrastrar";
// Lock a region and move it around
stroke.strokeTypeGrab = "Agarre";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.strokeTypeGrabRadius = "Agarre - radio dinámico";
// Lock a region and sculpt it by changing the tool intensity
stroke.strokeTypeGrabIntensity = "Agarre - intensidad dinámica";

// Symmetry
symmetry = "Simetría";
symmetry.enable = "Activado";
// Display a warning (the feature is only available for mesh object)
symmetry.primitiveWarning = "La simetría de pincel solo está disponible para primitivas validadas, con la excepción de la Triplanar.";
symmetry.plane.title = "Planos";
symmetry.toolIgnore = "La herramienta actual ignora la simetría.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Radial";
symmetry.radialX = "Radial X";
symmetry.radialY = "Radial Y";
symmetry.radialZ = "Radial Z";
// Synonym: Offset
symmetry.offset.title = "Desplazamiento";
symmetry.offsetX = "Desplazamiento X";
symmetry.offsetY = "Desplazamiento Y";
symmetry.offsetZ = "Desplazamiento Y";
// Number of clones
symmetry.count.title = "Cantidad";
symmetry.countX = "Cantidad X";
symmetry.countY = "Cantidad Y";
symmetry.countZ = "Cantidad Z";
// method
symmetry.method = "Método:";
symmetry.method.help = "-- Local
El plano de simetría se moverá a lo largo de la malla cuando utilice una de las herramientas de transformación (Gizmo o Transformar).


-- Mundo
El plano de simetría es fijo y no se mueve.";
// Local means: in the coordinate of the scene
symmetry.methodWorld = "Mundo";
// Local means: in the coordinate of the object (internal)
symmetry.methodLocal = "Local";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Voltear objeto";
// Mirror the mesh
symmetry.mirror = "Duplicación";
symmetry.mirror.help = "Intenta volver a aplicar la simetría sin afectar a la topología.

Se ignorará la simetría radial.

Si la topología no se puede mantener porque no se considera simétrica, tendrás la opción de aplicar la duplicación.";
symmetry.mirrorLeftToRight = "De izquierda a derecha";
symmetry.mirrorRightToLeft = "De derecha a izquierda";
symmetry.mirrorFail = "No se pudo aplicar la simetría.

¿Quieres imponer la simetría duplicando la malla?";
symmetry.mirrorUseMasking = "Proteger área enmascarada";
symmetry.mirrorUseMasking.help = "Mantener el área enmascarada intacta.

Esta opción se ignorará con topología no simétrica (o superficie desconectada, como un par de ojos).";
// Reset the symmetry plane position
symmetry.reset = "Restablecer";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Centro de maya";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "Centro del Mundo";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Orientación";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Mostrar línea";
// Display the symmetry plane in 3d
symmetry.showPlane = "Mostrar plano";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Editar aparato";
symmetry.edit.warning = "La edición de simetría es experimental.";
symmetry.edit.help = "Puedes establecer libremente el plano de simetría.

Esta función es un poco experimental y probablemente nunca deberías usarla.";

// Ideally <10 chars
tool.dynTopo = "DynTopo";
// Ideally <10 chars (Symmetry)
tool.symmetry = "Sim";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "Espejo";
// Ideally <10 chars
tool.clay = "Arcilla";
// Ideally <10 chars (Subtract)
tool.clay.sub = "Sub";
// Ideally <10 chars
tool.brush = "Brocha";
// Ideally <10 chars
tool.move = "Mover";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "Normal";
// Ideally <10 chars
tool.drag = "Arrastrar";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "Suavizar";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Relajar";
// Ideally <10 chars (Paint mask)
tool.mask = "Máscara";
// Ideally <10 chars
tool.mask.unmask = "Quitar máscara";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "Sel. máscara";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "Difuminar";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "Aplanar";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Rellenar";
// Ideally <10 chars (Layer brush)
tool.layer = "Capa";
// Ideally <10 chars
tool.crease = "Doblar";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "Recortar";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Dividir";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "Proyectar";
// Ideally <10 chars
tool.inflate = "Inflar";
// Ideally <10 chars
tool.pinch = "Pellizcar";
// Ideally <10 chars
tool.nudge = "Posicionar";
// Ideally <10 chars
tool.stamp = "Tapón";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "Eli. capa";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.select = "Seleccionar";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "Aparato";
// Ideally <10 chars
tool.gizmo.editPivot = "Pivote";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "Capturar";
// Ideally <10 chars (Snap translation)
tool.gizmo.moveSnap = "Capturar";
// Ideally <10 chars (Local space)
tool.gizmo.local = "Local";
// Ideally <10 chars (Local space)
tool.gizmo.world = "Mundo";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "Transformar";
// Ideally <10 chars (Translate the object)
tool.transform.move = "Mover";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "Rotar";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "Escala";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "Capturar";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "medir";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "Ver";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "Torno";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "Tubo";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "Insertar";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "Voltear";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "Ver";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "Lazo";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Curva";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Polígono";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Ruta";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "Rect";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "Elipse";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "Línea";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Cerrado";

// Popup when editing the vertical sliders on the left
tool.slider.radius = "Radio $0";
// Popup when editing the vertical sliders on the left
tool.slider.intensity = "Intensidad $0 %";

tool.settings = "Configuración";
tool.settings.none = "Esta herramienta no tiene ninguna configuración específica.";

// Flatten distance offset
tool.clay.flattenOffset = "Desplazamiento de aplanamiento";
tool.crease.pinchFactor = "Pellizcar fuerza";

tool.layer.removeInfluence = "Usar desplazamiento de capa actual";
tool.layer.removeInfluence.help = "Esta opción solo está activa cuando hay una capa actual seleccionada.

Utilizará el desplazamiento de capa actual para limitar el desplazamiento a lo largo de los trazos.";
tool.layer.noLayerSelected = "Esta opción solo está disponible si se seleccionas una capa actual";

tool.flatten.warning = "Estas opciones son experimentales y podrían eliminarse en el futuro";
tool.flatten.planeLockOrigin = "Bloquear origen del plano";
tool.flatten.planeLockNormal = "Bloquear dirección del plano";
tool.flatten.planeAverageOrigin = "Promedio de origen del plano";
tool.flatten.planeAverageNormal = "Promedio de dirección del plano";
tool.flatten.planeOffset = "Desplazamiento del plano";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "Sync";
tool.syncInstance.message = "The new object will be added on all other instances!";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Vértice pegajoso  en el borde";

tool.paint = "Pintura";
// Erase the painting
tool.paint.erase = "Eliminar";
// Only paint the part of the mesh above a certain height
tool.paint.depthFilter = "Filtrado profundo";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Filtrado de capas";
tool.paint.layerFilter.help = "Utiliza esta opción si solo quieres volver a pintar el área ya pintada de una capa.";

// Clear the painted mask
tool.mask.clear = "Eliminar";
// Invert the painted mask
tool.mask.invert = "Invertir";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Invert mask (connected)";
// Blur the painted mask
tool.mask.blur = "Difuminado";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Nitidez";
// The thickness of the extracted mesh (from the painted mask)
tool.mask.thickness = "Espesor";
// Smooth the border of the extracted mesh (from the painted mask)
tool.mask.polish = "Suavidad de bordes";
// Extract a new mesh from the painteed mask and carve/emboss the base mesh
tool.mask.engraveEmboss = "Grabar / Relieve";
// Extract a new mesh from the painted mask
tool.mask.extract = "Extraer";
// Extract two new mesh from the painted mask and from the unmasked area
tool.mask.split = "Dividir";
// How should we close the topology of the extracted object
tool.mask.closeMask = "Acción de cierre (enmascarado):";
// How should we close the topology of the extracted object
tool.mask.closeUnmask = "Acción de cierre (desenmascarad):";
// How should we close the topology of the extracted object
tool.mask.closeAction = "Acción de cierre:";
// Do not close the mesh (leave it open)
tool.mask.closeActionNone = "Ninguno";
// Close the mesh with a hole-filling algorithm
tool.mask.closeActionFill = "Rellenar";
// Close the mesh by adding a thickness on the surface
tool.mask.closeActionShell = "Caparazón";
// Close the mesh by using the layer data as a difference thickness
tool.mask.closeActionLayer = "Capa";
tool.mask.closeAction.help = "-- Ninguno
Simplemente extrae la pieza y deja que la parte extraída se abra.

-- Rellenar
El agujero se rellena y se alisa.
No utilices esta opción para superficies planas.

-- Caparazón
Cierra la forma extraída utilizando el valor de espesor.

-- Capa
Extrae la diferencia de capa (solo submenú de capa).";

// Transform/Matrix
tool.matrix = "Matriz";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.apply = "Objetivo";
// Automatic
tool.matrix.apply.auto = "Automático";
// Transform the object alone (the children stands still)
tool.matrix.apply.object = "Objeto";
// Auto apply the transform on the vertices
tool.matrix.apply.vertex = "Vértice";
// Transform the object and its children
tool.matrix.apply.group = "Agrupar";
tool.matrix.apply.help = "-- Automático
De forma predeterminada, esto funciona de forma parecida a la opción Grupo.
Si la malla tiene una máscara o si se ha activado la simetría con el gizmo, funcionará igual que la opción Vértice.

-- Vértice
Se intenta aplicar la transformación a los vértices. No funcionará con primitivas sin validar.
También se verán modificadas las instancias.

-- Objeto
Se mueve únicamente el objeto, ignorando la simetría y la máscara.
Solo se moverá el nodo editado; los nodos hijos quedarán inmóviles.

-- Grupo
Se mueve el nodo, ignorando la simetría y la máscara. El resto de la jerarquía también se transformará.";
// Operation on the mesh
tool.matrix.action = "Acción";
tool.matrix.action.help = "-- Mover origen
Mueve la malla al origen mundial.

-- Restablecer
Restablece la transformación de malla a identidad.

-- Hornear
Aplica la matriz al vértice y restablece la matriz. Visualmente, nada debería cambiar.";
tool.matrix.translation = "Traducción";
tool.matrix.rotation = "Rotación";
tool.matrix.scale = "Escala";
// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "Sesgar";
tool.matrix.uniformScale = "Escala uniforme";
tool.matrix.uniformScale.help = "Nomad no puede admitir una escala no uniforme como transformación de objeto, por lo que se aplicará como transformación de vértice.";
tool.matrix.moveToOrigin = "Mover origen";
tool.matrix.resetTransform = "Restablecer";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "Hornear";

tool.transform.tip = "Single tap with second finger to switch mode";

// Size of the gizmo
tool.gizmo.size = "Tamaño del widget";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "Entrada numérica";
tool.gizmo.allowInput.help = "Allow numerical input when tapping one of the gizmo widget";
// Angle threshold
tool.gizmo.linearRollThreshold = "Umbral de balanceo tangente";
tool.gizmo.linearRollThreshold.help = "Umbral de ángulo para elegir entre el método de rodillo lineal o circular.

El valor por encima de este umbral utilizará el rodillo circular.

Si prefiere el rodillo lineal (dirección de la tangente), simplemente establezca este valor en 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Ocultar en interacción";
tool.gizmo.tap = "Mover pivote personalizado con una sola pulsación";
tool.gizmo.tap.help = "Esta opción solo es efectiva en el modo de pivote personalizado (desactivado automáticamente).

-- Ninguno
No pasa nada al pulsar la malla.

-- Primer golpe
Mueve el Gizmo en la primera intersección.

-- Punzada media
Mueve el Gizmo en el promedio de las dos primeras intersecciones.";
tool.gizmo.tapNone = "Ninguno";
tool.gizmo.tapFirstHit = "Primer golpe";
tool.gizmo.tapMiddleStab = "Punzada media";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "Fijado";

// Fill the object's hole
tool.hole = "Relleno de agujero";
tool.hole.fillHoles = "Rellenar agujeros";
// synonym: Alternative method
tool.hole.bridges = "Espacio de pantalla booleano";
tool.hole.bridges.help = "Si esta opción está habilitada, puedes hacer agujeros en el volumen.
La pendiente de corte también seguirá más de cerca la forma de corte.";
tool.hole.threshold = "Epsilon de umbral";
tool.hole.threshold.help = "Ajustar este valor podría ayudar con el algoritmo de rellenado de orificios.";
tool.hole.smoothing = "Suavidad del agujero";

tool.smudge.quality = "Calidad";
tool.smudge.quality.help = "Cambia la resolución de los píxeles proyectados, los valores más bajos significan trazos más rápidos.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Forma";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Cuadrado";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Centrado";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Circulo";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Centrado";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Girar paso";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Mostrar radio dorado";

// Topology
topology = "Topología";
// Synynom: detail value, density
topology.dynamic.detail = "Detalle";
// See glossary
topology.multires = "Multiresolución";
topology.multires.help = "Mantén la resolución múltiple de una malla.

Si realizas cambios en una resolución más baja, los detalles de las resoluciones más altas se reproyectarán cuando vuelva a cambiar.

Las capas están disponibles en todas las resoluciones.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "Reverso";
topology.multires.reverse.confirm = "No se pudo crear la subdivisión base.

La topología actual probablemente no es el resultado de una subdivisión.";
topology.multires.subdivide = "Subdividir";
topology.multires.subdivide.confirm = "La malla tendrá vértices de $0M, ¿estás seguro?";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "Límite de subdivisión excedido, ver $0";
topology.multires.deleteLower = "Eliminar inferior";
topology.multires.deleteHigher = "Eliminar superior";
topology.multires.keepTriangles = "Mantener triángulos";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "";
// Synonym: Flat subdivision
topology.multires.linear = "Subdivisión lineal";
topology.multires.linear.help = "Simplemente subdivide la malla sin aplicar suavizado";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Refuerzo de malla de Voxel";
topology.voxel.help = "Refuerzo de malla muestreando la malla en una cuadrícula.

Si el objeto no está cerrado (estanco), se aplicará primero un algoritmo de rellenado de orificios.

Las capas se vuelven a inyectar después de volver a mallar, pero la calidad se degradará.";
topology.voxel.resolution = "Resolucion";
topology.voxel.remesh = "Reforza de malla";
topology.voxel.sharp = "Mantener bordes nítidos";
topology.voxel.sharp.help = "Esta opción es útil principalmente para operaciones booleanas primitivas simples.

Introducirá distorsión en alguna área debido a que los puntos se rompen en los bordes.";
topology.voxel.subLevel = "Construir multiresolución";
topology.voxel.subLevel.help = "Puedes reconstruir una jerarquía de varias resoluciones a partir de la salida del remezclador de Voxeles.

También se ejecutará más rápido y usará menos memoria, especialmente si el valor de detalle de Voxel es alto.
Sin embargo, si el valor de detalle de Voxel es bajo y estás solicitando muchos niveles múltiples, perderás detalles.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Reforzar malla";
topology.surface.detail = "Detalle";
topology.surface.detail.help = "A diferencia del refuerzo de malla del Voxel, el de superficie no requiere que la malla esté cerrada.

También puede admitir enmascaramiento para que pueda proteger una parte de la malla de los cambios de topología.

Las capas se actualizan correctamente.";
topology.surface.method = "Método";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Uniformidad";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Subdivisión";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Diezmado";
topology.surface.method.help = "Comportamiento de la topología dinámica:
- Uniformidad: añadir y eliminar detalles
- Subdivisión: añadir detalle
- Diezmado: eliminar detalles.";
topology.surface.useMasking = "Proteger área enmascarada";
topology.surface.useMasking.help = "The masked areas will protect the topology from being changed.";
topology.surface.extrapolate = "Extrapolación de vértices";
// DynTopo
topology.dynamic = "Topología dinámica";
topology.dynamic.activate = "Habilitado";
topology.dynamic.activate.help = "Con la topología dinámica, las herramientas de escultura pueden subdividir o simplificar la malla localmente en tiempo real.

Esta característica puede tener un impacto notable en el rendimiento.

Las capas se actualizan correctamente.";
topology.dynamic.method = "Detalle basado en...";
topology.dynamic.method.zoom = "Zoom";
topology.dynamic.method.radius = "Radio";
topology.dynamic.method.constant = "Constante";
topology.dynamic.method.help = "-- Zoom
El nivel de detalle se basa en lo lejos que se encuentre de la superficie.

-- Radio
El radio de la herramienta define la cantidad de detalle.

-- Constante
El detalle está fijado, el valor de detalle también se comparte con el control deslizante de Voxel.";
topology.dynamic.quality = "Preferir...";
topology.dynamic.quality.help = "Si eliges la calidad, las dos diferencias principales son:
- el refinamiento se aplica antes que el operador de escultura, obtendrá menos artefactos de interpolación al pintar o esculpir detalles muy pequeños
- el refinamiento no se aplica de forma incremental, si esculpe detalles muy pequeños o realiza trazos rápidos, la topología siempre se refinará correctamente

Para un mejor rendimiento, y si planea usar esta opción, puedes considerar habilitar la opción 'dibujo parcial' en el panel de configuración.";
topology.dynamic.quality.speed = "Velocidad";
topology.dynamic.quality.quality = "Calidad";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Aplicar presión sobre el radio";
topology.dynamic.usePressure.help = "Utiliza esta opción si deseas que el impacto de la presión del lápiz en el radio de la herramienta afecte al nivel de detalle.";
// Decimate
topology.decimate.title = "Diezmado";
topology.decimate.title.help = "Reduce el número de polígonos intentando mantener la mayor cantidad de detalles posible..

Esta función puede ser útil si quieres exportar para una impresión 3D.
Sin embargo, probablemente no deberías usarlo si quieres seguir esculpiendo en él, ya que puede producir triángulos desiguales.

Ten en cuenta que el área enmascarada no se diezmará.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Diezmar";
topology.decimateTargetFaces = "Triángulos objetivos";
topology.decimatePaintWeight = "Preservar pintura";
topology.decimatePaintWeight.help = "Un valor más alto intentará preservar la pintura.

Establece este valor en 0 si no te importa la pintura.";
topology.decimateUniform = "Caras uniformes";
topology.decimateUniform.help = "Un valor más alto generará triángulos de tamaño similar.";
// topology.decimatePreserveBorders = "Preserve borders";
// topology.decimatePreserveBorders.help = "Do not decimate the border of the mesh.";

// Unwrapping means compute UV (texture coordinates), it allows the object to receive on texture (wrap the texturing on the object)
topology.uv.title = "Desenvoltura automática UV";
// UV Unwrapping
topology.uvAtlas = "Desenvolver Atlas";
// The operation can be very slow
topology.uvAtlas.warning = "Puede ser muy lento, objetivo a < 100k vértices";
// UV Unwrapping (BFF best left untranslated, stands for Boundary First Flattening)
topology.uvBFF = "Desenvolver Bff";
// Handles are topological holes (synonym: genus, hole)
topology.uvBFF.warning = "Can have overlaps if the mesh has handles!";
// Synonym: Point count? Singularity count ?
topology.uvBFFCones = "Recuento de conos";
topology.uvBFFCones.help = "Un valor más alto reducirá la distorsión para objetos complejos.

Un valor más alto significará un tiempo de cálculo más largo.";
topology.uvDelete = "Eliminar UV";

// Transfer the vertex painting in the texture
topology.bake = "Hornear pintura de vértices";
topology.bake.help = "Transfiere la pintura de vértices a una textura.

El color de los vértices se restablece en el proceso.";
topology.bakeResolution = "Resolucion";

// Reset key-bindings/shortcuts
binding.reset = "Restablecer atajos";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.materialPicker = "Selector de material";
// Edit the tool brush size/radius
binding.editRadius = "Radio de herramienta";
// Edit the tool brush size/radius
binding.editIntensity = "Intensidad de herramienta";
// Snap the camera
binding.viewFront = "Vista frontal";
// Snap the camera
binding.viewLeft = "Vista izquierda";
// Snap the camera
binding.viewTop = "Vista superior";
// Move/Translate the view
binding.panLeft = "Desplazar a izquierda (vista)";
// Move/Translate the view
binding.panRight = "Desplazar a derecha (vista)";
// Move/Translate the view
binding.panForward = "Desplazar hacia delante (vista)";
// Move/Translate the view
binding.panBackward = "Desplazar hacia atrás (vista)";
// Move/Translate the view
binding.panUp = "Desplazar arriba (vista)";
// Move/Translate the view
binding.panDown = "Desplazar abajo (vista)";
// Snap the view (while rotating)
binding.snapViewOnRotate = "Ajustar vista (al rotar)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "Abrir (proyecto)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "Añadir (proyecto)";
// Import an external scene file (replace current scene)
binding.import.open = "Abrir (importar)";
// Import an external scene file (add it to the current scene)
binding.import.add = "Añadir (importar)";
// Select all the objects in the scene
binding.selectAll = "Seleccionar todo";
// Rotate environment and the lighting
binding.rotateLighting = "Girar iluminación";

// Privacy policy
privacyPolicy.title = "Política de privacidad";
privacyPolicy.reject = "Rechazar";
// Hexanomad is the company name
privacyPolicy = "Hexanomad no recopila ningún dato de Nomad Sculpt.";

// version trial
version.buyWeb = "La versión web es solo una demostración";
version.buyFull = "Actualiza a la versión completa";
version.restorePurchase = "Restaurar compra";

version.trialHistory = "Versión de prueba: Deshacer/rehacer 4 veces";
version.trialLayer = "Trial version: 1 layer per object";
version.trialOneProject = "Versión de prueba: solo un proyecto activo";
version.trialNoImport = "Versión de prueba: sin importación";
version.trialNoExport = "Versión de prueba: sin exportación";

version.fullFeatures = "- Compra única
- Deshacer/rehacer ilimitado
- Capas ilimitadas
- Guardar y cargar
- Exportación e importación";
