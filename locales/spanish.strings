// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "¿Confirmar?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Sí";
// Answer to a question (Are you sure you want to do that? [yes, no, cancel])
confirm.no = "No";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "Aceptar";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Cancelar";

// Experimental feature
experimental = "¡Experimental!";

status.exit = "¡Cambios no guardados! ¿Desea guardar antes de cerrar?";
status.exit.yes = "Guardar";
status.exit.no = "No guardar";

// On single tap (should be short)
ontap = "Pulsación";

all = "Todo";
error = "Error";

reset = "Restablecer";
resetOrder = "Restablecer el orden";

clipboard = "Portapapeles";
clipboard.copy = "Copiar";
clipboard.paste = "Pegar";

// memory size
bytes = "bytes";
kB = "kB";
MB = "MB";
GB = "GB";
TB = "TB";

// Noun
instance = "Instanciar";
object = "Objeto";

// Same value (usually for axis, e.g: x == y == z)
uniform = "Uniforme";

sync = "Sincronizar";

// position
position.top = "Superior";
position.bottom = "Inferior";
position.left = "Izquierda";
position.right = "Derecha";
position.center = "Centrada";
// direction
direction.up = "Superior";
direction.down = "Inferior";
direction.left = "Izquierda";
direction.right = "Derecha";
// 3d cube
cube.top = "Superior";
cube.bottom = "Inferior";
cube.left = "Izquierda";
cube.right = "Derecha";
cube.front = "Frontal";
cube.back = "Posterior";

// Name of an item (object, tool, etc)
item.name = "Nombre";
// Add a new item (object, tool, etc)
item.new = "Crear";
// Rename an item (object, tool, etc)
item.rename = "Renombrar";
// Add a new item (object, tool, project, etc)
item.add = "Añadir";
// Update an item image with a new image (synonym: Update)
item.replace = "Reemplazar";
// Save an item (object, tool, etc)
item.save = "Guardar";
item.save.confirm = "¿Confirmar guardado?";
// Update an item (update camera view point, etc)
item.update = "Actualizar";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Último guardado";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "¿Cargar último guardado?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Restablecer";
item.reset.confirm = "¿Confirmar restablecido?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "Instanciar";
// Uninstance the object, make the object real
item.uninstance = "Des-instanciar";
// Clone an item (object, tool, etc)
item.clone = "Clonar";
// Delete an item (object, tool, etc)
item.delete = "Eliminar";
item.delete.confirm = "¿Confirmar eliminación?";
item.delete.confirm.yes = "Sí, eliminar";
// When we delete the item but the image is used somewhere
item.delete.used = "Imagen utilizada";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "A nodo";
// Item visibility (object, layer, etc)
item.visible = "Visible";
// Show an item (object, layer, etc)
item.show = "Mostrar";
// Hide an item (object, layer, etc)
item.hide = "Ocultar";
// Select an item (object, layer, etc)
item.select = "Seleccionar";
// Unselect an item (object, layer, etc)
item.unselect = "Deseleccionar";
// Merge an item with another one below (layer)
item.mergeDown = "Fusionar hacia bajo";
// The order of an item in a list
item.order = "Orden";
// Focus on previous item
item.previous = "Anterior";
// Focus on next item
item.next = "Siguiente";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "Bloquear";
// No item selected
item.none = "Ninguno";

// Search something (text entry to filter item)
search = "Buscar";

// Three-state toggle button (Auto, Off, On)
toggle.on = "Activado";
// Three-state toggle button (Auto, Off, On)
toggle.off = "No";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "Automático";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Faltan miniaturas, reprocesamiento de archivos...";
loading.reprocess.cancel = "¿Omitir generación de miniaturas?";

access.title = "Accesibilidad";
access.window = "Ventana de asistencia";
access.pinch = "Pellizcar";
access.drag = "Arrastrar";
access.rotate = "Rotar";
access.roll = "Rodar";

// Color of an object
material.color = "Color";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "Aspereza";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "Brillo";
// Whether the material is a metal or not
material.metalness = "Metálico";
// How much light a surface will reflect
material.specular = "Especular";
// Light that the surface can emit (glow)
material.emissive = "Emisivo";
// Normal map (synonym: detail, bump)
material.normal = "Normal";
// flip y coordinate
material.normal.flipY = "Invertir Y";
// Ambient Occlusion (AO)
material.occlusion = "Oclusión";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "Texturas";
// Textures/Image
material.texture = "Textura";
// A warning indicating that the mesh has no UVs
material.warningNoUVs = "¡No hay UVs!";
// Texture filtering https://en.wikipedia.org/wiki/Texture_filtering
material.texture.filter = "Filtrado";
// Nearest Filtering (closest sample)
material.texture.nearest = "Más cercano";
// Bilinear Filter
material.texture.linear = "Lineal";
// Mipmap filtering
material.texture.mipmap = "Mipmap";
// Triplanar mapping
material.projection = "Proyección";
material.projection.triplanar = "Triplanar";

// Prefer low power
about.lowPower = "GPU de bajo consumo";
about.lowPower.confirm = "Después de cambiar este valor, necesita reiniciar Nomad.";
// Wintab wacom API
about.wintab = "Usar WinTab";
about.wintab.help = "Si WinTab está habilitado, probablemente debería desactivar Windows Ink en sus configuraciones de Wacom.

De manera similar, si WinTab está deshabilitado, entonces Windows Ink debería estar habilitado en las configuraciones de Wacom.";
// Prefer low power
about.fullScreen = "Pantalla Completa";
// Minify
about.minify = "Minimizar la interfaz de usuario";
about.minify.help = "También puedes pulsar la pantalla con 4 dedos, si el dispositivo lo admite.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Placa giratoria";
// Rotation center of the turntable
about.turntable.pivot = "Centro de rotación";
// Keep current pivot
about.turntable.pivot.keep = "Mantener actual";
// Turntable pivot will be at the center of the scene
about.turntable.pivot.scene = "Escena";
// Make the entire scene turn around (speed of the animation)
about.turntable.speed = "Velocidad";
// Stuffs that I used to make the app
about.credits = "Créditos";
// Link to open source projects that I used for the app
about.credits.openSource = "Código abierto";
// Only translate the &
about.credits.arts = "MatCaps y Hdris";
// Change languages of the app
about.languages = "Idiomas";
about.languages.help = "El archivo de traducción está disponible en $0";
// Link to the App Website
about.website = "Sitio web";
// Link to the App Forum
about.forum = "Foro";
// Link to the App Manual
about.manual = "Manual";
// Link to the App Email
about.mail = "Soporte";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";
// Link to the App Threads account
about.threads = "Threads";

// The user canceled an operation that was running
alert.aborted = "¡Operación abortada!";
// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "¡El objeto no tiene agujeros!";
// No operation occured because the mesh is already manifold
alert.manifold.already = "¡La malla ya es manifold!";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "¡La malla actual es invisible!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Nada que recortar.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Cancelar recorte: la malla está completamente recortada.";
// In order to extract something, the mesh needs to have painted mask
alert.extract.none = "¡Nada que extraer!";
// In order to split something, the mesh needs to have painted mask
alert.extract.split.none = "¡Nada que dividir!";
// List of disabled features when View Mode is selected
alert.view.disabled = "Funciones deshabilitadas en el modo de vista:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Widgets primitivos";
// The object needs to have two parts disconnected
alert.separate.fail = "No se pudo separar: ¡el objeto tiene una sola parte!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "¡Malla reforzada!";
alert.voxelRemesh.empty = "Cancelar refuerzo de malla: La malla resultante no tiene caras.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "¡Entrada no válida!";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "El objeto se duplicará";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "Se creará una instancia del objeto";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Modo de edición de pivote.";
alert.mask.full = "Máscara = 100%!";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "Modo de edición de objetos.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Topología dinámica activa";
// See Glossary (DynTopo)
alert.dynamic.disable = "Deshabilitar la topología dinámica";
alert.colorPicker = "Arrastra el dedo sobre la malla para elegir un color.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Pulsa para salir del modo de transformación.";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "Toca simple para salir del modo de edición de simetría.";
// Show the painted mask on the mesh
alert.mask.show = "Mostrar máscara";
// Hide the painted mask on the mesh
alert.mask.hide = "Ocultar máscara";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Selección de bloqueo";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Selección de desbloqueo";
// Hide the objects that are not selected
alert.selection.isolate = "Selección de aislado";
// Show the objects that are hidden
alert.selection.showAll = "Mostrar todo";
// Project quick saving
alert.quickSave = "Guardando...";
// Painting on the object was hidden but the user did paint the object
alert.forcePainting.fill = "Mostrar pintura activada, se utilizó [Pintar todo].";
// Painting on the object was hidden but the user started to paint on the object
alert.forcePainting.tool = "Mostrar pintura activada, el objeto fue pintado.";
// See Glossary (Multiresolution)
alert.multiresLost = "¡La multirresolución se perderá!";
// Boolean cut mode will ignore some features
alert.booleanIgnored = "¡Boolean ignorará las áreas enmascaradas u ocultas!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "El valor de detalle es alto y puede requerir mucha memoria";
// Autosave popup
alert.autoSave.auto = "Guardar automáticamente en... $0s";
// The selected object doesn't have any layers
alert.needLayer = "La herramienta actual requiere una capa activa.";
// The user decided to hide the painting on the objects
alert.paintingHidden = "Pintura oculta!";
// The user decided to hide the masking on the objects
alert.maskingHidden = "¡La máscara está oculta!";
// The user decided to display hidden faces
alert.hideIgnored = "¡Ocultar es ignorado!";
// The selected object doesn't have any layers
alert.noPartialWireframe = "El dibujo parcial se desactiva cuando se muestra el esquema de página.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Considera la posibilidad de utilizar una cámara ortográfica si quieres evitar la distorsión de tronco de perspectiva al utilizar el proyector de pantalla.";
// Trial version has a limited number of undo
alert.state.trial = "Deshacer cancelación: versión de prueba";

background = "Fondo";
// A flat color will be displayed in the background of the scene
background.color = "Color";
// 2 color with rotation
background.gradient = "Degradado";
// The environment (HDRI) will be displayed in the background
background.environment = "Entorno";
background.blur = "Borroso";
background.exposure = "Exposición";

// Image that the artist uses as a reference
background.imageEnable = "Imagen de referencia";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Superposición";
// Opposite of transparency (Alpha)
background.imageAlpha = "Alfa";
background.imageReset = "Restablecer configuración";
background.imageTransform = "Transformar";
// X screen coordinate of the image reference
background.imageX = "Posición X";
// Y screen coordinate of the image reference
background.imageY = "Posición Y";
// Rotation of the reference image
background.imageRotation = "Rotación";
// Scale of the reference image
background.imageScale = "Escala";
// Auto adjust the reference when moving the camera
background.syncLock = "Sincronizar con bloqueo de cámara";

// Blend: normal
blend.normal = "Normal";
// Blend: darker
blend.darker = "Más oscuro";
blend.darker.darken = "Oscurecer";
blend.darker.multiply = "Multiplicar";
blend.darker.linearBurn = "Quema lineal";
blend.darker.colorBurn = "Intensificar color";
// Blend: lighter
blend.lighter = "Más claro";
blend.lighter.lighten = "Aclarar";
blend.lighter.screen = "Pantalla";
blend.lighter.linearDodge = "Esquiva lineal";
blend.lighter.colorDodge = "Sobreexposición de color";
// Blend: contrast
blend.contrast = "Contraste";
blend.contrast.hardLight = "Luz intensa";
blend.contrast.softLight = "Luz suave";
blend.contrast.overlay = "Superposición";
blend.contrast.hardMix = "Mezcla Dura";
blend.contrast.linearLight = "Luz Lineal";
blend.contrast.vividLight = "Luz Vívida";
blend.contrast.average = "Promedio";
// Blend: inversion
blend.inversion = "Inversión";
blend.inversion.exclusion = "Exclusión";
blend.inversion.difference = "Diferencia";
// Blend: cancelation
blend.cancelation = "Cancelación";
blend.cancelation.divide = "Dividir";
blend.cancelation.subtract = "Sustraer";
// Blend: component
blend.component = "Componente";
blend.component.luminosity = "Luminosidad";

// Camera (point of view in 3d)
camera = "Cámara";
cameras = "Cámaras";
camera.view = "Ver";
// Copy the views
camera.updateView = "¿Actualizar el punto de vista?";
// Add a new camera
camera.addView = "Añadir vista";
// Focus on the camera
camera.focus = "Centrar";
// Add on the camera camera
camera.focusOn = "Centrar";
// Camera projection, Orthographic or Perspective
camera.projection = "Proyección";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Ortográfica";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Perspectiva";
// camera Vertical Field of View
camera.fov = "Campo de visión vertical";
// Camera Field of View hint
camera.focal = "distancia focal $0 mm (sensor de 35 mm)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Modo órbita";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "Giro";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Trackball";
camera.rotation.trackball.help = "La Trackball te da más grados de libertad. También puedes rodar la cámara con 2 dedos.";
// Camera interaction mode, 1st person view
camera.firstPerson = "Primera persona";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Velocidad";
// Camera rotation sensitivity
camera.speed.rotation = "Rotación";
// Camera translation sensitivity
camera.speed.panning = "Hacer panorámica";
// Camera zooming sensitivity
camera.speed.zooming = "Zoom";
// Reset camera position
camera.resetView = "Restablecer vista";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Capturar vista";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "La cámara tiene ajuste (ortográfico)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "Ajuste ortográfico";
camera.snapOrthographic.help = "Esta opción también funciona al usar Capturar cubo en la esquina.";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Pivote";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Pulsar dos veces en la malla";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Pulsar dos veces en el fondo";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "Activar/desactivar";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "Selección";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "Escena";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "Pulsar dos veces para actualizar";
camera.doubleTapPivot.help = "Actualiza el pivote de rotación al pulsar dos veces la superficie del objeto.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "Pivote aéreo";
camera.airPivot.help = "Permite un nuevo pivote incluso al hacer zoom fuera de la superficie del objeto.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "Iniciar con gesto en cámara";
camera.autoPivot.help = "Actualiza el pivote cuando comiences a interactuar con la cámara.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Centrar";
camera.doubleTapFocus.help = "Al pulsar dos veces la malla, la cámara se desplazará y enfocará en el punto seleccionado.";
// Disable XY panning when unzomming
camera.centerZoomOut = "Centrar vista al alejar";
camera.panZoomOut.help = "Cuando esta opción está deshabilitada, esta posición de pivote se mantendrá intacta.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "Multiselección";
// There is 0 nodes/items selected
context.noSelection = "No hay nada seleccionado";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "Preajustes";
// Quick curve x side shift
curve.shift = "Mayús";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "Spline";
curve.bspline = "B-spline";
curve.precision = "Precisión";
// merge or collapse 1 point into another
curve.merge = "Fusionar";
// snap
curve.snap = "Capturar";
curve.snap.offset = "Desplazamiento";
curve.snap.offset.help = "Un valor de 100% es igual al radio del tubo.";
curve.snap.surface = "Superficie";
curve.snap.vertex = "Vértice";
curve.snap.grid = "Rejilla (si está capturada)";
// Regular spaced sampling
curve.uniform = "Uniforme";
curve.uniform.help = "La curva será muestreada a intervalos regulares, para asegurar una densidad uniforme.

Puedes desactivar esta opción para controlar un poco los bucles de borde añadiendo nuevos puntos de control en la curva.";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "Muestra el decaimiento de manera simétrica.

Esta opción es solo una señal visual, no afecta el decaimiento en sí";
curve.radius = "Radio";
curve.twist = "Retorcer";
curve.spiral = "Espiral";
curve.spiral.twist = "Ángulo de torsión";
curve.spiral.scale = "Escala";
curve.spiral.offset = "Desplazamiento";
curve.spiral.angle = "Desplazamiento de ángulo";
curve.pivot = "Pivote";
curve.pivot.self = "Curva";
curve.pivot.children = "Hijos";

// Set the desired FPS (frame per second, refresh rate)
debug.limitFps = "FPS del objetivo";
debug.limitFps.help = "Cuando está desactivado, el valor predeterminado significa que se sincronizará con la tasa de refresco de la pantalla.";

// Warning about UVs (using extra memory)
debug.uvPrimitive.warning = "Deshabilita esta opción si no necesitas UV (memoria adicional).";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "Normalizar UV";
debug.uvNormalize.help = "Nomad normalizará los UV dentro del mosaico [0-1].";

// Debug option, display an window with some debugging logs
debug.logs = "Registros";
// Model shortcut window
debug.shortcut = "Ventana de atajos";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Mapa de alturas";
// Debug options, graphical stuffs
debug.graphics = "Gráficos";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Crear miniaturas de tienda";

// Open file explorer
file.explore = "Explorar";
// Empty list: there is no projects
file.project.load = "Recargar proyecto al iniciar";
// Empty list: there is no projects
file.project.empty = "¡Aún no tienes ningún proyecto guardado!";
// The current opened project has some unsaved changes
file.project.unsaved = "¡Cambios no guardados!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "¡Perderá los cambios no guardados!";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Vista previa de lo último guardado manualmente";

file.project = "Proyecto";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Guardar";
// E.g: Save "my_project"?
file.project.save.confirm = "¿Guardar $0?";
// Make a copy
file.project.saveAs = "Guardar como";
// Overwrite another project
file.project.overwrite = "¿Sobrescribir?";
// E.g: Overwrite "my_other_project"?
file.project.overwrite.confirm = "¿Sobrescribir $0?";
// Open a project
file.project.open = "Abrir";
// E.g: Open "my_project"?
file.project.open.confirm = "¿Abrir $0?";
// E.g: Clone "my_project"?
file.project.clone.confirm = "¿Clonar $0?";
// Load another project and add/append all its data to the current scene
file.project.add = "Añadir a la escena";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "¿Añadir $0 a la escena?";
// Reset the scene and create a new project
file.project.new = "Crear";
file.project.new.confirm = "¿Crear nueva escena?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "¿Eliminar $0?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "¿Eliminar $0?

¡Este es el proyecto activo actual!";

// Auto save section
file.autoSave = "Guardado automático";
file.autoSave.confirm = "¿Desactivar el guardado automático?";
file.autoSave.help = "Guarda el proyecto en un archivo separado a intervalos regulares.

El archivo de guardado automático se puede encontrar en:";
// Interval in minutes in which the auto save popup will appear
file.autoSave.popup = "Tiempo de espera emergente";
// In minutes
file.autoSave.minutes = "Temporizador emergente";
// Delete the current autoSave data
file.autoSave.delete = "Descartar auto guardado";
// Open the outdated auto save
file.autoSave.open.manual = "Abrir guardado manual desactualizado";
file.autoSave.open.auto = "Abrir auto guardado desactualizado";

// color space (linear or srgb), do not translate linear/srgb if there is a doubt
file.colorSpace = "Espacio de Color";
file.colorSpace.help = "Intenta alternar esta opción si los colores parecen incorrectos.";
file.colorSpace.linear = "Lineal";
file.colorSpace.srgb = "sRGB";

// Configure imports option
file.importSettings = "Importar opciones";

// Load interface preference settings when opening a scene file
file.import.guiSettings = "Mantener la configuración de la gui";
file.import.guiSettings.help = "Al abrir o importar un archivo de proyecto, se cargarán todas las configuraciones relacionadas con la gui integradas en el proyecto.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.import.obj.splitByGroup = "Dividir OBJ por grupos";
file.import.obj.splitByGroup.help = "Cuando está habilitado, Nomad dividirá el grupo de vértices OBJECT en objetos separados.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.import.mergeLayers = "Combinar capas";
// Ignore the textures present in the file to load
file.import.skipTextures = "Omitir texturas";
// Do not fiddle with the object topology when loading the file
file.import.keepTopology = "Mantener topología";
file.import.keepTopology.help = "Utilice esta opción si no desea que Nomad juegue con la topología de la malla importada.

Deshabilitará el reordenamiento de vértices/caras, la eliminación de duplicados de vértices/caras y la eliminación de vértices no utilizados.";

// Import file section
file.import.title = "Importar";
file.import.title.help = "Formato compatible:";
// The user imports a scene file that will replace the current scene
file.import.open = "Abrir";
file.import.open.confirm = "¿Importar un nuevo archivo?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Añadir a escena";
file.import.add.confirm = "¿Importar un nuevo archivo?";

// Export scene file
file.export = "Exportar";

// Filter nodes that we want to export
file.select.include = "Incluir";
file.select.all = "Todo";
file.select.visible = "Visible";
file.select.selected = "Seleccionado";
file.select.unselected = "No seleccionado";

// Export each node in a separate file
file.export.separate = "Un archivo por objeto";

// Export the current selected objects instead of the entire scene
file.onlySelection = "Exportar selección únicamente";
file.onlySelection.help = "Exportar la malla seleccionada actual en lugar de toda la escena.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Reconstruir quad";
file.convertToQuad.help = "Reconstruye quads a partir de triángulos emparejando triángulos (si son adyacentes en los archivos).";
// ----------------------------------------------
// Whether we include the textures in the exported file
file.export.texture = "Texturas";
// Baking means transfering/converting
file.export.texture.help = "Esta opción no integra colores de vértices en texturas.";
// ----------------------------------------------
file.export.color0 = "Colores de vértices";
file.export.color1 = "Pintura PBR";
file.export.color1.help = "Exportar rugosidad, metalidad y pintura de máscaras. Esto será ignorado por otros softwares.";
// ----------------------------------------------
// Whether we include normals vector in the exported file
file.export.normal = "Normales";
file.export.normal.help = "Marca esta opción si deseas abrir el archivo en otro software.

Nomad siempre ignora las normales, ya que las volverá a calcular.";
// ----------------------------------------------
file.export.tangent = "Tangencias";
file.export.tangent.help = "Marca esta opción si deseas abrir el archivo en otro software.

Las tangencias solo se utilizan si el modelo tiene un mapa normal.

Nomad siempre ignora las tangencias ya que las volverá a calcular.";
// ----------------------------------------------
file.export.nomad.help = "Formato de archivo interno de Nomad Sculpt.

Este formato no se cargará en otros programas, esto es principalmente para propósitos de re-importación.";
// ----------------------------------------------
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Capas";
file.export.gltf.layer.help = "Exportar capas como transformaciones. Oficialmente compatible con glTF, por lo que también debería funcionar en otros softwares.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Pintura de capa";
file.export.gltf.layerPaint.help = "Exportar pintura de capa. Por lo general, es ignorado por otros softwares.";
// ----------------------------------------------
file.export.obj.warning = "Se perderán las capas y la pintura adicional (rugosidad, metálico y máscara).";
// Whether we include the vertex color in the exported file
file.export.obj.color = "Colores de vértices";
file.export.obj.color.help = "Algunos softwares 3D podrán leerlo, pero no todos.";
file.export.obj.color.help.append = "Agregar información de color después de los vértices.";
file.export.obj.color.help.hexa = "Una forma alternativa de codificar el color. También soporta datos de máscara.";
file.export.obj.faceGroup = "Grupo de Caras";
file.export.obj.object = "Escribir objetos";
file.export.obj.object.help = "Mantener objetos separados.

Desactivar esta opción exportará todo como una sola entidad.
Debes desactivar esta opción si quieres usar la característica 'Mesh ID / Polygroup' de Substance Painter.";
file.export.obj.archive = "Tipo";
file.export.obj.archive.folder = "Carpeta";
file.export.obj.archive.zip = "Zip";
file.export.obj.archive.help = "Algunas aplicaciones (Google Drive, One Drive, etc.) no admiten la importación de carpetas, por lo que puedes usar Zip en su lugar.";
// ----------------------------------------------
file.export.ply.warning = "Se perderán las capas y la pintura pintura (rugosidad, metálico y máscara).";
// ----------------------------------------------
file.export.stl.warning = "Se perderán las capas y la pintura pintura (rugosidad, metálico y máscara).";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Colores de vértices";
file.export.stl.color.help = "Algunos softwares 3D podrán leerlo, pero no todos.";
// ----------------------------------------------
file.export.usd.skew = "Permitir inclinación";
file.export.usd.skew.help = "Permitir inclinación en las transformaciones de la matriz.

Cuando está deshabilitado, Nomad dividirá las matrices de inclinación en dos transformaciones separadas de escalado y rotación.";
// ----------------------------------------------
// Advanced settings
settings.advanced = "Avanzado";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "Estas opciones no se guardan en la configuración.";
settings.reset.title = "Configuración";
settings.reset.title.help = "Restablecerá los ajustes de la app.

Ciertos recursos se guardan por separado y NO se restablecerán, entre ellos:
• Proyectos
• Atajos de teclado
• Preajustes de herramientas
• Entornos HDR
• MatCaps
• Alfas
• Texturas (pincel)
• Imágenes de referencia

Importante: todo lo vinculado con el proyecto permanecerá intacto, como la iluminación, posprocesado, vistas de cámara, etc.";

// Reset preference settings button
settings.reset = "Restablecer a los valores predeterminados";
settings.reset.confirm = "¿Restablecer las preferencias?";

// Render a screenshot of the scene
file.render = "Renderizar";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Mostrar interfaz";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Render proporción";
file.render.renderRatio.help = "Un valor de 1.0 significa que Nomad se renderizará con la misma resolución que el tamaño de imagen solicitado a continuación.

Utiliza esta opción si no puedes renderizar a una resolución determinada (se bloquea por falta de memoria).";
// Desired size of the exported screenshot
file.render.size = "Tamaño final";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Personalizar";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "Pantalla";
// width of exported screenshot
file.render.width = "Ancho";
// height of exported screenshot
file.render.height = "Altura";
// export screenshot of the scene
file.render.warn = "¡La resolución de exportación es alta ($0x$1)!

Asegúrate de guardar el proyecto en caso de que el dispositivo se quede sin VRAM y se bloquee.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Fondo transparente";
file.render.transparent.help = "Esta opción puede ser útil si quieres insertar la malla en un software de creación 2D.

Por el momento, no se admite la transparencia parcial de objetos.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Utilizar configuración global";
pressure.useGlobal.help = "De forma predeterminada, las herramientas comparten los mismos ajustes de presión.

Desmarca esta opción si quieres la configuración de presión específica para esta herramienta.";

// Pencil pressure
pressure.title = "Presión";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "Esta herramienta no usa presión de lápiz.";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "El tipo de pincel de agarre ignorará los ajustes de presión.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Radio";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Intensidad";
// Average pencil pressure event to get smoother result
pressure.average = "Suavizado de presión";
pressure.average.help = "Promedia los eventos de presión del lápiz para obtener resultados más suaves.";
// Limit pressure to 100%
pressure.limit = "Limitar presión al 100%";
pressure.limit.help = "Esta es una configuración global.

Use esta opción para asegurarse de que la presión del lápiz nunca supere el 100%.";

// list of inputs allowing camera interaction
gesture.camera = "Cámara";
// list of inputs allowing sculpting interaction
gesture.sculpt = "Esculpir";
// Select object
gesture.select = "Seleccionar objeto";
// Finger/Touch input
gesture.finger = "Dedo";
// Stylus/Pencil
gesture.stylus = "Lápiz";
// Mouse/Trackpad
gesture.mouse = "Ratón";

// long press to pick the color/material under the cursor
gesture.dropper = "Selección de material";
gesture.dropper.help = "El selector de color/material se puede invocar manteniendo pulsado el lienzo.

Importante: esto solo funciona si el pincel actual tiene activada la pintura.";

camera.airStroke = "Permitir trazo aéreo";
camera.airStroke.help = "Permitir que el trazo de escultura comience incluso si el cursor inicial falla en la malla.

Esta opción solo está activa para entradas con escultura habilitada y cámara desactivada.";

// Three fingers on screen
gesture.three.title = "Tres dedos";
gesture.three.light = "Girar iluminación";
gesture.three.light.help = "Rotar el entorno, las luces y el MatCap.";
gesture.three.radius = "Radio de herramienta";
gesture.three.intensity = "Intensidad de herramienta";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.finger.smooth = "El dedo siempre suaviza";
gesture.finger.smooth.help = "Esta opción solo está activa si una herramienta de escultura está activa.";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Permitir presión no reconocida";
gesture.unknownPressure.help = "Marca esta opción si la presión no funciona con el lápiz o si necesitas presionar con el dedo.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Botón de lápiz";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Pulsar dos veces con el lápiz";
gesture.pencilAction.ios.help = "Solo activo para el Apple Pencil de 2.ª gen.";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "Ninguno";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Añadir/Restar";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "Atajos de un toque";
gesture.mask.oneTap.help = "Permite usar el atajo de Máscara tocando una vez la pantalla, sin necesidad de mantener pulsado el atajo del botón de máscara.

Permite el siguiente gesto:
• tocar en el fondo para invertir la máscara
• tocar en una zona con máscara para desenfocar la máscara
• tocar en una zona sin máscara para enfocar la máscara";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.holdStroke = "Trazo";
gesture.mask.holdStroke.help = "Una pulsación larga alternará entre Máscara y SelMáscara y comenzará un nuevo trazo.

Al final del trazo, se selecciona de nuevo la herramienta anterior.";
gesture.mask.holdIdle = "Herramienta";
gesture.mask.holdIdle.help = "Pulsación larga y suelta sin mover para cambiar entre Máscara y SelMáscara.";

// Shortcut customization, choose the action that the shortcut will performan (select tool, etc)
gesture.shortcut = "Atajo";

// Shortcuts to undo/redo
gesture.history = "Atajos del historial";
gesture.history.help = "• Deshacer: pulsa con 2 dedos
• Rehacer: pulsa con 3 dedos";
gesture.history.hold = "Pulsación larga";
gesture.history.hold.help = "Mantén 2/3 dedos hacia abajo (continuo)";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Utilizar rechazo de tamaño";
gesture.palmRejection.confirm = "Asegúrate de desactivar esta opción si tienes problemas para interactuar con el lienzo";
gesture.palmRejection.help = "Rechaza la entrada si el área de contacto es mayor que este valor.

Es posible que no funcione en todos los dispositivos.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Umbral de tamaño máximo";

// Smoothing strategy
extract.polish.all = "Todo";
extract.polish.sharp = "Borde afilado";
extract.polish.border = "Solo bordes";
// Smooth the border in a way that it matches completely with its dual
extract.polish.syncBorder = "Sincronizar borde";
// topology of extracted mesh
extract.edgeLoop = "Bucle de borde (lateral)";
extract.edgeLoop.auto = "Bucle de borde automático";
extract.edgeLoop.division = "División";
// The thickness of the extracted mesh (from the painted mask)
extract.thickness = "Espesor";
// Carve the mask into the surface
extract.carve = "Grabar";
// Extract a new mesh from the painted mask
extract = "Extraer";
// Preview extract
extract.preview = "Vista previa";
// Extract two new mesh from the painted mask and from the unmasked area
extract.split = "Dividir";
// How should we close the topology of the extracted object
extract.action = "Acción de cierre:";
extract.action.help = "• Ninguno
Simplemente extrae la pieza y deja que la parte extraída se abra.

• Rellenar
El agujero se rellena y se alisa.
No utilices esta opción para superficies planas.

• Caparazón
Cierra la forma extraída utilizando el valor de espesor.

• Capa
Extrae la diferencia de capa (solo submenú de capa).";
// Do not close the mesh (leave it open)
extract.action.none = "Ninguno";
// Close the mesh with a hole-filling algorithm
extract.action.fill = "Rellenar";
// Close the mesh by adding a thickness on the surface
extract.action.shell = "Caparazón";
// Close the mesh by using the layer data as a difference thickness
extract.action.layer = "Capa";

// uv part of revolution surface
genus.main = "Principal";
genus.hole = "Agujero";
genus.bottom = "Inferior";
genus.top = "Superior";

// History, list of undo/redo
history = "Historial";
// First "undo" state
history.root = "Raíz";
history.undoConfirm = "¿Confirmas deshacer todas estas operaciones?";
history.undoWarning = "Si realizas una edición después, es posible que pierdas muchos cambios.";
// Settings concerning the history stack of undo/redo
history.stack = "Pila";
// Actions to include in the undo/redo stack
history.include = "Incluir acciones";
// include lighting editing in the undo/redo
history.includeLights = "Luces";
history.includeLights.help = "Si esta opción está desactivada, mover las luces con el Gizmo seguirá estando incluido, ya que puede afectar a otros objetos en la jerarquía de la escena.";
// include postProcess editing in the undo/redo
history.includePostProcess = "Posprocesado";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCaps y Hdris";
// Can limit the stack of undo/redo size
history.limitSize = "Límite de historial";
history.limitSize.help = "Tamaño máximo del historial.

El historial se actualizará en la siguiente operación registrada.";
// Limit the number of undo in the history stack
history.limitStack = "Límite de pila";
history.limitStack.help = "Número máximo de operaciones que la aplicación puede mantener.

El historial se actualizará en la siguiente operación registrada.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Protección de rango";
history.rangeProtect.help = "Si retrocedes mucho en el historial, aparecerá un cuadro de diálogo de confirmación antes de deshacer las operaciones.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Restaurar cámara";
history.restoreCamera.help = "Habilita esta opción para restaurar el punto de vista de la cámara guardado al deshacer/rehacer una acción.";
// Undo
history.undo = "Deshacer";
// Redo
history.redo = "Rehacer";
// Shown during undo
history.state.undo = "Deshacer: $0";
// Shown during redo
history.state.redo = "Rehacer: $0";
// Shown during undo/redo
history.state.symmetrySplit = "División de simetría";
// Shown during undo/redo
history.state.voxelRemesh = "Reforzar malla de Vóxel";
// Shown during undo/redo
history.state.surfaceRemesh = "Reforzar malla de superficie";
// Shown during undo/redo
history.state.multiresLevel = "Cambio de resolución";

// Debugging/Inspect object material (view channel separately color, roughness, normal, uv, etc)
inspect = "Inspector";
// Inspector but SHORT
inspect.short = "Inspeccionar";
// Display the material channel on the background
inspect.onBackground = "En Fondo";
// Display the material channel on the mesh
inspect.onMesh = "En Malla";
// Show UV seams
inspect.seams = "Costuras";

// Interface customization
interface = "Interfaz";

// UI customization: one item row will stands on one line (synonym: Inlined)
interface.compact = "IU: Compacta";

// UI customization: each row of the list will be bigger
interface.expandList = "Interfaz de usuario: Expandir lista";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Solo una opción de interfaz de usuario para una administración de listas más fácil.";

// Add shortcuts buttons to the bottom of the screen
interface.shortcut.bottom = "Añadir accesos directos (abajo)...";
// Floating window
interface.shortcut.float = "Añadir accesos directos (ventana flotante)...";

// Interface option (main base color)
interface.colorBase = "Base de color";
// Interface option (accent widget color)
interface.colorSelect = "Widget de color";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Panel transparente";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Fuerza de difuminado";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Panel de control";

// Interface color style
interface.preset.title = "Ajustes predeterminados";

// Reset interface settings
interface.resetAll = "Restablecer interfaz";
interface.resetAll.confirm = "¿Restablecer la configuración de la interfaz?";
// help popup when hovering
interface.hoverHelp = "Ayuda emergente al pasar el cursor";
// Interface option (main base color)
interface.iconSupport = "Botón de alto contraste";
interface.iconSupport.help = "Un estilo alternativo para botones que los hace más visibles cuando están habilitados.

Si se configura en Auto, Nomad usará este modo cuando el contraste de color de la IU entre habilitado/deshabilitado sea bajo.";
// Interface customization
interface.flipTop = "voltear superior";
// Interface customization
interface.flipBottom = "voltear inferior";
// Interface customization
interface.flipMiddle = "voltear medio";
// list of tools
interface.toolbox = "Caja de herramientas";
// hide toolbox by default
interface.toolbox.hide = "Ocultar";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.columns = "Columna";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.rows = "Filas";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Restablecer el orden";
// Colored text and icon
interface.toolbox.color = "Coloreado";
// Scale the interface
interface.scale = "Escala general";
// Spacing between widgets
interface.cursorStep = "Espaciado vertical";
// Width of the interface panels
interface.panelWidth = "Ancho del panel";
// Size of fonts
interface.fontScale = "Escala frontal";
// Inset
interface.inset.title = "Desplazamientos de borde";
interface.inset.title.help = "Solo se pueden cambiar estos valores si tiene problemas para interactuar con los botones de los bordes de la pantalla.

Si el regulador está desactivado, Nomad usará los valores de área segura que indique el propio dispositivo.";

// (see Glossary for Layer)
layer = "Capa";
layers.syncTransform = "Sincronizar transformación";
layers.syncTransform.help = "If enabled, all the unselected layers will be adjusted depending on the transform rotation, scale and skew.

Disable this option if the other layers are meant to be used without the new transform that you are applying.

When set on auto, only the visible layers will be adjusted.";
// (see Glossary for Layer)
layers.lock = "Conservar detalles de capas superiores";
// (see Glossary for Layer)
layers.lock.yes = "¿Bloquear las capas superiores?";
// (see Glossary for Layer)
layers.lock.warning = "Al esculpir, se ignorará la deformación proveniente de las capas superiores.

No obstante, los detalles de dichas capas seguirán siendo visibles.

Esta opción solo funciona si las capas superiores tienen detalles de escala relativamente pequeños.";
// (see Glossary for Layer)
layers.addLayer = "Añadir capa";
// (see Glossary for Layer)
layer.factors = "Factores de canal";
// (see Glossary for Layer)
layer.factor = "Factor";
// (see Glossary for Layer)
layer.offset = "Desplazamiento";
// Layer blend mode
layer.blendMode = "Mezcla";
// (see Glossary for Layer)
layer.base = "Base";
layer.base.nothing = "¡Nada que extraer!";
layer.base.background = "Material de fondo";
layer.base.background.help = "Si está activo, solo se extraerán los valores del material que difieran del material de fondo.";
// (see Glossary for Layer)
layers = "Capas";
layers.title = "Capas";
// (see Glossary for Layer)
layers.title.help = "Las capas pueden registrar desplazamientos de posición y pintura, que puede ser útil para flujos de trabajo no lineales.
Por ejemplo, se puede experimentar con diferentes expresiones faciales sin depender de la pila de historial para deshacer los cambios.

Para pintar datos, las capas se ordenan de arriba hacia abajo; por lo tanto, las capas superiores enmascararán las inferiores.

Puedes restablecer parte de esta máscara (y, por lo tanto, la influencia de la capa) utilizando la herramienta `DelLayer`.";
layers.primitive = "Las capas no están disponibles para las primitivas.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "Ninguno";

light = "Luz";
lights = "Luces";
// Intensity of light
light.intensity = "Intensidad";
// Color of light
light.color = "Color";
// Kelvin (the temperature unit)
light.kelvin = "Kelvin";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "Temperatura";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Adjunto";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Fijado";
// The light will move along the camera
light.attachment.camera = "Cámara";
light.attachment.help = "• Fijado
La orientación de la luz no cambiará.

• Cámara
La orientación de la luz depende de la vista de la cámara.";
// Light type (directional, spot, point)
light.type = "Tipo";
// Directional light (synonym: sun light)
light.type.directional = "Direccional";
light.type.sun = "Sol";
// Directional light (synonym: sun light)
light.type.environment = "Entorno";
light.type.hdri = "HDRI";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Marca";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Punto";
// For directional light (angle jitter)
light.angle = "Ángulo";
// For point/spot light (offset jitter)
light.size = "Tamaño";
// Cone angle for spot angles
light.spot.angle = "Ángulo de cono";
// Softness of the spot light
light.spot.softness = "Suavidad";
// Position of the light
light.position = "Posición";
// Enable or disable shadows for a light
light.shadow.cast = "Sombra";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "La luz puntual solo admite sombras del espacio de pantalla.";
light.shadow.type = "Tipo de sombra";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "Mapa de sombras";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "Espacio de pantalla";
light.shadow.type.screenspace.help = "Esta función es experimental y podría retirarse en las versiones futuras.

Esta opción está pensada para usarse con la función de suavidad de sombra.";
// Adjustment to fix artefacts
light.shadow.bias = "Sesgo";
// How blurry the shadow is
light.shadow.softness = "Suavidad";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "Contacto";
light.contact.help = "Si se selecciona automático, solo la luz más dominante tendrá sombra de contacto.";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "Tolerancia";
// Activated the light
light.visible = "Mostrar";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Volver a centrar";

// Object's material
material = "Material";
// See glossary
material.pbrRoughnessMetalness.warning = "La rugosidad y la metalidad requieren el modo de sombreado PBR.";
// See glossary
material.pbrReflectance.warning = "La reflectancia requiere el modo de sombreado PBR.";
// See glossary
material.pbrRefraction.warning = "La refracción requiere el modo de sombreado PBR.";
// See glossary
material.pbrSubsurface.warning = "La subsuperficie requiere el modo de sombreado PBR.";
// Value that says how much light will change direction when hitting the surface
material.ior = "Índice de refracción";
// an object-level value that overrides the roughness interior/surface of the mesh
material.paintingOverride = "Anular pintura";
// The roughness in the inside is turbidity
material.paintingOverride.help = "Hay dos rugosidades en juego, la que impulsa la superficie y la que está en el interior.

Sin embargo, solo hay una rugosidad que se puede pintar, por lo que las dos rugosidades tienen los mismos valores.";
// Glossiness is simply the opposite of roughness
material.refraction.surface = "Superficie";
// Synonym: turbidity
material.refraction.interior = "Interior";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Pintura brillante";
material.paintGlossy.help = "Pintará el objeto con una rugosidad y metalidad de 0, lo que permitirá una refracción nítida.

Esto es lo mismo que ir al menú pintar y usar la función pintar todo con el color desactivado.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Absorción";
material.absorptionEnable.help = "Simule la luz que se absorbe cuando viaja a través del volumen.

Las partes delgadas brillarán a medida que deja pasar más luz, mientras que las áreas gruesas serán más oscuras.

El efecto depende en gran medida de la geometría de la malla, solo se utiliza una aproximación del grosor de la malla.";
material.absorptionFactor = "Factor";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "Profundidad";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "Translucidez";
material.translucency.help = "Necesitas tener una luz que proyecte sombras para ver la translucidez.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Opacidad";
// Fully opaque material
material.type.opaque = "Opaco";
material.type.opaque.help = "Este es el tipo de material predeterminado.

El alfa del vértice pintado, la textura de opacidad o el canal alfa del canal de color aún se tomarán en cuenta a través del tramado.

Solo se ignorará el control deslizante de opacidad principal.";
// Fully opaque material
material.type.shadowCatcher = "Capturador de sombras";
material.type.shadowCatcher.help = "Hacer el objeto completamente transparente, excepto por las sombras proyectadas por las luces.

Este modo generalmente se utiliza en la geometría del plano.";
material.type.shadowCatcher.warning = "No hay luces con sombras en tu escena, el Caster de Sombras estará inactivo. De lo contrario, si el capturador de sombras es completamente metálico, el Capturador de Sombras puede reflejar la escena si está habilitado el Post Proceso SSR (Reflexión).";
// See glossary
material.type.subsurface = "Subsuperficie";
material.type.subsurface.help = "Para obtener el mejor resultado, puedes cambiar al modo de sombreado PBR y usar al menos una luz direccional, idealmente con un entorno tenue.";
// Transparency mode, alpha blendingd
material.type.blending = "Mezcla";
material.type.blending.help = "Haz que la malla sea semitransparente ajustando el valor de opacidad

Ten en cuenta que, debido a las limitaciones en tiempo real, puedes tener artefactos visuales notables si tu objeto tiene una forma compleja.";
// Transparency mode
material.type.additive = "Aditivo";
material.type.additive.help = "Haz que la malla sea semitransparente ajustando el valor de opacidad.

Este método tiende a tener menos artefactos que el método de fusión, pero el objeto será más brillante.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Tramado";
material.type.dithering.help = "Haz que el objeto sea semitransparente descartando algunos píxeles de forma aleatoria.";
// Simulate glass-like material
material.type.refraction = "Refracción";
material.type.refraction.help = "Este modo se puede utilizar para simular material de vidrio

Debido a las limitaciones de tiempo real, la autorrefracción o la refracción multicapa es limitada.";
material.castShadows = "Proyectar sombras";
material.receiveShadows = "Recibir sombras";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Siempre apagado";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Culling inverso";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Reflectancia";
material.reflectance.help = "Controla la cantidad de reflexión que recibirá el material para materiales no metálicos

La mayoría de las veces, se debe usar el valor predeterminado (que corresponde al 4 % de luz reflejada estándar en ángulo normal).";
// Material preview in the viewport
material.preview = "Vista previa del Selector de materiales";
material.preview.help = "When you modify a material, a preview will be displayed in the viewport on the selected object.

The preview is shown while you interact with the color, roughness, metalness, opacity and intensity sliders.";
// Menu name
menu.files = "Archivos";
// Menu name
menu.scene = "Escena";
// Menu name
menu.multires = "Multiresolución";
// Menu name
menu.voxel = "Vóxel";
// Menu name
menu.dynamic = "DynTopo";
// Menu name (Synonym: Misc, Other)
menu.topology = "Miscelánea";
// Menu name
menu.primitive = "Primitivo";
// Menu name
menu.render = "Renderizado";
// Menu name
menu.material = "Material";
// Menu name
menu.postprocess = "Posprocesado";
// Menu name
menu.camera = "Cámara";
// Menu name
menu.background = "Fondo";
// Menu name
menu.tool = "Herramienta";
// Menu name
menu.stroke = "Trazo";
// Menu name
menu.alpha = "Alfa";
// Menu name
menu.filter = "Filtro";
// Menu name
menu.falloff = "Disminución";
// Menu name
menu.paint = "Pintura";
// Menu name
menu.symmetry = "Simetría";
// Menu name
menu.operation = "Acción";
// Menu name (pencil pressure)
menu.pressure = "Presión";
// Menu name
menu.gesture = "Gesto";
// Menu name
menu.layers = "Capas";
// Menu name
menu.settings = "Configuración";
// Menu name
menu.interface = "Interfaz";
// Menu name
menu.bindings = "Atajos";
// Menu name
menu.history = "Historia";
// Menu name
menu.historySettings = "Configuración";
// Menu name
menu.about = "Acerca de";
// Menu name
menu.debug = "Depurar";

// Operation on the object (action)
mesh.holes = "Agujeros";
// If the object has holes, the algorithm will close them
mesh.holes.close = "Cerrar agujeros";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holes.detail = "Detalle";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Separado";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "Se perderán las capas, la pintura y la multirresolución.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Resolucion";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Fuerza cúbica";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Convertir";
// Static object means "static topology"
mesh.static = "Malla";
// See glossary
mesh.multires = "Multiresolución";
// Dynamic topology
mesh.dynamic = "DynTopo";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Material global";
paint.useGlobal.help = "Si esta opción está habilitada, el material seleccionado será el mismo que el de las otras herramientas.

Ten en cuenta que solo toma en cuenta la rugosidad, la metalidad y los ajustes de color.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Pintura de trazo";
// If true save the textures data into
paint.preset.embed = "Incorporar texturas";
paint.preset.embed.help = "The textures can be found in the Nomad textures/ folder.
The material presets can be found in the Nomad materials/ folder.

When this option is off, the material preset only reference the texture inside the textures/ folder.

You can enable this option to make a copy of the textures inside the material preset.
It can be useful if you want to share a textured preset without providing the associated textures.";
paint.preset.embed.apply = "Apply to all materials";
// Factor/Opacity of paint tool
paint.intensity = "Intensidad de pintura";
// Apply the paint on the object
paint.paintAll = "Pintar todo";
paint.paintAll.help = "Aplicar el material actual a la malla.";
paint.paintAll.help.mask = "El área enmascarada no se verá afectada.";
paint.paintAll.help.hide = "El área oculta no se verá afectada.";
paint.paintAll.help.opacity = "Use el factor de pintura de la herramienta superior.";
paint.paintAll.help.layer = "Area no pintada de a no se verá afectada.";
paint.strokePainting.title = "Pintura";
// Brush stroke texture
paint.texture.warningEnable = "La pintura de trazos debe estar habilitada para permitir la proyección de texturas (casilla de verificación en la parte superior)";
paint.texture.warningIgnored = "¡La herramienta actual no puede usar texturas!";
// use stencil mode
paint.stencil = "Plantilla";
// Inherit stroke falloff option for the painting
paint.tool.help = "Use la herramienta alpha, desvanecimiento y aleatorizador para modular la intensidad del trazo de pintura.

Estas opciones se ignoran para la función de pintar todo, pero el alpha se toma en cuenta para la variante triplanar.";
// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "Nombre";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "Valor";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "Color hexadecimal";

// Post process effect
postprocess = "posprocesado";
// Denoise
postprocess.denoise = "Filtro de ruido";
postprocess.denoise.help = "Aplicar un paso de reducción de ruido después de acumular todos los fotogramas.";
postprocess.denoise.warning = "Esta es una operación costosa, solo active este efecto si la imagen tiene ruido.";
// Quality vs performance
postprocess.quality = "Calidad";
postprocess.quality.help = "Activa estas opciones para mejorar la calidad en detrimento del rendimiento.";
// More samples means better quality but slower performance
postprocess.maxSamples = "Muestras máx.";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Resolución completa";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "Máx. muestreo de fotogramas";
postprocess.accumulateCount.help = "Número máximo de fotogramas que se acumularán antes de detener el renderizado.

Al detener el renderizado, Nomad no hará nada, lo que ahorra batería.

Muchas funciones de renderizado sacan partido de la acumulación de fotogramas, especialmente las siguientes:
• Sombras suaves
• Iluminación global
• Reflejo (SSR)
• Oclusión ambiental
• Subsuperficie
• Profundidad de campo

Las cantidades altas de fotogramas son necesarias principalmente para las sombras suaves y la iluminación glboal.
Nomad podrá detener el renderizado antes si se desactivan dichas funciones.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Renderizar resolución";
postprocess.renderRatio.warning = "Anulado por el efecto Pixel Art.";
postprocess.renderRatio.help = "Esta opción impacta mucho en el rendimiento.
Se recomienda mantener un valor inferior a x1.25.

Esta opción no se guarda en la configuración.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "Suavizado (TAA)";
postprocess.taa.help = "Reduce el parpadeo al mover la cámara.";
// Ditherhing pixel
postprocess.dithering = "Tramado";
postprocess.dithering.help = "Difuminar píxeles para reducir artefactos de bandas.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "Reflexión (SSR)";
postprocess.ssr.warning = "SSR requiere el modo de sombreado PBR.";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "Iluminación global (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "Tolerancia";
postprocess.ssgi.warning = "SSGI requiere el modo de sombreado PBR.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "Oclusión ambiental";
// How far the effect spreads
postprocess.ssao.radius = "Tamaño";
// How strong the effect is
postprocess.ssao.factor = "Fuerza";
// Adjustment to fix artefacts
postprocess.ssao.bias = "Sesgo de curvatura";
postprocess.ssao.bias.help = "La sensibilidad del efecto depende de la curvatura de la superficie.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "Profundidad de campo";
// The blur factor behind the focused point
postprocess.dof.blurFar = "Borrosidad lejana";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "Borrosidad cercana";
postprocess.dof.focusTip = "Pulsa un objeto para cambiar el punto de enfoque.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "Resplandor";
// Intensity of the effect
postprocess.bloom.intensity = "Intensidad";
// How far the effect spreads
postprocess.bloom.radius = "Radio";
postprocess.bloom.radius.help = "Qué tan extendido está el resplandor.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "Umbral";
postprocess.bloom.threshold.help = "Umbral de luminosidad para decidir si un píxel emitirá resplandor o no.
Si el valor es 0, todo tendrá resplandor.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "Mapeo de tonos";
postprocess.tone.exposure = "Exposición";
postprocess.tone.contrast = "Contraste";
postprocess.tone.saturation = "Saturación";
postprocess.tone.hue = "Matiz";
// No tonemapping operator is used
postprocess.tone.mapping.none = "Ninguno";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "Neutral";
// Color curves
postprocess.curve = "Graduación de color";
// Curve for pixel luminance
postprocess.curve.luminance = "Principal";
postprocess.curve.red = "Rojo";
postprocess.curve.green = "Verde";
postprocess.curve.blue = "Azul";
// Reset color grading curves
postprocess.curve.resetAll = "Restablecer todo";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "Aberración cromática";
postprocess.chromatic.factor = "Fuerza";
// Darking on the edges
postprocess.vignette = "Viñeta";
// How far the effect spreads
postprocess.vignette.size = "Tamño";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "Dureza";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "Nitidez";
postprocess.sharpness.factor = "Fuerza";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "Ruido";
postprocess.grain.factor = "Fuerza";
// Accentuate the edges of the model
postprocess.curvature = "Curvatura";
// main strength of curvatre
postprocess.curvature.factor = "Factor";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "Cavidad";
// Color/Strength of convex curvature
postprocess.curvature.bump = "Relieve";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "Arte pixelado";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "Permitir muestreo de fotogramas";
// Simulate scanline rendering (horizontal line)
postprocess.scanline = "Línea de exploración";
postprocess.scanline.factor = "Factor";
// Spacing between lines
postprocess.scanline.spacing = "Espaciado";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Primitivo";
primitive.box = "Caja";
primitive.sphereCube = "Esfera Cuádruple";
primitive.sphereUV = "Esfera UV";
primitive.icosahedron = "Icosaedro";
primitive.cylinder = "Cilindro";
primitive.cone = "Cono";
primitive.torus = "Toro";
primitive.lathe = "Torno";
primitive.tube = "Tubo";
primitive.plane = "Plano";
primitive.triplanar = "Triplanar";
primitive.needValidate = "Las primitivas deben ser validadas!";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Editar";
primitive.edit.help = "Permitir la edición 3D en la ventana gráfica.

Puedes desactivar esta función si deseas interactuar con el Gizmo o la herramienta de transformar sin modificando la primitiva.";

// Primitive configuration
primitive.mainConfig = "Parámetro";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Topología";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Geometría";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Validar";
// Maximum number of faces of the primitives
primitive.maxFaces = "Caras máx.";
primitive.maxFaces.help = "El número máximo de caras que puede tener una primitiva.

Este límite solo está activo mientras la primitiva no está validada, después la salvaguarda desaparece.";
// Synonym: Flat subdivision
primitive.linear = "Subdivisión lineal";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Postsubdivisión";

// Radius (of a sphere, torus, etc)
primitive.radius = "Radio";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radius.sync = "El mismo radio";
primitive.radius.start = "Inicio del radio";
primitive.radius.end = "Fin del radio";
// Size (of cube x dimension)
primitive.size = "Tamaño";
primitive.sizeX = "Tamaño X";
primitive.sizeY = "Tamaño Y";
primitive.sizeZ = "Tamaño Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "División";
primitive.divisionX = "División X";
primitive.divisionY = "División Y";
primitive.divisionZ = "División Z";
// Angle of torus, etc
primitive.angleX = "Ángulo X";
primitive.angleY = "Ángulo Y";
primitive.angleZ = "Ángulo Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Densidad constante";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Proyecto sobre esfera";
primitive.projectOnSphere.help = "Ajustar los puntos en una esfera perfecta.";

// triplanar
primitive.triplanar.title = "Triplanar";
primitive.triplanar.title.help = "Triplanar utiliza la información de máscara de 3 planos para rellenar una cuadrícula de Vóxel que luego se poligoniza.

Si interactúas con los controles deslizantes de división o tamaño, la información de pintura se restablecerá (la suavidad está bien).

Probablemente deberías deshabilitar la simetría, ya que podría no funcionar como cabría esperar.

Puedes usar la opción `Conectado topológicamente` en el panel máscara para pintar un plano que impacte en los otros planos.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanar.sameSize = "Mismo tamaño (cubo)";
primitive.triplanar.polish = "Suavidad";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanar.resetMask = "Restablecer máscara";
// One side of a cube (the back plane)
primitive.isolate.back = "Atrás";
// One side of a cube (the right plane)
primitive.isolate.right = "Derecho";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Inferior";
// Plane
primitive.planeSameSize = "Mismo tamaño (cuadrado)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "Disco";
// Box
primitive.boxRegular = "Mismo tamaño (cuba)";
// Torus
primitive.torus.radiusOuter = "Radio exterior";
primitive.torus.radiusInner = "Radio interior";
primitive.torus.angle = "Ángulo";
primitive.torus.angleOffset = "Desplazamiento de ángulo";
// Cylinder
primitive.cylinder.height = "Altura";
// Cone
primitive.cone.radius = "Radio";
primitive.cone.height = "Altura";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Agujero";
// Make a hole in the primitive to make it hollow
primitive.hasHole = "Tiene un agujero";
// Curve profile (synonym: profile, curve)
primitive.profile = "Perfil";
primitive.profile.viewport = "Mostrar en el visor";
// If the revolution surface has caps (E.g: cylinder)
primitive.cap = "Tapa";

// Singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "Repetidor";
// All the new items will be inserted inside the bound rather than outside
repeater.array.fitInside = "Ajustar dentro";
// The object will follow the curve
repeater.curve.align = "Alinear";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Importar";
// iOS Photos gallery
resource.import.ios.photos = "Fotos";
// iOS Files App
resource.import.ios.files = "Archivos";

scene.title = "Escena";
scene.title.help = "Cuando uses la casilla de verificación de selección, mantén presionado y arrastra el dedo para seleccionar otros objetos fácilmente.";
// The view will focus on the item when we click on it
scene.focus = "IU: Enfocar en el elemento al hacer doble toque";
// Add new object on gizmo position
scene.addOnGizmo = "En gizmo";
scene.addOnGizmo.help = "Mover el nodo a la posición del gizmo (si la herramienta gizmo está seleccionada)";
// Select the gizmo tool after adding a new object
scene.addSelectGizmo = "Seleccionar gizmo";
scene.addSelectGizmo.help = "Seleccionar la herramienta gizmo al añadir un nuevo nodo";
// Icon size in pixel (min/max)
scene.iconSize = "Tamaño de icono";
// Min size of icon
scene.iconSize.min = "Mín.";
// Max size of icon
scene.iconSize.max = "Máx.";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "Líneas de jerarquía";
scene.showHierarchy.help = "Mostrar una línea entre el padre y sus hijos en el visor.";
scene.showHierarchyNomadPivot = "Usar pivote de Nomad";
scene.showHierarchyNomadPivot.help = "El pivote de Nomad es el pivote utilizado por las herramientas de Transformación y Gizmo.

Si esta opción está desactivada, utilizará el pivote base natural.
¡En algunos casos este pivote base puede estar lejos del centro del objeto en sí!";
// The view will focus on the item when we click on it
scene.syncVisible = "Sincronizar visibilidad";
scene.syncVisible.help = "Cuando está activado, usar el icono visible (ojo) afectará a todos los elementos seleccionados.";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "Unir";
// Group the selected object with a new created Empty Node as a parent
scene.group = "Agrupar";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "Desvincular";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "Espejo";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "Curva";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "Matriz";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "Radial";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "Repetidores";
scene.repeaters.help = "Nodos repetidores que hacen instancias de cualquier geometría debajo de ellos en la jerarquía de la escena.";
// Validate button
scene.validateGroup = "Validar";
// Keep instances in the scene
scene.validateGroup.keepInstances = "Mantener instancias";
// If we should join children
scene.validateGroup.joinChildren = "Unir hijos";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Combinar Vóxel";
scene.voxelResolution = "Resolución";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Resta  : ocultar malla";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Intersección: Todas las mallas ocultas";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "No hay malla seleccionada.";
// Need to select one object only
scene.noneButNeedOne = "No hay objetos seleccionados, seleccione uno.";
// Need to select one object only
scene.onlyOneObject = "Se seleccionaron varias mallas, selecciona solo una malla.";
// Boolean operation
scene.boolean = "Booleano";
scene.boolean.help = "Fusionar, sustraer o intersecar objetos realizando una operación booleana.

La operación puede fallar si algunos objetos no son varietales o no son estancos.

Si falla la booleana, siempre puedes utilizar el remallador de vóxeles en el objeto problemático para asegurarte de que sea un varietal estanco.";
// Weld intersection
scene.boolean.mergeIntersection = "Soldar intersección";

// General scene display settings
settings.display.title = "Configuración de pantalla";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Malla";
// Display the material texture
settings.debugChannel = "Mostrar Textura";
// Display the material texture in the background
settings.debugChannel.onBackground = "En Fondo";
// Display the material texture on the mesh
settings.debugChannel.onMesh = "En Malla";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Dos cara";
settings.twoSided.help = "Las caras serán visibles desde ambos lados.";
// If we colorize the inverted side of faces
settings.backface.color = "Color de cara posterior";
// Color of the inverted side of faces
settings.backface.colored = "Cara posterior coloreada";
// Outline (contour highlight around the selected object)
settings.outline = "Contorno";
// Outline (contour highlight around the selected object)
settings.outline.help = "Se aplicará contorno a los objetos seleccionados.";
settings.outline.thickness = "Espesor";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Capturar cubo";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "Inferior";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "Izquierdo";
// Flip the camera (rotate 180° to see the other side)
settings.snapCube.flip = "Voltear 180°";
settings.snapCube.flip.help = "Voltear la vista si ya está fijada.";
// Alignment (can be auto/on/off)
settings.snapCube.align = "Restringir alineación";
settings.snapCube.align.help = "Alinear las vistas al eje mundial. Si está habilitado, solo son posibles 6 vistas de encaje.

En Automático, la restricción ocurrirá solo si la cámara está en modo Órbita.";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Estadísticas";
settings.stats.right = "Derecho";
settings.stats.all = "Mostrar escena completa";
// Grid
settings.grid = "Cuadrícula";
// Cursor
settings.cursor.title = "Cursor";
settings.cursor.whileSculpting = "Mostrar círculo mientras esculpes";
// A small indicator dot
settings.cursor.showDot = "Mostrar punto pequeño";
settings.cursor.showDot.help = "El punto puede aparecer como el punto de pivote de la cámara o cuando estás esculpiendo.";
settings.cursor.showRope = "Mostrar estabilizador de cuerda";
// indicator
settings.indicator.title = "Indicador";
settings.indicator.title.help = "Mostrar un indicador visual (tutoriales, captura de pantalla, etc).";
settings.indicator.size = "Tamaño";
// Highlight (the object glows when we select it)
settings.highlight.selection = "Resaltar mallas seleccionadas";
// Highlight settings
settings.highlight = "Selección de resaltado";
settings.highlight.duration = "Duración";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Oscurecer mallas no seleccionadas";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Sombreado suave";
// Experimental feature
settings.partialDraw = "Dibujo parcial";
settings.partialDraw.help = "¡Característica no pulida!

Úsela si estás esculpiendo una parte relativamente pequeña de una malla de polietileno alto.

Debería hacer que la escultura sea más suave, pero no debes habilitar la malla.

También puede agregar artefactos visuales durante los trazados";
settings.partialDraw.warning = "¡No olvides desactivar esta opción si los artefactos visuales son demasiado molestos!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Mostrar pintura";
// Show and use the masking on the mesh
settings.showMasking = "Mostrar máscara";
// Disable this option to force show the hidden faces
settings.showDiscard = "Usar Ocultar";
// Show icon on the canvas
settings.icon = "Icono";
// Show icons on the canvas
settings.icons = "Iconos";
// Tooltip
settings.icons.help = "Mostrar un icono en el lienzo para que se puedan seleccionar y editar directamente.";
// Hole filling settings
settings.hole = "Relleno de agujero";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Rellenar espacio no topológico";
settings.hole.nonManifold.help = "Intenta llenar el agujero del espacio topológico.
Esta opción no se guarda en la configuración.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Recuento máximo de vértices";
settings.multires.maxVertices.help = "Nomad no realiza una comprobación de memoria antes de la subdivisión, un recuento alto de poli puede provocar bloqueos fácilmente.";
settings.multires.lowResVertices = "Umbral de baja resolución";
settings.multires.lowResVertices.help = "Se puede mostrar una resolución más baja de la malla cuando mueve la cámara.

Puedes aumentar este valor si deseas mostrar una resolución más alta de la malla.";

// The main rendering mode
shading = "Sombreado";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "Encendido (PBR)";
shading.pbr.help = "En este modo, puede agregar luces (con sombras), junto con un entorno HDR.

También puede pintar metal y rugosidad, lo que permite un control más fino sobre el aspecto de tu material.";
// Fast rendering mode for sculpting purpose
shading.matcap = "MatCap";
shading.matcap.help = "MatCap significa captura de material (MATerial CAPture) y se encarga de la iluminación y la información del material en una sola imagen.

Este es un modo de renderizado rápido, adecuado principalmente para esculpir en bruto.";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "Apagado";
shading.unlit.help = "Modo de sombreado de color sólido, apagado.";
// Helper rendering mode that display solid colors
shading.object = "Objeto ID";
shading.object.help = "Modo de renderizado sin iluminación: cada objeto tiene un color aleatorio asignado.

Esto resulta especialmente útil si la escena contiene muchos objetos.";
// Helper rendering mode that display solid colors
shading.instance = "Instanciar ID";
shading.instance.help = "Igual que ID de Objeto, pero las instancias tendrán el mismo color.";
// Helper rendering mode that display solid colors
shading.material = "ID de Material";
shading.material.help = "Muestra un color sólido para cada instancia de material.";
// Randomize colors
shading.id.randomize = "ID aleatorio";
shading.textures = "Utilizar texturas";
shading.textures.help = "Por el momento, no puedes crear ni editar texturas dentro de Nomad.

Pero si importas un archivo con texturas, debería funcionar.

• Texturas compatibles
Opacidad: Iluminado, MatCap, apagado
Normal: Encendido, MatCap
Color: Encendido, Apagado
Emisor: Encendido
Rugosidad: Encendido
Metalidad: Encendido";
// Lights
shading.lights = "Luces";
shading.lights.addLight = "Agregar luz";
shading.lights.warning = "Las luces requieren el modo de sombreado PBR.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Entorno";
shading.environment.import = "Importar HDR";
shading.environment.exposure = "Exposición";
shading.environment.backgroundBlur = "Borroso (fondo)";
shading.environment.rotation = "Rotación";
shading.environment.rotation.help = "Puedes rotar el entorno arrastrando 3 dedos horizontalmente en la ventana gráfica.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "Conectado a la cámara";
shading.environment.attachedToCamera.help = "Conecte el entorno a la cámara.

Obligará a que la iluminación sea consistente, lo que puede ser útil para esculpir.";
shading.matcap.rotation = "Rotación";
shading.matcap.rotation.help = "Puedes girar el MatCap arrastrando 3 dedos horizontalmente en la ventana gráfica.";
shading.matcap.global = "Utilizar el MatCap global";
shading.matcap.global.help = "Desmarca esta opción para usar un MatCap diferente para esta malla en particular.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible = "Máscara";
shortcut.solo = "Individual";
shortcut.xray = "Rayos X";
shortcut.voxelRemesh = "Vóxel";
shortcut.wireframe = "Malla";
shortcut.cameraReset = "Restablecer";
shortcut.cameraSnap = "Capturar";
shortcut.lockSelection = "Bloquear";
shortcut.lockSelection.help = "Cuando está habilitado, no puedes cambiar la selección pulsando una malla.";
shortcut.grid = "Cuadrícula";

// Memory taken by the scene
stat.ramScene = "Escena";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Escena Vram";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "Renderizar Vram";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "Texturas Vram";
// Memory taken by the undo/redo history
stat.ramHistory = "Historial";
// Memory taken by other stuffs
stat.ramOther = "Otro";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "Memoria usada";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "Memoria libre";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "Usado: $0";
stat.free = "Libre: $0";
stat.faces = "Caras";
stat.triangles = "Triángulos";
stat.vertices = "Vértices";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Quads";
stat.vertex = "Vértice";
stat.scene.face = "Caras de escena";
stat.scene.vertex = "Vértices de escena";

// Brush stroke
stroke = "Trazo";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "Radio mundo-espacio";
// The settings is shared among every tools
stroke.useWorldRadius.help = "Es compartido entre todas las herramientas.";
// Share the radius value among every tools.
stroke.useShareRadius = "Compartir radio";
stroke.useShareRadius.help = "Comparte el valor del radio entre todas las herramientas.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.spacing = "Espaciado de trazos";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.spacing.adjust = "Ajusta la intensidad del espaciado";
stroke.minSpacingAdjustIntensity.help = "Ajusta la intensidad de la brocha para garantizar una deformación uniforme en función de la separación entre trazos.";
stroke.minSpacing.help = "Espaciado entre cada trazo, en relación con el radio de la herramienta.

Un valor más bajo permitirá un trazo más suave, pero el rendimiento se degradará.";
// Brush stroke smoothing
stroke.lazySmooth = "Suavidad del trazo";
stroke.lazySmooth.help = "Promedia la posición de varios punteros para obtener un trazo más suave

Con valores altos, el trazo se retrasará detrás del puntero, pero eventualmente lo alcanzará.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Estabilidad del trazo";
stroke.lazyRadius.help = "Los trazos se retrasarán detrás de la posición del puntero de acuerdo con una cierta distancia.

Esto se puede usar para dibujar líneas suaves.";
// It is not a per-tool settings
stroke.globalSettings = "Este es una configuración global";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Capturar radio";
stroke.snapRadius.help = "Carturar el trazo si el puntero se encuentra cerca del último trazo grabado

Esto puede ser útil al dibujar líneas largas y continuas, mientras se hacen pausas frecuentes.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Desplazamiento de trazo";
stroke.sculptOffset.help = "Aplica un desplazamiento constante en el trazo.

Esta opción está ahí para ayudar con la pantalla pequeña cuando se usan los dedos para no cubrir el trazo.";
stroke.accumulate = "Acumular trazo";
stroke.accumulate.help = "Si esta opción está habilitada, no hay límite en la cantidad de material que puedas agregar/eliminar por trazo.";
// The tool can use DynTopo
stroke.useDynamic = "Permitir topología dinámica";
// Only sculpt the part that are linked topologically
stroke.connect = "Topología conectada";
stroke.connect.help = "Esta opción solo esculpirá los vértices que están vinculados a la superficie seleccionada.

Por lo general, se utiliza para la herramienta Mover, por ejemplo, si quieres mover exclusivamente una parte que se interseca automáticamente con otra parte.";
stroke.connect.short = "Conectada";
// sculpt on hide or mask
stroke.protect = "Proteger área";
stroke.protect.hide.help = "Cuando esté en automático, se editarán las caras ocultas si el marco de alambre en las caras ocultas es visible (ver menú de marco de alambre).";
// Only sculpt the vertex that points toward the camera
stroke.culling = "Solo vértice frontal";
stroke.culling.help = "Esta opción ignorará los vértices orientados hacia atrás.

Puede ser útil si quieres pintar parte de una geometría fina sin afectar al otro lado.

También funciona para esculpir, pero es posible que experimentes algunos artefactos.";
// Infinite depth, move everything under the circle, disregarding depth
stroke.silhouette = "Silueta";
stroke.silhouette.view = "Ver";
stroke.silhouette.snapped = "Si está fijado";
stroke.silhouette.closest = "Más cercano";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.sameSide = "Solo vértice del mismo lado";
stroke.sameSide.help = "Ignora los vértices que apuntan en la dirección opuesta a la deformación.";
stroke.onlyLasso = "La configuración solo está activa para la herramienta lazo.";

// Here sampling refers to the app gathering information under the mouse
stroke.area = "Muestreo de área";
stroke.area.help = "Algunos pinceles u opciones de trazo requieren un plano normal a la superficie para funcionar.
Puedes controlar cómo calcular este plano promedio ajustando el área de muestreo como un porcentaje del radio de la herramienta.

Al 100%, se toman en cuenta todos los puntos dentro del círculo de selección.
Al 0%, solo se toma en cuenta el vértice o triángulo más cercano.";
// Sampling radius size (percent)
stroke.area.normal.radius = "Radio normal";
// Sampling radius size (percent)
stroke.area.point.radius = "Radio de posición";
// Sampling averaging
stroke.area.normal.average = "Promedio normal";
// Sampling averaging
stroke.area.point.average = "Promedio de posición";
// Keep sharp edges
stroke.keepSharp = "Mantener bordes nítidos";
stroke.keepSharp.help = "
Filtrado profundo";

// Only paint the part of the mesh above a certain height
stroke.depthFilter = "Máscara de profundidad";
stroke.depthFilter.help = "Excluir puntos que estén por encima o por debajo de una cierta distancia del plano calculado (Muestreo de área).

Como ejemplo, se puede usar para pintar protuberancias o cavidades.";
stroke.depthFilter.max = "Área superior";
stroke.depthFilter.min = "Área inferior";
stroke.depthFilter.offset = "Desplazamiento de altura";

// Invert the pixel (black <-> white)
stroke.alpha.invert = "invertir valor";
// Repeat the alpha image (pattern)
stroke.alpha.wrap = "Mosaico";
// No repeat pattern
stroke.alpha.wrap.none = "Ninguno";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alpha.wrap.repeat = "Repetir";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alpha.wrap.mirror = "Espejo";
// Tight fit when using tiling
stroke.alpha.fit = "Ajustar dentro";
stroke.alpha.fit.help = "This option is only relevant if the alpha and brushes textures are non square.

When enabled, each images will tile independently with no spacing.
You can disable this option if you want to keep the alpha and other images synchronized, in case their ratio are not the same.";
// Alpha rotation
stroke.alpha.rotation = "Rotación";
stroke.alpha.rotation.lock.help = "Bloquear la orientación alfa.

Si la rotación está desbloqueada, la orientación seguirá la dirección del trazo en tiempo real.";
// Repeat the image
stroke.alpha.tiling = "Mosaico";
// Scale the image (make it bigger or smaller)
stroke.alpha.scale = "Escalar";
stroke.alpha.scale.help = "En el valor mínimo, el cuadrado alfa está dentro del radio del círculo de la herramienta.";
// Middle-point value at which no deformation occurs
stroke.alpha.midValue = "Valores medios";
stroke.alpha.midValue.help = "Valor de punto medio en el que no se produce deformación.

(Valor medio = 0)
• Negro: sin desplazamiento
• Blanco: desplazamiento positivo

(Valor medio = 0.5)
• Negro: desplazamiento negativo
• Blanco: desplazamiento positivo

(Valor medio = 1)
• Negro: desplazamiento negativo
• Blanco: sin desplazamiento";
// Synonymous: Scatter/Jitter/Randomize
stroke.jitter = "Aleatorizar";
// Sculpt and paint along the brush stroke at regular spacing
stroke.type.dot = "Punto";
// Sculpt and paint along with alpha spaced by brush radius
stroke.type.roll = "Rodar";
// Sculpt and paint with alpha projected on screen stencil
stroke.type.tile = "Mosaico";
// Sculpt and paint with alpha projected on 3 axis
stroke.type.triplanar = "Triplanar";
// Sculpt continuously
stroke.type.drag = "Arrastrar";
// Lock a region and move it around
stroke.type.grab = "Agarre";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.type.grabRadius = "Agarre • radio dinámico";
// Lock a region and sculpt it by changing the tool intensity
stroke.type.grabIntensity = "Agarre • intensidad dinámica";

stroke.falloffProject = "Influencia";
stroke.falloffProject.help = "• Esfera (3d)
La influencia se calcula tomando la distancia desde el vértice hasta el centro del pincel.

• Círculo (2d)
El vértice se proyecta primero en el plano del área, antes de tomar su distancia al centro del pincel.
Esto es similar a cómo se muestrean las alfas.";
stroke.falloffProject.sphere = "Esfera";
stroke.falloffProject.circle = "Circulo";
stroke.falloffProject.cylinder = "Cilindro";

// Symmetry
symmetry = "Simetría";
symmetry.enable = "Activado";
symmetry.primitiveWarning = "La simetría de pincel solo está disponible para primitivas validadas, con la excepción de la Triplanar.";
symmetry.plane.title = "Planos";
symmetry.toolIgnore = "La herramienta actual ignora la simetría.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Radial";
symmetry.radialX = "Radial X";
symmetry.radialY = "Radial Y";
symmetry.radialZ = "Radial Z";
// A warning indicating that we limit the number of repetitions ($0 is a number)
symmetry.limited = "¡Número de repeticiones limitado a $0!";
// Synonym: Offset
symmetry.offset.title = "Desplazamiento";
symmetry.offsetX = "Desplazamiento X";
symmetry.offsetY = "Desplazamiento Y";
symmetry.offsetZ = "Desplazamiento Y";
// Number of clones
symmetry.count.title = "Cantidad";
symmetry.countX = "Cantidad X";
symmetry.countY = "Cantidad Y";
symmetry.countZ = "Cantidad Z";
// method
symmetry.method = "Método:";
symmetry.method.help = "• Local
El plano de simetría se moverá a lo largo de la malla cuando utilice una de las herramientas de transformación (Gizmo o Transformar).


• Mundo
El plano de simetría es fijo y no se mueve.";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.method.world = "Mundo";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.method.local = "Local";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Voltear objeto";
// Mirror the mesh
symmetry.mirror = "Duplicación";
symmetry.mirror.help = "Intenta volver a aplicar la simetría sin afectar a la topología.

Se ignorará la simetría radial.

Si la topología no se puede mantener porque no se considera simétrica, tendrás la opción de aplicar la duplicación.";
symmetry.mirrorFail = "No se pudo aplicar la simetría.

¿Quieres imponer la simetría duplicando la malla?";
symmetry.mirrorUseMasking = "Proteger área enmascarada";
symmetry.mirrorUseMasking.help = "Mantener el área enmascarada intacta.

Esta opción se ignorará con topología no simétrica (o superficie desconectada, como un par de ojos).";
symmetry.apply = "Espejo
(mantener topología)";
symmetry.splitMirror = "Dividir y Espejar
(nueva topología)";
// Reset the symmetry plane position
symmetry.reset = "Restablecer";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Centro de maya";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "Centro del Mundo";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Orientación";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Mostrar línea";
// Display the symmetry plane in 3d
symmetry.showPlane = "Mostrar plano";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Editar aparato";
symmetry.edit.warning = "La edición de simetría es experimental.";
symmetry.edit.help = "Puedes establecer libremente el plano de simetría.

Esta función es un poco experimental y probablemente nunca deberías usarla.";

// Ideally <10 chars
tool.dynamic = "DynTopo";
// Ideally <10 chars (Symmetry)
tool.symmetry = "Sim";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "Espejo";
// Ideally <10 chars
tool.clay = "Arcilla";
// Ideally <10 chars (Subtract)
tool.clay.sub = "Sub";
// Ideally <10 chars
tool.brush = "Brocha";
// Ideally <10 chars
tool.move = "Mover";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "Normal";
// Ideally <10 chars
tool.drag = "Arrastrar";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "Suavizar";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Relajar";
// Ideally <10 chars (Paint mask)
tool.mask = "Máscara";
// Ideally <10 chars
tool.mask.unmask = "Quitar máscara";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "Sel. máscara";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "Difuminar";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "Aplanar";
// Ideally <10 chars (Flatten the surface, more strongly than Flatten)
tool.planar = "Planar";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Rellenar";
// Ideally <10 chars (Layer brush)
tool.layer = "Capa";
// Ideally <10 chars
tool.crease = "Doblar";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "Recortar";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Dividir";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "Proyectar";
// Ideally <10 chars
tool.inflate = "Inflar";
// Ideally <10 chars
tool.pinch = "Pellizcar";
// Ideally <10 chars
tool.nudge = "Posicionar";
// Ideally <10 chars
tool.stamp = "Tapón";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "Eli. capa";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.select = "Seleccionar";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "Aparato";
// Ideally <10 chars
tool.gizmo.editPivot = "Pivote";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "Capturar";
// Ideally <10 chars (Snap translation)
tool.gizmo.moveSnap = "Capturar";
// Ideally <10 chars (Local/Relative space)
tool.gizmo.local = "Local";
// Ideally <10 chars (Align/Snap the gizmo to world axis)
tool.gizmo.align = "Alinear";
// Ideally <10 chars (Pin the gizmo, so that it stays in place when switching between objects)
tool.gizmo.pin = "Fijar";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "Transformar";
// Ideally <10 chars (Translate the object)
tool.transform.move = "Mover";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "Rotar";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "Escala";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "Capturar";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "medir";
// Ideally <10 chars (Lattice, deformer)
tool.lattice = "Enrejado";
// If an option is shared among the tools
tool.all = "Todo";
// Ideally <10 chars (Quad Remesher)
tool.remesh = "Remallador Cuadrado";
tool.remesh.guides = "Guías";
tool.remesh.density = "Densidad";
tool.remesh.same = "Same";
tool.remesh.half = "Half";
// Ideally <10 chars (FaceGroup)
tool.faceGroup = "Grupo de Caras";
tool.faceGroup.autoPick = "Selección automática";
tool.faceGroup.flush = "Eliminar no utilizados";
tool.faceGroup.skip = "Omitir grupos pequeños basados en:";
tool.faceGroup.skipFace = "Recuento de caras";
tool.faceGroup.skipFace.help = "No crear un nuevo grupo si el número de caras es inferior o igual a este umbral.";
tool.faceGroup.skipArea = "Área de superficie";
tool.faceGroup.skipArea.help = "No crear un nuevo grupo si el área superficial del nuevo grupo es inferior a este umbral.

El umbral se da como porcentaje del área total del objeto.";
// Ideally <10 chars (Hide)
tool.hide = "Ocultar";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "Ver";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "Torno";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "Tubo";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "Insertar";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "Voltear";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "Ver";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "Lazo";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Curva";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Polígono";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Ruta";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "Rect";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "Elipse";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "Línea";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Cerrado";

// Radius of the tool (size)
tool.radius = "Radio";
// Intensity of the tool (force)
tool.intensity = "Intensidad";

tool.settings = "Configuración";
tool.settings.none = "Esta herramienta no tiene ninguna configuración específica.";

tool.crease.pinchFactor = "Pellizcar fuerza";
tool.crease.offsetFactor = "Factor de desplazamiento";

tool.layer.removeInfluence = "Usar desplazamiento de capa actual";
tool.layer.removeInfluence.help = "Esta opción solo está activa cuando hay una capa actual seleccionada.

Utilizará el desplazamiento de capa actual para limitar el desplazamiento a lo largo de los trazos.";
tool.layer.noLayerSelected = "Esta opción solo está disponible si se seleccionas una capa actual";

tool.flatten.planeLockOrigin = "Bloquear origen del plano";
tool.flatten.planeLockNormal = "Bloquear dirección del plano";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "Sincronizar";
tool.syncInstance.message = "¡El nuevo objeto se añadirá en todas las demás instancias!";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Vértice pegajoso  en el borde";
tool.smooth.screen = "Suavizado de pantalla";
tool.smooth.screen.help = "Utiliza esta opción para obtener un suavizado independiente de la topología, incluso en alta poligonización.";
tool.smooth.screen.samples = "Muestras de pantalla";
tool.smooth.stable = "Suavizado estable";
tool.smooth.stable.help = "Intenta hacer que el suavizado sea independiente de la topología.

Este modo funciona mejor con una densidad de topología variable y con un alto valor de intensidad de suavizado.";

tool.paint = "Pintura";
// Erase the painting
tool.paint.erase = "Eliminar";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Filtrado de capas";
tool.paint.layerFilter.help = "Utiliza esta opción si solo quieres volver a pintar el área ya pintada de una capa.";

// Clear the painted mask
tool.mask.clear = "Eliminar";
tool.mask.clearAll = "Limpiar todo";
// Invert the painted mask
tool.mask.invert = "Invertir";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Voltear conectado";
// Blur the painted mask
tool.mask.blur = "Borroso";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Nitidez";
// Transform/Matrix
tool.matrix = "Matriz";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.target = "Objetivo";
// Automatic
tool.matrix.target.auto = "Automático";
tool.matrix.target.auto.help = "De forma predeterminada, esto funciona de forma parecida a la opción Grupo.
Si la malla tiene una máscara o si se ha activado la simetría, funcionará igual que la opción Vértice.";
// Auto apply the transform on the vertices
tool.matrix.target.vertex = "Vértice";
tool.matrix.target.vertex.help = "Se intenta aplicar la transformación a los vértices. No funcionará con primitivas sin validar.
También se verán modificadas las instancias.";
// Transform the object alone (the children stands still)
tool.matrix.target.object = "Objeto";
tool.matrix.target.object.help = "Se mueve únicamente el objeto, ignorando la simetría y la máscara.
Solo se moverá el nodo editado; los nodos hijos quedarán inmóviles.";
// Transform the object and its children
tool.matrix.target.group = "Agrupar";
tool.matrix.target.group.help = "Se mueve el nodo, ignorando la simetría y la máscara.
El resto de la jerarquía también se transformará.";
// Operation on the mesh
tool.matrix.action = "Acción";
tool.matrix.action.origin = "Mover origen";
tool.matrix.action.origin.help = "Mueve la malla al origen mundial.";
tool.matrix.action.bake = "Hornear";
tool.matrix.action.bake.help = "Aplica la matriz al vértice y restablece la matriz. Visualmente, nada debería cambiar.";
tool.matrix.action.reset = "Restablecer";
tool.matrix.action.reset.help = "Restablece la transformación de malla a identidad.";

// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "Sesgar";
tool.matrix.translation = "Traslación";
tool.matrix.rotation = "Rotación";
tool.matrix.scale = "Escala";
tool.matrix.uniformScale = "Escala uniforme";

tool.transform.tip = "Un toque simple con el segundo dedo para cambiar de modo";

// Size of the gizmo
tool.gizmo.size = "Tamaño del widget";
// If true, there is less spacing between gizmo handlers (rotate, scale, etc)
tool.gizmo.compact = "Compacto";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "Entrada numérica";
tool.gizmo.allowInput.help = "Permite la entrada numérica al tocar uno de los widgets del gizmo";
// Angle threshold
tool.gizmo.linearRollThreshold = "Umbral de balanceo tangente";
tool.gizmo.linearRollThreshold.help = "Umbral de ángulo para elegir entre el método de rodillo lineal o circular.

El valor por encima de este umbral utilizará el rodillo circular.

Si prefiere el rodillo lineal (dirección de la tangente), simplemente establezca este valor en 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Ocultar en interacción";
tool.gizmo.tap = "Pulsación única";
tool.gizmo.tap.help = "Esta opción solo es efectiva en el modo de pivote personalizado (desactivado automáticamente).";
tool.gizmo.tap.none = "Ninguno";
tool.gizmo.tap.none.help = "No pasa nada al pulsar la malla.";
tool.gizmo.tap.normal = "Normal";
tool.gizmo.tap.normal.help = "Move the gizmo on the first intersection and align it according to the surface normal.";
tool.gizmo.tap.first = "Primer golpe";
tool.gizmo.tap.first.help = "Mueve el Gizmo en la primera intersección.";
tool.gizmo.tap.medial = "Punzada media";
tool.gizmo.tap.medial.help = "Mueve el Gizmo en el promedio de las dos primeras intersecciones.";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "Fijado";
tool.lathe.axisOnly = "Solo eje";
tool.lathe.stable = "Estable";
tool.lathe.axis = "Eje";

// Fill the object's hole
tool.hole = "Relleno de agujero";
tool.hole.fillHoles = "Rellenar agujeros";
// synonym: Alternative method
tool.hole.method.fill = "Rellenar";
tool.hole.method.legacy = "Legado";
tool.hole.method.boolean = "Booleano";
tool.hole.bridges = "Espacio de pantalla booleano";
tool.hole.bridges.help = "Si esta opción está habilitada, puedes hacer agujeros en el volumen.
La pendiente de corte también seguirá más de cerca la forma de corte.";
tool.hole.threshold = "Epsilon de umbral";
tool.hole.threshold.help = "Ajustar este valor podría ayudar con el algoritmo de rellenado de orificios.";
tool.hole.smoothing = "Suavidad del agujero";

tool.smudge.quality = "Calidad";
tool.smudge.quality.help = "Cambia la resolución de los píxeles proyectados, los valores más bajos significan trazos más rápidos.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Forma";
// Auto-validate the drawn shape
tool.shape.autoValidate = "Auto-validar";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Cuadrado";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Centrado";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Circulo";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Centrado";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Girar paso";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Proporción áurea";
// volume of a mesh
tool.measure.volume = "Volumen del mesh";
// Surface of a mesh
tool.measure.surface = "Superficie";

// Always display the camera shortcut buttons on the viewport
tool.view.stickyCamera = "Acceso directo a la cámara (siempre)";

// Topology
topology = "Topología";
// Synynom: detail value, density
topology.dynamic.detail = "Detalle";
// See glossary
topology.multires = "Multiresolución";
topology.multires.help = "Mantén la resolución múltiple de una malla.

Si realizas cambios en una resolución más baja, los detalles de las resoluciones más altas se reproyectarán cuando vuelva a cambiar.

Las capas están disponibles en todas las resoluciones.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "Reverso";
topology.multires.reverse.confirm = "No se pudo crear la subdivisión base.

La topología actual probablemente no es el resultado de una subdivisión.";
topology.multires.subdivide = "Subdividir";
topology.multires.subdivide.confirm = "La malla tendrá vértices de $0M, ¿estás seguro?";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "Límite de subdivisión excedido, ver $0";
topology.multires.deleteLower = "Eliminar inferior";
topology.multires.deleteHigher = "Eliminar superior";
topology.multires.keepTriangles = "Mantener triángulos";
topology.multires.lock = "Bloquear (LV0)";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "Nivel Multires →";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "Nivel Multires ←";
// Synonym: Flat subdivision
topology.multires.linear = "Subdivisión lineal";
topology.multires.linear.help = "Simplemente subdivide la malla sin aplicar suavizado";
// Only show the lowest resolution wireframe
topology.multires.minWireframe = "Solo nivel 0";
// Create a new object by recomputing a new topology
topology.remesh = "Refuerzo de malla";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Refuerzo de malla de Vóxel";
topology.voxel.help = "Refuerzo de malla muestreando la malla en una cuadrícula.

Si el objeto no está cerrado (estanco), se aplicará primero un algoritmo de rellenado de orificios.

Las capas se vuelven a inyectar después de volver a mallar, pero la calidad se degradará.";
topology.voxel.resolution = "Resolucion";
topology.voxel.sharp = "Mantener bordes nítidos";
topology.voxel.sharp.help = "Esta opción es útil principalmente para operaciones booleanas primitivas simples.

Introducirá distorsión en alguna área debido a que los puntos se rompen en los bordes.";
topology.voxel.subLevel = "Construir multiresolución";
topology.voxel.subLevel.help = "Puedes reconstruir una jerarquía de varias resoluciones a partir de la salida del remezclador de Vóxeles.

También se ejecutará más rápido y usará menos memoria, especialmente si el valor de detalle de Vóxel es alto.
Sin embargo, si el valor de detalle de Vóxel es bajo y estás solicitando muchos niveles múltiples, perderás detalles.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Reforzar malla";
topology.surface.detail = "Detalle";
topology.surface.detail.help = "A diferencia del refuerzo de malla del Vóxel, el de superficie no requiere que la malla esté cerrada.

También puede admitir enmascaramiento para que pueda proteger una parte de la malla de los cambios de topología.

Las capas se actualizan correctamente.";
topology.surface.method = "Método";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Uniformidad";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Subdivisión";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Diezmado";
topology.surface.method.help = "Comportamiento de la topología dinámica:
• Uniformidad: añadir y eliminar detalles
• Subdivisión: añadir detalle
• Diezmado: eliminar detalles.";
topology.surface.useMasking = "Proteger área enmascarada";
topology.surface.useMasking.help = "Las áreas enmascaradas protegerán la topología para que no se modifique.";
topology.surface.extrapolate = "Extrapolación de vértices";
// DynTopo
topology.dynamic = "Topología dinámica";
topology.dynamic.global = "Global activado/desactivado";
topology.dynamic.activate = "Habilitado";
topology.dynamic.activate.help = "Con la topología dinámica, las herramientas de escultura pueden subdividir o simplificar la malla localmente en tiempo real.

Esta característica puede tener un impacto notable en el rendimiento.

Las capas se actualizan correctamente.";
topology.dynamic.method = "Detalle basado en...";
topology.dynamic.method.screen = "Pantalla";
topology.dynamic.method.radius = "Radio";
topology.dynamic.method.constant = "Constante";
topology.dynamic.method.help = "• Zoom
El nivel de detalle se basa en lo lejos que se encuentre de la superficie.

• Radio
El radio de la herramienta define la cantidad de detalle.

• Constante
El detalle está fijado, el valor de detalle también se comparte con el control deslizante de Vóxel.";
topology.dynamic.quality = "Preferir...";
topology.dynamic.quality.help = "Si eliges la calidad, las dos diferencias principales son:
• el refinamiento se aplica antes que el operador de escultura, obtendrá menos artefactos de interpolación al pintar o esculpir detalles muy pequeños
• el refinamiento no se aplica de forma incremental, si esculpe detalles muy pequeños o realiza trazos rápidos, la topología siempre se refinará correctamente";
topology.dynamic.quality.speed = "Velocidad";
topology.dynamic.quality.quality = "Calidad";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Aplicar presión sobre el radio";
topology.dynamic.usePressure.help = "Utiliza esta opción si deseas que el impacto de la presión del lápiz en el radio de la herramienta afecte al nivel de detalle.";
topology.dynamic.useFalloff = "Utilizar trazo de disminución";
// Decimate
topology.decimate.title = "Diezmado";
topology.decimate.title.help = "Reduce el número de polígonos intentando mantener la mayor cantidad de detalles posible..

Esta función puede ser útil si quieres exportar para una impresión 3D.
Sin embargo, probablemente no deberías usarlo si quieres seguir esculpiendo en él, ya que puede producir triángulos desiguales.

Ten en cuenta que el área enmascarada no se diezmará.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Diezmar";
topology.decimatePaintWeight = "Preservar pintura";
topology.decimatePaintWeight.help = "Un valor más alto intentará preservar la pintura.

Establece este valor en 0 si no te importa la pintura.";
topology.decimateUniform = "Caras uniformes";
topology.decimateUniform.help = "Un valor más alto generará triángulos de tamaño similar.";
topology.decimatePreserveBorders = "Preservar bordes";
topology.decimatePreserveBorders.help = "No decimar el borde de la malla.";
// Target a certain number of triangles, faces and vertices
topology.target.triangles = "Tríangulos del objetivo";
topology.target.faces = "Caras objetivo";
topology.target.quads = "Cuadrángulos objetivo";
topology.target.points = "Puntos objetivo";
// Quad remesher
topology.qremesh = "Remallado de cuadrángulos";
topology.qremesh.angle = "Ángulo de bisel";
topology.qremesh.border = "Preservar bordes";
topology.qremesh.onlyQuad = "Solo cuadrángulos";
topology.qremesh.hole = "Máximo relleno de agujero";
topology.qremesh.hole.help = "
Desenvoltura UV";

// Unwrapping means compute UV (texture coordinates), with uvs you can appliy (wrap) a texture onto the model
topology.uv.title = "Desenvolver UV";
// UV Unwrap but as a Verb
topology.uv.unwrap = "Desenvolver";
// The operation can be very slow
topology.uv.atlas.warning = "Puede ser muy lento, objetivo a < 100k vértices";
// Handles are topological holes (synonym: genus, hole)
topology.uv.bff.warning = "¡Puede tener superposiciones si la malla tiene asas!";
// Solo patch
topology.uv.bff.seamless = "Parches sin costuras";
topology.uv.bff.seamless.help = "Esta opción puede introducir una distorsión importante.

Típicamente, se puede utilizar cuando los grupos de caras están cuidadosamente configurados.";
// Synonym: Point count? Singularity count ?
topology.uv.bff.cones = "Recuento de conos";
topology.uv.bff.help = "Un valor más alto reducirá la distorsión para objetos complejos.

Un valor más alto significará un tiempo de cálculo más largo.";
topology.uv.delete = "Eliminar UV";

// Transfer the vertex painting in the texture, bake means "create texture (from mesh data)"
topology.bake.title = "Hornear";
// Bake here means "create texture (from mesh data)"
topology.bake.title.help = "La cocción de texturas creará texturas proyectando otros objetos visibles en la escena.

Aquí está el flujo de trabajo típico para la cocción:
• Tienes una malla con detalles finos y pintura
• Clónala
• Decímala (¡establece `Preservar pintura` en 0!)
• Desenvuelve UV
• Cuécela!

Ahora deberías tener una malla de baja resolución que retiene la mayoría de la pintura y detalles de tu objeto anterior.

Después de la operación, los colores de los vértices se moverán a una nueva capa desactivada, para que se ignore en lugar de multiplicarse contra la textura coloreada.

Para elegir qué objetos se utilizan para el horneado, se aplicará la siguiente lógica:
- se hornearán todos los objetos seleccionados y el objeto principal seleccionado (el resaltado más fuerte en el menú de la escena)
- si solo hay un objeto seleccionado, Nomad considerará todos los objetos visibles en su lugar
- de lo contrario, si todos los objetos están ocultos (por ejemplo, usando Solo), se tomará en cuenta toda la escena";
// Bake here means "create texture (from mesh data)"
topology.bake.self = "Desde sí mismo";
// Bake here means "create texture (from another mesh data)"
topology.bake.other = "Desde alta resolución";
topology.bake.resolution = "Resolucion";
// Cage is a specific term, synonyom: "Bake offset"
topology.bake.offset = "Compensación del rayo";
topology.bake.radius = "Radio de jaula";
// Bake opacity (from mask data)
topology.bake.opacityFromMask = "Máscara -> Opacidad";
topology.bake.backup = "Respaldo";

// project a high resolution mesh details onto another
topology.reproject.title = "Reproyectar";
topology.reproject.title.help = "Proyectar detalles esculpidos, pintura y capas desde los objetos visibles más cercanos.

Esto está destinado principalmente a ser utilizado también en una malla de alta resolución, típicamente con una topología limpia.";
// tweaking value
topology.reproject.rayBias = "Sesgo de rayo";
topology.reproject.rayBias.help = "Se utilizan dos métodos para la reproyección:
• más cercano: el punto más cercano en la superficie
• rayo: punto de intersección a través de la dirección normal

Valores de sesgo más altos favorecerán la intersección de rayos en lugar de la superficie más cercana.";
topology.reproject.normalOffset = "Desplazamiento normal";
topology.reproject.shpereCast = "Reversión de lanzamiento de esfera";
topology.reproject.shpereCast.help = "Si la reproyección de rayo normal falla, Nomad recurrirá a la intersección de la superficie más cercana.";
// number of iteration the algorithm will take
topology.reproject.iterations = "Iteraciones";
topology.reproject.relax = "Relajar";
topology.reproject.relax.help = "Relajación debería ser preferida cuando la malla es de bajo poli.";
topology.reproject.layers.help = "Transferir otras capas a la malla seleccionada.";

topology.manifold = "Manifold";
topology.nonManifold = "No-topológico";
topology.manifold.clean = "Limpiar";
topology.manifold.collapse = "Eliminar caras pequeñas";
topology.manifold.title = "Forzar Manifold";
topology.manifold.title.help = "Intenta limpiar el borde no manifold.

Puede ser útil para softwares externos que no admiten bordes que tienen más de 2 caras en común.";

// Reset key-bindings/shortcuts
binding.reset = "Restablecer atajos";
// Add node in a sync mode (synchronize instance)
binding.addSync = "Sincronizar";
binding.addSync.help = "Por defecto, usará el valor de sincronización establecido en el menú de escenas.";
// Binding option
binding.context.toggle = "Alternar contexto";
binding.toggleTool = "Alternar atajos de herramientas";
binding.toggleTool.help = "Al usar uno de los atajos de herramientas, se seleccionará la herramienta anterior si la herramienta actual del atajo está activa.";
// When the key is tap once, the value will be toggled
binding.toggleTap = "Alternar acceso directo al presionar la tecla";
// The binding force camera movement
binding.forceCamera = "Forzar cámara";
binding.forceCamera.help = "Forzar la interacción de la cámara en caso de conflicto con otra vinculación.

Esto puede ocurrir típicamente si la misma vinculación está asignada a un atajo de herramienta o Añadir/Sustraer.";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickMaterial = "Selector de material";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickFaceGroup = "Seleccionar Grupo de Caras";
// Edit the tool brush size/radius
binding.editRadius = "Radio de herramienta";
// Edit the tool brush size/radius
binding.editIntensity = "Intensidad de herramienta";
// Controller dead zone
binding.joystick = "Joystick";
binding.controller.deadZone = "Zona muerta del stick";
binding.controller.deadZone.help = "Aumenta este valor si la cámara se mueve incluso si el stick del controlador se deja sin tocar.";
// Snap the camera
binding.view.front = "Vista Frontal";
binding.view.left = "Vista Izquierda";
binding.view.top = "Vista Superior";
// Move/Translate the view
binding.pan.left = "Desplazar a la Izquierda";
binding.pan.right = "Desplazar a derecha (vista)";
binding.pan.forward = "Desplazar hacia delante (vista";
binding.pan.backward = "Desplazar hacia atrás (vista";
binding.pan.up = "Desplazar arriba (vista";
binding.pan.down = "Desplazar abajo (vista";
// Snap the view (while rotating)
binding.snapViewOnRotate = "Ajustar vista (al rotar)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "Abrir (proyecto)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "Añadir (proyecto)";
// Select all the objects in the scene
binding.selectAll = "Seleccionar todo";
// Rotate environment and the lighting
binding.rotateLighting = "Girar iluminación";
// The Camera pivot is the point around which the camera rotates
binding.updatePivot = "Pivote";

quadremesh.adaptQuadCount = "Cantidad de Cuadrados Adaptativos";
quadremesh.curvatureAdaptivness = "Tamaño Adaptativo";
quadremesh.curvatureAdaptivness.help = "Al 100%, el tamaño de los cuadrados variará dependiendo de la curvatura del objeto, permitiendo cuadrados más pequeños en alta curvatura.
Al 0%, el tamaño de los cuadrados será uniforme.";
quadremesh.useVertexColors = "Preservar pintura";
quadremesh.autoDetectHardEdges = "Detección Automática de Bordes Duros";
quadremesh.autoDetectHardEdges.short = "Bordes duros";
quadremesh.reprojectVertex = "Reproyectar vértice";
quadremesh.reprojectVertex.short = "Reproyectar vértice";
quadremesh.reprojectVertex.label = "Cuando está activado, Nomad reproyectará la posición en la malla anterior.

Tenga en cuenta que si la malla tiene capas, siempre se utilizará la reproyección.";

// Privacy policy
privacyPolicy.title = "Política de privacidad";
privacyPolicy.reject = "Rechazar";
// Hexanomad is the company name
privacyPolicy = "Hexanomad no recopila ningún dato de Nomad Sculpt.";

sonar.disconnect = "Desconectar SonarPen";
sonar.connect = "Conectar SonarPen";
sonar.connect.confirm = "¿Conectar SonarPen?";
sonar.connect.confirm.warning = "Sonar Pen usará el micrófono (audio loopback) para detectar la presión del lápiz.";

// Color disc mode
widget.color.disc = "Disco";
widget.color.ring = "Anillo";
widget.color.square = "Cuadrado";

nomad.mainFolder = "Carpeta principal de Nomad";
nomad.mainFolder.warning = "Los archivos quedan intactos.
No se copian, eliminan ni mueven.";
nomad.mainFolder.error = "Después de seleccionar sí, Nomad se cerrará y podrás reiniciarlo simplemente.";

license.title = "Licencia";
license.retry = "Reintentar";
license.key = "Clave de licencia";
license.activate = "Activar licencia";
// ----------------------------------------------
license.newest = "¡Nueva versión disponible!";
// ----------------------------------------------
license.portal.title = "Usuarios existentes";
license.portal.label = "Portal de licencias";
// ----------------------------------------------
license.checkout.title = "Nuevos usuarios";
license.checkout.label = "Comprar Nomad";
// ----------------------------------------------
license.device.error = "No se pudo obtener la identificación del dispositivo.";
license.device.mismatch = "¡Discrepancia en la identificación del dispositivo!";
// ----------------------------------------------
license.validate.error404 = "Clave de licencia no encontrada.";
license.validate.error422 = "Entidad no procesable.";
// ----------------------------------------------
license.activate.error403 = "¡Número máximo de dispositivos alcanzado!
Puedes desactivar otro dispositivo en tu portal de licencias.";
license.activate.error404 = "Clave de licencia no encontrada.";
license.activate.error422 = "Entidad no procesable.";
// ----------------------------------------------
// version trial
version.restore = "Restaurar compra";
version.buyWeb = "La versión web es solo una demostración";
version.buyFull = "Actualiza a la versión completa";
version.buyQR = "Compra";
version.buyQR.promo = "
El Quad Remesher es un algoritmo que produce una malla dominante de cuadrados.
La distribución de cuadrados intentará seguir la curvatura natural del objeto.

El algoritmo también puede adaptar el tamaño de los cuadrados dependiendo de la curvatura local.

También puedes guiar la topología resultante con:

• Grupo de Caras $0 (¡asegúrate de suavizar sus bordes para un mejor resultado!)

• Simetría planar X/Y/Z $1

• Guías de curvas $2

• Pintura de densidad $3

El Quad Remesher es desarrollado por https://exoside.com/.";

version.trialHistory = "Versión de prueba: Deshacer/rehacer 4 veces";
version.trialLayer = "Versión de prueba: Una capa por malla";
version.trialNoImport = "Versión de prueba: sin importación";
version.trialNoExport = "Versión de prueba: sin exportación";

version.fullFeatures = "• Compra única
• Deshacer/rehacer ilimitado
• Capas ilimitadas
• Exportación e importación";

version.demo.purpose = "Esta versión se ha creado específicamente con fines de demostración.";
version.demo.disable = "Prestación no activada para esta demo.";

// app store main page
store.name = "Nomad Sculpt";
store.headline = "Esculpir, pintar y crear en 3D";
store.tag = "sculpt, 3d, nomad, paint, modeling, esculpir, pintar, modelado";
// ----------------------------------------------
store.description.sculpt = "• Herramientas de escultura
Arcilla, aplanar, suavizar, máscara y muchas otras brochas te permitirán dar forma a tu creación.
También puedes usar la herramienta de corte booleano de recorte con lazo, rectángulo y otras formas, para propósitos de superficies duras.";
// ----------------------------------------------
store.description.stroke = "• Personalización de trazo
Decaimiento, alphas, mosaicos, presión de lápiz y otros parámetros de trazo pueden ser personalizados.
También puedes guardar y cargar tus ajustes de herramienta.";
// ----------------------------------------------
store.description.paint = "• Herramientas de pintura
Vertex painting con color, roughness y metalness.
También puedes gestionar fácilmente todos tus presets de material.";
// ----------------------------------------------
store.description.layer = "• Capas
Registra tus operaciones de escultura y pintura en capas separadas para facilitar la iteración durante el proceso de creación.
Tanto los cambios de escultura como de pintura se registran.";
// ----------------------------------------------
store.description.multires = "• Escultura multiresolución
Cambia de una resolución a otra con tu malla para un flujo de trabajo flexible.";
// ----------------------------------------------
store.description.voxel = "• Vóxel remeshing
Remesh rápidamente tu mesh para obtener un nivel uniforme de detalle.
Se puede usar para esbozar rápidamente una forma áspera al principio del proceso de creación.";
// ----------------------------------------------
store.description.dynamic = "• Topología dinámica
Refina localmente tu mesh bajo tu brocha para obtener un nivel automático de detalle.
¡Incluso puedes mantener tus layers, ya que se actualizarán automáticamente!";
// ----------------------------------------------
store.description.topology = "• Decimación
Reduce el número de polígonos manteniendo tantos detalles como sea posible.";
// ----------------------------------------------
store.description.group = "• Grupo de Caras
Segmenta tu mesh en subgrupos con la herramienta de grupo de caras.";
// ----------------------------------------------
store.description.unwrap = "• Desenvolvimiento UV automático
El unwrapper UV automático puede usar grupos de caras para controlar el proceso de unwrapping.";
// ----------------------------------------------
store.description.baking = "• Baking
Puedes transferir datos de vértice como color, roughness, metalness y detalles a pequeña escala a texturas.
También puedes hacer lo contrario, transferir datos de texturas a datos de vértice o layers.";
// ----------------------------------------------
store.description.primitive = "• Forma primitiva
Cilindro, toro, tubo, torno y otras primitivas se pueden usar para comenzar rápidamente nuevas formas desde cero.";
// ----------------------------------------------
store.description.rendering = "• Renderizado PBR
Hermoso renderizado PBR por defecto, con iluminación y sombras.
Puedes siempre cambiar a MatCap para un sombreado más estándar con fines de escultura.";
// ----------------------------------------------
store.description.postprocess = "• Postprocesado
Reflexión de espacio de pantalla, Profundidad de campo, Oclusión ambiental, Mapeo de tonos, etc";
// ----------------------------------------------
store.description.files = "• Exportar e Importar
Los formatos soportados incluyen archivos glTF, OBJ, STL o PLY.";
// ----------------------------------------------
store.description.interface = "• Interfaz
Interfaz fácil de usar, diseñada para la experiencia móvil.
¡La personalización también es posible!";
// ----------------------------------------------
store.description.remesher = "• Remallador Cuádruple (solo disponible como compra dentro de la aplicación)
Remalla tu objeto automáticamente con una malla dominante de cuádruples que sigue las curvaturas del mesh.
Admite guías, grupos de caras y pintura de densidad.";
// ----------------------------------------------