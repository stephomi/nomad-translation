// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "Conferma?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Sì";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "Ok";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Annulla";

// Experimental feature
experimental = "Sperimentale!";

// On single tap (should be short)
ontap = "Tocco";

clipboard = "Appunti";
clipboard.copy = "Copia";
clipboard.paste = "Incolla";

// memory size
bytes = "byte";
kB = "kB";
MB = "MB";
GB = "GB";
TB = "TB";

// Noun
instance = "Crea istanza";

// Same value (usually for axis, e.g: x == y == z)
uniform = "Uniforme";

sync = "Sincronizza";

// position
position.top = "Alto";
position.bottom = "Basso";
position.left = "Sinistra";
position.right = "Destra";
position.center = "Centrato";
// direction
direction.up = "Alto";
direction.down = "Basso";
direction.left = "Sinistra";
direction.right = "Destra";
// 3d cube
cube.top = "Superiore";
cube.bottom = "Inferiore";
cube.left = "Sinistra";
cube.right = "Destra";
cube.front = "Anteriore";
cube.back = "Posteriore";

// Name of an item (object, tool, etc)
item.name = "Nome";
// Add a new item (object, tool, etc)
item.new = "Nuovo";
// Rename an item (object, tool, etc)
item.rename = "Rinomina";
// Add a new item (object, tool, project, etc)
item.add = "Aggiungi";
// Update an item image with a new image (synonym: Update)
item.replace = "Sostituisci";
// Save an item (object, tool, etc)
item.save = "Salva";
item.save.confirm = "Conferma salvataggio?";
// Update an item (update camera view point, etc)
item.update = "Aggiorna";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Ultimo salvataggio";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "Carica ultimo salvataggio?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Ripristina";
item.reset.confirm = "Conferma ripristino?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "Crea istanza";
// Uninstance the object, make the object real
item.uninstance = "Disinstanzia";
// Clone an item (object, tool, etc)
item.clone = "Clona";
// Delete an item (object, tool, etc)
item.delete = "Elimina";
item.delete.confirm = "Conferma eliminazione?";
item.delete.confirm.yes = "Sì, elimina";
// When we delete the item but the image is used somewhere
item.delete.used = "Immagine utilizzata";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "In Nodo";
// Item visibility (object, layer, etc)
item.visible = "Visibile";
// Show an item (object, layer, etc)
item.show = "Mostra";
// Hide an item (object, layer, etc)
item.hide = "Nascondi";
// Select an item (object, layer, etc)
item.select = "Seleziona";
// Unselect an item (object, layer, etc)
item.unselect = "Deseleziona";
// Merge an item with another one below (layer)
item.mergeDown = "Unisci sotto";
// The order of an item in a list
item.order = "Ordine";
// Focus on previous item
item.previous = "Precedente";
// Focus on next item
item.next = "Avanti";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "Blocca";
// No item selected
item.none = "Nessuno";

// Search something (text entry to filter item)
search = "Cerca";

// Three-state toggle button (Auto, Off, On)
toggle.on = "On";
// Three-state toggle button (Auto, Off, On)
toggle.off = "No";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "Auto";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Miniature mancanti, rielaborazione dei file...";
loading.reprocess.cancel = "Saltare la generazione delle miniature?";

access.title = "Accessibilità";
access.window = "Finestra assistiva";
access.pinch = "Pizzica";
access.drag = "Trascina";
access.rotate = "Ruota";
access.roll = "Rotazione";

// Color of an object
material.color = "Colore";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "Disturbo";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "Lucentezza";
// Whether the material is a metal or not
material.metalness = "Metallicità";
// How much light a surface will reflect
material.specular = "Speculare";
// Light that the surface can emit (glow)
material.emissive = "Emissivo";
// Normal map (synonym: detail, bump)
material.normal = "Normale";
// flip y coordinate
material.normal.flipY = "Inverti Y";
// Ambient Occlusion (AO)
material.occlusion = "Occlusione";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "Texture";
// Textures/Image
material.texture = "Texture";
// A warning indicating that the mesh has no UVs
material.warningNoUVs = "No UV!";
// Texture filtering https://en.wikipedia.org/wiki/Texture_filtering
material.texture.filter = "Filtraggio";
// Nearest Filtering (closest sample)
material.texture.nearest = "Vicino";
// Bilinear Filter
material.texture.linear = "Lineare";
// Mipmap filtering
material.texture.mipmap = "Mipmap";
// Triplanar mapping
material.projection = "Proiezione";
material.projection.triplanar = "Triplanare";

// Minify
about.minify = "Minimizza UI";
about.minify.help = "Puoi anche toccare lo schermo con 4 dita, se il tuo dispositivo lo supporta.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Piattaforma girevole";
// Rotation center of the turntable
about.turntable.pivot = "Centro di rotazione";
// Keep current pivot
about.turntable.pivot.keep = "Mantieni attuale";
// Turntable pivot will be at the center of the scene
about.turntable.pivot.scene = "Scena";
// Make the entire scene turn around (speed of the animation)
about.turntable.speed = "Velocità";
// Stuffs that I used to make the app
about.credits = "Riconoscimenti";
// Link to open source projects that I used for the app
about.credits.openSource = "Open Source";
// Only translate the &
about.credits.arts = "MatCap e HDRI";
// Change languages of the app
about.languages = "Lingue";
about.languages.help = "File di traduzione disponibili a $0";
// Link to the App Website
about.website = "Sito Web";
// Link to the App Forum
about.forum = "Forum";
// Link to the App Manual
about.manual = "Manuale";
// Link to the App Email
about.mail = "Supporto";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";
// Link to the App Threads account
about.threads = "Threads";

// The user canceled an operation that was running
alert.aborted = "Operazione annullata!";
// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "L'oggetto non ha aperture!";
// No operation occured because the mesh is already manifold
alert.manifold.already = "La mesh è già manifold!";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "L'oggetto corrente è invisibile!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Niente da rifilare.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Interrompi rifilatura: l'oggetto è completamente rifilato.";
// In order to extract something, the mesh needs to have painted mask
alert.extract.none = "Niente da estrarre!";
// In order to split something, the mesh needs to have painted mask
alert.extract.split.none = "Niente da dividere!";
// List of disabled features when View Mode is selected
alert.view.disabled = "Funzionalità disabilitate in Modalità Vista:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Widget primitive";
// The object needs to have two parts disconnected
alert.separate.fail = "Impossibile separare: l'oggetto è composto da una sola parte!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "Remeshing eseguito!";
alert.voxelRemesh.empty = "Interrompi remeshing: la mesh risultante non ha lati.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "Inserimento non valido!";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "L'oggetto verrà duplicato";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "L'oggetto verrà istanziato";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Modifica modalità pivot.";
alert.mask.full = "Maschera = 100%!";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "Modifica modalità oggetto.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Attiva topologia dinamica";
// See Glossary (DynTopo)
alert.dynamic.disable = "Disattiva topologia dinamica";
alert.colorPicker = "Trascina il dito sull'oggetto per scegliere un colore.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Basta toccare per uscire dalla modalità di trasformazione.";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "Tocco semplice per uscire dalla modalità di simmetria di modifica.";
// Show the painted mask on the mesh
alert.mask.show = "Mostra maschera";
// Hide the painted mask on the mesh
alert.mask.hide = "Nascondi maschera";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Blocca selezione";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Sblocca selezione";
// Hide the objects that are not selected
alert.selection.isolate = "Isola selezione";
// Show the objects that are hidden
alert.selection.showAll = "Mostra tutto";
// Project quick saving
alert.quickSave = "Salvataggio...";
// Painting on the object was hidden but the user did paint the object
alert.forcePainting.fill = "Mostra dipinti attivata, è stato utilizzato [Dipingi tutto].";
// Painting on the object was hidden but the user started to paint on the object
alert.forcePainting.tool = "Mostra dipinti attivata, l'oggetto è stato dipinto.";
// See Glossary (Multiresolution)
alert.multiresLost = "La multirisoluzione andrà persa!";
// Boolean cut mode will ignore some features
alert.booleanIgnored = "Boolean ignorerà le aree mascherate o nascoste!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "Il valore dei dettagli è elevato e potrebbe richiedere molta memoria!";
// Autosave popup
alert.autoSave.auto = "Salvataggio automatico in… $0s";
// The selected object doesn't have any layers
alert.needLayer = "Lo strumento attuale richiede un livello attivo.";
// The user decided to hide the painting on the objects
alert.paintingHidden = "Dipinti nascosta!";
// The user decided to hide the masking on the objects
alert.maskingHidden = "La maschera è nascosta!";
// The user decided to display hidden faces
alert.hideIgnored = "Nascondi viene ignorato!";
// The selected object doesn't have any layers
alert.noPartialWireframe = "Il disegno parziale è disabilitato quando è visualizzato il wireframe.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Considerare l'utilizzo della telecamera ortografica se si desidera evitare la distorsione del tronco prospettico quando si utilizza il proiettore dello schermo.";
// Trial version has a limited number of undo
alert.state.trial = "Versione di prova: annulla non eseguito";

background = "Sfondo";
// A flat color will be displayed in the background of the scene
background.color = "Colore";
// 2 color with rotation
background.gradient = "Gradiente";
// The environment (HDRI) will be displayed in the background
background.environment = "Ambiente";
background.blur = "Sfocatura";
background.exposure = "Esposizione";

// Image that the artist uses as a reference
background.imageEnable = "Immagine di riferimento";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Sovrapponi";
// Opposite of transparency (Alpha)
background.imageAlpha = "Opacità";
background.imageReset = "Ripristina impostazioni";
background.imageTransform = "Trasforma";
// X screen coordinate of the image reference
background.imageX = "Posizione X";
// Y screen coordinate of the image reference
background.imageY = "Posizione Y";
// Rotation of the reference image
background.imageRotation = "Rotazione";
// Scale of the reference image
background.imageScale = "Dimensione";

// Blend: normal
blend.normal = "Normale";
// Blend: darker
blend.darker = "Più scuro";
blend.darker.darken = "Scurezza";
blend.darker.multiply = "Moltiplica";
blend.darker.linearBurn = "Brucia lineare";
blend.darker.colorBurn = "Brucia colori";
// Blend: lighter
blend.lighter = "Più chiaro";
blend.lighter.lighten = "Schiarisci";
blend.lighter.screen = "Scolora";
blend.lighter.linearDodge = "Dodge Lineare";
blend.lighter.colorDodge = "Dodge Colore";
// Blend: contrast
blend.contrast = "Contrasto";
blend.contrast.hardLight = "Luce Decisa";
blend.contrast.softLight = "Luce Soffice";
blend.contrast.overlay = "Sovrapponi";
blend.contrast.hardMix = "Miscela Dura";
blend.contrast.linearLight = "Luce Lineare";
blend.contrast.vividLight = "Luce Vivida";
blend.contrast.average = "Media";
// Blend: inversion
blend.inversion = "Inversione";
blend.inversion.exclusion = "Esclusione";
blend.inversion.difference = "Differenza";
// Blend: cancelation
blend.cancelation = "Annullamento";
blend.cancelation.divide = "Dividi";
blend.cancelation.subtract = "Sottrai";
// Blend: component
blend.component = "Componente";
blend.component.luminosity = "Luminosità";

// Camera (point of view in 3d)
camera = "Fotocamera";
cameras = "Fotocamere";
camera.view = "Vista";
// Copy the views
camera.updateView = "Aggiornare punto di vista?";
// Add a new camera
camera.addView = "Aggiungi vista";
// Focus on the camera
camera.focus = "Fuoco";
// Add on the camera camera
camera.focusOn = "Fuoco su $0";
// Camera projection, Orthographic or Perspective
camera.projection = "Proiezione";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Ortografica";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Prospettiva";
// camera Vertical Field of View
camera.fov = "Campo visivo verticale";
// Camera Field of View hint
camera.focal = "focale $0mm (sensore 35mm)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Rotazione";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "Piattaforma girevole";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Trackball";
camera.rotation.trackball.help = "Trackball offre un maggior grado di libertà: è possibile ruotare la fotocamera con due dita.";
// Camera interaction mode, 1st person view
camera.firstPerson = "In prima persona";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Velocità";
// Camera rotation sensitivity
camera.speed.rotation = "Rotazione";
// Camera translation sensitivity
camera.speed.panning = "Panoramica";
// Camera zooming sensitivity
camera.speed.zooming = "Zoom";
// Reset camera position
camera.resetView = "Reimposta vista";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Aggancia vista";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "La telecamera è agganciata (ortografica)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "Aggancio ortografico";
camera.snapOrthographic.help = "Questa opzione funziona anche quando si utilizza il Cubo a scatto nell'angolo.";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Pivot";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Tocca due volte sull'oggetto";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Tocca due volte sullo sfondo";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "Attiva/Disattiva";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "Selezione";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "Scena";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "Aggiorna con un doppio tocco";
camera.doubleTapPivot.help = "Aggiorna il pivot di rotazione quando si tocca due volte la superficie dell'oggetto.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "Pivot esterno";
camera.airPivot.help = "Consente un nuovo pivot anche quando si esegue lo zoom all'esterno della superficie dell'oggetto.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "A inizio interazione con la telecamera";
camera.autoPivot.help = "Aggiorna il pivot quando si inizia a interagire con la telecamera.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Fuoco";
camera.doubleTapFocus.help = "Quando si tocca due volte l'oggetto, la telecamera esegue una panoramica e una messa a fuoco sul punto selezionato.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "Multiselezione";
// There is 0 nodes/items selected
context.noSelection = "Nessuna selezione";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "Preset";
// Quick curve x side shift
curve.shift = "Shift";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "Spline";
curve.bspline = "B-spline";
curve.precision = "Precisione";
// snap
curve.snap = "Aggancio";
curve.snap.offset = "Spostamento";
curve.snap.offset.help = "Un valore di 100% è uguale al raggio del tubo.";
curve.snap.surface = "Superficie";
curve.snap.vertex = "Vertice";
curve.snap.grid = "Griglia (se agganciata)";
// Regular spaced sampling
curve.uniform = "Uniforme";
curve.uniform.help = "La curva verrà campionata a intervalli regolari, per garantire una densità uniforme.

È possibile disabilitare questa opzione per controllare un po' i loop dei bordi aggiungendo nuovi punti di controllo sulla curva.";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "Mostra l'attenuazione in modo simmetrico.

Questa opzione è solo un indizio visivo, non influisce sull'attenuazione stessa";
curve.radius = "Raggio";
curve.twist = "Torsione";
curve.spiral = "Spirale";
curve.spiral.twist = "Angolo di torsione";
curve.spiral.scale = "Dimensione";
curve.spiral.offset = "Spostamento";
curve.spiral.angle = "Spostamento angolo";
curve.pivot = "Pivot";
curve.pivot.self = "Curva";
curve.pivot.children = "Figli";

// Set the desired FPS (frame per second, refresh rate)
debug.targetFPS = "FPS Obiettivo";
debug.targetFPS.help = "Quando disabilitato, il valore predefinito significa che si sincronizzerà con il tasso di aggiornamento del display.";

// Warning about UVs (using extra memory)
debug.uvPrimitive.warning = "Disabilita questa opzione se non hai bisogno di UV (memoria extra).";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "Normalizza UV";
debug.uvNormalize.help = "Nomad normalizzerà le UV all'interno del riquadro [0-1].";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "Aggiungi UV BFF";
debug.uvBFF.help = "Si aggiunge un metodo di unwrapping alternativo (Boundary First Flattening).

Si noti che BFF produrrà sovrapposizioni se la topologia della mesh è diversa da un disco o da una sfera.";

// Debug option, display an window with some debugging logs
debug.logs = "Log";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Heightmap";
// Debug options, graphical stuffs
debug.graphics = "Grafica";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Crea miniature per lo store";

// Empty list: there is no projects
file.project.empty = "Non hai ancora un progetto salvato!";
// The current opened project has some unsaved changes
file.project.unsaved = "Vi sono modifiche non salvate!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "Perderai le modifiche non salvate!";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Anteprima dell'ultimo salvataggio manuale";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "Versione di prova: non potrai riaprire il progetto corrente!";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "Versione di prova: puoi solo riaprire il tuo progetto attuale!";

file.project = "Progetto";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Salva";
// E.g: Save "my_project"?
file.project.save.confirm = "Salvare $0?";
// Overwrite another project
file.project.saveAs = "Salva come";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "Sovrascrivere $0?";
// Open a project
file.project.open = "Apri";
// E.g: Open "my_project"?
file.project.open.confirm = "Aprire $0?";
// Load another project and add/append all its data to the current scene
file.project.add = "Aggiungi alla scena";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "Aggiungere $0 alla scena?";
// Reset the scene and create a new project
file.project.new = "Nuovo";
file.project.new.confirm = "Creare nuova scena?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "Eliminare $0?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "Eliminare $0?

Questo è il progetto attivo al momento!";

// Auto save section
file.project.autoSave = "Salvataggio automatico";
file.project.autoSave.confirm = "Disattivare salvataggio automatico?";
file.project.autoSave.help = "Salva il tuo progetto in un file separato a intervalli regolari.

Il file di salvataggio automatico si trova in:";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "Intervallo popup";
// In minutes
file.project.autoSave.minutes = "Timer popup";
// Delete the current autoSave data
file.project.autoSave.delete = "Elimina dati salvataggio automatico";

// color space (linear or srgb), do not translate linear/srgb if there is a doubt
file.colorSpace = "Spazio Colore";
file.colorSpace.help = "Prova ad attivare questa opzione se i colori sembrano incorretti.";
file.colorSpace.linear = "Lineare";
file.colorSpace.srgb = "sRGB";

// Configure imports option
file.importSettings = "Opzioni importazione";

// Load interface preference settings when opening a scene file
file.import.guiSettings = "Mantieni impostazioni GUI";
file.import.guiSettings.help = "Quando si apre o si importa un file di progetto, verranno caricate tutte le impostazioni relative alla GUI incorporate nel progetto.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.import.obj.splitByGroup = "Dividi OBJ per gruppi";
file.import.obj.splitByGroup.help = "Quando abilitato, Nomad dividerà i gruppi OBJ in oggetti separati.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.import.mergeLayers = "Unisci livelli";
// Ignore the textures present in the file to load
file.import.skipTextures = "Ignora texture";
// Do not fiddle with the object topology when loading the file
file.import.keepTopology = "Mantieni topologia";
file.import.keepTopology.help = "Usa questa opzione se non vuoi che Nomad interferisca con la topologia della mesh importata.

Disabiliterà il riordino dei vertici/lati, la rimozione dei duplicati dei vertici/lati e la rimozione dei vertici inutilizzati.";

// Import file section
file.import.title = "Importa";
file.import.title.help = "Formati supportati:";
// The user imports a scene file that will replace the current scene
file.import.open = "Apri";
file.import.open.confirm = "Importare nuovo file?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Aggiungi alla scena";
file.import.add.confirm = "Importare nuovo file?";

// Export scene file
file.export.title = "Esporta";

file.select.include = "Includi";
file.select.all = "Tutti";
file.select.visible = "Visibile";
file.select.selected = "Selezionati";
file.select.unselected = "Deselezionato";

// Export the current selected objects instead of the entire scene
file.onlySelection = "Includi solo oggetti selezionati";
file.onlySelection.help = "Includi solo la selezione, invece dell'intera scena.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Ricostruisci quadrilatero";
file.convertToQuad.help = "Ricostruisci quadrilateri da triangoli accoppiando i triangoli (se sono adiacenti nei file).";
// ----------------------------------------------
// Whether we include the textures in the exported file
file.export.texture = "Texture";
// Baking means transfering/converting
file.export.texture.help = "Questa opzione non trasferisce i colori dei vertici nelle texture.";
// ----------------------------------------------
file.export.color0 = "Colori dei vertici";
file.export.color1 = "Dipinti PBR";
file.export.color1.help = "Esporta rugosità, metallicità e dipinti della maschera. Questo verrà ignorato da altri software.";
// ----------------------------------------------
// Whether we include normals vector in the exported file
file.export.normal = "Normali";
file.export.normal.help = "Selezionare questa opzione se si desidera aprire il file in un altro software.

Nomad ignora sempre le normali poiché le ricalcolerà.";
// ----------------------------------------------
file.export.tangent = "Tangenti";
file.export.tangent.help = "Selezionare questa opzione se si desidera aprire il file in un altro software.

Le tangenti sono utilizzate solo se il modello ha una mappa normale.

Nomad ignora sempre le tangenti poiché verranno ricomputate.";
// ----------------------------------------------
file.export.nomad = "Esporta Nomad";
file.export.nomad.help = "Formato file interno di Nomad Sculpt.

Questo formato non si aprirà su altri software, è principalmente per scopi di re-importazione.";
// ----------------------------------------------
file.export.gltf = "Esporta glTF 2.0";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Livelli";
file.export.gltf.layer.help = "Esporta livelli come morph. Ufficialmente supportato da glTF, quindi dovrebbe funzionare anche su altri software.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Livelli dipinti";
file.export.gltf.layerPaint.help = "Esporta livelli di dipinti. Solitamente viene ignorato da altri software.";
// ----------------------------------------------
file.export.obj = "Esporta OBJ";
file.export.obj.warning = "I livelli e la dipinti extra (rugosità, metallicità e maschera) andranno persi.";
// Whether we include the vertex color in the exported file
file.export.obj.color = "Colori dei vertici";
file.export.obj.color.help = "Alcuni software 3D potranno leggerle, ma non tutti.";
file.export.obj.color.help.append = "Aggiungi informazioni sul colore dopo i vertici.";
file.export.obj.color.help.hexa = "Un modo alternativo per codificare il colore. Supporta anche i dati della maschera.";
file.export.obj.faceGroup = "Gruppo di facce";
file.export.obj.object = "Scrivi oggetti";
file.export.obj.object.help = "Tieni gli oggetti separati.

Disabilitando questa opzione verrà esportato tutto come un'unica entità.
Devi disabilitare questa opzione se vuoi usare la funzione 'Mesh ID / Polygroup' di Substance Painter.";
file.export.obj.archive = "Tipo";
file.export.obj.archive.folder = "Cartella";
file.export.obj.archive.zip = "Zip";
file.export.obj.archive.help = "Alcune app (Google Drive, One Drive, ecc.) non supportano l'importazione di cartelle, quindi puoi usare Zip al loro posto.";
// ----------------------------------------------
file.export.stl = "Esporta STL";
file.export.stl.warning = "I livelli e la dipinti extra (rugosità, metallicità e maschera) andranno persi.";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Colori dei vertici";
file.export.stl.color.help = "Alcuni software 3D potranno leggerli, ma non tutti.";
// ----------------------------------------------
file.export.ply = "Esporta STL";
file.export.ply.warning = "I livelli e la dipinti extra (rugosità, metallicità e maschera) andranno persi.";
// ----------------------------------------------
file.export.fbx = "Esporta FBX";
// ----------------------------------------------
// Advanced settings
settings.advanced = "Avanzato";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "Queste opzioni non vengono salvate nelle impostazioni.";
settings.reset.title = "Impostazioni";
settings.reset.title.help = "Ripristinerà le impostazioni delle preferenze dell'app.

Alcune risorse vengono salvate separatamente e NON verranno ripristinate, tra cui:
• Progetti
• Collegamenti ai tasti
• Preset di strumenti
• Ambienti HDR
• MatCap
• Alfa
• Texture (pennello)
• Immagini di riferimento

Tieni presente che tutto ciò che è collegato al progetto verrà mantenuto intatto, come l'illuminazione, il post processing, le viste, ecc";

// Reset preference settings button
settings.reset = "Ripristina valori predefiniti";
settings.reset.confirm = "Ripristinare le impostazioni delle preferenze?";

// Render a screenshot of the scene
file.render = "Renderizza";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Mostra interfaccia";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Rapporto di rendering";
file.render.renderRatio.help = "Un valore di 1.0 significa che Nomad eseguirà il rendering alla stessa risoluzione delle dimensioni dell'immagine richieste di seguito.

Utilizzare questa opzione se non è possibile eseguire il rendering con una determinata risoluzione (arresto anomalo per mancanza di memoria).";
// Desired size of the exported screenshot
file.render.size = "Dimensione finale";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Personalizzata";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "Scolora";
// width of exported screenshot
file.render.width = "Larghezza";
// height of exported screenshot
file.render.height = "Altezza";
// export screenshot of the scene
file.render.export = "Esporta png";
file.render.warn = "La risoluzione di esportazione è alta ($0x$1)!

Assicurati di salvare il progetto per evitare che il tuo dispositivo esaurisca la VRAM e vada in crash.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Sfondo trasparente";
file.render.transparent.help = "Questa opzione può essere utile se vuoi inserire la mesh in un software di creazione 2D.

Per ora la trasparenza parziale degli oggetti non è supportata.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Usa le impostazioni globali";
pressure.useGlobal.help = "Per impostazione predefinita, gli strumenti condividono le stesse impostazioni di pressione.

Deseleziona questa opzione se desideri impostazioni di pressione specifiche per questo strumento.";

// Pencil pressure
pressure.title = "Pressione";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "Questo strumento non utilizza la pressione della matita/stilo.";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "Il tipo di tratto Cattura ignorerà le impostazioni di pressione.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Raggio";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Intensità";
// Average pencil pressure event to get smoother result
pressure.average = "Livellamento della pressione";
pressure.average.help = "Media gli eventi di pressione della matita per risultati più fluidi.";

// list of inputs allowing camera interaction
gesture.camera = "Fotocamera";
// list of inputs allowing sculpting interaction
gesture.sculpt = "Scolpire";
// Select object
gesture.select = "Seleziona oggetto";
// Finger/Touch input
gesture.finger = "Dito";
// Stylus/Pencil
gesture.stylus = "Stilo";
// Mouse/Trackpad
gesture.mouse = "Mouse";

// long press to pick the color/material under the cursor
gesture.dropper = "Selezione materiale";
gesture.dropper.help = "Il selettore colore/materiale può essere attivato premendo a lungo sulla tela.

Si noti che funziona solo se il pennello corrente ha la dipinti abilitata.";

// Three fingers on screen
gesture.three.title = "Tre dita";
gesture.three.light = "Ruota illuminazione";
gesture.three.light.help = "Ruotare l'ambiente, le luci e MatCap.";
gesture.three.radius = "Raggio strumento";
gesture.three.intensity = "Intensità strumento";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.finger.smooth = "Il dito leviga sempre";
gesture.finger.smooth.help = "Questa opzione è attiva solo se uno strumento di scultura è attivo.";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Consenti pressione non riconosciuta";
gesture.unknownPressure.help = "Seleziona questa opzione se la pressione non funziona con lo stilo o se hai bisogno di premere con il dito.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Pulsante stilo";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Doppio tocco Pencil";
gesture.pencilAction.ios.help = "Attivo solo per Apple Pencil 2ª gen.";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "Nessuno";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Agg./Sott.";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "Scorciatoie con un tocco";
gesture.mask.oneTap.help = "Consenti la scorciatoia Maschera toccando lo schermo una volta, senza dover tenere premuta la scorciatoia del pulsante maschera.

Permetterà i seguenti gesti:
• toccare lo sfondo per invertire la maschera
• tocca un'area mascherata per sfocare la maschera
• tocca un'area non mascherata per rendere più nitida la maschera";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.holdStroke = "Tratto";
gesture.mask.holdStroke.help = "Una pressione prolungata attiverà l'alternanza tra Maschera e SelMaschera e inizierà un nuovo tratto.

Al termine del tratto, verrà selezionato nuovamente lo strumento precedente.";
gesture.mask.holdIdle = "Strumento";
gesture.mask.holdIdle.help = "Premi a lungo e rilascia senza muoverti per passare tra Maschera e SelMaschera.";

// Shortcut customization, choose the action that the shortcut will performan (select tool, etc)
gesture.shortcut = "Scorciatoia";

// Shortcuts to undo/redo
gesture.history = "Cronologia scorciatoie";
gesture.history.help = "• Annulla: tocca con 2 dita
• Ripeti: tocca con 3 dita";
gesture.history.hold = "Pressione lunga";
gesture.history.hold.help = "Tieni premuto con 2/3 dita (continuo).";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Rifiuto del palmo";
gesture.palmRejection.confirm = "Assicurati di disabilitare questa opzione se hai problemi a interagire con la tela!";
gesture.palmRejection.help = "Rifiuta input se la dimensione dell'area di contatto è maggiore di questo valore.

Potrebbe non funzionare su tutti i dispositivi.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Soglia di dimensione massima";

// Smoothing strategy
extract.polish.all = "Tutti";
extract.polish.sharp = "Bordo netto";
extract.polish.border = "Solo bordi";
// Smooth the border in a way that it matches completely with its dual
extract.polish.syncBorder = "Sincronizza bordo";
// topology of extracted mesh
extract.edgeLoop = "Loop del bordo (lato)";
extract.edgeLoop.auto = "Loop del bordo automatico";
extract.edgeLoop.division = "Divisione";
// The thickness of the extracted mesh (from the painted mask)
extract.thickness = "Spessore";
// Carve the mask into the surface
extract.carve = "Incisione";
// Extract a new mesh from the painted mask
extract = "Estrai";
// Preview extract
extract.preview = "Anteprima";
// Extract two new mesh from the painted mask and from the unmasked area
extract.split = "Dividi";
// How should we close the topology of the extracted object
extract.action = "Azione di chiusura:";
extract.action.help = "• Nessuno
Estrae semplicemente la parte e lascia aperta la parte estratta.

• Riempi
Il foro viene riempito e levigato.
Non utilizzare questa opzione per le superfici piane.

• Involucro
Chiude la forma estratta utilizzando il valore dello spessore.

• Livello
Estrae la differenza di livello (solo nel sottomenu dei livelli).";
// Do not close the mesh (leave it open)
extract.action.none = "Nessuno";
// Close the mesh with a hole-filling algorithm
extract.action.fill = "Riempi";
// Close the mesh by adding a thickness on the surface
extract.action.shell = "Involucro";
// Close the mesh by using the layer data as a difference thickness
extract.action.layer = "Livello";

// uv part of revolution surface
genus.main = "Principale";
genus.hole = "Apertura";
genus.bottom = "Basso";
genus.top = "Alto";

// History, list of undo/redo
history = "Cronologia";
// First "undo" state
history.root = "Primo stato";
history.undoConfirm = "Confermi l'annullamento di tutte queste operazioni?";
history.undoWarning = "Se apporti una modifica in seguito potresti perdere molte modifiche.";
// Settings concerning the history stack of undo/redo
history.stack = "Pila";
// Actions to include in the undo/redo stack
history.include = "Includi azioni";
// include lighting editing in the undo/redo
history.includeLights = "Luci";
history.includeLights.help = "Se questa opzione è disabilitata, lo spostamento delle luci con il Gizmo sarà comunque incluso, poiché può influire su altri oggetti nella gerarchia delle scene.";
// include postProcess editing in the undo/redo
history.includePostProcess = "Post processing";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCap e HDRI";
// Can limit the stack of undo/redo size
history.limitSize = "Limite cronologia";
history.limitSize.help = "Dimensione massima della cronologia.

La cronologia verrà aggiornata alla successiva operazione registrata.";
// Limit the number of undo in the history stack
history.limitStack = "Limite passaggi";
history.limitStack.help = "Numero massimo di operazioni che l'applicazione può mantenere.

La cronologia verrà aggiornata alla successiva operazione registrata.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Massimo annullabile";
history.rangeProtect.help = "Se si va lontano nella cronologia, verrà visualizzata una finestra di dialogo di conferma prima di annullare molte operazioni.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Ripristina telecamera";
history.restoreCamera.help = "Abilitare questa opzione per ripristinare il punto di vista della telecamera salvato quando si annulla/ripete un'azione.";
// Undo
history.undo = "Annulla";
// Redo
history.redo = "Ripeti";
// Shown during undo
history.state.undo = "Annulla: $0";
// Shown during redo
history.state.redo = "Ripeti: %0";
// Shown during undo/redo
history.state.symmetrySplit = "Simmetria divisa";
// Shown during undo/redo
history.state.voxelRemesh = "Remeshing voxel";
// Shown during undo/redo
history.state.surfaceRemesh = "Remeshing superficie";
// Shown during undo/redo
history.state.multiresLevel = "Modifica della risoluzione";

// Debugging/Inspect object material (view channel separately color, roughness, normal, uv, etc)
inspect = "Ispettore";
// Inspector but SHORT
inspect.short = "Ispeziona";
// Display the material channel on the background
inspect.onBackground = "Sullo sfondo";
// Display the material channel on the mesh
inspect.onMesh = "Sulla mesh";
// Show UV seams
inspect.seams = "Cuciture";

// Interface customization
interface = "Interfaccia";

// UI customization: one item row will stands on one line (synonym: Inlined)
interface.compact = "UI: Compatta";

// UI customization: each row of the list will be bigger
interface.expandList = "UI: espandi elenchi";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Solo un'opzione dell'interfaccia utente per una più semplice gestione degli elenchi.";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "Aggiungi scorciatoie (in basso)...";

// Interface option (main base color)
interface.colorBase = "Colori di base";
// Interface option (accent widget color)
interface.colorSelect = "Colore widget";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Pannelli trasparenti";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Intensità sfocatura";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Colore pannelli";

// Interface color style
interface.preset.title = "Preset";

// Reset interface settings
interface.resetAll = "Ripristina stile";
interface.resetAll.confirm = "Ripristinare le impostazioni dell'interfaccia?";
// help popup when hovering
interface.hoverHelp = "Finestra di aiuto al passaggio del mouse";
// Interface option (main base color)
interface.iconSupport = "Pulsante ad alto contrasto";
interface.iconSupport.help = "Uno stile alternativo per i pulsanti che li rende più visibili quando sono abilitati.

Se impostato su Auto, Nomad utilizzerà questa modalità quando il contrasto dei colori dell'interfaccia tra abilitato/disabilitato è basso.";
// Interface customization
interface.flipTop = "Inverti barra superiore";
// Interface customization
interface.flipBottom = "Inverti barra inferiore";
// Interface customization
interface.flipMiddle = "Inverti barre laterali";
// list of tools
interface.toolbox = "Casella strumenti";
// hide toolbox by default
interface.toolbox.hide = "Nascosto";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.columns = "Colonnes";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.rows = "Righe";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Ripristina ordine";
// Colored text and icon
interface.toolbox.color = "Colorato";
// Scale the interface
interface.scale = "Scala complessiva";
// Spacing between widgets
interface.cursorStep = "Spaziatura verticale";
// Width of the interface panels
interface.panelWidth = "Larghezza pannelli";
// Size of fonts
interface.fontScale = "Dimensione font";
// Inset
interface.inset.title = "Spostamenti dei bordi";
interface.inset.title.help = "È possibile modificare questi valori solo se si riscontrano problemi nell'interazione con i pulsanti ai bordi dello schermo.

Se il cursore è disabilitato, Nomad utilizzerà i valori dell'area sicura restituiti dal dispositivo stesso.";

// (see Glossary for Layer)
layer = "Livello";
layers.syncTransform = "Sincronizza trasformazione";
layers.syncTransform.help = "If enabled, all the unselected layers will be adjusted depending on the transform rotation, scale and skew.

Disable this option if the other layers are meant to be used without the new transform that you are applying.

When set on auto, only the visible layers will be adjusted.";
// (see Glossary for Layer)
layers.lock = "Conserva i dettagli dei livelli superiori";
// (see Glossary for Layer)
layers.lock.yes = "Bloccare i livelli superiori?";
// (see Glossary for Layer)
layers.lock.warning = "Durante la scultura, la deformazione proveniente dai livelli superiori verrà ignorata.

Tuttavia i dettagli di questi livelli saranno ancora visibili.

Questa opzione funziona solo se i livelli superiori hanno dettagli in scala relativamente ridotta.";
// (see Glossary for Layer)
layers.addLayer = "Aggiungi livello";
// (see Glossary for Layer)
layer.factors = "Fattori canale";
// (see Glossary for Layer)
layer.factor = "Fattore";
// (see Glossary for Layer)
layer.offset = "Spostamento";
// Layer blend mode
layer.blendMode = "Fusione";
// (see Glossary for Layer)
layer.base = "Base";
layer.base.nothing = "Niente da estrarre!";
layer.base.background = "Materiale di sfondo";
layer.base.background.help = "Se attivo, verranno estratti solo i valori del materiale che differiscono dal materiale di sfondo.";
// (see Glossary for Layer)
layers.title = "Livelli";
// (see Glossary for Layer)
layers.title.help = "I livelli possono registrare dipinti e spostamenti di posizione; può essere utile per un flusso di lavoro non lineare.
Per esempio, sperimentando diverse espressioni facciali senza fare affidamento sui passaggi della cronologia per annullare le modifiche.

Per i dati di dipinti, i livelli sono ordinati dall'alto verso il basso; quindi i livelli in alto maschereranno quelli inferiori.

Si può cancellare parte del livello (e quindi l'influenza del livello) utilizzando lo strumento `DelLayer`.";
layers.primitive = "I livelli non sono disponibili per le primitive.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "Nessuno";

light = "Luce";
lights = "Luci";
// Intensity of light
light.intensity = "Intensità";
// Color of light
light.color = "Colore";
// Kelvin (the temperature unit)
light.kelvin = "Kelvin";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "Temperatura";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Collegamento";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Fisso";
// The light will move along the camera
light.attachment.camera = "Fotocamera";
light.attachment.help = "• Fisso
L'orientamento della luce non cambierà.

• Telecamera
L'orientamento della luce dipende dalla visuale della telecamera.";
// Light type (directional, spot, point)
light.type = "Tipo";
// Directional light (synonym: sun light)
light.type.directional = "Direzionale";
light.type.sun = "Sole";
// Directional light (synonym: sun light)
light.type.environment = "Ambiente";
light.type.hdri = "HDRI";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Spot";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Puntiforme";
// For directional light (angle jitter)
light.angle = "Angolo";
// For point/spot light (offset jitter)
light.size = "Dimensioni";
// Cone angle for spot angles
light.spot.angle = "Angolo del cono";
// Softness of the spot light
light.spot.softness = "Morbidezza";
// Position of the light
light.position = "Posizione";
// Enable or disable shadows for a light
light.shadow.cast = "Ombra";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "La luce puntiforme supporta solo le ombre dello spazio dello schermo.";
light.shadow.type = "Tipo di ombra";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "Shadow map";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "Spazio dello schermo";
light.shadow.type.screenspace.help = "Funzionalità sperimentale, potrebbe essere rimossa in una versione futura.

Questa opzione è pensata per essere utilizzata con la funzione morbidezza ombra.";
// Adjustment to fix artefacts
light.shadow.bias = "Bias";
// How blurry the shadow is
light.shadow.softness = "Morbidezza";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "Di contatto";
light.contact.help = "Se si seleziona auto, solo la luce più dominante avrà un'ombreggiatura di contatto.";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "Tolleranza";
// Activated the light
light.visible = "Mostra";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Ricentra";

// Object's material
material = "Materiale";
// See glossary
material.pbrRoughnessMetalness.warning = "Rugosità e metallicità richiedono la modalità di shading PBR.";
// See glossary
material.pbrReflectance.warning = "La riflettanza richiede la modalità di shading PBR.";
// See glossary
material.pbrRefraction.warning = "La rifrazione richiede la modalità di shading PBR.";
// See glossary
material.pbrSubsurface.warning = "La dispersione luminosa in profondità richiede la modalità di shading PBR.";
// Value that says how much light will change direction when hitting the surface
material.ior = "Indice di rifrazione";
// an object-level value that overrides the roughness interior/surface of the mesh
material.paintingOverride = "Sovrascrivi dipinti";
// The roughness in the inside is turbidity
material.paintingOverride.help = "Ci sono due rugosità in gioco, quella che guida la superficie e quella all'interno.

Tuttavia esiste una sola rugosità verniciabile, quindi le due rugosità hanno gli stessi valori.";
// Glossiness is simply the opposite of roughness
material.refraction.surface = "Superficie";
// Synonym: turbidity
material.refraction.interior = "Interna";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Dipinti lucida";
material.paintGlossy.help = "Dipingerà l'oggetto con una rugosità e una metallicità pari a 0, consentendo così una rifrazione intensa.

Ciò equivale ad andare nel menu dipinti e usare la funzione Dipingi tutto con colore disabilitato.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Assorbimento";
material.absorptionEnable.help = "Simula la luce che viene assorbita quando viaggia attraverso il volume.

Le parti sottili risulteranno luminose in quanto lasciano passare più luce, mentre le aree spesse saranno più scure.

L'effetto dipende fortemente dalla forma dell'oggetto, viene utilizzata solo un'approssimazione dello spessore dell'oggetto.";
material.absorptionFactor = "Fattore";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "Profondità";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "Traslucenza";
material.translucency.help = "Occorre avere una luce che proietti ombre per vedere la traslucenza.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Opacità";
// Fully opaque material
material.type.opaque = "Opaco";
// See glossary
material.type.subsurface = "Subsurface";
material.type.subsurface.help = "Per ottenere il miglior risultato, puoi passare alla modalità di shading PBR e utilizzare almeno una luce direzionale, idealmente in un ambiente poco luminoso.";
// Transparency mode, alpha blending
material.type.blending = "Fusione";
material.type.blending.help = "Può rendere l'oggetto semitrasparente modificando il valore di opacità.

Si noti che, a causa dei vincoli in tempo reale, si possono avere artefatti visivi evidenti se l'oggetto ha una forma complessa.";
// Transparency mode
material.type.additive = "Additivo";
material.type.additive.help = "Può rendere l'oggetto semitrasparente modificando il valore di opacità.

Questo metodo tende a produrre meno artefatti rispetto al metodo di fusione, ma l'oggetto sarà più luminoso.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Dithering";
material.type.dithering.help = "Può rendere l'oggetto semitrasparente scartando alcuni pixel in modo casuale.";
// Simulate glass-like material
material.type.refraction = "Rifrazione";
material.type.refraction.help = "Questa modalità può essere utilizzata per simulare materiale in vetro.

A causa dei vincoli di tempo reale, l'autorifrazione o la rifrazione multistrato sono limitate.";
material.castShadows = "Proietta ombre";
material.receiveShadows = "Ricevi ombre";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Sempre non illuminato";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Culling inverso";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Riflettanza";
material.reflectance.help = "Controlla la quantità di riflessione che il materiale riceve per i materiali non metallici.

Nella maggior parte dei casi, si dovrebbe utilizzare il valore predefinito (che corrisponde al 4% di luce riflessa ad angolo normale).";
// Material preview in the viewport
material.preview = "Anteprima colore del materiale";
material.preview.help = "When you modify a material, a preview will be displayed in the viewport on the selected object.

The preview is shown while you interact with the color, roughness, metalness, opacity and intensity sliders.";
// Menu name
menu.files = "File";
// Menu name
menu.scene = "Scena";
// Menu name
menu.multires = "Multires";
// Menu name
menu.voxel = "Voxel";
// Menu name
menu.dynamic = "DynTopo";
// Menu name (Synonym: Misc, Other)
menu.topology = "Varie";
// Menu name
menu.primitive = "Primitiva";
// Menu name
menu.render = "Renderizza";
// Menu name
menu.material = "Materiale";
// Menu name
menu.postprocess = "Post processing";
// Menu name
menu.camera = "Fotocamera";
// Menu name
menu.background = "Sfondo";
// Menu name
menu.tool = "Strumento";
// Menu name
menu.stroke = "Tratto";
// Menu name
menu.alpha = "Alfa";
// Menu name
menu.filter = "Filtro";
// Menu name
menu.falloff = "Decadimento";
// Menu name
menu.paint = "Dipinti";
// Menu name
menu.symmetry = "Simmetria";
// Menu name
menu.operation = "Azione";
// Menu name (pencil pressure)
menu.pressure = "Pressione";
// Menu name
menu.gesture = "Gesto";
// Menu name
menu.layers = "Livelli";
// Menu name
menu.settings = "Impostazioni";
// Menu name
menu.interface = "Interfaccia";
// Menu name
menu.bindings = "Collegamenti";
// Menu name
menu.history = "Cronologia";
// Menu name
menu.historySettings = "Impostazioni";
// Menu name
menu.about = "Info";
// Menu name
menu.debug = "Debug";

// Operation on the object (action)
mesh.holes = "Aperture";
// If the object has holes, the algorithm will close them
mesh.holes.close = "Chiudi aperture";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holes.detail = "Dettaglio";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Separa";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "I livelli, la dipinti e la multirisoluzione andranno persi.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Risoluzione";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Forza cubico";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Converti";
// Static object means "static topology"
mesh.static = "Trama";
// See glossary
mesh.multires = "Multirisoluzione";
// Dynamic topology
mesh.dynamic = "DynTopo";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Materiale globale";
paint.useGlobal.help = "Se questa opzione è attivata, il materiale selezionato sarà lo stesso degli altri strumenti.

Si noti che tiene conto solo delle impostazioni di rugosità, metallicità e colore.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Dipinti a tratto";
// If true save the textures data into
paint.preset.embed = "Incorpora texture";
paint.preset.embed.help = "The textures can be found in the Nomad textures/ folder.
The material presets can be found in the Nomad materials/ folder.

When this option is off, the material preset only reference the texture inside the textures/ folder.

You can enable this option to make a copy of the textures inside the material preset.
It can be useful if you want to share a textured preset without providing the associated textures.";
paint.preset.embed.apply = "Apply to all materials";
// Factor/Opacity of paint tool
paint.intensity = "Intensità dipinti";
// Apply the paint on the object
paint.paintAll = "Dipingi tutto";
paint.paintAll.help = "Applica il materiale corrente all'oggetto.";
paint.paintAll.help.mask = "L'area mascherata non sarà interessata.";
paint.paintAll.help.hide = "L'area nascosta non sarà interessata.";
paint.paintAll.help.opacity = "Utilizza il fattore di dipinti dello strumento sopra.";
paint.paintAll.help.layer = "L'area non dipinta di un . non sarà interessata.";
paint.strokePainting.title = "Dipinti";
// Brush stroke texture
paint.texture.warningEnable = "La dipinti a tratto deve essere abilitata per consentire la proiezione della trama (casella di controllo in alto)!";
paint.texture.warningIgnored = "Lo strumento attuale non può utilizzare texture!";
// use stencil mode
paint.stencil = "Stencil";
// Inherit stroke falloff option for the painting
paint.tool.help = "Utilizza l'alpha dello strumento, l'attenuazione e il randomizzatore per modulare l'intensità del tratto di pittura.

Queste opzioni vengono ignorate per la funzione di pittura completa, ma l'alpha è preso in considerazione per la variante triplanar.";
// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "Nuovo nome";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "Nuovo valore";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "Nuovo colore (formato hex)";

// Post process effect
postprocess = "Post processing";
// Quality vs performance
postprocess.quality = "Qualità";
postprocess.quality.help = "Attivare queste opzioni per migliorare la qualità a scapito delle prestazioni.";
// More samples means better quality but slower performance
postprocess.maxSamples = "Max campioni";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Piena risoluzione";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "Campionamento massimo di fotogrammi";
postprocess.accumulateCount.help = "Numero massimo di fotogrammi da accumulare prima che il rendering si interrompa.

Quando il rendering si interrompe, Nomad non farà nulla, aumentando così l'autonomia della batteria.

Molte funzionalità di rendering traggono vantaggio dall'accumulo di frame, in particolare:
• Ombre morbide
• Illuminazione globale
• Riflessione (SSR)
• Occlusione ambientale
• Dispersione luminosa in profondità
• Profondità di campo

Un numero elevato di fotogrammi è principalmente necessario per Ombre morbide e Illuminazione globale.
Nomad può interrompere il rendering prima se si disabilitano le funzionalità summenzionate.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Risoluzione rendering";
postprocess.renderRatio.warning = "Sostituito dall'effetto Pixel Art.";
postprocess.renderRatio.help = "Questa opzione influisce molto sulle prestazioni.
Si consiglia di mantenere un valore inferiore a x1.25.

Questa opzione non è salvata nelle impostazioni.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "Anti-aliasing (TAA)";
postprocess.taa.help = "Riduce lo sfarfallio quando si sposta la telecamera.";
// Ditherhing pixel
postprocess.dithering = "Dithering";
postprocess.dithering.help = "Dither pixels to reduce banding artefacts.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "Riflessione (SSR)";
postprocess.ssr.warning = "SSR richiede la modalità di shading PBR.";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "Illuminazione globale (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "Tolleranza";
postprocess.ssgi.warning = "SSGI richiede la modalità di shading PBR.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "Occlusione ambientale";
// How far the effect spreads
postprocess.ssao.radius = "Dimensioni";
// How strong the effect is
postprocess.ssao.factor = "Intensità";
// Adjustment to fix artefacts
postprocess.ssao.bias = "Distorsione curvatura";
postprocess.ssao.bias.help = "La sensibilità dell'effetto dipende dalla curvatura della superficie.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "Profondità di campo";
// The blur factor behind the focused point
postprocess.dof.blurFar = "Sfocatura lontana";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "Sfocatura vicina";
postprocess.dof.focusTip = "Tocca un oggetto per cambiare il punto di messa a fuoco.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "Bagliore diffuso";
// Intensity of the effect
postprocess.bloom.intensity = "Intensità";
// How far the effect spreads
postprocess.bloom.radius = "Raggio";
postprocess.bloom.radius.help = "Il grado di diffusione del bagliore.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "Soglia";
postprocess.bloom.threshold.help = "Soglia di luminosità per decidere se un pixel emetterà bagliore o no.
Se il valore è pari a 0, tutto riceverà un bagliore diffuso.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "Mappatura dei toni";
postprocess.tone.exposure = "Esposizione";
postprocess.tone.contrast = "Contrasto";
postprocess.tone.saturation = "Saturazione";
postprocess.tone.hue = "Tonalità";
// No tonemapping operator is used
postprocess.tone.mapping.none = "Nessuno";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "Neutrale";
// Color curves
postprocess.curve = "Gradazione colore";
// Curve for pixel luminance
postprocess.curve.luminance = "Principale";
postprocess.curve.red = "Rosso";
postprocess.curve.green = "Verde";
postprocess.curve.blue = "Blu";
// Reset color grading curves
postprocess.curve.resetAll = "Ripristina tutto";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "Aberrazione cromatica";
postprocess.chromatic.factor = "Intensità";
// Darking on the edges
postprocess.vignette = "Vignettatura";
// How far the effect spreads
postprocess.vignette.size = "Dimensioni";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "Durezza";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "Nitidezza";
postprocess.sharpness.factor = "Intensità";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "Grana";
postprocess.grain.factor = "Intensità";
// Accentuate the edges of the model
postprocess.curvature = "Curvatura";
// main strength of curvatre
postprocess.curvature.factor = "Fattore";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "Cavità";
// Color/Strength of convex curvature
postprocess.curvature.bump = "Rilievo";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "Pixel Art";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "Consenti campionamento fotogrammi";
// Simulate scanline rendering (horizontal line)
postprocess.scanline = "Linea di scansione";
postprocess.scanline.factor = "Fattore";
// Spacing between lines
postprocess.scanline.spacing = "Spaziatura";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Primitiva";
primitive.box = "Parallelepipedo";
primitive.sphereCube = "Sfera";
primitive.sphereUV = "Sfera UV";
primitive.icosahedron = "Icosaedro";
primitive.cylinder = "Cilindro";
primitive.cone = "Cono";
primitive.torus = "Toro";
primitive.lathe = "Lathe";
primitive.tube = "Tubo";
primitive.plane = "Piano";
primitive.triplanar = "Triplanare";
primitive.faceXYZ = "Lato XYZ";
primitive.faceXYZ.help = "Mesh di base con mappa UV srotolata fornita da https://texturing.xyz/";
primitive.needValidate = "Le primitive devono essere convalidate!";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Modifica";
primitive.edit.help = "Consente la modifica 3D nella finestra.

È possibile disattivare questa funzione se si desidera interagire con il Gizmo o lo strumento Trasforma senza modificare la primitiva.";

// Primitive configuration
primitive.mainConfig = "Parametro";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Topologia";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Geometria";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Convalida";
// Maximum number of faces of the primitives
primitive.maxFaces = "Lati massimi";
primitive.maxFaces.help = "Il numero massimo di lati che può avere una primitiva.

Questo limite è attivo solo finché la primitiva non è convalidata, dopodiché tale contromisura viene meno.";
// Synonym: Flat subdivision
primitive.linear = "Suddivisione lineare";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Post-suddivisione";

// Radius (of a sphere, torus, etc)
primitive.radius = "Raggio";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radius.sync = "Stesso raggio";
primitive.radius.start = "Inizio raggio";
primitive.radius.end = "Fine raggio";
// Size (of cube x dimension)
primitive.size = "Dimensioni";
primitive.sizeX = "Dimensione X";
primitive.sizeY = "Dimensione Y";
primitive.sizeZ = "Dimensione Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "Divisione";
primitive.divisionX = "Divisione X";
primitive.divisionY = "Divisione Y";
primitive.divisionZ = "Divisione Z";
// Angle of torus, etc
primitive.angleX = "Angolo X";
primitive.angleY = "Angolo Y";
primitive.angleZ = "Angolo Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Densità costante";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Proietta su sfera";
primitive.projectOnSphere.help = "Aggancia i punti su una sfera perfetta.";

// triplanar
primitive.triplanar.title = "Triplanare";
primitive.triplanar.title.help = "Triplanare utilizza le informazioni di maschera di 3 piani per riempire una griglia di voxel che viene poi poligonizzata.

Se si interagisce con i cursori di divisione o di dimensione, le informazioni di dipinti si resettano (la levigatezza è ok).

Probabilmente si dovrebbe disabilitare la simmetria perché potrebbe non funzionare come ci si aspetterebbe.

È possibile utilizzare l'opzione `Topologicamente collegato` nel pannello delle maschera per dipingere un piano che influisca sugli altri piani.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanar.sameSize = "Stessa dimensione (cubo)";
primitive.triplanar.polish = "Levigatezza";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanar.resetMask = "Ripristina maschera";
// One side of a cube (the back plane)
primitive.isolate.back = "Indietro";
// One side of a cube (the right plane)
primitive.isolate.right = "Destra";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Basso";
// Plane
primitive.planeSameSize = "Stessa dimensione (quadrato)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "Disco";
// Box
primitive.boxRegular = "Stessa dimensione (cubo)";
// Torus
primitive.torus.radiusOuter = "Raggio esterno";
primitive.torus.radiusInner = "Raggio interno";
primitive.torus.angle = "Angolo";
primitive.torus.angleOffset = "Spostamento angolo";
// Cylinder
primitive.cylinder.height = "Altezza";
// Cone
primitive.cone.radius = "Raggio";
primitive.cone.height = "Altezza";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Apertura";
// Make a hole in the primitive to make it hollow
primitive.hasHole = "Ha un'apertura";
// Curve profile (synonym: profile, curve)
primitive.profile = "Profilo";
primitive.profile.viewport = "Mostra nel viewport";
// If the revolution surface has caps (E.g: cylinder)
primitive.cap = "Cappello";

// Singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "Ripetitore";
// All the new items will be inserted inside the bound rather than outside
repeater.array.fitInside = "Adatta all'interno";
// The object will follow the curve
repeater.curve.align = "Allinea";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Importa...";
// iOS Photos gallery
resource.import.ios.photos = "Foto";
// iOS Files App
resource.import.ios.files = "File";

scene.title = "Scena";
scene.title.help = "Quando si utilizzano i pulsanti di selezione/visibilità, tenere premuto e trascinare il dito per selezionare facilmente altri oggetti.

È anche possibile premere a lungo i pulsanti di selezione/visibilità per influenzare anche gli elementi figli.";
// The view will focus on the item when we click on it
scene.focus = "UI: Focalizzare sull'oggetto con doppio tocco";
// Add new object on gizmo position
scene.addOnGizmo = "Sul gizmo";
scene.addOnGizmo.help = "Muovi il nodo sulla posizione del gizmo (se lo strumento gizmo è selezionato)";
// Select the gizmo tool after adding a new object
scene.addSelectGizmo = "Seleziona gizmo";
scene.addSelectGizmo.help = "Seleziona lo strumento gizmo quando aggiungi un nuovo nodo";
// Icon size in pixel (min/max)
scene.iconSize = "Dimensione icona";
// Min size of icon
scene.iconSize.min = "Min";
// Max size of icon
scene.iconSize.max = "Max";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "Linee gerarchiche";
scene.showHierarchy.help = "Mostra una linea tra il genitore e i suoi figli nel viewport.";
scene.showHierarchyNomadPivot = "Usa pivot Nomad";
scene.showHierarchyNomadPivot.help = "Il pivot Nomad è il pivot utilizzato dagli strumenti Trasforma e Gizmo.

Se questa opzione è disabilitata, verrà utilizzato il pivot di base naturale.
In alcuni casi questo pivot di base può essere lontano dal centro dell'oggetto stesso!";
// The view will focus on the item when we click on it
scene.syncVisible = "Sincronizza visibilità";
scene.syncVisible.help = "Quando attivato, utilizzare l'icona visibile (occhio) influenzerà tutti gli elementi selezionati.";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "Unisci";
// Group the selected object with a new created Empty Node as a parent
scene.group = "Gruppo";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "Scollega";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "Specchio";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "Curva";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "Array";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "Radiale";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "Ripetitori";
scene.repeaters.help = "Nodi ripetitori che creano istanze di qualsiasi geometria sottostante nella gerarchia della scena.";
// Validate button
scene.validateGroup = "Convalida";
// Keep instances in the scene
scene.validateGroup.keepInstances = "Mantieni istanze";
// If we should join children
scene.validateGroup.joinChildren = "Unisci figli";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Unione voxel";
scene.voxelResolution = "Risoluzione";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Sottrazione: Nascondi oggetto";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Intersezione: tutti gli oggetti nascosti";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "Nessun oggetto selezionato, seleziona almeno un oggetto.";
// Need to select one object only
scene.noneButNeedOne = "Nessun oggetto selezionato, seleziona un oggetto.";
// Need to select one object only
scene.onlyOneObject = "Sono selezionati più oggetti, seleziona un solo oggetto.";
// Boolean operation
scene.boolean = "Booleano";
scene.boolean.help = "Unisci, sottrai o interseca gli oggetti eseguendo un'operazione booleana.

L'operazione può fallire se alcuni oggetti non sono manifold o non sono impermeabili.

Se l'operazione booleana fallisce, puoi sempre utilizzare il voxel remesher sull'oggetto problematico per garantire che sia un manifold impermeabile.";
// Weld intersection
scene.boolean.mergeIntersection = "Saldare intersezione";

// General scene display settings
settings.display.title = "Impostazioni visualizzazione";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Wireframe";
// Display the material texture
settings.debugChannel = "Mostra Texture";
// Display the material texture in the background
settings.debugChannel.onBackground = "In Sfondo";
// Display the material texture on the mesh
settings.debugChannel.onMesh = "Sulla mesh";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Dai due lati";
settings.twoSided.help = "Le facce saranno visibili da entrambi i lati.";
// If we colorize the inverted side of faces
settings.backface.color = "Colore lato posteriore";
// Color of the inverted side of faces
settings.backface.colored = "Lato posteriore colorato";
// Outline (contour highlight around the selected object)
settings.outline = "Bordato";
// Outline (contour highlight around the selected object)
settings.outline.help = "Gli oggetti selezionati verranno contornati.";
settings.outline.thickness = "Spessore";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Cubo a scatto";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "Basso";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "Sinistra";
// Flip the camera (rotate 180° to see the other side)
settings.snapCube.flip = "Ribalta 180°";
settings.snapCube.flip.help = "Ribalta la vista se la vista è già agganciata.";
// Alignment (can be auto/on/off)
settings.snapCube.align = "Restringi allineamento";
settings.snapCube.align.help = "Allinea le viste agli assi del mondo. Se abilitato, sono possibili solo 6 viste di aggancio.

In Auto, la restrizione avverrà solo se la camera è in modalità Orbita.";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Statistiche";
settings.stats.right = "Destra";
settings.stats.all = "Mostra l'intera scena";
// Grid
settings.grid = "Griglia";
// Cursor
settings.cursor.title = "Cursore";
settings.cursor.whileSculpting = "Mostra il cerchio mentre scolpisci";
// A small indicator dot
settings.cursor.showDot = "Mostra puntino";
settings.cursor.showDot.help = "Il puntino può apparire come punto pivot della telecamera o quando stai scolpendo.";
settings.cursor.showRope = "Mostra stabilizzatore di corda";
// indicator
settings.indicator.title = "Indicatore";
settings.indicator.title.help = "Mostra un indicatore visivo (tutorial, cattura schermo, ecc.).";
settings.indicator.size = "Dimensioni";
// Highlight (the object glows when we select it)
settings.highlight.selection = "Evidenzia selezione";
// Highlight settings
settings.highlight = "Evidenziazione";
settings.highlight.duration = "Durata";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Scurisci gli oggetti non selezionati";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Ombreggiatura uniforme";
// Experimental feature
settings.partialDraw = "Disegno parziale";
settings.partialDraw.help = "Funzionalità sperimentale!

Da usarsi se si scolpisce una parte relativamente piccola di una mesh ad alto numero di poligoni.

Dovrebbe rendere la scultura più fluida, ma non si deve abilitare il wireframe!

Inoltre potrebbe aggiungere artefatti visivi durante le pennellate";
settings.partialDraw.warning = "Non dimenticarti di disattivare questa opzione se gli artefatti visivi sono troppo fastidiosi!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Mostra dipinti";
// Show and use the masking on the mesh
settings.showMasking = "Mostra maschera";
// Disable this option to force show the hidden faces
settings.showDiscard = "Usa Nascondi";
// Show icon on the canvas
settings.icon = "Icona";
// Show icons on the canvas
settings.icons = "Icone";
// Tooltip
settings.icons.help = "Visualizza un'icona sull'area di disegno per poterla selezionare e modificare direttamente.";
// Hole filling settings
settings.hole = "Riempimento aperture";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Riempi non-manifold";
settings.hole.nonManifold.help = "Tenta di riempire l'apertura non-manifold.
Questa opzione non viene salvata nelle impostazioni.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Numero massimo di vertici";
settings.multires.maxVertices.help = "Nomad non esegue il controllo della memoria prima della suddivisione; un numero elevato di poligoni può facilmente causare dei crash.";
settings.multires.lowResVertices = "Soglia di bassa risoluzione";
settings.multires.lowResVertices.help = "Quando si sposta la telecamera, è possibile visualizzare una risoluzione inferiore della mesh.

È possibile aumentare questo valore se si desidera visualizzare una risoluzione maggiore della mesh.";

// The main rendering mode
shading = "Shading";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "Illuminato (PBR)";
shading.pbr.help = "In questa modalità è possibile aggiungere luci (con ombre) e un ambiente HDR.

È inoltre possibile dipingere la metallicità e la rugosità, consentendo così un controllo più fine sull'aspetto del materiale.";
// Fast rendering mode for sculpting purpose
shading.matcap = "MatCap";
shading.matcap.help = "Sta per MATerial CAPture; MatCap si occupa delle informazioni sull'illuminazione e sui materiali in un'unica immagine.

Si tratta di una modalità di rendering veloce, adatta soprattutto alla scultura grezza.";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "Non illuminato";
shading.unlit.help = "Modalità di shading a tinta unita, senza illuminazione.";
// Helper rendering mode that display solid colors
shading.object = "Oggetto ID";
shading.object.help = "Modalità di rendering non illuminata, in cui a ogni oggetto viene assegnato un colore casuale.

Questa modalità è utile soprattutto quando si hanno molti oggetti nella scena.";
// Helper rendering mode that display solid colors
shading.instance = "Crea istanza ID";
shading.instance.help = "Uguale all'ID Oggetto, ma le istanze avranno lo stesso colore.";
// Helper rendering mode that display solid colors
shading.material = "";
shading.material.help = "";
// Randomize colors
shading.id.randomize = "Randomizza ID";
shading.textures = "Usa texture";
shading.textures.help = "Al momento non è possibile creare o modificare le texture all'interno di Nomad.

Ma se si importa un file con texture, dovrebbe funzionare.

• Texture supportate
Opacità: Illuminato, MatCap, Non illuminato
Normale: Illuminato, MatCap
Colore: illuminato, Non illuminato
Emissivo: Illuminato
Rugosità: Illuminato
Metallicità: Illuminato";
// Lights
shading.lights = "Luci";
shading.lights.addLight = "Aggiungi luce";
shading.lights.warning = "Le luci richiedono la modalità di shading PBR.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Ambiente";
shading.environment.import = "Importa HDR";
shading.environment.exposure = "Esposizione";
shading.environment.backgroundBlur = "Sfoca (sfondo)";
shading.environment.rotation = "Rotazione";
shading.environment.rotation.help = "È possibile ruotare l'ambiente trascinando 3 dita in orizzontale sulla finestra di visualizzazione.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "Collegato alla telecamera";
shading.environment.attachedToCamera.help = "Collega l'ambiente alla telecamera.

Ciò costringerà l'illuminazione a essere coerente, il che può essere utile per la scultura.";
shading.matcap.rotation = "Rotazione";
shading.matcap.rotation.help = "È possibile ruotare MatCap trascinando 3 dita in orizzontale sulla finestra di visualizzazione.";
shading.matcap.global = "Usa MatCap globale";
shading.matcap.global.help = "Deselezionare questa opzione per utilizzare una MatCap diversa per questa particolare mesh.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible = "Maschera";
shortcut.solo = "Isolato";
shortcut.xray = "Raggi X";
shortcut.voxelRemesh = "Voxel";
shortcut.wireframe = "Wire";
shortcut.cameraReset = "Ripristina";
shortcut.cameraSnap = "Aggancio";
shortcut.lockSelection = "Blocca";
shortcut.lockSelection.help = "Quando è abilitato, non è possibile modificare la selezione toccando una mesh.";
shortcut.perspective = "Persp";
shortcut.grid = "Griglia";

// Memory taken by the scene
stat.ramScene = "Scena";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Vram Scena";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "Vram Rendering";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "Vram Texture";
// Memory taken by the undo/redo history
stat.ramHistory = "Cronologia";
// Memory taken by other stuffs
stat.ramOther = "Altro";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "Memoria utilizzata";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "Memoria libera";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "Utilizzata: $0";
stat.free = "Libera: $0";
stat.faces = "Lati";
stat.triangles = "Triangoli";
stat.vertices = "Vertici";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Quadrilateri";
stat.vertex = "Vertice";
stat.scene.face = "Lati scena";
stat.scene.vertex = "Vertici scena";

// Brush stroke
stroke = "Tratto";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "Raggio dello spazio mondo";
// The settings is shared among every tools
stroke.useWorldRadius.help = "Questo è condiviso da tutti gli strumenti.";
// Share the radius value among every tools.
stroke.useShareRadius = "Condividi raggio";
stroke.useShareRadius.help = "Condivide il valore del raggio tra tutti gli strumenti.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.spacing = "Spaziatura tratto";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.spacing.adjust = "Regola l'intensità della spaziatura";
stroke.minSpacingAdjustIntensity.help = "Regola l'intensità del pennello per garantire una deformazione uniforme in base alla spaziatura del tratto.";
stroke.minSpacing.help = "Spaziatura tra le pennellate, rispetto al raggio dell'utensile.

Un valore più basso consente una pennellata più fluida, ma le prestazioni si riducono.";
// Brush stroke smoothing
stroke.lazySmooth = "Levigatura tratto";
stroke.lazySmooth.help = "Calcola la media di più posizioni del puntatore per ottenere un tratto più uniforme.

Con valori elevati, il tratto rimarrà indietro rispetto al puntatore, ma alla fine lo raggiungerà.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Stabilizzatore di corda ritardato";
stroke.lazyRadius.help = "I tratti rimarranno indietro rispetto alla posizione del puntatore secondo una certa distanza.

Questo può essere usato per disegnare linee morbide.";
// It is not a per-tool settings
stroke.globalSettings = "Questa è un'impostazione globale";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Aggancia raggio";
stroke.snapRadius.help = "Aggancia il tratto se il puntatore si trova vicino all'ultimo tratto registrato.

Questo può essere utile quando si disegnano lunghe linee continue, mentre si fanno pause frequenti.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Spostamento tratto";
stroke.sculptOffset.help = "Applica uno spostamento costante al tratto.

Questa opzione è utile quando si usano le dita su schermi piccoli, in modo che il dito non copra il tratto.";
stroke.accumulate = "Accumulazione tratto";
stroke.accumulate.help = "Se questa opzione è attivata, non c'è limite alla quantità di materia che si può aggiungere/rimuovere per ogni tratto.";
// The tool can use DynTopo
stroke.useDynamic = "Permetti topologia dinamica";
// Only sculpt the part that are linked topologically
stroke.connect = "Topologia collegata";
stroke.connect.help = "Questa opzione scolpisce solo i vertici collegati alla superficie selezionata.

Questa opzione si usa tipicamente per lo strumento Sposta, per esempio se si vuole spostare esclusivamente una parte che si autointerseca con un'altra parte.";
stroke.connect.short = "Collegata";
// sculpt on hide or mask
stroke.protect = "Proteggi l'area";
stroke.protect.hide.help = "Quando impostato su auto, i volti nascosti verranno modificati se il reticolo sui volti nascosti è visibile (vedi menu reticolo).";
// Only sculpt the vertex that points toward the camera
stroke.culling = "Solo vertice frontale";
stroke.culling.help = "Questa opzione ignora i vertici rivolti verso il retro.

Può essere utile se si vuole dipingere una parte di una geometria sottile senza influenzare l'altro lato.

Funziona anche per la scultura, ma si potrebbero generare alcuni artefatti.";
// Infinite depth, move everything under the circle, disregarding depth
stroke.silhouette = "Silhouette";
stroke.silhouette.view = "Vista";
stroke.silhouette.snapped = "Se agganciato";
stroke.silhouette.closest = "Più vicino";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.sameSide = "Solo vertice dello stesso lato";
stroke.sameSide.help = "Ignora i vertici che puntano nella direzione opposta alla deformazione.";
stroke.onlyLasso = "Impostazioni attive solo per lo strumento lazo.";

// Here sampling refers to the app gathering information under the mouse
stroke.area = "Campionamento area";
stroke.area.help = "Alcuni pennelli o opzioni di tratto richiedono un piano normale alla superficie per funzionare.
Puoi controllare come calcolare questo piano medio impostando l'area di campionamento come rapporto del raggio dello strumento.

Al 100%, ogni punto all'interno del cerchio di selezione viene preso in considerazione.
Al 0%, viene preso in considerazione solo il vertice o il triangolo più vicino.";
// Sampling radius size (percent)
stroke.area.normal.radius = "Raggio normale";
// Sampling radius size (percent)
stroke.area.point.radius = "Raggio posizione";
// Sampling averaging
stroke.area.normal.average = "Media normale";
// Sampling averaging
stroke.area.point.average = "Media posizione";
// Keep sharp edges
stroke.keepSharp = "Mantieni bordi affilati";
stroke.keepSharp.help = "
Filtro profondità";

// Only paint the part of the mesh above a certain height
stroke.depthFilter = "Mascheramento profondità";
stroke.depthFilter.help = "Escludi punti che sono sopra o sotto una certa distanza dal piano calcolato (Campionamento area).

Come esempio, può essere usato per dipingere rilievi o cavità.";
stroke.depthFilter.max = "Area superiore";
stroke.depthFilter.min = "Area inferiore";
stroke.depthFilter.offset = "Compensazione altezza";

// Invert the pixel (black <-> white)
stroke.alpha.invert = "Inverti pixel";
// Repeat the alpha image (pattern)
stroke.alpha.wrap = "Tiling";
// No repeat pattern
stroke.alpha.wrap.none = "Nessuno";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alpha.wrap.repeat = "Ripeti";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alpha.wrap.mirror = "Specchia";
// Tight fit when using tiling
stroke.alpha.fit = "Adatta all'interno";
stroke.alpha.fit.help = "This option is only relevant if the alpha and brushes textures are non square.

When enabled, each images will tile independently with no spacing.
You can disable this option if you want to keep the alpha and other images synchronized, in case their ratio are not the same.";
// Alpha rotation
stroke.alpha.rotation = "Rotazione";
stroke.alpha.rotation.lock.help = "Blocca l'orientamento dell'alfa.

Se la rotazione è sbloccata, l'orientamento seguirà la direzione del tratto in tempo reale.";
// Repeat the image
stroke.alpha.tiling = "Tiling";
// Scale the image (make it bigger or smaller)
stroke.alpha.scale = "Ridimensionamento";
stroke.alpha.scale.help = "Al valore minimo, il quadrato alfa si trova all'interno del raggio del cerchio dell'utensile.";
// Middle-point value at which no deformation occurs
stroke.alpha.midValue = "Valore medio";
stroke.alpha.midValue.help = "Valore medio al quale non si verifica alcuna deformazione.

(Valore medio = 0)
• Nero: nessuno spostamento
• Bianco: spostamento positivo

(Valore medio = 0.5)
• Nero: spostamento negativo
• Bianco: spostamento positivo

(Valore medio = 1)
• Nero: spostamento negativo
• Bianco: nessuno spostamento";
// Synonymous: Scatter/Jitter/Randomize
stroke.jitter = "Randomizza";
// Sculpt and paint along the brush stroke at regular spacing
stroke.type.dot = "Punto";
// Sculpt and paint along with alpha spaced by brush radius
stroke.type.roll = "Rotazione";
// Sculpt and paint with alpha projected on screen stencil
stroke.type.tile = "Piastrella";
// Sculpt and paint with alpha projected on 3 axis
stroke.type.triplanar = "Triplanare";
// Sculpt continuously
stroke.type.drag = "Trascina";
// Lock a region and move it around
stroke.type.grab = "Cattura";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.type.grabRadius = "Cattura • raggio dinamico";
// Lock a region and sculpt it by changing the tool intensity
stroke.type.grabIntensity = "Cattura • intensità dinamica";

stroke.falloffProject = "Influenza";
stroke.falloffProject.help = "• Sfera (3d)
L'influenza è calcolata prendendo la distanza dal vertice al centro del pennello.

• Cerchio (2d)
Il vertice è prima proiettato sul piano dell'area, prima di prendere la sua distanza al centro del pennello.
Questo è simile a come vengono campionate le alfa.";
stroke.falloffProject.sphere = "Sfera";
stroke.falloffProject.circle = "Cerchio";

// Symmetry
symmetry = "Simmetria";
symmetry.enable = "Abilitato";
symmetry.primitiveWarning = "La simmetria del pennello è disponibile solo per le primitive convalidate, ad eccezione di Triplanare.";
symmetry.plane.title = "Piani";
symmetry.toolIgnore = "Lo strumento attuale ignora la simmetria.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Radiale";
symmetry.radialX = "Radiale X";
symmetry.radialY = "Radiale Y";
symmetry.radialZ = "Radiale Z";
// A warning indicating that we limit the number of repetitions ($0 is a number)
symmetry.limited = "Numero di ripetizioni limitato a $0!";
// Synonym: Offset
symmetry.offset.title = "Spostamento";
symmetry.offsetX = "Spostamento X";
symmetry.offsetY = "Spostamento Y";
symmetry.offsetZ = "Spostamento Z";
// Number of clones
symmetry.count.title = "Conteggio";
symmetry.countX = "Conteggio X";
symmetry.countY = "Conteggio Y";
symmetry.countZ = "Conteggio Z";
// method
symmetry.method = "Metodo:";
symmetry.method.help = "• Locale
Il piano di simmetria si sposta lungo la mesh quando si utilizza uno degli strumenti di trasformazione (Gizmo o Trasforma).

• Mondo
Il piano di simmetria è fisso e non si sposta.";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.method.world = "Mondo";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.method.local = "Locale";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Rifletti oggetto";
// Mirror the mesh
symmetry.mirror = "Specchiamento";
symmetry.mirror.help = "Cerca di riapplicare la simmetria senza influenzare la topologia.

La simmetria radiale verrà ignorata.

Se la topologia non può essere mantenuta perché non è considerata simmetrica, si avrà la possibilità di imporre lo specchiamento (mirroring).";
symmetry.mirrorFail = "Impossibile applicare la simmetria.

Si vuole imporre la simmetria specchiando la mesh?";
symmetry.mirrorUseMasking = "Proteggi l'area mascherata";
symmetry.mirrorUseMasking.help = "Mantiene intatta l'area mascherata.

Questa opzione verrà ignorata con topologia non simmetrica (o superficie discontinua, come un paio di occhi).";
symmetry.apply = "Specchio
(mantieni la topologia)";
symmetry.splitMirror = "Dividi & Specchio
(nuova topologia)";
// Reset the symmetry plane position
symmetry.reset = "Ripristina";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Centro dell'oggetto";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "Centro del mondo";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Orientamento";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Mostra linea";
// Display the symmetry plane in 3d
symmetry.showPlane = "Mostra piano";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Modifica con Gizmo";
symmetry.edit.warning = "La modifica della simmetria è sperimentale.";
symmetry.edit.help = "È possibile impostare liberamente il piano di simmetria.

Questa funzione è un po' sperimentale e probabilmente non dovrebbe essere utilizzata.";

// Ideally <10 chars
tool.dynamic = "DynTopo";
// Ideally <10 chars (Symmetry)
tool.symmetry = "Simm";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "Specchia";
// Ideally <10 chars
tool.clay = "Argilla";
// Ideally <10 chars (Subtract)
tool.clay.sub = "Sub";
// Ideally <10 chars
tool.brush = "Pennello";
// Ideally <10 chars
tool.move = "Sposta";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "Normale";
// Ideally <10 chars
tool.drag = "Trascina";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "Morbida";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Attenua";
// Ideally <10 chars (Paint mask)
tool.mask = "Maschera";
// Ideally <10 chars
tool.mask.unmask = "Togli masch.";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "SelMasch.";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "Sfumino";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "Appiattisci";
// Ideally <10 chars (Flatten the surface, more strongly than Flatten)
tool.planar = "Planare";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Riempi";
// Ideally <10 chars (Layer brush)
tool.layer = "Livello";
// Ideally <10 chars
tool.crease = "Agg. piega";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "Rifila";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Dividi";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "Proietta";
// Ideally <10 chars
tool.inflate = "Gonfia";
// Ideally <10 chars
tool.pinch = "Pizzica";
// Ideally <10 chars
tool.nudge = "Spingi";
// Ideally <10 chars
tool.stamp = "Punto";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "DelLayer";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.select = "Seleziona";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "Gizmo";
// Ideally <10 chars
tool.gizmo.editPivot = "Pivot";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "Aggancia";
// Ideally <10 chars (Snap translation)
tool.gizmo.moveSnap = "Aggancia";
// Ideally <10 chars (Local/Relative space)
tool.gizmo.local = "Locale";
// Ideally <10 chars (Align/Snap the gizmo to world axis)
tool.gizmo.align = "Allinea";
// Ideally <10 chars (Pin the gizmo, so that it stays in place when switching between objects)
tool.gizmo.pin = "Fissa";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "Trasforma";
// Ideally <10 chars (Translate the object)
tool.transform.move = "Sposta";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "Ruota";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "Dimensione";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "Aggancia";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "Misura";
// Ideally <10 chars (Lattice, deformer)
tool.lattice = "Reticolo";
// If an option is shared among the tools
tool.all = "Tutti";
// Ideally <10 chars (Quad Remesher)
tool.remesh = "Rimesh Quadrato";
tool.remesh.guides = "Guide";
tool.remesh.density = "Densità";
tool.remesh.same = "Same";
tool.remesh.half = "Half";
// Ideally <10 chars (FaceGroup)
tool.faceGroup = "Gruppo di facce";
tool.faceGroup.autoPick = "Selezione automatica";
tool.faceGroup.flush = "Rimuovi inutilizzati";
tool.faceGroup.skip = "Ignora piccoli gruppi in base a:";
tool.faceGroup.skipFace = "Conteggio facce";
tool.faceGroup.skipFace.help = "Non creare un nuovo gruppo se il numero di facce è inferiore o uguale a questa soglia.";
tool.faceGroup.skipArea = "Area superficiale";
tool.faceGroup.skipArea.help = "Non creare un nuovo gruppo se l'area superficiale del nuovo gruppo è inferiore a questa soglia.

La soglia è data come percentuale dell'area totale dell'oggetto.";
// Ideally <10 chars (Hide)
tool.hide = "Nascondi";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "Vista";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "Lathe";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "Tubo";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "Inserisci";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "Rifletti";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "Vista";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "Lazo";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Curva";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Poligono";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Tracciato";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "Rett.";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "Ellisse";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "Linea";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Chiuso";

// Radius of the tool (size)
tool.radius = "Raggio";
// Intensity of the tool (force)
tool.intensity = "Intensità";

tool.settings = "Impostazioni";
tool.settings.none = "Questo strumento non ha impostazioni specifiche.";

tool.crease.pinchFactor = "Intensità piega";
tool.crease.offsetFactor = "Fattore di offset";

tool.layer.removeInfluence = "Utilizza dati del livello";
tool.layer.removeInfluence.help = "Questa opzione è attiva solo quando è selezionato un livello.

Utilizzerà i dati del livello per limitare lo spostamento sulle pennellate.";
tool.layer.noLayerSelected = "Questa opzione è disponibile solo se è selezionato un livello";

tool.flatten.planeLockOrigin = "Blocca origine del piano";
tool.flatten.planeLockNormal = "Blocca direzione del piano";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "Sincronizza";
tool.syncInstance.message = "Il nuovo oggetto sarà aggiunto su tutte le altre istanze!";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Vertice fisso sul bordo";
tool.smooth.screen = "Lisciatura dello schermo";
tool.smooth.screen.help = "Utilizza questa opzione per ottenere una lisciatura indipendente dalla topologia, anche con molti poligoni.";
tool.smooth.screen.samples = "Campioni dello schermo";
tool.smooth.stable = "Levigatura stabile";
tool.smooth.stable.help = "Cerca di rendere la levigatura indipendente dalla topologia.

Questa modalità funziona meglio con densità di topologia variabile e con un alto valore di intensità della levigatura.";

tool.paint = "Dipinti";
// Erase the painting
tool.paint.erase = "Cancella";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Filtro livelli";
tool.paint.layerFilter.help = "Utilizzare questa opzione se si desidera solo ridipingere l'area già dipinta di un livello.";

// Clear the painted mask
tool.mask.clear = "Cancella";
tool.mask.clearAll = "Pulisci tutto";
// Invert the painted mask
tool.mask.invert = "Inverti";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Rifletti collegato";
// Blur the painted mask
tool.mask.blur = "Sfocatura";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Nitidezza";
// Transform/Matrix
tool.matrix = "Matrice";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.target = "Target";
// Automatic
tool.matrix.target.auto = "Auto";
tool.matrix.target.auto.help = "Per impostazione predefinita, funziona in modo simile all'opzione Gruppo.
Se la mesh ha una mascheratura o se la simmetria è abilitata, funzionerà come Vertice.";
// Auto apply the transform on the vertices
tool.matrix.target.vertex = "Vertice";
tool.matrix.target.vertex.help = "Cerca di applicare la trasformazione ai vertici, non funzionerà su primitive non convalidate.
Anche le istanze ne risentiranno.";
// Transform the object alone (the children stands still)
tool.matrix.target.object = "Oggetto";
tool.matrix.target.object.help = "Sposta solo l'oggetto, ignorando simmetria e mascheramento.
Solo il nodo modificato si sposterà, i figli resteranno fermi.";
// Transform the object and its children
tool.matrix.target.group = "Gruppo";
tool.matrix.target.group.help = "Sposta il nodo, ignorando simmetria e mascheramento.
Anche il resto della gerarchia verrà trasformato.";
// Operation on the mesh
tool.matrix.action = "Azione";
tool.matrix.action.help = "• Sposta origine
Sposta la mesh all'origine del mondo.

• Ripristina
Reimposta la trasformazione della mesh su identità.

• Trasferisci
Applica la matrice al vertice e ripristina la matrice. Visivamente, nulla dovrebbe cambiare.";
tool.matrix.translation = "Traslazione";
tool.matrix.rotation = "Rotazione";
tool.matrix.scale = "Dimensione";
// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "Inclina";
tool.matrix.uniformScale = "Scala uniforme";
tool.matrix.moveToOrigin = "Sposta origine";
tool.matrix.resetTransform = "Ripristina";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "Trasferisci";

tool.transform.tip = "Tocco singolo con secondo dito per cambiare modalità";

// Size of the gizmo
tool.gizmo.size = "Dimensione widget";
// If true, there is less spacing between gizmo handlers (rotate, scale, etc)
tool.gizmo.compact = "Compatto";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "Inserimento numerico";
tool.gizmo.allowInput.help = "Consente l'input numerico quando si tocca uno dei widget gizmo";
// Angle threshold
tool.gizmo.linearRollThreshold = "Soglia scorrimento tangente";
tool.gizmo.linearRollThreshold.help = "Soglia dell'angolo per scegliere tra il metodo di scorrimento lineare o circolare.

Se il valore è superiore a questa soglia, si utilizzerà lo scorrimento circolare.

Se si preferisce lo scorrimento lineare (direzione della tangente), basta impostare questo valore a 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Nascondi durante l'interazione";
tool.gizmo.tap = "Solo tocco";
tool.gizmo.tap.help = "Questa opzione è efficace solo in modalità pivot personalizzata (Auto disabilitato).";
tool.gizmo.tap.none = "Nessuno";
tool.gizmo.tap.none.help = "Non succede nulla quando si tocca la mesh.";
tool.gizmo.tap.normal = "Normale";
tool.gizmo.tap.normal.help = "Move the gizmo on the first intersection and align it according to the surface normal.";
tool.gizmo.tap.first = "Primo colpo";
tool.gizmo.tap.first.help = "Sposta il gizmo sulla prima intersezione.";
tool.gizmo.tap.medial = "Colpo medio";
tool.gizmo.tap.medial.help = "Sposta il gizmo sul punto medio delle prime due intersezioni.";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "Fisso";
tool.lathe.axisOnly = "Solo asse";
tool.lathe.stable = "Stabile";
tool.lathe.axis = "Asse";

// Fill the object's hole
tool.hole = "Riempimento aperture";
tool.hole.fillHoles = "Riempi aperture";
// synonym: Alternative method
tool.hole.method.fill = "Riempi";
tool.hole.method.legacy = "Legacy";
tool.hole.method.boolean = "Booleano";
tool.hole.bridges = "Booleano dello spazio dello schermo";
tool.hole.bridges.help = "Se questa opzione è attivata, è possibile praticare aperture nel volume.
La pendenza del taglio seguirà più da vicino la forma di taglio.";
tool.hole.threshold = "Soglia epsilon";
tool.hole.threshold.help = "La modifica di questo valore potrebbe aiutare con l'algoritmo di riempimento delle aperture.";
tool.hole.smoothing = "Levigatura apertura";

tool.smudge.quality = "Qualità";
tool.smudge.quality.help = "Cambia la risoluzione dei pixel proiettati, valori più bassi significano tratti più veloci.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Forma";
// Auto-validate the drawn shape
tool.shape.autoValidate = "Validazione automatica";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Quadrato";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Centrato";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Cerchio";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Centrata";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Passo di rotazione";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Sezione aurea";
// volume of a mesh
tool.measure.volume = "Volume del mesh";
// Surface of a mesh
tool.measure.surface = "Superficie";

// Always display the camera shortcut buttons on the viewport
tool.view.stickyCamera = "Scorciatoia fotocamera (sempre)";

// Topology
topology = "Topologia";
// Synynom: detail value, density
topology.dynamic.detail = "Dettaglio";
// See glossary
topology.multires = "Multirisoluzione";
topology.multires.help = "Mantiene più risoluzioni di una mesh.

Se si apportano modifiche in una risoluzione inferiore, i dettagli delle risoluzioni superiori verranno riproiettati quando si torna indietro.

I livelli sono disponibili in ogni risoluzione.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "Rovescia";
topology.multires.reverse.confirm = "Impossibile creare la suddivisione di base.

La topologia attuale probabilmente non è il risultato di una suddivisione.";
topology.multires.subdivide = "Suddividi";
topology.multires.subdivide.confirm = "La mesh avrà $0 milioni di vertici, sei sicuro?";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "Limite di suddivisione superato, vedere $0";
topology.multires.deleteLower = "Elimina inferiore";
topology.multires.deleteHigher = "Elimina superiore";
topology.multires.keepTriangles = "Mantieni triangoli";
topology.multires.lock = "Blocca (LV0)";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "Livello Multires →";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "Livello Multires ←";
// Synonym: Flat subdivision
topology.multires.linear = "Suddivisione lineare";
topology.multires.linear.help = "Suddivide semplicemente la mesh senza applicare alcuna levigatura";
// Only show the lowest resolution wireframe
topology.multires.minWireframe = "Solo livello 0";
// Create a new object by recomputing a new topology
topology.remesh = "Remesh";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Remeshing dei voxel";
topology.voxel.help = "Remeshing mediante campionamento della mesh su una griglia.

Se l'oggetto non è chiuso (impermeabile), viene prima applicato un algoritmo di riempimento delle aperture.

I livelli vengono riproiettati dopo il remeshing, ma la qualità diminuisce.";
topology.voxel.resolution = "Risoluzione";
topology.voxel.sharp = "Mantieni bordi affilati";
topology.voxel.sharp.help = "Questa opzione è utile principalmente per semplici operazioni booleane primitive.

Introdurrà una distorsione in alcune aree a causa dell'aggancio dei punti sui bordi.";
topology.voxel.subLevel = "Crea multirisoluzione";
topology.voxel.subLevel.help = "È possibile ricostruire una gerarchia multirisoluzione dall'output del voxel remesher.

Inoltre il processo sarà più veloce e utilizzerà meno memoria, soprattutto se il valore di dettaglio dei voxel è elevato.
Tuttavia, se il valore di dettaglio dei voxel è basso e si richiedono molti livelli multirisoluzione, si perderanno dettagli.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Remesh";
topology.surface.detail = "Dettaglio";
topology.surface.detail.help = "A differenza del remeshing dei voxel, il remeshing delle superfici non richiede la chiusura della mesh.

Può anche supportare la mascheratura, in modo da proteggere alcune parti della mesh dalle modifiche alla topologia.

I livelli vengono aggiornati correttamente.";
topology.surface.method = "Metodo";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Uniformizzazione";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Suddivisione";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Decimazione";
topology.surface.method.help = "Comportamento della topologia dinamica:
• Uniformizzazione: aggiunge e rimuove dettaglio
• Suddivisione: aggiunge dettaglio
• Decimazione: rimuove dettaglio";
topology.surface.useMasking = "Proteggi l'area mascherata";
topology.surface.useMasking.help = "Le aree mascherate proteggono la topologia da eventuali modifiche.";
topology.surface.extrapolate = "Estrapolazione dei vertici";
// DynTopo
topology.dynamic = "Topologia dinamica";
topology.dynamic.activate = "Abilitata";
topology.dynamic.activate.help = "Con la topologia dinamica, gli strumenti di scultura possono suddividere o semplificare localmente la mesh in tempo reale.

Questa funzione può avere un impatto notevole sulle prestazioni.

I livelli vengono aggiornati correttamente.";
topology.dynamic.method = "Dettaglio basato su...";
topology.dynamic.method.screen = "Scolora";
topology.dynamic.method.radius = "Raggio";
topology.dynamic.method.constant = "Costante";
topology.dynamic.method.help = "• Zoom
Il livello di dettaglio si basa sulla distanza dalla superficie.

• Raggio
Il raggio dello strumento definisce la quantità di dettagli.

• Costante
Il dettaglio è fisso, il valore del dettaglio è condiviso anche con il cursore voxel.";
topology.dynamic.quality = "Preferire...";
topology.dynamic.quality.help = "Se si sceglie Qualità, le 2 differenze principali sono:
• il raffinamento viene applicato prima dell'operatore di scultura, in modo da ottenere meno artefatti di interpolazione quando si dipingono o scolpiscono dettagli molto piccoli
• il raffinamento non viene applicato in modo incrementale; se si scolpiscono dettagli molto piccoli o si eseguono pennellate rapide, la topologia sarà sempre raffinata correttamente";
topology.dynamic.quality.speed = "Velocità";
topology.dynamic.quality.quality = "Qualità";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Usa la pressione sul raggio";
topology.dynamic.usePressure.help = "Scegliere questa opzione se si desidera che l'impatto della pressione della penna sul raggio dello strumento influisca sul livello di dettaglio.";
topology.dynamic.useFalloff = "Usa decadimento tratto";
// Decimate
topology.decimate.title = "Decimazione";
topology.decimate.title.help = "Riduce il numero di poligoni cercando di mantenere il maggior numero di dettagli possibile.

Questa funzione può essere utile se si desidera esportare per la stampa 3D.
Tuttavia probabilmente non si dovrebbe usare se si vuole continuare a scolpire, dato che potrebbe produrre triangoli non uniformi.

Si noti che l'area mascherata non verrà decimata.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Decima";
topology.decimatePaintWeight = "Conserva la dipinti";
topology.decimatePaintWeight.help = "Un valore più alto cercherà di preservare la dipinti.

Impostare questo valore su 0 se non si desidera preservare la dipinti.";
topology.decimateUniform = "Uniforma i lati";
topology.decimateUniform.help = "Un valore più alto produrrà triangoli di dimensioni simili.";
topology.decimatePreserveBorders = "Preserva bordi";
topology.decimatePreserveBorders.help = "Non semplificare il bordo della mesh.";
// Target a certain number of triangles, faces and vertices
topology.target.triangles = "Punta ai triangoli";
topology.target.faces = "Facce target";
topology.target.quads = "Quad target";
topology.target.points = "Punti target";
// Quad remesher
topology.qremesh = "Rimesh quadrato";
topology.qremesh.angle = "Angolo di smussatura";
topology.qremesh.border = "Preserva bordi";
topology.qremesh.onlyQuad = "Solo quads";
topology.qremesh.hole = "Massima riempimento buco";
topology.qremesh.hole.help = "
Srotolamento UV";

// Unwrapping means compute UV (texture coordinates), with uvs you can appliy (wrap) a texture onto the model
topology.uv.title = "Srotolamento UV";
// UV Unwrap but as a Verb
topology.uv.unwrap = "Srotolamento";
// The operation can be very slow
topology.uv.atlas.warning = "Può essere molto lento, punta a <100k vertici!";
// Handles are topological holes (synonym: genus, hole)
topology.uv.bff.warning = "Se la mesh ha maniglie, si possono avere delle sovrapposizioni!";
// Solo patch
topology.uv.bff.seamless = "Toppe senza soluzione di continuità";
topology.uv.bff.seamless.help = "Questa opzione può introdurre una distorsione importante.

In genere, può essere utilizzata quando i gruppi di facce sono impostati con attenzione.";
// Synonym: Point count? Singularity count ?
topology.uv.bff.cones = "Conteggio coni";
topology.uv.bff.help = "Un valore più alto riduce la distorsione per gli oggetti complessi.

Un valore più alto significa tempi di elaborazione più lunghi.";
topology.uv.delete = "Elimina le UV";

// Transfer the vertex painting in the texture, bake means "create texture (from mesh data)"
topology.bake.title = "Trasferisci";
// Bake here means "create texture (from mesh data)"
topology.bake.title.help = "La cottura delle texture creerà texture proiettando altri oggetti visibili nella scena.

Ecco il flusso di lavoro tipico per la cottura:
• Hai una mesh con dettagli fini e dipinti
• Clonala
• Semplificala (imposta `Preserva dipinti` a 0!)
• Effettua l'unwrap UV
• Cuocila!

Nomad prenderà in considerazione ogni mesh visibile nella scena.
Puoi anche usare la modalità Solo per nascondere rapidamente la maggior parte delle altre mesh.
Se non ci sono altri oggetti visibili, prenderà in considerazione l'intera scena.

Dovresti ora avere una mesh a bassa risoluzione che conserva la maggior parte della dipinti e dei dettagli del tuo oggetto precedente.

Dopo l'operazione, i colori dei vertici verranno spostati in un nuovo livello disabilitato, in modo che vengano ignorati invece di essere moltiplicati contro la texture colorata.";
// Bake here means "create texture (from mesh data)"
topology.bake.self = "Da sé stesso";
// Bake here means "create texture (from another mesh data)"
topology.bake.other = "Da alta risoluzione";
topology.bake.resolution = "Risoluzione";
// Cage is a specific term, synonyom: "Bake offset"
topology.bake.offset = "Offset del raggio";
topology.bake.radius = "Raggio gabbia";
// Bake opacity (from mask data)
topology.bake.opacityFromMask = "Maschera -> Opacità";
topology.bake.backup = "Backup";

// project a high resolution mesh details onto another
topology.reproject.title = "Riproietta";
topology.reproject.title.help = "Proietta dettagli scolpiti, dipinti e strati dagli oggetti visibili più vicini.

Questo è per lo più destinato ad essere usato anche su una mesh ad alta risoluzione, tipicamente con una topologia pulita.";
// tweaking value
topology.reproject.rayBias = "Sfasamento raggio";
topology.reproject.rayBias.help = "Due metodi sono usati per la riproiezione:
• più vicino: il punto più vicino sulla superficie
• raggio: punto di intersezione attraverso la direzione normale

Valori di sfasamento più alti favoriranno l'intersezione del raggio invece della superficie più vicina.";
topology.reproject.normalOffset = "Offset normale";
topology.reproject.shpereCast = "Retrocessione del lancio della sfera";
topology.reproject.shpereCast.help = "Se la riproiezione del raggio normale fallisce, Nomad ricorrerà all'intersezione della superficie più vicina.";
// number of iteration the algorithm will take
topology.reproject.iterations = "Iterazioni";
topology.reproject.relax = "Attenua";
topology.reproject.relax.help = "Relax dovrebbe essere preferito quando la mesh è a basso poligono.";
topology.reproject.layers.help = "Trasferisci altri strati sulla mesh selezionata.";

topology.manifold = "Manifold";
topology.nonManifold = "Non-manifold";
topology.manifold.clean = "Pulisci";
topology.manifold.collapse = "Elimina piccole facce";
topology.manifold.title = "Forza Manifold";
topology.manifold.title.help = "Tenta di pulire il bordo non manifold.

Può essere utile per software esterni che non supportano bordi che hanno più di 2 facce in comune.";

// Reset key-bindings/shortcuts
binding.reset = "Ripristina collegamenti";
// Binding option
binding.context.toggle = "Cambia contesto";
binding.toggleTool = "Attiva/Disattiva scorciatoie strumenti";
binding.toggleTool.help = "Quando si utilizza una delle scorciatoie degli strumenti, verrà selezionato lo strumento precedente se lo strumento corrente della scorciatoia è attivo.";
// When the key is tap once, the value will be toggled
binding.tapToggle = "Attiva/disattiva la scorciatoia con un tocco del tasto";
// The binding force camera movement
binding.forceCamera = "Forza telecamera";
binding.forceCamera.help = "Forza l'interazione della camera in caso di conflitto con un altro binding.

Questo può tipicamente accadere se lo stesso binding è assegnato a un collegamento rapido di uno strumento o Aggiungi/Sottrai.";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickMaterial = "Selettore materiale";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickFaceGroup = "Seleziona Gruppo di Facce";
// Edit the tool brush size/radius
binding.editRadius = "Raggio strumento";
// Edit the tool brush size/radius
binding.editIntensity = "Intensità strumento";
// Snap the camera
binding.view.front = "Vista Frontale";
binding.view.left = "Vista Sinistra";
binding.view.top = "Vista dall'Alto";
// Move/Translate the view
binding.pan.left = "Scorri a Sinistra";
binding.pan.right = "Panoramica a destra";
binding.pan.forward = "Panoramica in avanti";
binding.pan.backward = "Panoramica all'indietro";
binding.pan.up = "Panoramica verso l'alto";
binding.pan.down = "Panoramica verso il basso";
// Snap the view (while rotating)
binding.snapViewOnRotate = "Aggancia vista (durante la rotazione)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "Apri (progetto)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "Aggiungi (progetto)";
// Select all the objects in the scene
binding.selectAll = "Seleziona tutto";
// Rotate environment and the lighting
binding.rotateLighting = "Ruota illuminazione";
// The Camera pivot is the point around which the camera rotates
binding.updatePivot = "Pivot";

quadremesh.adaptQuadCount = "Numero Quad Adattivo";
quadremesh.curvatureAdaptivness = "Dimensione Adattiva";
quadremesh.curvatureAdaptivness.help = "Al 100%, la dimensione dei quad varierà a seconda della curvatura dell'oggetto, permettendo quad più piccoli su curve accentuate.
Al 0%, la dimensione dei quad sarà uniforme.";
quadremesh.autoDetectHardEdges = "Rilevamento Automatico Bordi Neti";
quadremesh.useVertexColors = "Conserva la dipinti";

// Privacy policy
privacyPolicy.title = "Informativa sulla privacy";
privacyPolicy.reject = "Rifiuta";
// Hexanomad is the company name
privacyPolicy = "Hexanomad non raccoglie alcun dato da Nomad Sculpt.";

sonar.disconnect = "Disconnetti SonarPen";
sonar.connect = "Connetti SonarPen";
sonar.connect.confirm = "Connettere SonarPen?";
sonar.connect.confirm.warning = "Sonar Pen utilizzerà il microfono (audio loopback) per rilevare la pressione della penna.";

// Color disc mode
widget.color.disc = "Disco";
widget.color.ring = "Anello";
widget.color.square = "Quadrato";

nomad.mainFolder = "Cartella principale di Nomad";
nomad.mainFolder.warning = "I file sono lasciati inalterati.
Non sono copiati, cancellati o spostati.";
nomad.mainFolder.error = "Dopo aver selezionato 'sì', Nomad si chiuderà e potrà essere facilmente riavviata.";

// version trial
version.restore = "Ripristina acquisto";
version.buyWeb = "La versione Web è solo una demo";
version.buyFull = "Aggiorna alla versione completa";
version.buyQR = "Acquista";
version.buyQR.promo = "
Il Quad Remesher è un algoritmo che produce una mesh a dominanza quad.
La distribuzione dei quad cercherà di seguire la curvatura naturale dell'oggetto.

L'algoritmo può anche adattare la dimensione dei quad in base alla curvatura locale.

Puoi anche guidare la topologia risultante con:

• Gruppo di Facce $0 (assicurati di smussare i loro bordi per un risultato migliore!)

• Simmetria Planare X/Y/Z $1

• Guide Curve $2

• Dipinti Densità $3

Il Quad Remesher è sviluppato da https://exoside.com/.";

version.trialHistory = "Versione di prova: 4 annulla/ripeti possibili";
version.trialLayer = "Versione di prova: 1 livello per mesh";
version.trialOneProject = "Versione di prova: 1 solo progetto attivo";
version.trialNoImport = "Versione di prova: Nessuna importazione";
version.trialNoExport = "Versione di prova: Nessuna esportazione";

version.fullFeatures = "• Acquisto una tantum
• Annulla/ripeti illimitati
• Livelli illimitati
• Salvataggio e caricamento
• Esportazione e importazione";

version.demo.purpose = "Questa versione è stata appositamente creata per scopi dimostrativi.";
version.demo.disable = "Funzione non disponibile su questa versione demo.";

// app store main page
store.name = "Nomad Sculpt";
store.headline = "Scultura e dipingi in 3D";
store.tag = "sculpt, 3d, nomad, paint, modeling, scultura, dipinti, modellazione";
// ----------------------------------------------
store.description.sculpt = "• Strumenti di scultura
Creazione, appiattimento, levigatura, maschera e molti altri pennelli ti permetteranno di modellare la tua creazione.
Puoi anche utilizzare lo strumento di taglio booleano trim con lasso, rettangolo e altre forme, per scopi di hardsurface.• • • Strumenti di scultura
Creazione, appiattimento, levigatura, maschera e molti altri pennelli ti permetteranno di modellare la tua creazione.
Puoi anche utilizzare lo strumento di taglio booleano trim con lasso, rettangolo e altre forme, per scopi di hardsurface.";
// ----------------------------------------------
store.description.stroke = "• Personalizzazione del tratto
Dissolvenza, alphas, tassellature, pressione della matita e altri parametri del tratto possono essere personalizzati.
Puoi anche salvare e caricare il tuo preset di strumenti.";
// ----------------------------------------------
store.description.paint = "• Strumenti di dipinti
Verniciatura dei vertici con colore, roughness e metalness.
Puoi gestire facilmente tutti i tuoi preset di materiale.";
// ----------------------------------------------
store.description.layer = "• Livelli
Registra le tue operazioni di scultura e dipinti in livelli separati per iterazioni più facili durante il processo di creazione.
Sia le modifiche alla scultura che alla dipinti vengono registrate.";
// ----------------------------------------------
store.description.multires = "• Scultura multirisoluzione
Vai avanti e indietro tra molteplici risoluzioni della tua mesh per un flusso di lavoro flessibile.";
// ----------------------------------------------
store.description.voxel = "• Rimappatura voxel
Rimappa rapidamente la tua mesh per ottenere un livello uniforme di dettaglio.
Può essere utilizzato per schizzare rapidamente una forma approssimativa all'inizio del processo di creazione.";
// ----------------------------------------------
store.description.dynamic = "• Topologia dinamica
Affina localmente la tua mesh sotto il tuo pennello per ottenere un livello automatico di dettaglio.
Puoi persino mantenere i tuoi livelli, in quanto saranno automaticamente aggiornati!";
// ----------------------------------------------
store.description.topology = "• Decimare
Riduci il numero di poligoni mantenendo il maggior numero di dettagli possibile.";
// ----------------------------------------------
store.description.group = "• Gruppo Facciale
Segmenta la tua mesh in sottogruppi con lo strumento del gruppo facciale.";
// ----------------------------------------------
store.description.unwrap = "• Unwrap UV automatico
L'unwrapper UV automatico può utilizzare i gruppi facciali per controllare il processo di unwrapping.";
// ----------------------------------------------
store.description.baking = "• Baking
Puoi trasferire dati dei vertici come colore, roughness, metalness e dettagli a piccola scala in texture.
Puoi anche fare il contrario, trasferendo dati di texture in dati dei vertici o livelli.";
// ----------------------------------------------
store.description.primitive = "• Forma primitiva
Cilindro, toro, tubo, tornio e altre primitive possono essere usate per iniziare rapidamente nuove forme da zero.";
// ----------------------------------------------
store.description.rendering = "• Rendering PBR
Bellissimo rendering PBR predefinito, con illuminazione e ombre.
Puoi sempre passare a MatCap per un'ombreggiatura più standard per scopi di scultura.";
// ----------------------------------------------
store.description.postprocess = "• Post-elaborazione
Reflection dello spazio schermo, Profondità di campo, Occlusione ambientale, Mappatura dei toni, ecc";
// ----------------------------------------------
store.description.files = "• Esportazione e Importazione
I formati supportati includono file glTF, OBJ, STL o PLY.";
// ----------------------------------------------
store.description.interface = "• Interfaccia
Interfaccia facile da usare, progettata per l'esperienza mobile.
La personalizzazione è possibile!";
// ----------------------------------------------
store.description.remesher = "• Quad Remesher (acquisto in-app separato solo)
Rimappa automaticamente il tuo oggetto con una mesh dominata da quad che segue le curvature della mesh.
Supporta guide, gruppi facciali e dipinti di densità.";
// ----------------------------------------------