// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "Conferma?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Sì";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "Ok";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Annulla";

// common
position.top = "Alto";
position.right = "Destra";
position.left = "Sinistra";
position.bottom = "Basso";
position.center = "Centrato";
direction.up = "Alto";
direction.right = "Destra";
direction.left = "Sinistra";
direction.down = "Basso";

// Name of an item (object, tool, etc)
item.name = "Nome";
// Add a new item (object, tool, etc)
item.new = "Nuovo";
// Rename an item (object, tool, etc)
item.rename = "Rinomina";
// Add a new item (object, tool, project, etc)
item.add = "Aggiungi";
// Save an item (object, tool, etc)
item.save = "Salva";
item.save.confirm = "Conferma salvataggio?";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Ultimo salvataggio";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "Carica ultimo salvataggio?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Ripristina";
item.reset.confirm = "Conferma ripristino?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "Crea istanza";
// Uninstance the object, make the object real
item.uninstance = "Disinstanzia";
// Clone an item (object, tool, etc)
item.clone = "Clona";
// Delete an item (object, tool, etc)
item.delete = "Elimina";
item.delete.confirm = "Conferma eliminazione?";
item.delete.confirm.yes = "Sì, elimina";
// When we delete the item but the image is used somewhere
item.delete.imageUsed = "Utilizzato da questi strumenti:";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "In Nodo";
// Item visibility (object, layer, etc)
item.visible = "Visibile";
// Show an item (object, layer, etc)
item.show = "Mostra";
// Hide an item (object, layer, etc)
item.hide = "Nascondi";
// Select an item (object, layer, etc)
item.select = "Seleziona";
// Unselect an item (object, layer, etc)
item.unselect = "Deseleziona";
// Merge an item with another one below (layer)
item.mergeDown = "Unisci sotto";
// The order of an item in a list
item.order = "Ordine";
// Focus on previous item
item.previous = "Precedente";
// Focus on next item
item.next = "Avanti";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "Blocca";
// No item selected
item.none = "Nessuno";

// Search something (text entry to filter item)
search = "Cerca";

// Three-state toggle button (Auto, Off, On)
toggle.on = "On";
// Three-state toggle button (Auto, Off, On)
toggle.off = "No";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "Auto";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Miniature mancanti, rielaborazione dei file... ($0/$1)

$2";
loading.reprocess.cancel = "";

// Color of an object
material.color = "Colore";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "Disturbo";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "Lucentezza";
// Whether the material is a metal or not
material.metalness = "Metallicità";
// How much light a surface will reflect
material.specular = "Speculare";
// Light that the surface can emit (glow)
material.emissive = "Emissivo";
// Normal map (synonym: detail, bump)
material.normal = "Normale";
// Ambient Occlusion (AO)
material.occlusion = "Occlusione";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "Texture";
// Textures/Image
material.texture = "";
// A warning indicating that the mesh has no UVs
material.warningNoUVs = "";
// Texture filtering https://en.wikipedia.org/wiki/Texture_filtering
material.texture.filter = "";
// Nearest Filtering (closest sample)
material.texture.nearest = "";
// Bilinear Filter
material.texture.linear = "";
// Mipmap filtering
material.texture.mipmap = "";

// Minify
about.minify = "Minimizza UI";
about.minify.help = "Puoi anche toccare lo schermo con 4 dita, se il tuo dispositivo lo supporta.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Piattaforma girevole";
// Rotation center of the turntable
about.turntable.pivot = "";
// Keep current pivot
about.turntable.pivot.keep = "";
// Turntable pivot will be at the center of the scene
about.turntable.pivot.scene = "Scena";
// Make the entire scene turn around (speed of the animation)
about.turntable.speed = "Velocità piattaforma girevole";
// Stuffs that I used to make the app
about.credits = "Riconoscimenti";
// Link to open source projects that I used for the app
about.credits.openSource = "Open Source";
// Only translate the &
about.credits.arts = "MatCap e HDRI";
// Change languages of the app
about.languages = "Lingue";
about.languages.help = "File di traduzione disponibili a $0";
// Link to the App Website
about.website = "Sito Web";
// Link to the App Forum
about.forum = "Forum";
// Link to the App Manual
about.manual = "Manuale";
// Link to the App Email
about.mail = "Supporto";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";

// The user canceled an operation that was running
alert.aborted = "";
// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "L'oggetto non ha aperture!";
// No operation occured because the mesh is already manifold
alert.manifold.already = "";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "L'oggetto corrente è invisibile!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Niente da rifilare.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Interrompi rifilatura: l'oggetto è completamente rifilato.";
// In order to extract something, the mesh needs to have painted mask
alert.mask.noExtract = "Niente da estrarre!";
// In order to split something, the mesh needs to have painted mask
alert.mask.noSplit = "Niente da dividere!";
// List of disabled features when View Mode is selected
alert.view.disabled = "Funzionalità disabilitate in Modalità Vista:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Widget primitive";
// The object needs to have two parts disconnected
alert.separate.fail = "Impossibile separare: l'oggetto è composto da una sola parte!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "Remeshing eseguito!";
alert.voxelRemesh.empty = "Interrompi remeshing: la mesh risultante non ha lati.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "Inserimento non valido!";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "L'oggetto verrà duplicato";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "L'oggetto verrà istanziato";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Modifica modalità pivot.";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "Modifica modalità oggetto.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Attiva topologia dinamica";
// See Glossary (DynTopo)
alert.dynamic.disable = "Disattiva topologia dinamica";
alert.colorPicker = "Trascina il dito sull'oggetto per scegliere un colore.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Basta toccare per uscire dalla modalità di trasformazione.";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "";
// Show the painted mask on the mesh
alert.mask.show = "Mostra maschera";
// Hide the painted mask on the mesh
alert.mask.hide = "Nascondi maschera";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Blocca selezione";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Sblocca selezione";
// Hide the objects that are not selected
alert.selection.isolate = "Isola selezione";
// Show the objects that are hidden
alert.selection.showAll = "Mostra tutto";
// Project quick saving
alert.quickSave = "Salvataggio...";
// Painting on the object was hidden but the user did paint the object
alert.forceShowPainting.fill = "Mostra pittura attivata, è stato utilizzato [Dipingi tutto].";
// Painting on the object was hidden but the user started to paint on the object
alert.forceShowPainting.tool = "Mostra pittura attivata, l'oggetto è stato dipinto.";
// See Glossary (Multiresolution)
alert.multiresLost = "La multirisoluzione andrà persa!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "Il valore dei dettagli è elevato e potrebbe richiedere molta memoria!";
// Autosave popup
alert.autoSave.auto = "Salvataggio automatico in… $0s";
// The selected object doesn't have any layers
alert.needLayer = "Lo strumento attuale richiede un livello attivo.";
// The user decides to hide the painting on the objects
alert.paintingHidden = "Pittura nascosta: andare al pannello Impostazioni per mostrarla di nuovo.";
// The selected object doesn't have any layers
alert.noPartialWireframe = "Il disegno parziale è disabilitato quando è visualizzato il wireframe.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Considerare l'utilizzo della telecamera ortografica se si desidera evitare la distorsione del tronco prospettico quando si utilizza il proiettore dello schermo.";
// Trial version has a limited number of undo
alert.state.trial = "Versione di prova: annulla non eseguito";

background = "Sfondo";
// A flat color will be displayed in the background of the scene
background.color = "Colore";
// The environment (HDRI) will be displayed in the background
background.environment = "Ambiente";
background.blur = "Sfocatura";
background.exposure = "Esposizione";

// Image that the artist uses as a reference
background.imageEnable = "Immagine di riferimento";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Sovrapponi";
// Opposite of transparency (Alpha)
background.imageAlpha = "Opacità";
background.imageReset = "Ripristina impostazioni";
background.imageTransform = "Trasforma";
// X screen coordinate of the image reference
background.imageX = "Posizione X";
// Y screen coordinate of the image reference
background.imageY = "Posizione Y";
// Rotation of the reference image
background.imageRotation = "Rotazione";
// Scale of the reference image
background.imageScale = "Dimensione";

// Camera (point of view in 3d)
camera = "Fotocamera";
// Copy the views
camera.updateView = "Aggiornare punto di vista?";
// Add a new camera
camera.addView = "Aggiungi vista";
// Focus on the camera
camera.focus = "Fuoco";
// Add on the camera camera
camera.focusOn = "Fuoco su $0";
// Camera projection, Orthographic or Perspective
camera.projection = "Proiezione";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Ortografica";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Prospettiva";
// camera Vertical Field of View
camera.fov = "Campo visivo verticale";
// Camera Field of View hint
camera.focal = "focale $0mm (sensore 35mm)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Rotazione";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "Piattaforma girevole";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Trackball";
camera.rotation.trackball.help = "Trackball offre un maggior grado di libertà: è possibile ruotare la fotocamera con due dita.";
// Camera interaction mode, 1st person view
camera.firstPerson = "In prima persona";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Velocità";
// Camera rotation sensitivity
camera.speed.rotation = "Rotazione";
// Camera translation sensitivity
camera.speed.panning = "Panoramica";
// Camera zooming sensitivity
camera.speed.zooming = "Zoom";
// Reset camera position
camera.resetView = "Reimposta vista";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Aggancia vista";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "La telecamera è agganciata (ortografica)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "Aggancio ortografico";
camera.snapOrthographic.help = "Questa opzione funziona anche quando si utilizza il Cubo a scatto nell'angolo.";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Pivot";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Tocca due volte sull'oggetto";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Tocca due volte sullo sfondo";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "Attiva/Disattiva";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "Selezione";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "Scena";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "Aggiorna con un doppio tocco";
camera.doubleTapPivot.help = "Aggiorna il pivot di rotazione quando si tocca due volte la superficie dell'oggetto.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "Pivot esterno";
camera.airPivot.help = "Consente un nuovo pivot anche quando si esegue lo zoom all'esterno della superficie dell'oggetto.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "A inizio interazione con la telecamera";
camera.autoPivot.help = "Aggiorna il pivot quando si inizia a interagire con la telecamera.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Fuoco";
camera.doubleTapFocus.help = "Quando si tocca due volte l'oggetto, la telecamera esegue una panoramica e una messa a fuoco sul punto selezionato.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "Multiselezione";
// There is 0 nodes/items selected
context.noSelection = "Nessuna selezione";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "Preset";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "Spline";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "";

// Set the desired FPS (frame per second, refresh rate)
debug.targetFPS = "";
debug.targetFPS.help = "";

// Debug option, the newly created primitives will contains texture coordinates (UVs)
debug.uvPrimitive = "Mantieni UV nelle primitive";
debug.uvPrimitive.warning = "Disabilita questa opzione se non hai bisogno di UV (memoria extra).";
debug.uvPrimitive.help = "Per ora sono supportati solo Cubo e Sfera.

In futuro verranno supportati altri tipi.";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "Normalizza UV";
debug.uvNormalize.help = "Nomad normalizzerà le UV all'interno del riquadro [0-1].";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "Aggiungi UV BFF";
debug.uvBFF.help = "Si aggiunge un metodo di unwrapping alternativo (Boundary First Flattening).

Si noti che BFF produrrà sovrapposizioni se la topologia della mesh è diversa da un disco o da una sfera.";
// Debug option, display an window with some debugging logs
debug.logs = "Log";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Heightmap";
// Debug options, graphical stuffs
debug.graphics = "Grafica";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Crea miniature per lo store";

// Empty list: there is no projects
file.project.empty = "Non hai ancora un progetto salvato!";
// The current opened project has some unsaved changes
file.project.unsaved = "Vi sono modifiche non salvate!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "Perderai le modifiche non salvate!";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Anteprima dell'ultimo salvataggio manuale";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "Versione di prova: non potrai riaprire il progetto corrente!";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "Versione di prova: puoi solo riaprire il tuo progetto attuale!";

file.project = "Progetto";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Salva";
// E.g: Save "my_project"?
file.project.save.confirm = "Salvare $0?";
// Save to another project (either new one or overriding existing one)
file.project.saveAs = "Salva come";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "Sovrascrivere $0?";
// Open a project
file.project.open = "Apri";
// E.g: Open "my_project"?
file.project.open.confirm = "Aprire $0?";
// Load another project and add/append all its data to the current scene
file.project.add = "Aggiungi alla scena";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "Aggiungere $0 alla scena?";
// Reset the scene and create a new project
file.project.new = "Nuovo";
file.project.new.confirm = "Creare nuova scena?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "Eliminare $0?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "Eliminare $0?

Questo è il progetto attivo al momento!";

// Auto save section
file.project.autoSave = "Salvataggio automatico";
file.project.autoSave.confirm = "Disattivare salvataggio automatico?";
file.project.autoSave.help = "Salva il tuo progetto in un file separato a intervalli regolari.
Il file di salvataggio automatico si trova in:

$0";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "Intervallo popup";
// In minutes
file.project.autoSave.minutes = "Timer popup";
// Delete the current autoSave data
file.project.autoSave.delete = "Elimina dati salvataggio automatico";

// color space (linear or srgb), do not translate linear/srgb if there is a doubt
file.colorSpace = ""
file.colorSpace.help = "";
file.colorSpace.linear = "";
file.colorSpace.srgb = "";

// Configure imports option
file.importSettings = "Opzioni importazione";

// Load interface preference settings when opening a scene file
file.import.guiSettings = "Mantieni impostazioni GUI";
file.import.guiSettings.help = "Quando si apre o si importa un file di progetto, verranno caricate tutte le impostazioni relative alla GUI incorporate nel progetto.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.import.objSplitByGroup = "Dividi OBJ per gruppi";
file.import.objSplitByGroup.help = "Quando abilitato, Nomad dividerà i gruppi OBJ in oggetti separati.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.import.mergeLayers = "Unisci livelli";
// Ignore the textures present in the file to load
file.import.skipTextures = "Ignora texture";
// Do not fiddle with the object topology when loading the file
file.import.keepTopology = "Mantieni topologia";
file.import.keepTopology.help = "Usa questa opzione se non vuoi che Nomad interferisca con la topologia della mesh importata.

Disabiliterà il riordino dei vertici/lati, la rimozione dei duplicati dei vertici/lati e la rimozione dei vertici inutilizzati.";


// Import file section
file.import.title = "Importa";
file.import.title.help = "Formati supportati:
- Wavefront (.obj)
- glTF 2.0 (.glb .gltf)
- STL (.stl)";
// The user imports a scene file that will replace the current scene
file.import.open = "Apri";
file.import.open.confirm = "Importare nuovo file?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Aggiungi alla scena";
file.import.add.confirm = "Importare nuovo file?";

// Export scene file
file.export.title = "Esporta";

// Export the current selected objects instead of the entire scene
file.onlySelection = "Includi solo oggetti selezionati";
file.onlySelection.help = "Includi solo la selezione, invece dell'intera scena.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Ricostruisci quadrilatero";
file.convertToQuad.help = "Ricostruisci quadrilateri da triangoli accoppiando i triangoli (se sono adiacenti nei file).";

// Whether we include the textures in the exported file
file.export.texture = "Texture";
// Baking means transfering/converting
file.export.texture.help = "Questa opzione non trasferisce i colori dei vertici nelle texture.";
// Whether we include normals vector in the exported file
file.export.normal = "Normali";
file.export.normal.help = "Selezionare questa opzione se si desidera aprire il file in un altro software.

Nomad ignora sempre le normali poiché le ricalcolerà.";

file.export.nomad = "";
file.export.nomad.help = "";

file.export.gltf = "Esporta glTF 2.0";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Livelli";
file.export.gltf.layer.help = "Esporta livelli come morph. Ufficialmente supportato da glTF, quindi dovrebbe funzionare anche su altri software.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Livelli pittura";
file.export.gltf.layerPaint.help = "Esporta livelli di pittura. Solitamente viene ignorato da altri software.";
// Whether we include the vertex color in the exported file
file.export.gltf.color0 = "Colori dei vertici";
file.export.gltf.color0.help = "Esporta i colori dei vertici. Ufficialmente supportato da glTF, quindi dovrebbe funzionare anche su altri software.";
// Whether we include the vertex roughness and vertex metalness in the exported file
file.export.gltf.color1 = "Pittura PBR";
file.export.gltf.color1.help = "Esporta rugosità, metallicità e pittura della maschera. Questo verrà ignorato da altri software.";

file.export.obj = "Esporta OBJ";
file.export.obj.warning = "I livelli e la pittura extra (rugosità, metallicità e maschera) andranno persi.";
// Whether we include the vertex color in the exported file
file.export.obj.colorAppend = "Colori dei vertici";
file.export.obj.colorAppend.help = "Aggiungi informazioni sul colore dopo i vertici.

Alcuni software 3D potranno leggerle, ma non tutti.";

file.export.stl = "Esporta STL";
file.export.stl.warning = "I livelli e la pittura extra (rugosità, metallicità e maschera) andranno persi.";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Colori dei vertici";
file.export.stl.color.help = "Alcuni software 3D potranno leggerli, ma non tutti.";
file.export.stl.ascii = "Per impostazione predefinita, il formato è binario.

Puoi scegliere di esportare in formato testo (ASCII) ma il file sarà più grande.";

// Advanced settings
settings.advanced = "Avanzato";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "Queste opzioni non vengono salvate nelle impostazioni.";
settings.reset.title = "Impostazioni";
settings.reset.title.help = "Ripristinerà le impostazioni delle preferenze dell'app.

Alcune risorse vengono salvate separatamente e NON verranno ripristinate, tra cui:
- Progetti
- Collegamenti ai tasti
- Preset di strumenti
- Ambienti HDR
- MatCap
- Alfa
- Texture (pennello)
- Immagini di riferimento

Tieni presente che tutto ciò che è collegato al progetto verrà mantenuto intatto, come l'illuminazione, il post processing, le viste, ecc";

// Reset preference settings button
settings.reset = "Ripristina valori predefiniti";
settings.reset.confirm = "Ripristinare le impostazioni delle preferenze?";

// Render a screenshot of the scene
file.render = "Renderizza";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Mostra interfaccia";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Rapporto di rendering";
file.render.renderRatio.help = "Un valore di 1.0 significa che Nomad eseguirà il rendering alla stessa risoluzione delle dimensioni dell'immagine richieste di seguito.

Utilizzare questa opzione se non è possibile eseguire il rendering con una determinata risoluzione (arresto anomalo per mancanza di memoria).";
// Desired size of the exported screenshot
file.render.size = "Dimensione finale";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Personalizzata";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "scolora";
// width of exported screenshot
file.render.width = "Larghezza";
// height of exported screenshot
file.render.height = "Altezza";
// export screenshot of the scene
file.render.export = "Esporta png";
file.render.warn = "La risoluzione di esportazione è alta ($0x$1)!

Assicurati di salvare il progetto per evitare che il tuo dispositivo esaurisca la VRAM e vada in crash.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Sfondo trasparente";
file.render.transparent.help = "Questa opzione può essere utile se vuoi inserire la mesh in un software di creazione 2D.

Per ora la trasparenza parziale degli oggetti non è supportata.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Usa le impostazioni globali";
pressure.useGlobal.help = "Per impostazione predefinita, gli strumenti condividono le stesse impostazioni di pressione.

Deseleziona questa opzione se desideri impostazioni di pressione specifiche per questo strumento.";

// Pencil pressure
pressure.title = "Pressione";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "Questo strumento non utilizza la pressione della matita/stilo.";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "Il tipo di tratto Cattura ignorerà le impostazioni di pressione.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Raggio";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Intensità";
// Average pencil pressure event to get smoother result
pressure.average = "";
pressure.average.help = "";

// Customize whether finger and/or stylus can move the Camera
gesture.cameraInteraction = "Fotocamera:";
// Customize whether finger and/or stylus can sculpt on object
gesture.sculptInteraction = "Scolpire:";
// Both the finger and the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.fingerAndStylus = "Dito e Stilo";
// Only the finger can perform a certain action (move camera, sculpt, etc)
gesture.interaction.finger = "Dito";
// Only the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.stylus = "Stilo";
// Disable the action
gesture.interaction.none = "Nessuno";
// Allow the action for any inputs
gesture.interaction.any = "Qualsiasi input";

// long press to pick the color/material under the cursor
gesture.materialPicking = "Selezione materiale";
gesture.materialPicking.help = "Il selettore colore/materiale può essere attivato premendo a lungo sulla tela.

Si noti che funziona solo se il pennello corrente ha la pittura abilitata.";

// Three fingers on screen
gesture.three.title = "Tre dita";
// Drag 3 fingers horizontally on the canvas to rotate the environment, lights and MatCap
gesture.fingerLighting = "Ruota illuminazione (3 dita)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerLighting.help = "Trascina 3 dita orizzontalmente sulla tela per ruotare l'ambiente, le luci e MatCap.";
// Drag 3 fingers vertically to edit the tool radius
gesture.fingerRadius = "Modifica raggio strumento (3 dita)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerRadius.help = "Trascina 3 dita verticalmente sulla tela per modificare il raggio dello strumento.";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.fingerSmooth = "Il dito leviga sempre";
gesture.fingerSmooth.help = "";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Consenti pressione non riconosciuta";
gesture.unknownPressure.help = "Seleziona questa opzione se la pressione non funziona con lo stilo o se hai bisogno di premere con il dito.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Pulsante stilo";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Doppio tocco Pencil";
gesture.pencilAction.ios.help = "Attivo solo per Apple Pencil 2ª gen.";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "Nessuno";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Agg./Sott.";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "Scorciatoie con un tocco";
gesture.mask.oneTap.help = "Consenti la scorciatoia Maschera toccando lo schermo una volta, senza dover tenere premuta la scorciatoia del pulsante maschera.

Permetterà i seguenti gesti:
- toccare lo sfondo per invertire la maschera
- tocca un'area mascherata per sfocare la maschera
- tocca un'area non mascherata per rendere più nitida la maschera";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress = "Pressione lunga (Maschera ↔ SelMaschera)";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress.help = "Quando Maschera o SelMaschera è attivo, premere a lungo il dito per passare da uno strumento all'altro.

Se premi a lungo senza muovere il dito, il nuovo strumento verrà utilizzato come scorciatoia predefinita per la maschera.";
// Shortcut customization, choose the action that the shortcut will performan (select tool, etc)
gesture.shortcut = "Scorciatoia";

// Shortcuts to undo/redo
gesture.history = "Cronologia scorciatoie";
gesture.history.help = "- Annulla: tocca con 2 dita
- Ripeti: tocca con 3 dita
- Annulla/Ripeti: tieni premuto con 2/3 dita (continuo)";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Rifiuto del palmo";
gesture.palmRejection.confirm = "Assicurati di disabilitare questa opzione se hai problemi a interagire con la tela!";
gesture.palmRejection.help = "Rifiuta input se la dimensione dell'area di contatto è maggiore di questo valore.

Potrebbe non funzionare su tutti i dispositivi.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Soglia di dimensione massima";

// History, list of undo/redo
history = "Cronologia";
// First "undo" state
history.root = "Primo stato";
history.undoConfirm = "Confermi l'annullamento di tutte queste operazioni?";
history.undoWarning = "Se apporti una modifica in seguito potresti perdere molte modifiche.";
// Settings concerning the history stack of undo/redo
history.stack = "Pila";
// Actions to include in the undo/redo stack
history.include = "Includi azioni";
// include lighting editing in the undo/redo
history.includeLights = "Luci";
history.includeLights.help = "Se questa opzione è disabilitata, lo spostamento delle luci con il Gizmo sarà comunque incluso, poiché può influire su altri oggetti nella gerarchia delle scene.";
// include postProcess editing in the undo/redo
history.includePostProcess = "Post processing";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCap e HDRI";
// Can limit the stack of undo/redo size
history.limitSize = "Limite cronologia (MB)";
history.limitSize.help = "Dimensione massima (in MB) della cronologia.

La cronologia verrà aggiornata alla successiva operazione registrata.";
// Limit the number of undo in the history stack
history.limitStack = "Limite passaggi";
history.limitStack.help = "Numero massimo di operazioni che l'applicazione può mantenere.

La cronologia verrà aggiornata alla successiva operazione registrata.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Massimo annullabile";
history.rangeProtect.help = "Se si va lontano nella cronologia, verrà visualizzata una finestra di dialogo di conferma prima di annullare molte operazioni.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Ripristina telecamera";
history.restoreCamera.help = "Abilitare questa opzione per ripristinare il punto di vista della telecamera salvato quando si annulla/ripete un'azione.";
// Undo
history.undo = "Annulla";
// Redo
history.redo = "Ripeti";
// Shown during undo
history.state.undo = "Annulla: $0";
// Shown during redo
history.state.redo = "Ripeti: %0";
// Shown during undo/redo
history.state.symmetrySplit = "Simmetria divisa";
// Shown during undo/redo
history.state.voxelRemesh = "Remeshing voxel";
// Shown during undo/redo
history.state.surfaceRemesh = "Remeshing superficie";
// Shown during undo/redo
history.state.multiresLevel = "Modifica della risoluzione";
// Shown during undo/redo
history.state.multiresToDynamic = "Multires a DynTopo";
// Shown during undo/redo (mesh type conversion)
history.state.meshDynamicToStatic = "DynTopo a Statico";
// Shown during undo/redo (mesh type conversion)
history.state.meshStaticToDynamic = "Statico a DynTopo";

// Debugging/Inspect object material (view channel separately color, roughness, normal, uv, etc)
inspector = "";
// Inspector but SHORT
inspector.short = "";
// Display the material channel on the background
inspector.onBackground = "";
// Display the material channel on the mesh
inspector.onMesh = "";

// Interface customization
interface = "Interfaccia";

// UI customization: one item row will stands on one line (synonym: Inlined)
interface.compact = "";

// UI customization: each row of the list will be bigger
interface.expandList = "UI: espandi elenchi";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Solo un'opzione dell'interfaccia utente per una più semplice gestione degli elenchi.";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "Aggiungi scorciatoie (in basso)...";

// Interface option (main base color)
interface.colorBase = "Colori di base";
// Interface option (accent widget color)
interface.colorSelect = "Colore widget";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Pannelli trasparenti";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Intensità sfocatura";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Colore pannelli";

// Interface color style
interface.preset.title = "Preset colore";
// Interface color style (original color of Nomad Sculpt)
interface.preset.classic = "Classico";
// Interface color style
interface.preset.orange = "Arancio";
// Interface color style (~red)
interface.preset.cardinal = "Rosso cardinale";
// Interface Color style (~pink)
interface.preset.mulberry = "Rosato";
// Interface color style
interface.preset.brown = "Marrone";
// Interface color style (~green)
interface.preset.emerald = "Verde smeraldo";
// Interface color style (~blue)
interface.preset.neon = "Neon";
// Interface color style
interface.preset.violet = "Viola";
// Interface color style
interface.preset.gray = "Grigio";
// Interface color style
interface.preset.black = "Nero";
// Interface color style
interface.preset.white = "Bianco";

// Reset interface settings
interface.resetAll = "Ripristina stile";
interface.resetAll.confirm = "Ripristinare le impostazioni dell'interfaccia?";
// Interface option (main base color)
interface.iconSupport = "";
interface.iconSupport.help = "";
// Interface customization
interface.flipTop = "Inverti barra superiore";
// Interface customization
interface.flipBottom = "Inverti barra inferiore";
// Interface customization
interface.flipMiddle = "Inverti barre laterali";
// Interface customization (preview material in the viewport when editing material color)
interface.materialPreview = "Anteprima colore del materiale";
// Interface customization
interface.materialPreview.help = "Quando si seleziona un colore per un materiale, viene visualizzata un'anteprima di questo materiale sull'oggetto attualmente selezionato.";
interface.toolbox.hide = "Nascondi casella strumenti";
interface.toolboxHide.help = "Attivare questa opzione se si vuole nascondere la casella degli strumenti.";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.maxColumn = "Max colonne della casella strumenti";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Ripristina ordine casella strumenti";
// Scale the interface
interface.scale = "Scala complessiva";
// Spacing between widgets
interface.cursorStep = "Spaziatura verticale";
// Width of the interface panels
interface.panelWidth = "Larghezza pannelli";
// Size of fonts
interface.fontScale = "Dimensione font";
// Inset
interface.inset.title = "Spostamenti dei bordi";
interface.inset.title.help = "È possibile modificare questi valori solo se si riscontrano problemi nell'interazione con i pulsanti ai bordi dello schermo.

Se il cursore è disabilitato, Nomad utilizzerà i valori dell'area sicura restituiti dal dispositivo stesso.";

// (see Glossary for Layer)
layer = "Livello";
// (see Glossary for Layer)
layers.lock = "Conserva i dettagli dei livelli superiori";
// (see Glossary for Layer)
layers.lock.yes = "Bloccare i livelli superiori?";
// (see Glossary for Layer)
layers.lock.warning = "Durante la scultura, la deformazione proveniente dai livelli superiori verrà ignorata.

Tuttavia i dettagli di questi livelli saranno ancora visibili.

Questa opzione funziona solo se i livelli superiori hanno dettagli in scala relativamente ridotta.";
// (see Glossary for Layer)
layers.addLayer = "Aggiungi livello";
// (see Glossary for Layer)
layer.factors = "Fattori canale";
// (see Glossary for Layer)
layer.factor = "Fattore";
// (see Glossary for Layer)
layer.offset = "Spostamento";
// (see Glossary for Layer)
layers.title = "Livelli";
// (see Glossary for Layer)
layers.title.help = "I livelli possono registrare pittura e spostamenti di posizione; può essere utile per un flusso di lavoro non lineare.
Per esempio, sperimentando diverse espressioni facciali senza fare affidamento sui passaggi della cronologia per annullare le modifiche.

Per i dati di pittura, i livelli sono ordinati dall'alto verso il basso; quindi i livelli in alto maschereranno quelli inferiori.

Si può cancellare parte del livello (e quindi l'influenza del livello) utilizzando lo strumento 'DelLayer'.";
layers.primitive = "I livelli non sono disponibili per le primitive.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "Nessuno";

light = "Luce";
// Intensity of light
light.intensity = "Intensità";
// Kelvin (the temperature unit)
light.kelvin = "";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "Temperatura";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Collegamento";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Fisso";
// The light will move along the camera
light.attachment.camera = "Fotocamera";
light.attachment.help = "-- Fisso
L'orientamento della luce non cambierà.

-- Telecamera
L'orientamento della luce dipende dalla visuale della telecamera.";
// Light type (directional, spot, point)
light.type = "Tipo";
// Directional light (synonym: sun light)
light.type.directional = "Direzionale";
light.type.directional.short = "";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Spot";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Puntiforme";
// Cone angle for spot angles
light.spot.angle = "Angolo del cono";
// Softness of the spot light
light.spot.softness = "Morbidezza";
// Position of the light
light.position = "Posizione";
// Enable or disable shadows for a light
light.shadow.cast = "Ombra";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "La luce puntiforme supporta solo le ombre dello spazio dello schermo.";
light.shadow.type = "Tipo di ombra";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "Shadow map";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "Spazio dello schermo";
light.shadow.type.screenspace.help = "Funzionalità sperimentale, potrebbe essere rimossa in una versione futura.

Questa opzione è pensata per essere utilizzata con la funzione morbidezza ombra.";
// Adjustment to fix artefacts
light.shadow.bias = "Bias";
// How blurry the shadow is
light.shadow.softness = "Morbidezza";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "Di contatto";
light.contact.help = "Se si seleziona auto, solo la luce più dominante avrà un'ombreggiatura di contatto.";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "Tolleranza";
// Activated the light
light.visible = "Mostra";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Ricentra";

// Object's material
material = "Materiale";
// See glossary
material.pbrRoughnessMetalness.warning = "Rugosità e metallicità richiedono la modalità di shading PBR.";
// See glossary
material.pbrReflectance.warning = "La riflettanza richiede la modalità di shading PBR.";
// See glossary
material.pbrRefraction.warning = "La rifrazione richiede la modalità di shading PBR.";
// See glossary
material.pbrSubsurface.warning = "La dispersione luminosa in profondità richiede la modalità di shading PBR.";
// Value that says how much light will change direction when hitting the surface
material.ior = "Indice di rifrazione";
// an object-level value that overrides the painting of the mesh
material.paintingOverride = "Sovrascrivi pittura";
// The roughness in the inside is turbidity
material.paintingOverride.help = "Ci sono due rugosità in gioco, quella che guida la superficie e quella all'interno.

Tuttavia esiste una sola rugosità verniciabile, quindi le due rugosità hanno gli stessi valori.

È possibile utilizzare questo cursore per sovrascrivere la rugosità della superficie e renderla più lucida.";
// Glossiness is simply the opposite of roughness
material.refractionSurfaceGlossiness = "Lucentezza della superficie";
material.refractionSurfaceGlossiness.help = "- a 0, la superficie utilizza la rugosità dipinta
- a 1, la superficie è completamente liscia";
// Synonym: turbidity
material.refractionInteriorRoughness = "Rugosità interna";
material.refractionInteriorRoughness.help = "- a 0, l'interno utilizza la rugosità dipinta
- a 1, l'interno è completamente rugoso";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Pittura lucida";
material.paintGlossy.help = "Dipingerà l'oggetto con una rugosità e una metallicità pari a 0, consentendo così una rifrazione intensa.

Ciò equivale ad andare nel menu pittura e usare la funzione Dipingi tutto con colore e metallicità disabilitati.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Assorbimento";
material.absorptionEnable.help = "Simula la luce che viene assorbita quando viaggia attraverso il volume.

Le parti sottili risulteranno luminose in quanto lasciano passare più luce, mentre le aree spesse saranno più scure.

L'effetto dipende fortemente dalla forma dell'oggetto, viene utilizzata solo un'approssimazione dello spessore dell'oggetto.";
material.absorptionFactor = "Fattore";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "Profondità";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "Traslucenza";
material.translucency.help = "Occorre avere una luce che proietti ombre per vedere la traslucenza.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Opacità";
// Fully opaque material
material.type.opaque = "Opaco";
// See glossary
material.type.subsurface = "Subsurface";
material.type.subsurface.help = "Per ottenere il miglior risultato, puoi passare alla modalità di shading PBR e utilizzare almeno una luce direzionale, idealmente in un ambiente poco luminoso.";
// Transparency mode, alpha blending
material.type.blending = "Fusione";
material.type.blending.help = "Può rendere l'oggetto semitrasparente modificando il valore di opacità.

Si noti che, a causa dei vincoli in tempo reale, si possono avere artefatti visivi evidenti se l'oggetto ha una forma complessa.";
// Transparency mode
material.type.additive = "Additivo";
material.type.additive.help = "Può rendere l'oggetto semitrasparente modificando il valore di opacità.

Questo metodo tende a produrre meno artefatti rispetto al metodo di fusione, ma l'oggetto sarà più luminoso.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Dithering";
material.type.dithering.help = "Può rendere l'oggetto semitrasparente scartando alcuni pixel in modo casuale.";
// Simulate glass-like material
material.type.refraction = "Rifrazione";
material.type.refraction.help = "Questa modalità può essere utilizzata per simulare materiale in vetro.

A causa dei vincoli di tempo reale, l'autorifrazione o la rifrazione multistrato sono limitate.";
material.castShadows = "Proietta ombre";
material.receiveShadows = "Ricevi ombre";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Sempre non illuminato";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Culling inverso";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Riflettanza";
material.reflectance.help = "Controlla la quantità di riflessione che il materiale riceve per i materiali non metallici.

Nella maggior parte dei casi, si dovrebbe utilizzare il valore predefinito (che corrisponde al 4% di luce riflessa ad angolo normale).";

// Menu name
menu.files = "File";
// Menu name
menu.scene = "Scena";
// Menu name
menu.multires = "Multires";
// Menu name
menu.voxel = "Voxel";
// Menu name
menu.dynTopo = "DynTopo";
// Menu name
menu.topology = "Deci/UV...";
// Menu name
menu.primitive = "Primitiva";
// Menu name
menu.render = "Renderizza";
// Menu name
menu.material = "Materiale";
// Menu name
menu.postProcess = "Post processing";
// Menu name
menu.camera = "Fotocamera";
// Menu name
menu.background = "Sfondo";
// Menu name
menu.tool = "Strumento";
// Menu name
menu.stroke = "Tratto";
// Menu name
menu.alpha = "Alfa";
// Menu name
menu.filter = "";
// Menu name
menu.falloff = "Decadimento";
// Menu name
menu.paint = "Pittura";
// Menu name
menu.symmetry = "Simmetria";
// Menu name (pencil pressure)
menu.pressure = "Pressione";
// Menu name
menu.gesture = "Gesto";
// Menu name
menu.layers = "Livelli";
// Menu name
menu.settings = "Impostazioni";
// Menu name
menu.interface = "Interfaccia";
// Menu name
menu.bindings = "Collegamenti";
// Menu name
menu.history = "Cronologia";
// Menu name
menu.historySettings = "Impostazioni";
// Menu name
menu.about = "Info";
// Menu name
menu.debug = "Debug";

// Operation on the object (action)
mesh.action = "Azione";
// If the object has holes, the algorithm will close them
mesh.holeClose = "Chiudi aperture";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holeDetail = "Dettaglio";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Separa";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "I livelli, la pittura e la multirisoluzione andranno persi.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Risoluzione";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Forza cubico";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Converti";
// Static object means "static topology"
mesh.typeStatic = "Trama";
// See glossary
mesh.typeMultiresolution = "Multirisoluzione";
// Dynamic topology
mesh.typeDynamic = "DynTopo";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Materiale globale";
paint.useGlobal.help = "Se questa opzione è attivata, il materiale selezionato sarà lo stesso degli altri strumenti.

Si noti che tiene conto solo delle impostazioni di rugosità, metallicità e colore.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Pittura a tratto";
// Factor/Opacity of paint tool
paint.intensity = "Intensità pittura";
// Apply the paint on the object
paint.paintAll = "Dipingi tutto";
paint.paintAll.help = "Applica il materiale corrente all'oggetto.

L'area mascherata e i canali disabilitati non verranno dipinti.";
// Apply the paint on the object but ignore painting intensity (force full intensity)
paint.paintAllForce = "Forza dipingi tutto";
paint.strokePainting.title = "Pittura";
// Brush stroke texture
paint.texture.warningEnable = "La pittura a tratto deve essere abilitata per consentire la proiezione della trama (casella di controllo in alto)!";
paint.texture.warningIgnored = "Lo strumento attuale non può utilizzare texture!";
// Whether the Brush Alpha will be used to modulate painting intensity
paint.useAlpha = "Usa tratto alfa";
paint.useAlpha.help = "Utilizzo dell'impostazione alfa nel menu del tratto per modulare la pittura.";
// Whether the Brush Falloff will be used to modulate painting intensity
paint.useCurve = "Usa decadimento tratto";
paint.useFalloff.help = "Utilizzo dell'impostazione decadimento nel menu del tratto per modulare la pittura.";
// Whether the Brush Randomize will be used to modulate painting intensity
paint.useJitter = "";
paint.useJitter.help = "";

// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "Nuovo nome";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "Nuovo valore";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "Nuovo colore (formato hex)";

// Post process effect
postprocess = "Post processing";
// Quality vs performance
postprocess.quality = "Qualità";
postprocess.quality.help = "Attivare queste opzioni per migliorare la qualità a scapito delle prestazioni.";
// More samples means better quality but slower performance
postprocess.maxSamples = "Max campioni";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Piena risoluzione";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "Campionamento massimo di fotogrammi";
postprocess.accumulateCount.help = "Numero massimo di fotogrammi da accumulare prima che il rendering si interrompa.

Quando il rendering si interrompe, Nomad non farà nulla, aumentando così l'autonomia della batteria.

Molte funzionalità di rendering traggono vantaggio dall'accumulo di frame, in particolare:
- Ombre morbide
- Illuminazione globale
- Riflessione (SSR)
- Occlusione ambientale
- Dispersione luminosa in profondità
- Profondità di campo

Un numero elevato di fotogrammi è principalmente necessario per Ombre morbide e Illuminazione globale.
Nomad può interrompere il rendering prima se si disabilitano le funzionalità summenzionate.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Risoluzione rendering";
postprocess.renderRatio.warning = "Sostituito dall'effetto Pixel Art.";
postprocess.renderRatio.help = "Questa opzione influisce molto sulle prestazioni.
Si consiglia di mantenere un valore inferiore a x1.25.

Questa opzione non è salvata nelle impostazioni.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "Anti-aliasing (TAA)";
postprocess.taa.help = "Riduce lo sfarfallio quando si sposta la telecamera.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "Riflessione (SSR)";
postprocess.ssr.warning = "SSR richiede la modalità di shading PBR.";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "Illuminazione globale (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "Tolleranza";
postprocess.ssgi.experimental = "Sperimentale!";
postprocess.ssgi.warning = "SSGI richiede la modalità di shading PBR.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "Occlusione ambientale";
// How far the effect spreads
postprocess.ssao.radius = "Dimensioni";
// How strong the effect is
postprocess.ssao.factor = "Intensità";
// Adjustment to fix artefacts
postprocess.ssao.bias = "Distorsione curvatura";
postprocess.ssao.bias.help = "La sensibilità dell'effetto dipende dalla curvatura della superficie.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "Profondità di campo";
// The blur factor behind the focused point
postprocess.dof.blurFar = "Sfocatura lontana";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "Sfocatura vicina";
postprocess.dof.focusTip = "Tocca un oggetto per cambiare il punto di messa a fuoco.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "Bagliore diffuso";
// Intensity of the effect
postprocess.bloom.intensity = "Intensità";
// How far the effect spreads
postprocess.bloom.radius = "Raggio";
postprocess.bloom.radius.help = "Il grado di diffusione del bagliore.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "Soglia";
postprocess.bloom.threshold.help = "Soglia di luminosità per decidere se un pixel emetterà bagliore o no.
Se il valore è pari a 0, tutto riceverà un bagliore diffuso.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "Mappatura dei toni";
postprocess.tone.exposure = "Esposizione";
postprocess.tone.contrast = "Contrasto";
postprocess.tone.saturation = "Saturazione";
// No tonemapping operator is used
postprocess.tone.mapping.none = "Nessuno";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "Neutrale";
// Color curves
postprocess.curve = "Gradazione colore";
// Curve for pixel luminance
postprocess.curve.luminance = "Principale";
postprocess.curve.red = "Rosso";
postprocess.curve.green = "Verde";
postprocess.curve.blue = "Blu";
postprocess.curve.reset = "Ripristina";
// Reset color grading curves
postprocess.curve.resetAll = "Ripristina tutto";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "Aberrazione cromatica";
postprocess.chromatic.factor = "Intensità";
// Darking on the edges
postprocess.vignette = "Vignettatura";
// How far the effect spreads
postprocess.vignette.size = "Dimensioni";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "Durezza";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "Nitidezza";
postprocess.sharpness.factor = "Intensità";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "Grana";
postprocess.grain.factor = "Intensità";
// Accentuate the edges of the model
postprocess.curvature = "Curvatura";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "Cavità";
// Color/Strength of convex curvature
postprocess.curvature.bump = "Rilievo";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "Pixel Art";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "Consenti campionamento fotogrammi";
// Simulate scanline rendering (horizonal line)
postprocess.scanline = "Linea di scansione";
postprocess.scanline.factor = "Fattore";
// Spacing between lines
postprocess.scanline.spacing = "Spaziatura";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Primitiva";
primitive.box = "Parallelepipedo";
primitive.sphereCube = "Sfera";
primitive.sphereUV = "Sfera UV";
primitive.icosahedron = "Icosaedro";
primitive.cylinder = "Cilindro";
primitive.cone = "Cono";
primitive.torus = "Toro";
primitive.lathe = "Lathe";
primitive.tube = "Tubo";
primitive.plane = "Piano";
primitive.triplanar = "Triplanare";
primitive.faceXYZ = "Lato XYZ";
primitive.faceXYZ.help = "Mesh di base con mappa UV srotolata fornita da https://texturing.xyz/";
primitive.needValidate = "Le primitive devono essere convalidate per poter essere scolpite.";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Modifica";
primitive.edit.help = "Consente la modifica 3D nella finestra.

È possibile disattivare questa funzione se si desidera interagire con il Gizmo o lo strumento Trasforma senza modificare la primitiva.";

// Primitive configuration
primitive.mainConfig = "Parametro";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Topologia";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Geometria";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Convalida";
// Maximum number of faces of the primitives
primitive.maxFaces = "Lati massimi";
primitive.maxFaces.help = "Il numero massimo di lati che può avere una primitiva.

Questo limite è attivo solo finché la primitiva non è convalidata, dopodiché tale contromisura viene meno.";
// Synonym: Flat subdivision
primitive.linear = "Suddivisione lineare";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Post-suddivisione";

// Radius (of a sphere, torus, etc)
primitive.radius = "Raggio";
// Size (of cube x dimension)
primitive.size = "Dimensioni";
primitive.sizeX = "Dimensione X";
primitive.sizeY = "Dimensione Y";
primitive.sizeZ = "Dimensione Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "Divisione";
primitive.divisionX = "Divisione X";
primitive.divisionY = "Divisione Y";
primitive.divisionZ = "Divisione Z";
// Angle of torus, etc
primitive.angleX = "Angolo X";
primitive.angleY = "Angolo Y";
primitive.angleZ = "Angolo Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Densità costante";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Proietta su sfera";
primitive.projectOnSphere.help = "Aggancia i punti su una sfera perfetta.";

// triplanar
primitive.triplanar.title = "Triplanare";
primitive.triplanar.title.help = "Triplanare utilizza le informazioni di maschera di 3 piani per riempire una griglia di voxel che viene poi poligonizzata.

Se si interagisce con i cursori di divisione o di dimensione, le informazioni di pittura si resettano (la levigatezza è ok).

Probabilmente si dovrebbe disabilitare la simmetria perché potrebbe non funzionare come ci si aspetterebbe.

È possibile utilizzare l'opzione 'Topologicamente collegato' nel pannello delle maschera per dipingere un piano che influisca sugli altri piani.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanarSameSize = "Stessa dimensione (cubo)";
primitive.triplanarPolish = "Levigatezza";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanarResetMask = "Ripristina maschera";
// One side of a cube (the back plane)
primitive.isolate.back = "Indietro";
// One side of a cube (the right plane)
primitive.isolate.right = "Destra";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Basso";
// Plane
primitive.planeSameSize = "Stessa dimensione (quadrato)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "Disco";
// Box
primitive.boxRegular = "Stessa dimensione (cubo)";
// Distance to the snapping point
primitive.tubeSnapOffset = "Spostamento aggancio";
primitive.tubeSnapOffset.help = "Un valore di 1.0 è uguale al raggio del tubo.";
// Radius of the tube (starting end-point of the tube)
primitive.tubeThicknessStart = "Inizio raggio";
// Radius of the tube (ending end-point of the tube)
primitive.tubeThicknessEnd = "Fine raggio";
primitive.tubeTwist = "Torsione";
primitive.tubeTwistRotate = "Rotazione";
primitive.tubeTwistRadius = "Grandezza";
primitive.tubeTwistOffset = "Spostamento";
primitive.tubeSnap = "Aggancio";
primitive.torusRadiusOuter = "Raggio esterno";
primitive.torusRadiusInner = "Raggio interno";
primitive.torusAngle = "Angolo";
primitive.torusAngleOffset = "Spostamento angolo";
primitive.cylinderHeight = "Altezza";
primitive.coneRadius = "Raggio";
primitive.coneHeight = "Altezza";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Apertura";
// Make a hole in the primtive to make it hollow
primitive.hasHole = "Ha un'apertura";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radiusSync = "Stesso raggio";
primitive.radiusStart = "Inizio raggio";
primitive.radiusEnd = "Fine raggio";

// Singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "";
// All the new items will be inserted inside the bound rather than outside
repeater.array.fitInside = "";
// The object will follow the curve
repeater.curve.align = "";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Importa...";
// iOS Photos gallery
resource.import.ios.photos = "";
// iOS Files App
resource.import.ios.files = "";

scene.title = "Scena";
scene.title.help = "Quando si utilizzano i pulsanti di selezione/visibilità, tenere premuto e trascinare il dito per selezionare facilmente altri oggetti.

È anche possibile premere a lungo i pulsanti di selezione/visibilità per influenzare anche gli elementi figli.";
// The view will focus on the item when we click on it
scene.focus = "Fuoco sull'elemento";
// Add new object on gizmo position
scene.addOnGizmo = "";
scene.addOnGizmo.help = "";
// Select the gizmo tool after adding a new object
scene.addSelectGizmo = "";
scene.addSelectGizmo.help = "";
// Icon size in pixel (min/max)
scene.iconSize = "";
// Min size of icon
scene.iconSize.min = "Min";
// Max size of icon
scene.iconSize.max = "Max";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "";
scene.showHierarchy.help = "";
scene.showHierarchyNomadPivot = "";
scene.showHierarchyNomadPivot.help = "";
// The view will focus on the item when we click on it
scene.syncVisible = "";
scene.syncVisible.help = "";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "Unisci";
// Group the selected object with a new created Empty Node as a parent
scene.group = "Gruppo";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "Specchio";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "Curva";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "Array";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "Radiale";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "";
scene.repeaters.help = "";
// Validate button
scene.validateGroup = "Convalida";
// Keep instances in the scene
scene.validateGroup.keepInstances = "";
// If we should join children
scene.validateGroup.joinChildren = "Unisci figli";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Unione voxel";
scene.voxelResolution = "Risoluzione";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Sottrazione: Nascondi oggetto (icona dell'occhio)";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Intersezione: tutti gli oggetti nascosti";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "Nessun oggetto selezionato, seleziona almeno un oggetto.";
// Need to select one object only
scene.noneButNeedOne = "Nessun oggetto selezionato, seleziona un oggetto.";
// Need to select one object only
scene.onlyOneObject = "Sono selezionati più oggetti, seleziona un solo oggetto.";

// General scene display settings
settings.display.title = "Impostazioni visualizzazione";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Wireframe";
// Display the material texture
settings.debugChannel = "";
// Display the material texture in the background
settings.debugChannel.onBackground = "";
// Display the material texture on the mesh
settings.debugChannel.onMesh = "";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Dai due lati";
settings.twoSided.help = "Le facce saranno visibili da entrambi i lati.";
// If we colorize the inverted side of faces
settings.backface.color = "Colore lato posteriore";
// Color of the inverted side of faces
settings.backface.colored = "Lato posteriore colorato";
// Outline (contour highlight around the selected object)
settings.outline = "Bordato";
// Outline (contour highlight around the selected object)
settings.outline.help = "Gli oggetti selezionati verranno contornati.";
settings.outline.thickness = "Spessore";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Cubo a scatto";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "Basso";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "Sinistra";
// Alignment (can be auto/on/off)
settings.snapCube.align = "";
settings.snapCube.align.help = "";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Statistiche";
settings.stats.right = "Destra";
settings.stats.all = "Mostra l'intera scena";
// Grid
settings.grid = "Griglia";
// Cursor
settings.cursor.whileSculpting = "Mostra il cerchio mentre scolpisci";
// A small indicator dot
settings.cursor.showDot = "Mostra puntino";
settings.cursor.showDot.help = "Il puntino può apparire come punto pivot della telecamera o quando stai scolpendo.";
settings.cursor.showRope = "Mostra stabilizzatore di corda";
// Highlight (the object glows when we select it)
settings.highlight.selection = "Evidenzia selezione";
// Highlight settings
settings.highlight = "Evidenziazione";
settings.highlight.duration = "Durata";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Scurisci gli oggetti non selezionati";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Ombreggiatura uniforme";
// Experimental feature
settings.partialDraw = "Disegno parziale";
settings.partialDraw.help = "Funzionalità sperimentale!

Da usarsi se si scolpisce una parte relativamente piccola di una mesh ad alto numero di poligoni.

Dovrebbe rendere la scultura più fluida, ma non si deve abilitare il wireframe!

Inoltre potrebbe aggiungere artefatti visivi durante le pennellate";
settings.partialDraw.warning = "Non dimenticarti di disattivare questa opzione se gli artefatti visivi sono troppo fastidiosi!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Mostra pittura";
// Display the light icons in the viewport
settings.lightIcon = "Icone chiare";
// Display the camera icons in the viewport
settings.cameraIcon = "Icone telecamera";
// Show icon on the canvas
settings.icon = "Icona";
// Show icons on the canvas
settings.icons = "Icone";
// Tooltip
settings.icons.help = "Visualizza un'icona sull'area di disegno per poterla selezionare e modificare direttamente.";
// Hole filling settings
settings.hole = "Riempimento aperture";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Riempi non-manifold";
settings.hole.nonManifold.help = "Tenta di riempire l'apertura non-manifold.
Questa opzione non viene salvata nelle impostazioni.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Numero massimo di vertici";
settings.multires.maxVertices.help = "Nomad non esegue il controllo della memoria prima della suddivisione; un numero elevato di poligoni può facilmente causare dei crash.";
settings.multires.lowResVertices = "Soglia di bassa risoluzione";
settings.multires.lowResVertices.help = "Quando si sposta la telecamera, è possibile visualizzare una risoluzione inferiore della mesh.

È possibile aumentare questo valore se si desidera visualizzare una risoluzione maggiore della mesh.";

// The main rendering mode
shading = "Shading";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "Illuminato (PBR)";
shading.pbr.help = "In questa modalità è possibile aggiungere luci (con ombre) e un ambiente HDR.

È inoltre possibile dipingere la metallicità e la rugosità, consentendo così un controllo più fine sull'aspetto del materiale.";
// Fast rendering mode for sculpting purpose (do not translate)
shading.matcap = "MatCap";
shading.matcap.help = "Sta per MATerial CAPture; MatCap si occupa delle informazioni sull'illuminazione e sui materiali in un'unica immagine.

Si tratta di una modalità di rendering veloce, adatta soprattutto alla scultura grezza.";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "Non illuminato";
shading.unlit.help = "Modalità di shading a tinta unita, senza illuminazione.";
// Helper rendering mode that display a (do not translate)
shading.id = "ID";
shading.id.help = "Modalità di rendering non illuminata, in cui a ogni oggetto viene assegnato un colore casuale.

Questa modalità è utile soprattutto quando si hanno molti oggetti nella scena.";
// Randomize colors
shading.id.randomize = "Randomizza ID";
shading.textures = "Usa texture";
shading.textures.help = "Al momento non è possibile creare o modificare le texture all'interno di Nomad.

Ma se si importa un file con texture, dovrebbe funzionare.

-- Texture supportate --
Opacità: Illuminato, MatCap, Non illuminato
Normale: Illuminato, MatCap
Colore: illuminato, Non illuminato
Emissivo: Illuminato
Rugosità: Illuminato
Metallicità: Illuminato";
// Lights
shading.lights = "Luci";
shading.lights.addLight = "Aggiungi luce";
shading.lights.warning = "Le luci richiedono la modalità di shading PBR.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Ambiente";
shading.environment.import = "Importa HDR";
shading.environment.exposure = "Esposizione";
shading.environment.backgroundBlur = "Sfoca (sfondo)";
shading.environment.rotation = "Rotazione";
shading.environment.rotation.help = "È possibile ruotare l'ambiente trascinando 3 dita in orizzontale sulla finestra di visualizzazione.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "Collegato alla telecamera";
shading.environment.attachedToCamera.help = "Collega l'ambiente alla telecamera.

Ciò costringerà l'illuminazione a essere coerente, il che può essere utile per la scultura.";
shading.matcap.rotation = "Rotazione";
shading.matcap.rotation.help = "È possibile ruotare MatCap trascinando 3 dita in orizzontale sulla finestra di visualizzazione.";
shading.matcap.global = "Usa MatCap globale";
shading.matcap.global.help = "Deselezionare questa opzione per utilizzare una MatCap diversa per questa particolare mesh.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible = "Maschera";
shortcut.maskVisible.short = "Maschera";
// bottom shortcut buttons (should be SHORT)
shortcut.solo = "Isolato";
shortcut.solo.short = "Isolato";
// bottom shortcut buttons (should be SHORT)
shortcut.voxelRemesh = "Remeshing voxel";
shortcut.voxelRemesh.short = "Voxel";
// bottom shortcut buttons (should be SHORT)
shortcut.wireframe = "Wireframe";
shortcut.wireframe.short = "Wire";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraReset = "Reimposta telecamera";
shortcut.cameraReset.short = "Ripristina";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraSnap = "Aggancio telecamera";
shortcut.cameraSnap.short = "Aggancio";
// bottom shortcut buttons (should be SHORT)
shortcut.lockSelection = "Blocca selezione";
shortcut.lockSelection.short = "Blocca";
shortcut.lockSelection.help = "Quando è abilitato, non è possibile modificare la selezione toccando una mesh.";
// bottom shortcut buttons (should be SHORT)
shortcut.perspective = "Prospettiva";
shortcut.perspective.short = "Persp";
// bottom shortcut buttons (should be SHORT)
shortcut.grid = "Griglia";
shortcut.grid.short = "Griglia";

// Memory taken by the scene
stat.ramScene = "Scena";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Vram Scena";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "Vram Rendering";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "Vram Texture";
// Memory taken by the undo/redo history
stat.ramHistory = "Cronologia";
// Memory taken by other stuffs
stat.ramOther = "Altro";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "Memoria utilizzata";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "Memoria libera";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "Utilizzata: $0 MB";
stat.free = "Libera: $0 MB";
stat.faces = "Lati";
stat.triangles = "Triangoli";
stat.vertices = "Vertici";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Quadrilateri";
stat.sceneFaces = "Lati scena";
stat.sceneVertices = "Vertici scena";

// Brush stroke
stroke = "Tratto";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "Raggio dello spazio mondo";
// The settings is shared among every tools
stroke.useWorldRadius.help = "Questo è condiviso da tutti gli strumenti.";
// Share the radius value among every tools.
stroke.useShareRadius = "Condividi raggio";
stroke.useShareRadius.help = "Condivide il valore del raggio tra tutti gli strumenti.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.spacing = "Spaziatura tratto";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.spacing.adjust = "Regola l'intensità della spaziatura";
stroke.minSpacingAdjustIntensity.help = "Regola l'intensità del pennello per garantire una deformazione uniforme in base alla spaziatura del tratto.";
stroke.minSpacing.help = "Spaziatura tra le pennellate, rispetto al raggio dell'utensile.

Un valore più basso consente una pennellata più fluida, ma le prestazioni si riducono.";
// Brush stroke smoothing
stroke.lazySmooth = "Levigatura tratto";
stroke.lazySmooth.help = "Calcola la media di più posizioni del puntatore per ottenere un tratto più uniforme.

Con valori elevati, il tratto rimarrà indietro rispetto al puntatore, ma alla fine lo raggiungerà.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Stabilizzatore di corda ritardato";
stroke.lazyRadius.help = "I tratti rimarranno indietro rispetto alla posizione del puntatore secondo una certa distanza.

Questo può essere usato per disegnare linee morbide.";
// It is not a per-tool settings
stroke.globalSettings = "Questa è un'impostazione globale";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Aggancia raggio";
stroke.snapRadius.help = "Aggancia il tratto se il puntatore si trova vicino all'ultimo tratto registrato.

Questo può essere utile quando si disegnano lunghe linee continue, mentre si fanno pause frequenti.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Spostamento tratto";
stroke.sculptOffset.help = "Applica uno spostamento costante al tratto.

Questa opzione è utile quando si usano le dita su schermi piccoli, in modo che il dito non copra il tratto.";
stroke.accumulate = "Accumulazione tratto";
stroke.accumulate.help = "Se questa opzione è attivata, non c'è limite alla quantità di materia che si può aggiungere/rimuovere per ogni tratto.";
// The tool can use DynTopo
stroke.useDynamicTopology = "Permetti topologia dinamica";
// Only sculpt the part that are linked topologically
stroke.connected = "Topologia collegata";
stroke.connected.help = "Questa opzione scolpisce solo i vertici collegati alla superficie selezionata.

Questa opzione si usa tipicamente per lo strumento Sposta, per esempio se si vuole spostare esclusivamente una parte che si autointerseca con un'altra parte.";
// Only sculpt the vertex that points toward the camera
stroke.culling = "Solo vertice frontale";
stroke.culling.help = "Questa opzione ignora i vertici rivolti verso il retro.

Può essere utile se si vuole dipingere una parte di una geometria sottile senza influenzare l'altro lato.

Funziona anche per la scultura, ma si potrebbero generare alcuni artefatti.";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.sameSide = "Solo vertice dello stesso lato";
stroke.sameSide.help = "Ignora i vertici che puntano nella direzione opposta alla deformazione.";
// Module the intensity of the sculpting operation by using a falloff curve
menu.falloff = "Decadimento";
stroke.onlyLasso = "Impostazioni attive solo per lo strumento lazo.";
// Alpha
menu.alpha = "Alfa";
// Invert the pixel (black <-> white)
stroke.alphaInvert = "Inverti pixel";
// Repeat the alpha image (pattern)
stroke.alphaWrap = "Tiling";
// No repeat pattern
stroke.alphaWrap.none = "Nessuno";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alphaWrap.repeat = "Ripeti";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alphaWrap.mirror = "Specchia";
stroke.alphaFetch = "Metodo";
// Project the alpha perpendicularly onto the surface
stroke.alphaFetch.surface = "Superficie";
// Project the alpha onto the surface in the direction of the camera view
stroke.alphaFetch.screen = "Proietta schermo";
stroke.alphaRotation = "Rotazione";
stroke.alphaRotation.lock.help = "";
// Repeat the image
stroke.alphaTiling = "Tiling";
// Scale the image (make it bigger or smaller)
stroke.alphaScale = "Ridimensionamento";
stroke.alphaScale.help = "Al valore minimo, il quadrato alfa si trova all'interno del raggio del cerchio dell'utensile.";
// Middle-point value at which no deformation occurs
stroke.alphaMidValue = "Valore medio";
stroke.alphaMidValue.help = "Valore medio al quale non si verifica alcuna deformazione.

(Valore medio = 0)
- Nero: nessuno spostamento
- Bianco: spostamento positivo

(Valore medio = 0.5)
- Nero: spostamento negativo
- Bianco: spostamento positivo

(Valore medio = 1)
- Nero: spostamento negativo
- Bianco: nessuno spostamento";
// Synonymous: Scatter/Jitter/Randomize
stroke.jitter = "";
// Sculpt and paint along the brush stroke at regular spacing
stroke.strokeTypeDot = "Punto";
// Sculpt continuously
stroke.strokeTypeDrag = "Trascina";
// Lock a region and move it around
stroke.strokeTypeGrab = "Cattura";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.strokeTypeGrabRadius = "Cattura - raggio dinamico";
// Lock a region and sculpt it by changing the tool intensity
stroke.strokeTypeGrabIntensity = "Cattura - intensità dinamica";

// Symmetry
symmetry = "Simmetria";
symmetry.enable = "Abilitato";
// Display a warning (the feature is only available for mesh object)
symmetry.primitiveWarning = "La simmetria del pennello è disponibile solo per le primitive convalidate, ad eccezione di Triplanare.";
symmetry.plane.title = "Piani";
symmetry.toolIgnore = "Lo strumento attuale ignora la simmetria.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Radiale";
symmetry.radialX = "Radiale X";
symmetry.radialY = "Radiale Y";
symmetry.radialZ = "Radiale Z";
// A warning indicating that we limit the number of repetitions ($0 is a number)
symmetry.limited = "";
// Synonym: Offset
symmetry.offset.title = "Spostamento";
symmetry.offsetX = "Spostamento X";
symmetry.offsetY = "Spostamento Y";
symmetry.offsetZ = "Spostamento Z";
// Number of clones
symmetry.count.title = "Conteggio";
symmetry.countX = "Conteggio X";
symmetry.countY = "Conteggio Y";
symmetry.countZ = "Conteggio Z";
// method
symmetry.method = "Metodo:";
symmetry.method.help = "-- Locale
Il piano di simmetria si sposta lungo la mesh quando si utilizza uno degli strumenti di trasformazione (Gizmo o Trasforma).

-- Mondo
Il piano di simmetria è fisso e non si sposta.";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.method.world = "Mondo";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.method.local = "Locale";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Rifletti oggetto";
// Mirror the mesh
symmetry.mirror = "Specchiamento";
symmetry.mirror.help = "Cerca di riapplicare la simmetria senza influenzare la topologia.

La simmetria radiale verrà ignorata.

Se la topologia non può essere mantenuta perché non è considerata simmetrica, si avrà la possibilità di imporre lo specchiamento (mirroring).";
symmetry.mirrorLeftToRight = "Da sinistra a destra";
symmetry.mirrorRightToLeft = "Da destra a sinistra";
symmetry.mirrorFail = "Impossibile applicare la simmetria.

Si vuole imporre la simmetria specchiando la mesh?";
symmetry.mirrorUseMasking = "Proteggi l'area mascherata";
symmetry.mirrorUseMasking.help = "Mantiene intatta l'area mascherata.

Questa opzione verrà ignorata con topologia non simmetrica (o superficie discontinua, come un paio di occhi).";
// Reset the symmetry plane position
symmetry.reset = "Ripristina";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Centro dell'oggetto";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "Centro del mondo";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Orientamento";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Mostra linea";
// Display the symmetry plane in 3d
symmetry.showPlane = "Mostra piano";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Modifica con Gizmo";
symmetry.edit.warning = "La modifica della simmetria è sperimentale.";
symmetry.edit.help = "È possibile impostare liberamente il piano di simmetria.

Questa funzione è un po' sperimentale e probabilmente non dovrebbe essere utilizzata.";

// Ideally <10 chars
tool.dynTopo = "DynTopo";
// Ideally <10 chars (Symmetry)
tool.symmetry = "Simm";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "Specchia";
// Ideally <10 chars
tool.clay = "Argilla";
// Ideally <10 chars (Subtract)
tool.clay.sub = "Sub";
// Ideally <10 chars
tool.brush = "Pennello";
// Ideally <10 chars
tool.move = "Sposta";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "Normale";
// Ideally <10 chars
tool.drag = "Trascina";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "Morbida";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Attenua";
// Ideally <10 chars (Paint mask)
tool.mask = "Maschera";
// Ideally <10 chars
tool.mask.unmask = "Togli masch.";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "SelMasch.";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "Sfumino";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "Appiattisci";
// Ideally <10 chars (Flatten the surface, more strongly than Flatten)
tool.planar = "";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Riempi";
// Ideally <10 chars (Layer brush)
tool.layer = "Livello";
// Ideally <10 chars
tool.crease = "Agg. piega";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "Rifila";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Dividi";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "Proietta";
// Ideally <10 chars
tool.inflate = "Gonfia";
// Ideally <10 chars
tool.pinch = "Pizzica";
// Ideally <10 chars
tool.nudge = "Spingi";
// Ideally <10 chars
tool.stamp = "Punto";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "DelLayer";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.select = "Seleziona";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "Gizmo";
// Ideally <10 chars
tool.gizmo.editPivot = "Pivot";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "Aggancia";
// Ideally <10 chars (Snap translation)
tool.gizmo.moveSnap = "Aggancia";
// Ideally <10 chars (Local/Relative space)
tool.gizmo.local = "Locale";
// Ideally <10 chars (Align/Snap the gizmo to world axis)
tool.gizmo.align = "";
// Ideally <10 chars (Pin the gizmo, so that it stays in place when switching between objects)
tool.gizmo.pin = "";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "Trasforma";
// Ideally <10 chars (Translate the object)
tool.transform.move = "Sposta";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "Ruota";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "Dimensione";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "Aggancia";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "Misura";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "Vista";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "Lathe";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "Tubo";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "Inserisci";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "Rifletti";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "Vista";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "Lazo";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Curva";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Poligono";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Tracciato";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "Rett.";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "Ellisse";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "Linea";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Chiuso";

// Radius of the tool (size)
tool.radius = "Raggio";
// Intensity of the tool (force)
tool.intensity = "Intensità";

tool.settings = "Impostazioni";
tool.settings.none = "Questo strumento non ha impostazioni specifiche.";

// Flatten distance offset
tool.clay.flattenOffset = "Appiattisci spostamento";
tool.crease.pinchFactor = "Intensità piega";

tool.layer.removeInfluence = "Utilizza dati del livello";
tool.layer.removeInfluence.help = "Questa opzione è attiva solo quando è selezionato un livello.

Utilizzerà i dati del livello per limitare lo spostamento sulle pennellate.";
tool.layer.noLayerSelected = "Questa opzione è disponibile solo se è selezionato un livello";

tool.flatten.warning = "Queste opzioni sono sperimentali e potrebbero essere rimosse in futuro!";
tool.flatten.planeLockOrigin = "Blocca origine del piano";
tool.flatten.planeLockNormal = "Blocca direzione del piano";
tool.flatten.planeAverageOrigin = "Calcola la media dell'origine del piano";
tool.flatten.planeAverageNormal = "Calcola la media della direzione del piano";
tool.flatten.planeOffset = "Spostamento piano";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "";
tool.syncInstance.message = "";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Vertice fisso sul bordo";

tool.paint = "Pittura";
// Erase the painting
tool.paint.erase = "Cancella";
// Only paint the part of the mesh above a certain height
tool.paint.depthFilter = "Filtro profondità";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Filtro livelli";
tool.paint.layerFilter.help = "Utilizzare questa opzione se si desidera solo ridipingere l'area già dipinta di un livello.";

// Clear the painted mask
tool.mask.clear = "Cancella";
// Invert the painted mask
tool.mask.invert = "Inverti";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Rifletti collegato";
// Blur the painted mask
tool.mask.blur = "Sfocatura";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Nitidezza";
// The thickness of the extracted mesh (from the painted mask)
tool.mask.thickness = "Spessore involucro";
// Smooth the border of the extracted mesh (from the painted mask)
tool.mask.polish = "Levigatezza bordi";
// Extract a new mesh from the painteed mask and carve/emboss the base mesh
tool.mask.engraveEmboss = "Incisione / Rilievo";
// Extract a new mesh from the painted mask
tool.mask.extract = "Estrai";
// Extract two new mesh from the painted mask and from the unmasked area
tool.mask.split = "Dividi";
// How should we close the topology of the extracted object
tool.mask.closeMask = "Azione di chiusura (mascherata):";
// How should we close the topology of the extracted object
tool.mask.closeUnmask = "Azione di chiusura (non mascherata):";
// How should we close the topology of the extracted object
tool.mask.closeAction = "Azione di chiusura:";
// Do not close the mesh (leave it open)
tool.mask.closeActionNone = "Nessuno";
// Close the mesh with a hole-filling algorithm
tool.mask.closeActionFill = "Riempi";
// Close the mesh by adding a thickness on the surface
tool.mask.closeActionShell = "Involucro";
// Close the mesh by using the layer data as a difference thickness
tool.mask.closeActionLayer = "Livello";
tool.mask.closeAction.help = "-- Nessuno
Estrae semplicemente la parte e lascia aperta la parte estratta.

-- Riempi
Il foro viene riempito e levigato.
Non utilizzare questa opzione per le superfici piane.

-- Involucro
Chiude la forma estratta utilizzando il valore dello spessore.

-- Livello
Estrae la differenza di livello (solo nel sottomenu dei livelli).";

// Transform/Matrix
tool.matrix = "Matrice";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.apply = "Target";
// Automatic
tool.matrix.apply.auto = "Auto";
// Transform the object alone (the children stands still)
tool.matrix.apply.object = "Oggetto";
// Auto apply the transform on the vertices
tool.matrix.apply.vertex = "Vertice";
// Transform the object and its children
tool.matrix.apply.group = "Gruppo";
tool.matrix.apply.help = "-- Auto
Per impostazione predefinita, funziona in modo simile all'opzione Gruppo.
Se la mesh ha una mascheratura o se la simmetria del gizmo è abilitata, funzionerà come Vertice.

-- Vertice
Cerca di applicare la trasformazione ai vertici, non funzionerà su primitive non convalidate.
Anche le istanze ne risentiranno.

-- Oggetto
Sposta solo l'oggetto, ignorando simmetria e mascheramento.
Solo il nodo modificato si sposterà, i figli resteranno fermi.

-- Gruppo
Sposta il nodo, ignorando simmetria e mascheramento. Anche il resto della gerarchia verrà trasformato.";
// Operation on the mesh
tool.matrix.action = "Azione";
tool.matrix.action.help = "-- Sposta origine
Sposta la mesh all'origine del mondo.

-- Ripristina
Reimposta la trasformazione della mesh su identità.

-- Trasferisci
Applica la matrice al vertice e ripristina la matrice. Visivamente, nulla dovrebbe cambiare.";
tool.matrix.translation = "Traslazione";
tool.matrix.rotation = "Rotazione";
tool.matrix.scale = "Dimensione";
// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "Inclina";
tool.matrix.uniformScale = "Scala uniforme";
tool.matrix.moveToOrigin = "Sposta origine";
tool.matrix.resetTransform = "Ripristina";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "Trasferisci";

tool.transform.tip = "";

// Size of the gizmo
tool.gizmo.size = "Dimensione widget";
// If true, there is less spacing between gizmo handlers (rotate, scale, etc)
tool.gizmo.compact = "";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "Inserimento numerico";
tool.gizmo.allowInput.help = "Consente l'input numerico quando si tocca uno dei widget gizmo";
// Angle threshold
tool.gizmo.linearRollThreshold = "Soglia scorrimento tangente";
tool.gizmo.linearRollThreshold.help = "Soglia dell'angolo per scegliere tra il metodo di scorrimento lineare o circolare.

Se il valore è superiore a questa soglia, si utilizzerà lo scorrimento circolare.

Se si preferisce lo scorrimento lineare (direzione della tangente), basta impostare questo valore a 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Nascondi durante l'interazione";
tool.gizmo.tap = "Solo tocco";
tool.gizmo.tap.help = "Questa opzione è efficace solo in modalità pivot personalizzata (Auto disabilitato).

-- Nessuno
Non succede nulla quando si tocca la mesh.

-- Primo colpo
Sposta il gizmo sulla prima intersezione.

-- Colpo medio
Sposta il gizmo sul punto medio delle prime due intersezioni.";
tool.gizmo.tap.none = "Nessuno";
tool.gizmo.tap.align = "";
tool.gizmo.tap.first = "Primo colpo";
tool.gizmo.tap.medial = "Colpo medio";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "Fisso";

// Fill the object's hole
tool.hole = "Riempimento aperture";
tool.hole.fillHoles = "Riempi aperture";
// synonym: Alternative method
tool.hole.bridges = "Booleano dello spazio dello schermo";
tool.hole.bridges.help = "Se questa opzione è attivata, è possibile praticare aperture nel volume.
La pendenza del taglio seguirà più da vicino la forma di taglio.";
tool.hole.threshold = "Soglia epsilon";
tool.hole.threshold.help = "La modifica di questo valore potrebbe aiutare con l'algoritmo di riempimento delle aperture.";
tool.hole.smoothing = "Levigatura apertura";

tool.smudge.quality = "Qualità";
tool.smudge.quality.help = "Cambia la risoluzione dei pixel proiettati, valori più bassi significano tratti più veloci.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Forma";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Quadrato";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Centrato";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Cerchio";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Centrata";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Passo di rotazione";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Mostra sezione aurea";


// Always display the camera shortcut buttons on the viewport
tool.view.stickyCamera = "";

// Topology
topology = "Topologia";
// Synynom: detail value, density
topology.dynamic.detail = "Dettaglio";
// See glossary
topology.multires = "Multirisoluzione";
topology.multires.help = "Mantiene più risoluzioni di una mesh.

Se si apportano modifiche in una risoluzione inferiore, i dettagli delle risoluzioni superiori verranno riproiettati quando si torna indietro.

I livelli sono disponibili in ogni risoluzione.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "Rovescia";
topology.multires.reverse.confirm = "Impossibile creare la suddivisione di base.

La topologia attuale probabilmente non è il risultato di una suddivisione.";
topology.multires.subdivide = "Suddividi";
topology.multires.subdivide.confirm = "La mesh avrà $0 milioni di vertici, sei sicuro?";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "Limite di suddivisione superato, vedere $0";
topology.multires.deleteLower = "Elimina inferiore";
topology.multires.deleteHigher = "Elimina superiore";
topology.multires.keepTriangles = "Mantieni triangoli";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "";
// Synonym: Flat subdivision
topology.multires.linear = "Suddivisione lineare";
topology.multires.linear.help = "Suddivide semplicemente la mesh senza applicare alcuna levigatura";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Remeshing dei voxel";
topology.voxel.help = "Remeshing mediante campionamento della mesh su una griglia.

Se l'oggetto non è chiuso (impermeabile), viene prima applicato un algoritmo di riempimento delle aperture.

I livelli vengono riproiettati dopo il remeshing, ma la qualità diminuisce.";
topology.voxel.resolution = "Risoluzione";
topology.voxel.remesh = "Remesh";
topology.voxel.sharp = "Mantieni bordi affilati";
topology.voxel.sharp.help = "Questa opzione è utile principalmente per semplici operazioni booleane primitive.

Introdurrà una distorsione in alcune aree a causa dell'aggancio dei punti sui bordi.";
topology.voxel.subLevel = "Crea multirisoluzione";
topology.voxel.subLevel.help = "È possibile ricostruire una gerarchia multirisoluzione dall'output del voxel remesher.

Inoltre il processo sarà più veloce e utilizzerà meno memoria, soprattutto se il valore di dettaglio dei voxel è elevato.
Tuttavia, se il valore di dettaglio dei voxel è basso e si richiedono molti livelli multirisoluzione, si perderanno dettagli.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Remesh";
topology.surface.detail = "Dettaglio";
topology.surface.detail.help = "A differenza del remeshing dei voxel, il remeshing delle superfici non richiede la chiusura della mesh.

Può anche supportare la mascheratura, in modo da proteggere alcune parti della mesh dalle modifiche alla topologia.

I livelli vengono aggiornati correttamente.";
topology.surface.method = "Metodo";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Uniformizzazione";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Suddivisione";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Decimazione";
topology.surface.method.help = "Comportamento della topologia dinamica:
- Uniformizzazione: aggiunge e rimuove dettaglio
- Suddivisione: aggiunge dettaglio
- Decimazione: rimuove dettaglio";
topology.surface.useMasking = "Proteggi l'area mascherata";
topology.surface.useMasking.help = "Le aree mascherate proteggono la topologia da eventuali modifiche.";
topology.surface.extrapolate = "Estrapolazione dei vertici";
// DynTopo
topology.dynamic = "Topologia dinamica";
topology.dynamic.activate = "Abilitata";
topology.dynamic.activate.help = "Con la topologia dinamica, gli strumenti di scultura possono suddividere o semplificare localmente la mesh in tempo reale.

Questa funzione può avere un impatto notevole sulle prestazioni.

I livelli vengono aggiornati correttamente.";
topology.dynamic.method = "Dettaglio basato su...";
topology.dynamic.method.zoom = "Zoom";
topology.dynamic.method.radius = "Raggio";
topology.dynamic.method.constant = "Costante";
topology.dynamic.method.help = "-- Zoom
Il livello di dettaglio si basa sulla distanza dalla superficie.

-- Raggio
Il raggio dello strumento definisce la quantità di dettagli.

-- Costante
Il dettaglio è fisso, il valore del dettaglio è condiviso anche con il cursore voxel.";
topology.dynamic.quality = "Preferire...";
topology.dynamic.quality.help = "Se si sceglie Qualità, le 2 differenze principali sono:
- il raffinamento viene applicato prima dell'operatore di scultura, in modo da ottenere meno artefatti di interpolazione quando si dipingono o scolpiscono dettagli molto piccoli
- il raffinamento non viene applicato in modo incrementale; se si scolpiscono dettagli molto piccoli o si eseguono pennellate rapide, la topologia sarà sempre raffinata correttamente

Per ottenere prestazioni migliori, e se si intende utilizzare questa opzione, si potrebbe considerare di attivare l'opzione 'disegno parziale' nel pannello Impostazioni.";
topology.dynamic.quality.speed = "Velocità";
topology.dynamic.quality.quality = "Qualità";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Usa la pressione sul raggio";
topology.dynamic.usePressure.help = "Scegliere questa opzione se si desidera che l'impatto della pressione della penna sul raggio dello strumento influisca sul livello di dettaglio.";
// Decimate
topology.decimate.title = "Decimazione";
topology.decimate.title.help = "Riduce il numero di poligoni cercando di mantenere il maggior numero di dettagli possibile.

Questa funzione può essere utile se si desidera esportare per la stampa 3D.
Tuttavia probabilmente non si dovrebbe usare se si vuole continuare a scolpire, dato che potrebbe produrre triangoli non uniformi.

Si noti che l'area mascherata non verrà decimata.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Decima";
topology.decimateTargetFaces = "Punta ai triangoli";
topology.decimatePaintWeight = "Conserva la pittura";
topology.decimatePaintWeight.help = "Un valore più alto cercherà di preservare la pittura.

Impostare questo valore su 0 se non si desidera preservare la pittura.";
topology.decimateUniform = "Uniforma i lati";
topology.decimateUniform.help = "Un valore più alto produrrà triangoli di dimensioni simili.";
topology.decimatePreserveBorders = "";
topology.decimatePreserveBorders.help = "";

// Unwrapping means compute UV (texture coordinates), it allows the object to receive on texture (wrap the texturing on the object)
topology.uv.title = "Srotolamento automatico UV";
// UV Unwrapping
topology.uvAtlas = "Srotola Atlas";
// The operation can be very slow
topology.uvAtlas.warning = "Può essere molto lento, punta a <100k vertici!";
// UV Unwrapping (BFF best left untranslated, stands for Boundary First Flattening)
topology.uvBFF = "Srotola BFF";
// Handles are topological holes (synonym: genus, hole)
topology.uvBFF.warning = "Se la mesh ha maniglie, si possono avere delle sovrapposizioni!";
// Synonym: Point count? Singularity count ?
topology.uvBFFCones = "Conteggio coni";
topology.uvBFFCones.help = "Un valore più alto riduce la distorsione per gli oggetti complessi.

Un valore più alto significa tempi di elaborazione più lunghi.";
topology.uvDelete = "Elimina le UV";

// Transfer the vertex painting in the texture, bake means "create texture (from mesh data)"
topology.bake.title = "Trasferisci pittura vertici";
// Bake here means "create texture (from mesh data)"
topology.bake.title.help = "";
// Bake here means "create texture (from mesh data)"
topology.bakeSelf = "";
// Bake here means "create texture (from another mesh data)"
topology.bakeHires = "";
topology.bakeResolution = "Risoluzione";
// Cage is a specific term, synonyom: "Bake offset"
topology.bakeOffset = "";
// Bake opacity (from mask data)
topology.bake.opacityFromMask = "";

// project a high resolution mesh details onto another
topology.reproject.title = "";
topology.reproject.title.help = "";
// tweaking value
topology.reproject.rayBias = "";
topology.reproject.rayBias.help = "";
// number of iteration the algorithm will take
topology.reproject.iterations = "";

topology.forceManifold = "";
topology.forceManifold.help = "";

// Reset key-bindings/shortcuts
binding.reset = "Ripristina collegamenti";
// Binding option
binding.toggleTool = "";
binding.toggleTool.help = "";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.materialPicker = "Selettore materiale";
// Edit the tool brush size/radius
binding.editRadius = "Raggio strumento";
// Edit the tool brush size/radius
binding.editIntensity = "Intensità strumento";
// Snap the camera
binding.viewFront = "Vista frontale";
// Snap the camera
binding.viewLeft = "Vista a sinistra";
// Snap the camera
binding.viewTop = "Vista dall'alto";
// Move/Translate the view
binding.panLeft = "Panoramica a sinistra (Vista)";
// Move/Translate the view
binding.panRight = "Panoramica a destra (Vista)";
// Move/Translate the view
binding.panForward = "Panoramica in avanti (Vista)";
// Move/Translate the view
binding.panBackward = "Panoramica all'indietro (View)";
// Move/Translate the view
binding.panUp = "Panoramica verso l'alto (Vista)";
// Move/Translate the view
binding.panDown = "Panoramica verso il basso (Vista)";
// Snap the view (while rotating)
binding.snapViewOnRotate = "Aggancia vista (durante la rotazione)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "Apri (progetto)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "Aggiungi (progetto)";
// Import an external scene file (replace current scene)
binding.import.open = "Apri (importazione)";
// Import an external scene file (add it to the current scene)
binding.import.add = "Aggiungi (importazione)";
// Select all the objects in the scene
binding.selectAll = "Seleziona tutto";
// Rotate environment and the lighting
binding.rotateLighting = "Ruota illuminazione";

// Privacy policy
privacyPolicy.title = "Informativa sulla privacy";
privacyPolicy.reject = "Rifiuta";
// Hexanomad is the company name
privacyPolicy = "Hexanomad non raccoglie alcun dato da Nomad Sculpt.";

// Color disc mode
widget.color.disc = "";
// Color square mode
widget.color.square = "";

// version trial
version.buyWeb = "La versione Web è solo una demo";
version.buyFull = "Aggiorna alla versione completa";
version.restorePurchase = "Ripristina acquisto";

version.trialHistory = "Versione di prova: 4 annulla/ripeti possibili";
version.trialLayer = "Versione di prova: 1 livello per mesh";
version.trialOneProject = "Versione di prova: 1 solo progetto attivo";
version.trialNoImport = "Versione di prova: Nessuna importazione";
version.trialNoExport = "Versione di prova: Nessuna esportazione";

version.fullFeatures = "- Acquisto una tantum
- Annulla/ripeti illimitati
- Livelli illimitati
- Salvataggio e caricamento
- Esportazione e importazione";
