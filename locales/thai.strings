// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "ยืนยัน?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "ใช่";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "ตกลง";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "ยกเลิก";

// Experimental feature
experimental = "";

// common
position.top = "บน";
position.right = "ขวา";
position.left = "ซ้าย";
position.bottom = "ล่าง";
position.center = "อยู่กึ่งกลาง";
direction.up = "บน";
direction.right = "ขวา";
direction.left = "ซ้าย";
direction.down = "ล่าง";

// Name of an item (object, tool, etc)
item.name = "ชื่อ";
// Add a new item (object, tool, etc)
item.new = "ใหม่";
// Rename an item (object, tool, etc)
item.rename = "เปลี่ยนชื่อ";
// Add a new item (object, tool, project, etc)
item.add = "เพิ่ม";
// Update an item image with a new image (synonym: Update)
item.replace = "";
// Save an item (object, tool, etc)
item.save = "บันทึก";
item.save.confirm = "ยืนยันการบันทึก?";
// Reload last save of an item (object, tool, etc)
item.lastSave = "บันทึกล่าสุด";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "โหลดการบันทึกล่าสุด?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "รีเซ็ต";
item.reset.confirm = "ยืนยันการรีเซ็ต?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "อินสแตนซ์";
// Uninstance the object, make the object real
item.uninstance = "ยกเลิกอินสแตนซ์";
// Clone an item (object, tool, etc)
item.clone = "โคลนนิ่ง";
// Delete an item (object, tool, etc)
item.delete = "ลบ";
item.delete.confirm = "ยืนยันการลบ?";
item.delete.confirm.yes = "ใช่ ลบทิ้ง";
// When we delete the item but the image is used somewhere
item.delete.imageUsed = "ใช้โดยเครื่องมือต่อไปนี้";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "เป็นโหนด";
// Item visibility (object, layer, etc)
item.visible = "ที่เห็นได้";
// Show an item (object, layer, etc)
item.show = "แสดง";
// Hide an item (object, layer, etc)
item.hide = "ซ่อน";
// Select an item (object, layer, etc)
item.select = "เลือก";
// Unselect an item (object, layer, etc)
item.unselect = "ยกเลิกการเลือก";
// Merge an item with another one below (layer)
item.mergeDown = "รวมล่าง";
// The order of an item in a list
item.order = "เรียง";
// Focus on previous item
item.previous = "ก่อนหน้า";
// Focus on next item
item.next = "ถัดไป";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "ล็อค";
// No item selected
item.none = "ไม่มี";

// Search something (text entry to filter item)
search = "ค้นหา";

// Three-state toggle button (Auto, Off, On)
toggle.on = "เปิด";
// Three-state toggle button (Auto, Off, On)
toggle.off = "ปิด";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "อัตโนมัติ";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "ไม่มีภาพขนาดย่อ กำลังประมวลผลไฟล์ใหม่... ($0/$1)

$2";
loading.reprocess.cancel = "";

access.title = "";
access.window = "";
access.pinch = "";
access.drag = "";
access.roll = "";

// Color of an object
material.color = "คัลเลอร์";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "ความหยาบ";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "ความมันวาว";
// Whether the material is a metal or not
material.metalness = "ความเป็นโลหะ";
// How much light a surface will reflect
material.specular = "ความสะท้อนแสง";
// Light that the surface can emit (glow)
material.emissive = "ความเรืองแสง";
// Normal map (synonym: detail, bump)
material.normal = "ปกติ";
// Ambient Occlusion (AO)
material.occlusion = "แสงเงาระหว่างวัตถุ";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "พื้นผิว";
// Textures/Image
material.texture = "";
// A warning indicating that the mesh has no UVs
material.warningNoUVs = "";
// Texture filtering https://en.wikipedia.org/wiki/Texture_filtering
material.texture.filter = "";
// Nearest Filtering (closest sample)
material.texture.nearest = "";
// Bilinear Filter
material.texture.linear = "";
// Mipmap filtering
material.texture.mipmap = "";

// Minify
about.minify = "ลดขนาด UI";
about.minify.help = "คุณสามารถใช้นิ้ว 4 นิ้วแตะหน้าจอ หากอุปกรณ์ของคุณรองรับ";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "แท่นหมุน";
// Rotation center of the turntable
about.turntable.pivot = "";
// Keep current pivot
about.turntable.pivot.keep = "";
// Turntable pivot will be at the center of the scene
about.turntable.pivot.scene = "ซีน";
// Make the entire scene turn around (speed of the animation)
about.turntable.speed = "ความเร็วแท่นหมุน";
// Stuffs that I used to make the app
about.credits = "เครดิต";
// Link to open source projects that I used for the app
about.credits.openSource = "โอเพนซอร์ซ";
// Only translate the &
about.credits.arts = "MatCaps & HDRIs";
// Change languages of the app
about.languages = "ภาษา";
about.languages.help = "ไฟล์แปลงพร้อมใช้งานที่ $0";
// Link to the App Website
about.website = "เว็บไซต์";
// Link to the App Forum
about.forum = "ฟอรั่ม";
// Link to the App Manual
about.manual = "คู่มือ";
// Link to the App Email
about.mail = "บริการช่วยเหลือ";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "ขัดแย้ง";

// The user canceled an operation that was running
alert.aborted = "";
// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "ออบเจ็กต์ไม่มีรู!";
// No operation occured because the mesh is already manifold
alert.manifold.already = "";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "มองไม่เห็นออบเจ็กต์นี้!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "ไม่มีสิ่งที่ให้ตัดแต่ง";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "ยกเลิกการตัดแต่ง ออบเจ็กต์ถูกตัดแต่งสมบูรณ์แล้ว";
// In order to extract something, the mesh needs to have painted mask
alert.mask.noExtract = "ไม่มีสิ่งที่ให้สกัด!";
// In order to split something, the mesh needs to have painted mask
alert.mask.noSplit = "ไม่มีสิ่งที่ให้แยก!";
// List of disabled features when View Mode is selected
alert.view.disabled = "คุณสมบัติที่ปิดใช้งานในโหมดดู";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "วิดเจ็ตของรูปทรงพื้นฐาน";
// The object needs to have two parts disconnected
alert.separate.fail = "ไม่สามารถแยกออก ออบเจ็กต์มีเพียงส่วนเดียว!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "รีเมช!";
alert.voxelRemesh.empty = "ยกเลิกรีเมช ผลคือทำให้เมชไม่มีเฟส";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "อินพุตไม่ถูกต้อง!";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "จะทำสำเนาออบเจ็กต์";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "จะทำอินสแตนซ์ออบเจ็กต์";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "แก้ไขโหมดจุดหมุน";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "แก้ไขโหมดของออบเจ็กต์";
// See Glossary (DynTopo)
alert.dynamic.enable = "โทโพโลยีแบบไดนามิกที่ใช้งานอยู่";
// See Glossary (DynTopo)
alert.dynamic.disable = "ปิดใช้งานโทโพโลยีแบบไดนามิก";
alert.colorPicker = "ลากนิ้วของคุณบนออบเจ็กต์เพื่อเลือกสี";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "แค่แตะเพื่อออกจากโหมดการแปลง";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "";
// Show the painted mask on the mesh
alert.mask.show = "แสดงมาส์ก";
// Hide the painted mask on the mesh
alert.mask.hide = "ซ่อนมาส์ก";
// Selection refers to the objects that are currently selected
alert.selection.lock = "ล็อคการเลือก";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "ปลดล็อกการเลือก";
// Hide the objects that are not selected
alert.selection.isolate = "แยกการเลือก";
// Show the objects that are hidden
alert.selection.showAll = "แสดงทั้งหมด";
// Project quick saving
alert.quickSave = "กำลังบันทึก...";
// Painting on the object was hidden but the user did paint the object
alert.forceShowPainting.fill = "แสดงการวาดลงสีที่เปิดใช้งาน [ระบายสีทั้งหมด] ถูกใช้แล้ว";
// Painting on the object was hidden but the user started to paint on the object
alert.forceShowPainting.tool = "แสดงการวาดลงสีที่เปิดใช้งาน ออบเจ็กต์ถูกทาสีแล้ว";
// See Glossary (Multiresolution)
alert.multiresLost = "ความละเอียดแบบหลายระดับจะหายไป!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "ค่ารายละเอียดสูงและอาจต้องใช้หน่วยความจำมาก!";
// Autosave popup
alert.autoSave.auto = "บันทึกอัตโนมัติใน... $0วิ.";
// The selected object doesn't have any layers
alert.needLayer = "เครื่องมือปัจจุบันต้องการเลเยอร์ที่ใช้งานอยู่";
// The user decides to hide the painting on the objects
alert.paintingHidden = "การวาดลงสีที่ซ่อนอยู่ แสดงอีกครั้งในแผงการตั้งค่า";
// The selected object doesn't have any layers
alert.noPartialWireframe = "การวาดบางส่วนถูกปิดใช้งานเมื่อแสดงโครงร่าง";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "พิจารณาใช้กล้องออร์โธกราฟิกหากคุณต้องการหลีกเลี่ยงความผิดเพี้ยนของฟรัสตัม เปอร์สเป็คทีฟ เมื่อใช้โปรเจ็กเตอร์หน้าจอ";
// Trial version has a limited number of undo
alert.state.trial = "เวอร์ชันทดลอง เลิกทำรายการที่ยกเลิกแล้ว";

background = "พื้นหลัง";
// A flat color will be displayed in the background of the scene
background.color = "คัลเลอร์";
// The environment (HDRI) will be displayed in the background
background.environment = "สภาพแวดล้อม";
background.blur = "เบลอ";
background.exposure = "การเปิดรับแสง";

// Image that the artist uses as a reference
background.imageEnable = "ภาพอ้างอิง";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "โอเวอร์เลย์";
// Opposite of transparency (Alpha)
background.imageAlpha = "ความทึบ";
background.imageReset = "รีเซ็ตการตั้งค่า";
background.imageTransform = "ปรับแต่ง";
// X screen coordinate of the image reference
background.imageX = "ตำแหน่ง X";
// Y screen coordinate of the image reference
background.imageY = "ตำแหน่ง Y";
// Rotation of the reference image
background.imageRotation = "การหมุน";
// Scale of the reference image
background.imageScale = "สเกล";

// Camera (point of view in 3d)
camera = "กล้อง";
// Copy the views
camera.updateView = "อัพเดทมุมมอง?";
// Add a new camera
camera.addView = "เพิ่มมุมมอง";
// Focus on the camera
camera.focus = "โฟกัส";
// Add on the camera camera
camera.focusOn = "โฟกัสที่ $0";
// Camera projection, Orthographic or Perspective
camera.projection = "การฉายภาพ";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "ออร์โทกราฟฟิก";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "เพอร์สเปกทีฟ";
// camera Vertical Field of View
camera.fov = "Fov แล้วตั้ง";
// Camera Field of View hint
camera.focal = "โฟกัส $0มม. (เซนเซอร์ 35 มม.)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "การหมุน";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "แท่นหมุน";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "แทร็กบอล";
camera.rotation.trackball.help = "แทร็กบอลให้อิสระในระดับที่มากขึ้น คุณยังสามารถหมุนกล้องด้วย 2 นิ้วได้อีกด้วย";
// Camera interaction mode, 1st person view
camera.firstPerson = "บุคคลแรก";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "ความเร็ว";
// Camera rotation sensitivity
camera.speed.rotation = "การหมุน";
// Camera translation sensitivity
camera.speed.panning = "การแพน";
// Camera zooming sensitivity
camera.speed.zooming = "การซูม";
// Reset camera position
camera.resetView = "รีเซ็ตมุมมอง";
// Align the view (snap to nearest 90° angle)
camera.snapView = "มุมมองแบบสแนป";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "กล้องถูกสแน็ป (ออร์โธกราฟิก)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "สแนปแบบออร์โทกราฟฟิก";
camera.snapOrthographic.help = "ตัวเลือกนี้ยังคงทำงานอยู่เมื่อใช้สแนปคิวบ์ที่มุม";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "จุดหมุน";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "แตะสองครั้งที่ออบเจ็กต์";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "แตะสองครั้งที่พื้นหลัง";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "สลับ";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "การเลือก";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "ซีน";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "อัพเดทเมื่อแตะสองครั้ง";
camera.doubleTapPivot.help = "จะอัพเดทจุดหมุนเมื่อแตะสองครั้งบนพื้นผิวของออบเจ็กต์";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "จุดหมุนลอย";
camera.airPivot.help = "ให้ตั้งจุดหมุนใหม่แม้ในขณะที่ซูมออกนอกพื้นผิวออบเจ็กต์";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "ในกล้องการควบคุมด้วยท่าทางจะเริ่ม";
camera.autoPivot.help = "อัพเดทจุดหมุนเมื่อคุณเริ่มโต้ตอบกับกล้อง";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "โฟกัส";
camera.doubleTapFocus.help = "เมื่อแตะสองครั้งที่ออบเจ็กต์ กล้องจะเลื่อนและโฟกัสที่จุดที่เลือก";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "การเลือกหลายรายการ";
// There is 0 nodes/items selected
context.noSelection = "ไม่มีการเลือก";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "พรีเซ็ต";
// Quick curve x side shift
curve.shift = "";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "แคทมูลรอม";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "สลัก";
// Regular spaced sampling
curve.uniform = "";
curve.uniform.help = "";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "";

// Set the desired FPS (frame per second, refresh rate)
debug.targetFPS = "";
debug.targetFPS.help = "";

// Debug option, the newly created primitives will contains texture coordinates (UVs)
debug.uvPrimitive = "รักษาค่า UV ของรูปทรงพื้นฐาน";
debug.uvPrimitive.warning = "ปิดใช้งานตัวเลือกนี้หากคุณไม่ต้องการ UVs (หน่วยความจำเพิ่มเติม)";
debug.uvPrimitive.help = "สำหรับตอนนี้รองรับเฉพาะบ็อกซ์และสเฟียร์

จะรองรับประเภทอื่นๆ ได้ในอนาคต";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "ปรับ UVs ให้เป็นปกติ";
debug.uvNormalize.help = "Nomad จะทำให้ UVs ภายในไทล์ [0-1] เป็นปกติ";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "เพิ่ม BFF UVs";
debug.uvBFF.help = "เพิ่มวิธีการคำนวนแบบอื่น (ทำให้ขอบแบนก่อน)

โปรดทราบว่า BFF จะทับซ้อนกันหากโครงสร้างหรือโทโพโลยีของเมชของคุณแตกต่างจากดิสก์หรือสเฟียร์";

debug.quadriflow = "";
debug.quadriflow.help = "";


// Debug option, display an window with some debugging logs
debug.logs = "บันทึก";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "แผนที่ความสูง";
// Debug options, graphical stuffs
debug.graphics = "กราฟฟิก";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "สร้างภาพขนาดย่อของสโตร์";

// Empty list: there is no projects
file.project.empty = "คุณยังไม่มีโปรเจกต์ที่บันทึกไว้!";
// The current opened project has some unsaved changes
file.project.unsaved = "การเปลี่ยนแปลงที่ไม่ได้บันทึก!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "การเปลี่ยนแปลงที่ไม่ได้บันทึกจะหายไป";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "ดูตัวอย่างการบันทึกด้วยตนเองล่าสุด";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "เวอร์ชันทดลอง: คุณจะไม่สามารถเปิดโปรเจ็กต์ปัจจุบันได้อีกครั้ง!";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "เวอร์ชันทดลอง: คุณสามารถเปิดโปรเจ็กต์ปัจจุบันได้เท่านั้น!";

file.project = "โปรเจ็กต์";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "บันทึก";
// E.g: Save "my_project"?
file.project.save.confirm = "บันทึก$0?";
// Overwrite another project
file.project.saveAs = "บันทึกเป็น";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "เขียนทับ $0 หรือไม่?";
// Open a project
file.project.open = "เปิด";
// E.g: Open "my_project"?
file.project.open.confirm = "เปิด $0?";
// Load another project and add/append all its data to the current scene
file.project.add = "เพิ่มไปที่ซีน";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "เพิ่ม $0 ไปที่ซีน?";
// Reset the scene and create a new project
file.project.new = "ใหม่";
file.project.new.confirm = "สร้างซีนใหม่?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "ลบ $0?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "ลบ $0?

นี่คือโปรเจ็กต์ที่ใช้งานอยู่ในปัจจุบัน!";

// Auto save section
file.project.autoSave = "บันทึกอัตโนมัติ";
file.project.autoSave.confirm = "ปิดการบันทึกอัตโนมัติ?";
file.project.autoSave.help = "บันทึกโปรเจกต์ของคุณเป็นไฟล์แยกในช่วงเวลาปกติ
ไฟล์บันทึกอัตโนมัติสามารถพบได้ใน

$0";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "หมดเวลาป๊อปอัพ";
// In minutes
file.project.autoSave.minutes = "ป๊อปอัพตัวจับเวลา";
// Delete the current autoSave data
file.project.autoSave.delete = "ลบบันทึกอัตโนมัติ?";

// color space (linear or srgb), do not translate linear/srgb if there is a doubt
file.colorSpace = ""
file.colorSpace.help = "";
file.colorSpace.linear = "";
file.colorSpace.srgb = "";

// Configure imports option
file.importSettings = "นำเข้าตัวเลือก";

// Load interface preference settings when opening a scene file
file.import.guiSettings = "เก็บการตั้งค่า gui";
file.import.guiSettings.help = "เมื่อเปิดหรือนำเข้าไฟล์โปรเจ็กต์ การตั้งค่าที่เกี่ยวข้องกับ gui ทั้งหมดที่ฝังอยู่ในโปรเจ็กต์จะถูกโหลด";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.import.objSplitByGroup = "แยก OBJ ตามกลุ่ม";
file.import.objSplitByGroup.help = "เมื่อเปิดใช้งาน Nomad จะแบ่งกลุ่ม OBJ ออกเป็นอ็อบเจ็กต์แยกกัน";
// Merge all the object layers at when loading a file (deleting them in the process)
file.import.mergeLayers = "รวมเลเยอร์";
// Ignore the textures present in the file to load
file.import.skipTextures = "ข้ามพื้นผิว";
// Do not fiddle with the object topology when loading the file
file.import.keepTopology = "เก็บโทโพโลยี";
file.import.keepTopology.help = "ใช้ตัวเลือกนี้หากคุณไม่ต้องการให้ Nomad จัดการกับโทโพโลยีของเมชที่นำเข้า

จะปิดใช้งานการจัดลำดับใหม่จุดยอด/เฟส การลบจุดยอด/เฟสที่ซ้ำกัน และการลบจุดยอดที่ไม่ได้ใช้";


// Import file section
file.import.title = "นำเข้า";
file.import.title.help = "ฟอร์แมตที่รองรับ
- Wavefront (.obj)
- glTF 2.0 (.glb .gltf)
- STL (.stl)";
// The user imports a scene file that will replace the current scene
file.import.open = "เปิด";
file.import.open.confirm = "นำเข้าไฟล์ใหม่?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "เพิ่มไปที่ซีน";
file.import.add.confirm = "นำเข้าไฟล์ใหม่?";

// Export scene file
file.export.title = "นำออก";

// Export the current selected objects instead of the entire scene
file.onlySelection = "รวมเฉพาะออบเจ็กต์ที่เลือก";
file.onlySelection.help = "รวมเฉพาะส่วนที่เลือก แทนที่จะเป็นทั้งซีน";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "สร้างรูปสี่เหลี่ยมขึ้นใหม่";
file.convertToQuad.help = "สร้างรูปสี่เหลี่ยมขึ้นใหม่จากสามเหลี่ยมโดยจับคู่สามเหลี่ยม (หากอยู่ติดกันในไฟล์)";

// Whether we include the textures in the exported file
file.export.texture = "พื้นผิว";
// Baking means transfering/converting
file.export.texture.help = "ตัวเลือกนี้ไม่เบคสีของจุดยอดลงในพื้นผิว";
// Whether we include normals vector in the exported file
file.export.normal = "แนวฉาก";
file.export.normal.help = "เลือกตัวเลือกนี้หากคุณต้องการเปิดไฟล์ในซอฟต์แวร์อื่น

Nomad จะไม่สนใจแนวฉากเหล่านี้เพราะระบบจะคำนวณใหม่";

file.export.nomad = "";
file.export.nomad.help = "";

file.export.gltf = "นำออก glTF 2.0";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "เลเยอร์";
file.export.gltf.layer.help = "นำออกเลเยอร์เป็นมอร์ฟ รองรับอย่างเป็นทางการโดย glTF ดังนั้นจึงใช้งานได้บนซอฟต์แวร์อื่นด้วยเช่นกัน";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "การวาดเลเยอร์";
file.export.gltf.layerPaint.help = "นำออกการวาดลงสีเลเยอร์ มักจะถูกละเว้นโดยซอฟต์แวร์อื่น";
// Whether we include the vertex color in the exported file
file.export.gltf.color0 = "สีของวอร์เท็กซ์";
file.export.gltf.color0.help = "นำออกสีของจุดยอด รองรับอย่างเป็นทางการโดย glTF ดังนั้นจึงใช้งานได้บนซอฟต์แวร์อื่นด้วยเช่นกัน";
// Whether we include the vertex roughness and vertex metalness in the exported file
file.export.gltf.color1 = "การวาด pbr";
file.export.gltf.color1.help = "นำออกความหยาบ ความเป็นโลหะ และการวาดลงสีส่วนที่มาส์ก การดำเนินการนี้จะถูกละเว้นโดยซอฟต์แวร์อื่น";

file.export.obj = "นำออก OBJ";
file.export.obj.warning = "เลเยอร์และการวาดลงสีเพิ่มเติม (ความหยาบ ความเป็นโลหะและมาส์ก) จะหายไป";
// Whether we include the vertex color in the exported file
file.export.obj.colorAppend = "สีของวอร์เท็กซ์";
file.export.obj.colorAppend.help = "ผนวกข้อมูลสีหลังจุดยอด

ซอฟต์แวร์ 3D บางตัวจะสามารถอ่านได้ แต่ไม่ใช่ทั้งหมด";
file.export.obj.colorHexa = "";
file.export.obj.colorHexa.help = "";

file.export.stl = "นำออก STL";
file.export.stl.warning = "เลเยอร์และการวาดลงสีเพิ่มเติม (ความหยาบ ความเป็นโลหะและมาส์ก) จะหายไป";
// Whether we include the vertex color in the exported file
file.export.stl.color = "สีของวอร์เท็กซ์";
file.export.stl.color.help = "ซอฟต์แวร์ 3D บางตัวจะสามารถอ่านได้ แต่ไม่ใช่ทั้งหมด";
file.export.stl.ascii = "โดยค่าเริ่มต้น ฟอร์แมตจะเป็นแบบไบนารี

คุณสามารถเลือกที่จะนำออกเป็นฟอร์แมตข้อความ (ASCII) ได้ แต่ไฟล์จะใหญ่กว่า";

// Advanced settings
settings.advanced = "ขั้นสูง";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "ตัวเลือกเหล่านี้ไม่ถูกบันทึกไว้ในการตั้งค่า";
settings.reset.title = "การตั้งค่า";
settings.reset.title.help = "จะรีเซ็ตการตั้งค่ากำหนดแอป

ทรัพยากรบางอย่างจะถูกบันทึกแยกต่างหากและจะไม่ถูกรีเซ็ตอันได้แก่
- โปรเจ็กต์
- การผูกกุญแจ
- เครื่องมือที่ตั้งไว้ล่วงหน้า
- สภาพแวดล้อม HDRs 
- MatCaps
- อัลฟ่า
- พื้นผิว (แปรง)
- รูปภาพอ้างอิง

โปรดทราบว่าทุกอย่างที่เชื่อมโยงกับโพรเจ็กต์จะยังคงอยู่เหมือนเดิม เช่น การจัดแสง โพสต์โพรเซส มุมมองกล้อง ฯลฯ";

// Reset preference settings button
settings.reset = "รีเซ็ตเป็นค่าเริ่มต้น";
settings.reset.confirm = "รีเซ็ตการตั้งค่ากำหนด";

// Render a screenshot of the scene
file.render = "เร็นเดอร์";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "แสดงอินเตอร์เฟซ";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "อัตราส่วนของเร็นเดอร์";
file.render.renderRatio.help = "ค่า 1.0 หมายความว่า Nomad จะสร้างภาพที่ความละเอียดเดียวกันกับขนาดภาพที่ต้องการด้านล่าง

ใช้ตัวเลือกนี้หากคุณไม่สามารถสร้างได้ที่ความละเอียดที่แน่นอนได้ (หยุดทำงานเนื่องจากหน่วยความจำไม่เพียงพอ)";
// Desired size of the exported screenshot
file.render.size = "ขนาดสุดท้าย";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "กำหนดเอง";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "สกรีน";
// width of exported screenshot
file.render.width = "กว้าง";
// height of exported screenshot
file.render.height = "สูง";
// export screenshot of the scene
file.render.export = "นำออก png";
file.render.warn = "การนำออกมีค่าความละเอียดสูง ($0x$1)!

อย่าลืมบันทึกโปรเจ็กต์ของคุณในกรณีที่อุปกรณ์ที่คุณใช้ไม่มี VRAM และเกิดปัญหา";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "พื้นหลังโปร่งใส";
file.render.transparent.help = "ตัวเลือกนี้จะมีประโยชน์เมื่อคุณต้องการใส่เมชในซอฟต์แวร์สร้าง 2D

ในขณะนี้ไม่รองรับความโปร่งใสของออบเจ็กต์บางส่วน";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "ใช้การตั้งค่ากลาง";
pressure.useGlobal.help = "โดยค่าเริ่มต้น เครื่องมือจะใช้การตั้งค่าแรงกดเดียวกัน

ยกเลิกการเลือกตัวเลือกนี้หากคุณต้องการตั้งค่าแรงกดเฉพาะสำหรับเครื่องมือนี้";

// Pencil pressure
pressure.title = "แรงกด";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "เครื่องมือนี้ไม่ใช้แรงกดดินสอ";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "ประเภทของเส้นที่วาดที่เลือกไว้จะไม่มีผลต่อการตั้งค่าแรงกด";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "รัศมี";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "ความเข้ม";
// Average pencil pressure event to get smoother result
pressure.average = "";
pressure.average.help = "";

// list of inputs allowing camera interaction
gesture.camera = "กล้อง";
// list of inputs allowing sculpting interaction
gesture.sculpt = "แกะสลัก";
// Finger/Touch input
gesture.finger = "นิ้ว";
// Stylus/Pencil
gesture.stylus = "สไตลัส";
// Mouse/Trackpad
gesture.mouse = "";

// long press to pick the color/material under the cursor
gesture.dropper = "การเลือกวัสดุ";
gesture.dropper.help = "การเลือกสี/วัสดุสามารถเปิดใช้งานได้ด้วยการกดค้างบนแคนวาส

โปรดทราบว่าใช้งานได้เฉพาะเมื่อแปรงปัจจุบันเปิดใช้งานการระบายสี";

// Three fingers on screen
gesture.three.title = "สามนิ้ว";
// Drag 3 fingers horizontally on the canvas to rotate the environment, lights and MatCap
gesture.fingerLighting = "หมุนแสง (3 นิ้ว)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerLighting.help = "ลาก 3 นิ้วในแนวนอนบนแคนวาสเพื่อหมุนสภาพแวดล้อม แสงและ MatCap";
// Drag 3 fingers vertically to edit the tool radius
gesture.fingerRadius = "แก้ไขรัศมีเครื่องมือ (3 นิ้ว)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerRadius.help = "ลาก 3 นิ้วในแนวตั้งบนแคนวาสใบเพื่อแก้ไขรัศมีของเครื่องมือ";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.fingerSmooth = "นิ้วเรียบเสมอ";
gesture.fingerSmooth.help = "";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "ให้ใช้แรงกดที่ไม่รู้จัก";
gesture.unknownPressure.help = "เลือกตัวเลือกนี้หากใช้งานแรงกดไม่ได้กับ Pencil ของคุณ หรือหากต้องการใช้นิ้วกด";

// Action when we press an Android pencil button
gesture.pencilAction.android = "ปุ่ม Pencil";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "แตะสองครั้งที่ Pencil";
gesture.pencilAction.ios.help = "ใช้งานได้กับ Apple Pencil รุ่นที่ 2 เท่านั้น";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "ไม่มี";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "เพิ่ม/ย่อย";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "ทางลัดหนึ่งแตะ";
gesture.mask.oneTap.help = "เปิดใช้ทางลัดมาส์ก โดยแตะที่หน้าจอหนึ่งครั้ง โดยไม่ต้องกดทางลัดมาส์กค้างไว้

ด้วยท่าทางต่อไปนี้:
- แตะที่พื้นหลังเพื่อพลิกส่วนที่มาส์ก
- แตะที่พื้นที่มาส์กเพื่อเบลอการมาส์ก
- แตะที่พื่นที่ไม่ได้มาส์กเพื่อทำให้ส่วนที่มาส์กชัดเจนขึ้น";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress = "กดแช่ (มาส์ก ↔ SelMask)";
gesture.mask.holdStroke = "วาดเส้น";
gesture.mask.holdStroke.help = "";
gesture.mask.holdIdle = "เครื่องมือ";
gesture.mask.holdIdle.help = "";

// Shortcut customization, choose the action that the shortcut will performan (select tool, etc)
gesture.shortcut = "ทางลัด";

// Shortcuts to undo/redo
gesture.history = "ทางลัดรายการเลิกทำและทำซ้ำ";
gesture.history.help = "- เลิกทำ แตะด้วย 2 นิ้ว
- ทำซ้ำ แตะด้วย 3 นิ้ว
- เลิกทำ/ทำซ้ำ แตะค้าง 2/3 นิ้ว (ต่อเนื่อง)";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "วางฝ่ามือได้";
gesture.palmRejection.confirm = "อย่าลืมปิดการใช้งานตัวเลือกนี้หากคุณมีปัญหาในการใช้งานแคนวาส!";
gesture.palmRejection.help = "ปฏิเสธอินพุตหากพื้นที่ที่สัมผัสมีขนาดใหญ่กว่าค่านี้

อาจจะใช้งานไม่ได้กับทุกอุปกรณ์";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "เกณฑ์ขนาดสูงสุด";

// History, list of undo/redo
history = "ประวัติ";
// First "undo" state
history.root = "เริ่ม";
history.undoConfirm = "คุณยืนยันการยกเลิกการดำเนินการทั้งหมดเหล่านี้หรือไม่";
history.undoWarning = "หากคุณทำการแก้ไขในภายหลัง คุณอาจสูญเสียการเปลี่ยนแปลงหลายรายการ";
// Settings concerning the history stack of undo/redo
history.stack = "กอง";
// Actions to include in the undo/redo stack
history.include = "ได้แก่ การดำเนินการ";
// include lighting editing in the undo/redo
history.includeLights = "แสง";
history.includeLights.help = "หากปิดตัวเลือกนี้ การย้ายแสงด้วยกิซโม่จะยังรวมอยู่ด้วย เนื่องจากอาจส่งผลต่อออบเจ็กต์อื่นๆ ในลำดับชั้นของซีน";
// include postProcess editing in the undo/redo
history.includePostProcess = "PostProcess";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCaps & HDRIs";
// Can limit the stack of undo/redo size
history.limitSize = "ข้อจำกัดรายการประวัติ (Mb)";
history.limitSize.help = "ขนาดสูงสุด (เป็น Mb) ของประวัติ

รายการประวัติจะได้รับการอัพเดทในการดำเนินการที่บันทึกไว้ในครั้งต่อไป";
// Limit the number of undo in the history stack
history.limitStack = "ข้อจำกัดของกอง";
history.limitStack.help = "จำนวนรายการดำเนินการที่แอปพลิเคชันสามารถเก็บไว้ได้สูงสุด

จะอัพเดทประวัติการดำเนินการที่บันทึกไว้ในครั้งต่อไป";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "จำนวนสูงสุดของการเลิกทำ";
history.rangeProtect.help = "หากคุณย้อนกลับไปไกลในรายการประวัติการเลิกทำ จะต้องยืนยันกับระบบก่อนว่าต้องการเลิกทำรายการทั้งหลายเหล่านั้น";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "คืนค่ากล้อง";
history.restoreCamera.help = "เปิดใช้งานตัวเลือกนี้เพื่อกู้คืนมุมมองกล้องที่บันทึกไว้เมื่อคุณเลิกทำ/ทำซ้ำรายการนี้";
// Undo
history.undo = "เลิกทำ";
// Redo
history.redo = "ทำซ้ำ";
// Shown during undo
history.state.undo = "เลิกทำ $0";
// Shown during redo
history.state.redo = "ทำซ้ำ $0";
// Shown during undo/redo
history.state.symmetrySplit = "การแยกส่วนสมมาตร";
// Shown during undo/redo
history.state.voxelRemesh = "รีเมชว็อกเซล";
// Shown during undo/redo
history.state.surfaceRemesh = "รีเมชพื้นผิว";
// Shown during undo/redo
history.state.multiresLevel = "การเปลี่ยนแปลงของความละเอียด";

// Debugging/Inspect object material (view channel separately color, roughness, normal, uv, etc)
inspector = "";
// Inspector but SHORT
inspector.short = "";
// Display the material channel on the background
inspector.onBackground = "";
// Display the material channel on the mesh
inspector.onMesh = "";

// Interface customization
interface = "อินเตอร์เฟซ";

// UI customization: one item row will stands on one line (synonym: Inlined)
interface.compact = "";

// UI customization: each row of the list will be bigger
interface.expandList = "UI ขยายรายการ";
// UI customization: each row of the list will be bigger
interface.expandList.help = "เฉพาะตัวเลือก UI เพื่อการจัดการรายการได้ง่ายขึ้น";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "เพิ่มทางลัด (ล่าง)...";

// Interface option (main base color)
interface.colorBase = "ฐานสี";
// Interface option (accent widget color)
interface.colorSelect = "วิดเจ็ตสี";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "พาเนลโปร่งใส";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "ค่าความเบลอ";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "พาเนลสี";

// Interface color style
interface.preset.title = "พรีเซ็ตสี";
// Interface color style (original color of Nomad Sculpt)
interface.preset.classic = "คลาสสิก";
// Interface color style
interface.preset.orange = "ส้ม";
// Interface color style (~red)
interface.preset.cardinal = "แดงเข้ม";
// Interface Color style (~pink)
interface.preset.mulberry = "แดงลูกหม่อน";
// Interface color style
interface.preset.brown = "น้ำตาล";
// Interface color style (~green)
interface.preset.emerald = "เขียวมรกต";
// Interface color style (~blue)
interface.preset.neon = "Neon";
// Interface color style
interface.preset.violet = "ม่วง";
// Interface color style
interface.preset.gray = "เทา";
// Interface color style
interface.preset.black = "ดำ";
// Interface color style
interface.preset.white = "ขาว";

// Reset interface settings
interface.resetAll = "รีเซ็ตสไตล์";
interface.resetAll.confirm = "รีเซ็ตการตั้งค่าอินเตอร์เฟซ?";
// Interface option (main base color)
interface.iconSupport = "";
interface.iconSupport.help = "";
// Interface customization
interface.flipTop = "มิเรอร์แถบด้านบน";
// Interface customization
interface.flipBottom = "มิเรอร์แถบด้านล่าง";
// Interface customization
interface.flipMiddle = "มิเรอร์แถบด้านข้าง";
// Interface customization (preview material in the viewport when editing material color)
interface.materialPreview = "พรีวิวสีวัสดุ";
// Interface customization
interface.materialPreview.help = "เมื่อคุณเลือกสีสำหรับวัสดุ การแสดงตัวอย่างของวัสดุนี้จะแสดงบนออบเจ็กต์ที่เลือกในปัจจุบัน";
interface.toolbox.hide = "ซ่อนกล่องเครื่องมือ";
interface.toolboxHide.help = "เปิดใช้งานตัวเลือกนี้หากคุณต้องการซ่อนกล่องเครื่องมือ";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.maxColumn = "กล่องเครื่องมือแถวคอลัมน์สูงสุด";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "รีเซ็ตลำดับกล่องเครื่องมือ";
// Scale the interface
interface.scale = "ขนาดโดยรวม";
// Spacing between widgets
interface.cursorStep = "ระยะแนวตั้ง";
// Width of the interface panels
interface.panelWidth = "ความกว้างของพาเนล";
// Size of fonts
interface.fontScale = "ขนาดของฟอนต์";
// Inset
interface.inset.title = "ออฟเซ็ตของขอบ";
interface.inset.title.help = "คุณสามารถเปลี่ยนค่าเหล่านี้ได้ก็ต่อเมื่อคุณมีปัญหาในการโต้ตอบกับปุ่มที่ขอบหน้าจอ

หากตัวเลื่อนถูกปิดใช้งาน Nomad จะใช้ค่าพื้นที่ปลอดภัยที่กู้กลับมาด้วยเครื่องอุปกรณ์นี้เอง";

// (see Glossary for Layer)
layer = "เลเยอร์";
// (see Glossary for Layer)
layers.lock = "เก็บเลเยอร์บนสุดไว้เหมือนเดิม";
// (see Glossary for Layer)
layers.lock.yes = "ล็อคเลเยอร์บนสุด?";
// (see Glossary for Layer)
layers.lock.warning = "ในระหว่างการปั้น การเสียรูปที่มาจากเลเยอร์บนสุดจะถูกละเว้น

อย่างไรก็ตาม รายละเอียดของเลเยอร์เหล่านี้จะยังคงปรากฏให้เห็น

ตัวเลือกนี้ใช้ได้เฉพาะเมื่อเลเยอร์บนสุดมีรายละเอียดขนาดค่อนข้างเล็ก";
// (see Glossary for Layer)
layers.addLayer = "เพิ่มเลเยอร์";
// (see Glossary for Layer)
layer.factors = "แฟกเตอร์ของช่อง";
// (see Glossary for Layer)
layer.factor = "แฟกเตอร์";
// (see Glossary for Layer)
layer.offset = "ออฟเซ็ต";
// (see Glossary for Layer)
layers.title = "เลเยอร์";
// (see Glossary for Layer)
layers.title.help = "เลเยอร์สามารถบันทึกตำแหน่งออฟเซ็ตและการระบายสี ซึ่งจะเป็นประโยชน์สำหรับเวิร์กโฟลว์ที่ไม่ใช่เชิงเส้น
ตัวอย่างเช่น โดยการทดลองการแสดงออกทางสีหน้าต่างๆ โดยไม่ต้องอาศัยสแต็กรายการประวัติเพื่อเลิกทำการเปลี่ยนแปลง

สำหรับข้อมูลการวาดภาพ เลเยอร์จะถูกจัดเรียงแบบบนลงล่าง ดังนั้นเลเยอร์บนจะมาส์กชั้นล่าง

คุณสามารถลบบางส่วนหนึ่งของเลเยอร์ (นั้นคือ ผลกระทบอื่นๆ ของเลเยอร์ด้วย) โดยใช้เครื่องมือ 'DelLayer'";
layers.primitive = "เลเยอร์ไม่พร้อมใช้งานสำหรับรูปทรงพื้นฐาน";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "ไม่มี";

light = "แสง";
// Intensity of light
light.intensity = "ความเข้ม";
// Kelvin (the temperature unit)
light.kelvin = "";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "อุณหภูมิ";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "การผนวก";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "อยู่กับที่";
// The light will move along the camera
light.attachment.camera = "กล้อง";
light.attachment.help = "-- อยู่กับที่
การวางแนวแสงจะไม่เปลี่ยนแปลง

-- กล้อง
การวางแนวแสงขึ้นอยู่กับมุมมองของกล้อง";
// Light type (directional, spot, point)
light.type = "ชนิด";
// Directional light (synonym: sun light)
light.type.directional = "ทิศทาง";
light.type.directional.short = "";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "สปอต";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "จุด";
// Cone angle for spot angles
light.spot.angle = "มุมกรวย";
// Softness of the spot light
light.spot.softness = "ความนุ่ม";
// Position of the light
light.position = "ตำแหน่ง";
// Enable or disable shadows for a light
light.shadow.cast = "เงา";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "จุดของแสงรองรับเฉพาะเงาของพื้นที่หน้าจอ";
light.shadow.type = "ชนิดของเงา";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "แผนที่เงา";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "พื้นที่หน้าจอ";
light.shadow.type.screenspace.help = "คุณลักษณะทดลอง อาจถูกลบออกในรุ่นต่อๆ ไป

ตัวเลือกนี้มีไว้สำหรับใช้กับคุณสมบัติเงาที่นุ่มนวล";
// Adjustment to fix artefacts
light.shadow.bias = "เอน";
// How blurry the shadow is
light.shadow.softness = "ความนุ่ม";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "สัมผัส";
light.contact.help = "ถ้าเลือกเป็นอัตโนมัติ เฉพาะแสงที่โดดเด่นที่สุดเท่านั้นที่จะมีเงาสัมผัส";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "เกณฑ์การยอมรับ";
// Activated the light
light.visible = "แสดง";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "รีเซ็นเตอร์";

// Object's material
material = "วัสดุ";
// See glossary
material.pbrRoughnessMetalness.warning = "ความหยาบและความเป็นโลหะต้องใช้โหมดแรเงา PBR";
// See glossary
material.pbrReflectance.warning = "การสะท้อนต้องใช้โหมดแรเงา PBR";
// See glossary
material.pbrRefraction.warning = "การหักเหของแสงต้องใช้โหมดแรเงา PBR";
// See glossary
material.pbrSubsurface.warning = "พื้นผิวต้องใช้โหมดแรเงา PBR";
// Value that says how much light will change direction when hitting the surface
material.ior = "ค่าดัชนีหักเห";
// an object-level value that overrides the painting of the mesh
material.paintingOverride = "แทนที่ภาพวาด";
// The roughness in the inside is turbidity
material.paintingOverride.help = "สามารถปรับความหยาบได้สองแบบคือ แบบที่อยู่บนพื้นผิวและด้านใน

อย่างไรก็ตาม มีความหยาบที่ลงสีได้เพียงแบบเดียว ดังนั้นความหยาบทั้งสองจึงมีค่าเท่ากัน

คุณสามารถใช้แถบเลื่อนนี้เพื่อแทนที่ความหยาบของพื้นผิวซึ่งจะทำให้มีความมันวาวมากขึ้น";
// Glossiness is simply the opposite of roughness
material.refractionSurfaceGlossiness = "ความมันวาวของพื้นผิว";
material.refractionSurfaceGlossiness.help = "- ที่ 0 พื้นผิวใช้ความหยาบที่ทาสี
- ที่ 1 พื้นผิวเรียบสนิท";
// Synonym: turbidity
material.refractionInteriorRoughness = "ความหยาบภายใน";
material.refractionInteriorRoughness.help = "- ที่ 0 ภายในใช้ความหยาบที่ลงสี
- ที่ 1 ภายในหยาบโดยสิ้นเชิง";
// Set the roughness of the object with a value of 0
material.paintGlossy = "เคลือบเงา";
material.paintGlossy.help = "จะทาสีออบเจ็กต์ด้วยความหยาบและความเป็นโลหะค่าเป็น 0 ซึ่งช่วยให้การหักเหที่คมชัด

สิ่งนี้เหมือนกับการทำงานในเมนูการระบายสีและการใช้คุณสมบัติการระบายสีทั้งหมดและความเป็นโลหะที่ถูกปิดใช้งาน";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "การกลืน";
material.absorptionEnable.help = "การจำลองแสงที่ถูกดูดกลืนเมื่อส่องผ่านปริมาตร

บริเวณส่วนที่บางจะสว่างเพราะแสงส่องผ่านได้มากกว่า ส่วนบริเวณที่หนาจะมืดกว่า

เอฟเฟกต์จะขึ้นอยู่กับรูปร่างของวัตถุเสียส่วนใหญ่ โดยใช้การประมาณความหนาของวัตถุเท่านั้น";
material.absorptionFactor = "แฟกเตอร์";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "ความลึก";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "ความโปร่งแสง";
material.translucency.help = "คุณต้องมีแสงที่ส่องเงาจึงจะมองเห็นความโปร่งแสงได้";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "ความทึบ";
// Fully opaque material
material.type.opaque = "ทึบแสง";
// See glossary
material.type.subsurface = "ใต้พื้นผิว";
material.type.subsurface.help = "เพื่อให้ได้ผลลัพธ์ที่ดีที่สุด คุณสามารถเปลี่ยนไปใช้โหมดแรเงา PBR และใช้แสงส่องทิศทางอย่างน้อยหนึ่งดวง ซึ่งเหมาะกับสภาพแวดล้อมที่มืด";
// Transparency mode, alpha blending
material.type.blending = "การเบลนด์";
material.type.blending.help = "ทำให้ออบเจ็กต์กึ่งโปร่งแสงโดยปรับแต่งค่าความทึบ

โปรดทราบว่าเนื่องจากข้อจำกัดแบบเรียลไทม์ คุณสามารถมีภาพหลอกที่มองเห็นได้ชัดเจนหากวัตถุของคุณมีรูปร่างที่ซับซ้อน";
// Transparency mode
material.type.additive = "เติมแต่ง";
material.type.additive.help = "ทำให้ออบเจ็กต์กึ่งโปร่งแสงโดยปรับแต่งค่าความทึบ

วิธีนี้มีแนวโน้มที่จะมีภาพหลอกน้อยกว่าวิธีการผสม แต่ออบเจ็กต์จะสว่างกว่า";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "การรวมจุดสี";
material.type.dithering.help = "ทำให้ออบเจ็กต์กึ่งโปร่งแสงโดยลบพิกเซลบางส่วนแบบสุ่ม";
// Simulate glass-like material
material.type.refraction = "การหักเห";
material.type.refraction.help = "โหมดนี้สามารถใช้จำลองวัสดุแก้วได้

เนื่องจากข้อจำกัดตามเวลาจริง การหักเหตนเองหรือการหักเหของแสงหลายชั้นจึงถูกจำกัด";
material.castShadows = "ทอดเงา";
material.receiveShadows = "รับเงา";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "ไม่สว่างเสมอ";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "การคัดทิ้งส่วนตรงข้าม";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "การสะท้อนแสง";
material.reflectance.help = "ควบคุมปริมาณการสะท้อนที่วัสดุจะได้รับสำหรับวัสดุที่ไม่ใช่โลหะ

ส่วนใหญ่แล้วควรใช้ค่าเริ่มต้น (ซึ่งสอดคล้องกับมาตรฐานแสงสะท้อน 4% ที่มุมปกติ)";

// Menu name
menu.files = "ไฟล์";
// Menu name
menu.scene = "ซีน";
// Menu name
menu.multires = "ความละเอียดหลายระดับ";
// Menu name
menu.voxel = "ว็อกเซล";
// Menu name
menu.dynTopo = "DynTopo";
// Menu name (Synonym: Misc, Other)
menu.topology = "";
// Menu name
menu.primitive = "รูปทรงพื้นฐาน";
// Menu name
menu.render = "เร็นเดอร์";
// Menu name
menu.material = "วัสดุ";
// Menu name
menu.postProcess = "PostProcess";
// Menu name
menu.camera = "กล้อง";
// Menu name
menu.background = "พื้นหลัง";
// Menu name
menu.tool = "เครื่องมือ";
// Menu name
menu.stroke = "วาดเส้น";
// Menu name
menu.alpha = "อัลฟ่า";
// Menu name
menu.filter = "";
// Menu name
menu.falloff = "สร้างเส้นโค้ง";
// Menu name
menu.paint = "ลงสี";
// Menu name
menu.symmetry = "สมมาตร";
// Menu name (pencil pressure)
menu.pressure = "แรงกด";
// Menu name
menu.gesture = "ท่าทาง";
// Menu name
menu.layers = "เลเยอร์";
// Menu name
menu.settings = "การตั้งค่า";
// Menu name
menu.interface = "อินเตอร์เฟซ";
// Menu name
menu.bindings = "การมัดรวม";
// Menu name
menu.history = "ประวัติ";
// Menu name
menu.historySettings = "การตั้งค่า";
// Menu name
menu.about = "เกี่ยวกับ";
// Menu name
menu.debug = "แก้จุดบกพร่อง";

// Operation on the object (action)
mesh.holes = "รู";
// If the object has holes, the algorithm will close them
mesh.holes.close = "ปิดรู";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holes.detail = "รายละเอียด";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "แยก";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "เลเยอร์ การวาดและความละเอียดหลายระดับจะหายไป";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "ความละเอียด";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "บังคับลูกบาศก์";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "แปลง";
// Static object means "static topology"
mesh.static = "ตาราง";
// See glossary
mesh.multires = "ความละเอียดหลายระดับ";
// Dynamic topology
mesh.dynamic = "DynTopo";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "วัสดุทั้งหมด";
paint.useGlobal.help = "หากเปิดใช้งานตัวเลือกนี้ วัสดุที่เลือกจะเหมือนกับเครื่องมืออื่นๆ

โปรดทราบว่าจะพิจารณาเฉพาะการตั้งค่าความหยาบ ความโลหะ และสีเท่านั้น";
// The current tool will paint the object if this option is enabled
paint.usePainting = "ภาพวาดลายเส้น";
// Factor/Opacity of paint tool
paint.intensity = "ความเข้มของการลงสี";
// Apply the paint on the object
paint.paintAll = "ทาสีทั้งหมด";
paint.paintAll.help = "นำวัสดุปัจจุบันไปใช้กับออบเจ็กต์

พื้นที่และช่องที่มาส์กไว้จะไม่ถูกลงสี";
// Apply the paint on the object but ignore painting intensity (force full intensity)
paint.paintAllForce = "บังคับระบายสีทั้งหมด";
paint.strokePainting.title = "ทาสี";
// Brush stroke texture
paint.texture.warningEnable = "ต้องเปิดใช้งานการวาดภาพลายเส้นเพื่อให้สามารถฉายพื้นผิวได้ (ช่องทำเครื่องหมายด้านบน)!";
paint.texture.warningIgnored = "เครื่องมือปัจจุบันไม่สามารถใช้พื้นผิวได้!";
// Whether the Brush Alpha will be used to modulate painting intensity
paint.useAlpha = "ใช้เส้นวาดอัลฟ่า";
paint.useAlpha.help = "ใช้ชุดอัลฟ่าในเมนูการวาดเส้นเพื่อปรับแต่งภาพวาด";
// Whether the Brush Falloff will be used to modulate painting intensity
paint.useCurve = "ใช้การทำเส้นโค้งลายเส้น";
paint.useFalloff.help = "ใช้ชุดทำเส้นโค้งในเมนูการวาดเส้นเพื่อปรับแต่งภาพวาด";
// Whether the Brush Randomize will be used to modulate painting intensity
paint.useJitter = "";
paint.useJitter.help = "";

// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "ชื่อใหม่";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "ค่าใหม่";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "สีใหม่ (ฟอร์แมต hex)";

// Post process effect
postprocess = "โพสต์โปรเซส";
// Quality vs performance
postprocess.quality = "คุณภาพ";
postprocess.quality.help = "เปิดใช้งานตัวเลือกเหล่านี้เพื่อปรับปรุงคุณภาพและความเสียหายของประสิทธิภาพ";
// More samples means better quality but slower performance
postprocess.maxSamples = "ตัวอย่างสูงสุด";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "ความละเอียดสูง";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "การสุ่มตัวอย่างเฟรมสูงสุด";
postprocess.accumulateCount.help = "จำนวนเฟรมสูงสุดที่จะสะสมก่อนการเร็นเดอร์จะหยุด

เมื่อการเร็นเดอร์หยุดลง Nomad จะหยุดการทำงานด้วย ซึ่งจะช่วยประหยัดแบตเตอรี่

คุณสมบัติหลายประการของการเร็นเดอร์ได้รับประโยชน์จากการสะสมเฟรม โดยเฉพาะอย่างยิ่ง
- ซอฟท์แชโดว์
- โกลบอลอินลูมิเนชัน
- การสะท้อนกลับ (SSR)
- แสงเงาระหว่างวัตถุในฉาก
- ใต้ผิว
- ความลึกของภาพ

จำนวนเฟรมที่สูงนั้นส่วนใหญ่จำเป็นสำหรับ Soft Shadows และ Global Illumination
Nomad สามารถหยุดการเรนเดอร์ได้เร็วกว่าโดยคุณสมบัติที่กล่าวไปแล้วข้างต้นจะถูกปิดใช้งาน";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "ความละเอียดการสร้างภาพ";
postprocess.renderRatio.warning = "แทนที่ด้วยเอฟเฟกต์ Pixel Art";
postprocess.renderRatio.help = "ตัวเลือกนี้ส่งผลต่อประสิทธิภาพอย่างมาก
ขอแนะนำให้รักษาค่าที่ต่ำกว่า x1.25

ตัวเลือกนี้จะไม่ถูกบันทึกในการตั้งค่า";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "เทคโนโลยีลบรอยหยัก (TAA)";
postprocess.taa.help = "ลดการกะพริบเมื่อคุณกำลังเคลื่อนกล้อง";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "การสะท้อนแสง (SSR)";
postprocess.ssr.warning = "SSR ต้องใช้โหมดแรเงา PBR";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "โกลบอลอินลูมิเนชัน (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "เกณฑ์การยอมรับ";
postprocess.ssgi.experimental = "ที่ทดลอง!";
postprocess.ssgi.warning = "SSGI ต้องใช้โหมดแรเงา PBR";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "แสงเงาระหว่างวัตถุในฉาก";
// How far the effect spreads
postprocess.ssao.radius = "ขนาด";
// How strong the effect is
postprocess.ssao.factor = "ความแข็งแรง";
// Adjustment to fix artefacts
postprocess.ssao.bias = "ความเอนของค่าความโค้ง";
postprocess.ssao.bias.help = "ความไวของเอฟเฟกต์นั้นขึ้นอยู่กับความโค้งของพื้นผิว";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "ความลึกของภาพ";
// The blur factor behind the focused point
postprocess.dof.blurFar = "เบลอไกล";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "เบลอใกล้";
postprocess.dof.focusTip = "แตะออบเจ็กต์เพื่อเปลี่ยนจุดโฟกัส";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "ฟุ้ง";
// Intensity of the effect
postprocess.bloom.intensity = "ความเข้ม";
// How far the effect spreads
postprocess.bloom.radius = "รัศมี";
postprocess.bloom.radius.help = "รัศมีความกว้างที่แสงกระจายออก";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "เกณฑ์";
postprocess.bloom.threshold.help = "เกณฑ์ความส่องสว่างเพื่อตัดสินใจว่าพิกเซลจะเปล่งแสงหรือไม่
หากค่าเป็น 0 ทุกอย่างจะเปล่งแสง";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "โทนแมพปิ้ง";
postprocess.tone.exposure = "การเปิดรับแสง";
postprocess.tone.contrast = "ความต่างระดับสี";
postprocess.tone.saturation = "ความอิ่มตัว";
// No tonemapping operator is used
postprocess.tone.mapping.none = "ไม่มี";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "เป็นกลาง";
// Color curves
postprocess.curve = "เกลี่ยสี";
// Curve for pixel luminance
postprocess.curve.luminance = "หลัก";
postprocess.curve.red = "แดง";
postprocess.curve.green = "เขียว";
postprocess.curve.blue = "น้ำเงิน";
// Reset color grading curves
postprocess.curve.resetAll = "รีเซ็ตทั้งหมด";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "ความพร่าสี";
postprocess.chromatic.factor = "ความแข็งแรง";
// Darking on the edges
postprocess.vignette = "วิกเน็ตต์";
// How far the effect spreads
postprocess.vignette.size = "ขนาด";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "ความหนัก";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "ความคมชัด";
postprocess.sharpness.factor = "ความแข็งแรง";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "เกรน";
postprocess.grain.factor = "ความแข็งแรง";
// Accentuate the edges of the model
postprocess.curvature = "ความโค้ง";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "โพรง";
// Color/Strength of convex curvature
postprocess.curvature.bump = "บัมพ์";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "พิกเซลอาร์ต";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "อนุญาตให้สุ่มตัวอย่างเฟรม";
// Simulate scanline rendering (horizonal line)
postprocess.scanline = "สแกนไลน์";
postprocess.scanline.factor = "แฟกเตอร์";
// Spacing between lines
postprocess.scanline.spacing = "การเว้นระยะห่าง";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "รูปทรงพื้นฐาน";
primitive.box = "กล่อง";
primitive.sphereCube = "สเฟียร์";
primitive.sphereUV = "UV สเฟียร์";
primitive.icosahedron = "ไอโคซาเฮดรอน";
primitive.cylinder = "ไซลินเดอร์";
primitive.cone = "โคน";
primitive.torus = "ทอรัส";
primitive.lathe = "กลึง";
primitive.tube = "ท่อ";
primitive.plane = "ระนาบ";
primitive.triplanar = "สามระนาบ";
primitive.faceXYZ = "เฟส XYZ";
primitive.faceXYZ.help = "ฐานเมชที่คำนวน UV ให้บริการโดย https://texturing.xyz/";
primitive.needValidate = "รูปทรงพื้นฐานควรได้รับการตรวจสอบเพื่อที่จะแกะสลัก";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "แก้ไข";
primitive.edit.help = "อนุญาตให้แก้ไข 3Dในวิวพอร์ต

คุณสามารถปิดใช้งานคุณลักษณะนี้ได้หากต้องการโต้ตอบกับ Gizmo หรือเครื่องมือปรับแต่ง โดยไม่ต้องแก้ไขของรูปทรงพื้นฐาน";

// Primitive configuration
primitive.mainConfig = "พารามิเตอร์";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "โทโพโลยี";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "เรขาคณิต";

// Validating the primitive (then it can be sculpted)
primitive.validate = "ตรวจสอบ";
// Maximum number of faces of the primitives
primitive.maxFaces = "จำนวนเฟสมากสุด";
primitive.maxFaces.help = "จำนวนเฟสสูงสุดที่รูปทรงพื้นฐานสามารถมีได้

ขีดจำกัดนี้ใช้งานได้เฉพาะในขณะที่รูปทรงพื้นฐานไม่ได้รับการตรวจสอบ หลังจากนั้นการป้องกันก็หายไป";
// Synonym: Flat subdivision
primitive.linear = "ซับดิวิชันเชิงเส้น";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "โพสต์ซับดิวิชัน";

// Radius (of a sphere, torus, etc)
primitive.radius = "รัศมี";
// Size (of cube x dimension)
primitive.size = "ขนาด";
primitive.sizeX = "ขนาด X";
primitive.sizeY = "ขนาด Y";
primitive.sizeZ = "ขนาด Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "การแบ่งแยก";
primitive.divisionX = "การแบ่ง X";
primitive.divisionY = "การแบ่ง Y";
primitive.divisionZ = "การแบ่ง Z";
// Angle of torus, etc
primitive.angleX = "มุม X";
primitive.angleY = "มุม Y";
primitive.angleZ = "มุม Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "ความหนาแน่นคงที่";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "โปรเจ็กต์บนทรงกลม";
primitive.projectOnSphere.help = "สแนปจุดบนสเฟียร์ที่สมบูรณ์แบบ";

// triplanar
primitive.triplanar.title = "สามระนาบ";
primitive.triplanar.title.help = "สามระนาบกำลังใช้ข้อมูลมาสก์จากสามระนาบเพื่อเติมตารางว็อกเซลที่เป็นรูปหลายเหลี่ยม

หากคุณโต้ตอบกับแถบเลื่อนการแบ่งหรือขนาด ข้อมูลการวาดภาพจะถูกรีเซ็ต (ความเรียบจะโอเค)

คุณควรปิดการใช้งานความสมมาตรเนื่องจากอาจไม่ทำงานอย่างที่คาดหวัง

คุณสามารถใช้ตัวเลือก 'เชื่อมต่อเชิงทอพอโลยี' ในพาเนลหน้ากากเพื่อทาสีระนาบที่กระทบกับระนาบอื่นๆ";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanarSameSize = "ขนาดเดียวกัน (ลูกบาศก์)";
primitive.triplanarPolish = "ความเรียบ";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanarResetMask = "รีเซ็ตมาส์ก";
// One side of a cube (the back plane)
primitive.isolate.back = "ย้อนกลับ";
// One side of a cube (the right plane)
primitive.isolate.right = "ขวา";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "ล่าง";
// Plane
primitive.planeSameSize = "ขนาดเดียวกัน (สี่เหลี่ยม)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "จาน";
// Box
primitive.boxRegular = "ขนาดเดียวกัน (ลูกบาศก์)";
// Distance to the snapping point
primitive.tubeSnapOffset = "ออฟเซ็ทของสแนป";
primitive.tubeSnapOffset.help = "ค่า 1.0 เท่ากับรัศมีของท่อ";
// Radius of the tube (starting end-point of the tube)
primitive.tubeThicknessStart = "รัศมีเริ่มต้น";
// Radius of the tube (ending end-point of the tube)
primitive.tubeThicknessEnd = "รัศมีสิ้นสุด";
primitive.tubeTwist = "บิด";
primitive.tubeTwistRotate = "การหมุน";
primitive.tubeTwistRadius = "ความใหญ่";
primitive.tubeTwistOffset = "ออฟเซ็ต";
primitive.tubeSnap = "สแนป";
primitive.torusRadiusOuter = "รัศมีรอบนอก";
primitive.torusRadiusInner = "รัศมีรอบใน";
primitive.torusAngle = "มุม";
primitive.torusAngleOffset = "ออฟเซ็ตของมุม";
primitive.cylinderHeight = "สูง";
primitive.coneRadius = "รัศมี";
primitive.coneHeight = "สูง";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "รู";
// Make a hole in the primtive to make it hollow
primitive.hasHole = "มีรู";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radiusSync = "รัศมีเดียวกัน";
primitive.radiusStart = "รัศมีเริ่มต้น";
primitive.radiusEnd = "รัศมีสิ้นสุด";
// Curve profile (synonym: profile, curve)
primitive.profile = "";

// Singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "";
// All the new items will be inserted inside the bound rather than outside
repeater.array.fitInside = "";
// The object will follow the curve
repeater.curve.align = "";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "นำเข้า...";
// iOS Photos gallery
resource.import.ios.photos = "";
// iOS Files App
resource.import.ios.files = "";

scene.title = "ซีน";
scene.title.help = "เมื่อใช้ปุ่มที่มองเห็น/เลือก ให้กดค้างไว้แล้วลากนิ้วเพื่อเลือกออบเจ็กต์อื่นๆ อย่างง่ายดาย

คุณยังสามารถกดปุ่มที่มองเห็น/เลือกค้างไว้เพื่อให้มีผลกับโหนดลูกได้เช่นกัน";
// The view will focus on the item when we click on it
scene.focus = "โฟกัสที่รายการ";
// Add new object on gizmo position
scene.addOnGizmo = "";
scene.addOnGizmo.help = "";
// Select the gizmo tool after adding a new object
scene.addSelectGizmo = "";
scene.addSelectGizmo.help = "";
// Icon size in pixel (min/max)
scene.iconSize = "";
// Min size of icon
scene.iconSize.min = "น้อย";
// Max size of icon
scene.iconSize.max = "สูงสุด";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "";
scene.showHierarchy.help = "";
scene.showHierarchyNomadPivot = "";
scene.showHierarchyNomadPivot.help = "";
// The view will focus on the item when we click on it
scene.syncVisible = "";
scene.syncVisible.help = "";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "รวม";
// Group the selected object with a new created Empty Node as a parent
scene.group = "กลุ่ม";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "มิเรอร์";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "เคิร์ฟ";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "โหนดอาเรย์";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "เรเดียล";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "";
scene.repeaters.help = "";
// Validate button
scene.validateGroup = "ตรวจสอบ";
// Keep instances in the scene
scene.validateGroup.keepInstances = "";
// If we should join children
scene.validateGroup.joinChildren = "รวมโหนดลูก";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "ผสานว็อกเซล";
scene.voxelResolution = "ความละเอียด";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "การลบ ซ่อนวัตถุ (ไอคอนตา)";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "จุดตัด ออบเจ็กต์ทั้งหมดที่ซ่อนอยู่";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "ไม่ได้เลือกออบเจ็กต์ โปรดเลือกอย่างน้อยหนึ่งออบเจ็กต์";
// Need to select one object only
scene.noneButNeedOne = "ไม่ได้เลือกออบเจ็กต์ โปรดเลือกหนึ่งออบเจ็กต์";
// Need to select one object only
scene.onlyOneObject = "เลือกหลายออบเจ็กต์ โปรดเลือกออบเจ็กต์เดียวเท่านั้น";

// General scene display settings
settings.display.title = "แสดงการตั้งค่า";
// Wireframe (show triangles and quad edges)
settings.wireframe = "โครงลวด";
// Display the material texture
settings.debugChannel = "";
// Display the material texture in the background
settings.debugChannel.onBackground = "";
// Display the material texture on the mesh
settings.debugChannel.onMesh = "";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "สองด้าน";
settings.twoSided.help = "จะเห็นเฟสได้จากทั้งสองด้าน";
// If we colorize the inverted side of faces
settings.backface.color = "สีของเฟสที่กลับด้าน";
// Color of the inverted side of faces
settings.backface.colored = "ด้านกลับของเฟสที่ลงสีแล้ว";
// Outline (contour highlight around the selected object)
settings.outline = "เค้าร่าง";
// Outline (contour highlight around the selected object)
settings.outline.help = "ออบเจ็กต์ที่เลือกจะถูกร่าง";
settings.outline.thickness = "ความหนา";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "สแนปลูกบาศก์";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "ด้านล่าง";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "ซ้าย";
// Flip the camera (rotate 180° to see the other side)
settings.snapCube.flip = "";
settings.snapCube.flip.help = "";
// Alignment (can be auto/on/off)
settings.snapCube.align = "";
settings.snapCube.align.help = "";
// Stats (information logs about the scene displayed on screen)
settings.stats = "สถิติ";
settings.stats.right = "ขวา";
settings.stats.all = "แสดงหน้าจอเต็ม";
// Grid
settings.grid = "เส้นตาราง";
// Cursor
settings.cursor.title = "";
settings.cursor.whileSculpting = "แสดงวงกลมขณะแกะสลัก";
// A small indicator dot
settings.cursor.showDot = "แสดงจุดเล็ก";
settings.cursor.showDot.help = "จุดสามารถปรากฏเป็นจุดหมุนของกล้องหรือเมื่อคุณกำลังแกะสลัก";
settings.cursor.showRope = "แสดงเชือกกันโคลง";
// indicator
settings.indicator.title = "";
settings.indicator.title.help = "";
settings.indicator.size = "";
// Highlight (the object glows when we select it)
settings.highlight.selection = "ไฮไลท์การเลือก";
// Highlight settings
settings.highlight = "ไฮไลท์";
settings.highlight.duration = "ระยะเวลา";
// Mesh that are not selected will be dark
settings.darkenUnselected = "ทำให้ออบเจ็กต์ที่ไม่ได้เลือกมืดลง";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "แรเงาเรียบ";
// Experimental feature
settings.partialDraw = "การวาดบางส่วน";
settings.partialDraw.help = "คุณสมบัติทดลอง!

ใช้ฟีเจอร์นี้เลยหากคุณกำลังทำส่วนเล็กๆ ของเมชที่ไฮโพลี

ซึ่งจะทำให้การแกะสลักราบรื่นขึ้น แต่คุณไม่ควรเปิดใช้งานโครงลวด!

นอกจากนี้ยังอาจเพิ่มสิ่งแปลกปลอมที่มองเห็นได้ในระหว่างวาดด้วยแปรงด้วย";
settings.partialDraw.warning = "อย่าลืมปิดตัวเลือกนี้หากของแปลกปลอมที่มองเห็นได้น่ารำคาญเกินไป!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "แสดงการวาดลงสี";
// Display the light icons in the viewport
settings.lightIcon = "ไอคอนแสง";
// Display the camera icons in the viewport
settings.cameraIcon = "ไอคอนกล้อง";
// Show icon on the canvas
settings.icon = "ไอคอน";
// Show icons on the canvas
settings.icons = "ไอคอน";
// Tooltip
settings.icons.help = "แสดงไอคอนบนแคนวาสเพื่อที่ว่าคุณจะสามารถเลือกและแก้ไขได้โดยตรง";
// Hole filling settings
settings.hole = "อุดรู";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "เติมรูที่ไม่ซับซ้อน";
settings.hole.nonManifold.help = "พยายามเติมรูที่ไม่มีช่องรวม
ตัวเลือกนี้จะไม่ถูกบันทึกในการตั้งค่า";
// Maximum number of vertices (points)
settings.multires.maxVertices = "จำนวนสูงสุดของจุดยอด";
settings.multires.maxVertices.help = "Nomad ไม่ได้ทำการตรวจสอบหน่วยความจำก่อนซับดิวิชัน การนับโพลีจำนวนมากอาจนำไปสู่การขัดข้องได้ง่าย";
settings.multires.lowResVertices = "เกณฑ์ความละเอียดต่ำ";
settings.multires.lowResVertices.help = "ความละเอียดที่ต่ำกว่าของเมชสามารถแสดงได้เมื่อคุณขยับกล้อง

คุณสามารถเพิ่มค่านี้ได้หากต้องการแสดงค่าความละเอียดสูงขึ้นของเมช";

// The main rendering mode
shading = "การแรเงา";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "ให้แสง (PBR)";
shading.pbr.help = "ในโหมดนี้คุณสามารถเพิ่มแสง (กับเงา) พร้อมกับสภาพแวดล้อม HDR

คุณยังสามารถทาสีโลหะและความหยาบได้ ซึ่งช่วยให้ควบคุมรูปลักษณ์ของวัสดุได้ละเอียดยิ่งขึ้น";
// Fast rendering mode for sculpting purpose (do not translate)
shading.matcap = "MatCap";
shading.matcap.help = "MatCap ย่อมาจาก MAterial CAPture จะดูแลทั้งข้อมูลแสงและวัสดุในรูปภาพเดียว

โหมดนี้เป็นโหมดของการเร็นเดอร์ที่รวดเร็ว ส่วนใหญ่เหมาะสำหรับการแกะสลักแบบดิบ";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "ไม่ให้แสง";
shading.unlit.help = "โหมดแรเงาสีทึบโดยไม่มีแสง";
// Helper rendering mode that display a (do not translate)
shading.id = "ID";
shading.id.help = "โหมดการเร็นเดอร์แบบไม่มีแสงกับแต่ละอ็อบเจ็กต์ที่มีการกำหนดสีแบบสุ่ม

สิ่งนี้มีประโยชน์อย่างยิ่งเมื่อคุณมีออบเจ็กต์จำนวนมากในฉากของคุณ";
// Randomize colors
shading.id.randomize = "สุ่ม id";
shading.textures = "ใช้พื้นผิว";
shading.textures.help = "ในขณะนี้ คุณไม่สามารถสร้างหรือแก้ไขพื้นผิวภายใน Nomad ได้

แต่ถ้าคุณนำเข้าไฟล์ที่มีพื้นผิว ก็อาจจะทำได้

-- พื้นผิวที่รองรับ --
ความทึบ: Lit, MatCap, Unlit
ปกติ: Lit, MatCap
สี: Lit, Unlit
ความเปล่ง: Lit
ความหยาบ: Lit
ความเป็นโลหะ: Lit";
// Lights
shading.lights = "แสง";
shading.lights.addLight = "เพิ่มแสง";
shading.lights.warning = "แสงต้องใช้โหมดแรเงา PBR";
// Environment based lighting (synonym: HDRI)
shading.environment = "สภาพแวดล้อม";
shading.environment.import = "นำเข้า HDR";
shading.environment.exposure = "การเปิดรับแสง";
shading.environment.backgroundBlur = "เบลอ (พื้นหลัง)";
shading.environment.rotation = "การหมุน";
shading.environment.rotation.help = "คุณสามารถหมุนสภาพแวดล้อมได้ด้วยการลาก 3 นิ้วในแนวนอนบนวิวพอร์ต";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "ติดกับกล้อง";
shading.environment.attachedToCamera.help = "ผนึกสภาพแวดล้อมเข้ากับกล้อง

ทำให้แสงให้สม่ำเสมอ ซึ่งอาจเป็นประโยชน์สำหรับวัตถุประสงค์ในการแกะสลัก";
shading.matcap.rotation = "การหมุน";
shading.matcap.rotation.help = "คุณสามารถหมุน MatCap ได้ด้วยการลาก 3 นิ้วในแนวนอนบนวิวพอร์ต";
shading.matcap.global = "ใช้ MatCap ทั้งหมด";
shading.matcap.global.help = "ยกเลิกการเลือกตัวเลือกนี้เพื่อใช้ MatCap อื่นสำหรับเมชนี้";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible = "มาส์ก";
shortcut.maskVisible.short = "มาส์ก";
// bottom shortcut buttons (should be SHORT)
shortcut.solo = "เดี่ยว";
shortcut.solo.short = "เดี่ยว";
// bottom shortcut buttons (should be SHORT)
shortcut.voxelRemesh = "รีเมชว็อกเซล";
shortcut.voxelRemesh.short = "ว็อกเซล";
// bottom shortcut buttons (should be SHORT)
shortcut.wireframe = "โครงลวด";
shortcut.wireframe.short = "ลวด";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraReset = "รีเซ็ตกล้อง";
shortcut.cameraReset.short = "รีเซ็ต";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraSnap = "สแนปกล้อง";
shortcut.cameraSnap.short = "สแนป";
// bottom shortcut buttons (should be SHORT)
shortcut.lockSelection = "ล็อคการเลือก";
shortcut.lockSelection.short = "ล็อค";
shortcut.lockSelection.help = "เมื่อเปิดใช้งาน คุณจะไม่สามารถเปลี่ยนการเลือกได้โดยแตะที่เมช";
// bottom shortcut buttons (should be SHORT)
shortcut.perspective = "เพอร์สเปกทีฟ";
shortcut.perspective.short = "ทัศนมิติ";
// bottom shortcut buttons (should be SHORT)
shortcut.grid = "เส้นตาราง";
shortcut.grid.short = "เส้นตาราง";

// Memory taken by the scene
stat.ramScene = "ซีน";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Vram ซีน";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "เร็นเดอร์ Vram";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "พื้นผิว Vram";
// Memory taken by the undo/redo history
stat.ramHistory = "ประวัติ";
// Memory taken by other stuffs
stat.ramOther = "อื่นๆ";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "หน่วยความจำที่ใช้";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "หน่วยความจำที่ไม่ได้ใช้";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "ใช้อยู่ $0 MB";
stat.free = "ว่าง $0 MB";
stat.faces = "เฟส";
stat.triangles = "สามเหลี่ยม";
stat.vertices = "จุดยอด";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "สี่เหลี่ยม";
stat.sceneFaces = "เฟสต่างของซีน";
stat.sceneVertices = "จุดยอดของซีน";

// Brush stroke
stroke = "วาดเส้น";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "รัศมีแปรงมีพื้นที่ขนาดคงที่ในฉาก";
// The settings is shared among every tools
stroke.useWorldRadius.help = "มีการใช้ร่วมกันในทุกเครื่องมือ";
// Share the radius value among every tools.
stroke.useShareRadius = "แชร์รัศมี";
stroke.useShareRadius.help = "แชร์ค่ารัศมีในทุกเครื่องมือ";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.spacing = "ระยะห่างระหว่างลายเส้น";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.spacing.adjust = "ปรับความเข้มของระยะห่าง";
stroke.minSpacingAdjustIntensity.help = "ปรับความเข้มของแปรงเพื่อให้แน่ใจว่ามีการแปลงรูปที่สม่ำเสมอโดยขึ้นอยู่กับระยะห่างของลายเส้นวาด";
stroke.minSpacing.help = "ระยะห่างระหว่างแต่ละสโตรก สัมพันธ์กับรัศมีเครื่องมือ

ค่าที่ต่ำกว่าจะช่วยให้สโตรกที่เรียบขึ้น แต่ประสิทธิภาพจะลดลง";
// Brush stroke smoothing
stroke.lazySmooth = "ปรับเส้นวาดให้เรียบ";
stroke.lazySmooth.help = "ตำแหน่งตัวชี้หลายตัวแบบเฉลี่ยเพื่อให้ได้จังหวะลายเส้นวาดที่นุ่มนวลขึ้น

หากตั้งค่าที่สูง จังหวะวาดเส้นจะช้าตามหลังตัวชี้ แต่จะตามทันในที่สุด";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "ผ่อนเชือกกันโคลง";
stroke.lazyRadius.help = "สโตรกจะตามมาทีหลังตำแหน่งตัวชี้ตามระยะทางที่กำหนด

สามารถใช้วาดเส้นเรียบได้";
// It is not a per-tool settings
stroke.globalSettings = "นี่คือการตั้งค่าทั้งหมด";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "รัศมีของสแนป";
stroke.snapRadius.help = "สแนปสโตรกหากตัวชี้อยู่ใกล้กับสโตรกที่บันทึกไว้ล่าสุด

สิ่งนี้มีประโยชน์เมื่อต้องวาดเส้นต่อเนื่องยาวๆ ในขณะที่หยุดชั่วคราวบ่อยๆ";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "ออฟเซ็ตสโตรก";
stroke.sculptOffset.help = "ใช้ออฟเซ็ตคงที่ในการวาดเส้น

ตัวเลือกนี้มีประโยชน์สำหรับหน้าจอขนาดเล็กเมื่อใช้นิ้ว เพื่อไม่ให้นิ้วของคุณบังเส้นวาด";
stroke.accumulate = "สะสมเส้นวาด";
stroke.accumulate.help = "หากเปิดใช้งานตัวเลือกนี้ จะไม่มีการจำกัดจำนวนการเพิ่ม/ลบเส้นวาด";
// The tool can use DynTopo
stroke.useDynamicTopology = "ให้ใช้โทโพโลยีแบบไดนามิก";
// Only sculpt the part that are linked topologically
stroke.connected = "โทโพโลยีที่เชื่อมต่อ";
stroke.connected.help = "ตัวเลือกนี้จะปั้นเฉพาะจุดยอดที่เชื่อมโยงกับพื้นผิวที่เลือก

โดยทั่วไปจะใช้สำหรับเครื่องมือเคลื่อนย้าย ตัวอย่างเช่น หากคุณต้องการย้ายเฉพาะส่วนที่อินเตอร์เซกต์ตัวเองกับอีกส่วนหนึ่ง";
// Only sculpt the vertex that points toward the camera
stroke.culling = "จุดยอดด้านหน้าเท่านั้น";
stroke.culling.help = "ตัวเลือกนี้จะละเว้นจุดยอดที่หันไปด้านหลัง

อาจมีประโยชน์หากคุณต้องการทาสีบางๆ บนส่วนหนึ่งของรูปทรงเรขาคณิตโดยจะไม่กระทบอีกด้านหนึ่ง

และยังใช้งานได้สำหรับการแกะสลัก แต่คุณอาจพบสิ่งแปลกปลอมบางอย่าง";
// Infinite depth, move everything under the circle, disregarding depth
stroke.silhouette = "";
stroke.silhouette.view = "";
stroke.silhouette.snapped = "";
stroke.silhouette.closest = "";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.sameSide = "จุดยอดขนาดเดียวกันเท่านั้น";
stroke.sameSide.help = "ละเว้นจุดยอดที่ชี้ไปในทิศทางตรงกันข้ามกับดีฟอร์เมชัน";
stroke.onlyLasso = "การตั้งค่านี้จะเปิดใช้งานเฉพาะเครื่องมือลัสโซ";

// Here sampling refers to the app gathering information under the mouse
stroke.area = "";
stroke.area.help = "";
// Sampling radius size (percent)
stroke.area.normal.radius = "";
// Sampling radius size (percent)
stroke.area.point.radius = "";
// Sampling averaging
stroke.area.normal.average = "";
// Sampling averaging
stroke.area.point.average = "";
// Keep sharp edges
stroke.keepSharp = "รักษาขอบคมไว้";
stroke.keepSharp.help = ""

// Only paint the part of the mesh above a certain height
stroke.depthFilter = "การกรองความลึก";
stroke.depthFilter.help = "";
stroke.depthFilter.max = "";
stroke.depthFilter.min = "";
stroke.depthFilter.offset = "";

// Module the intensity of the sculpting operation by using a falloff curve
menu.falloff = "สร้างเส้นโค้ง";
// Alpha
menu.alpha = "อัลฟ่า";
// Invert the pixel (black <-> white)
stroke.alphaInvert = "สลับพิกเซล";
// Repeat the alpha image (pattern)
stroke.alphaWrap = "เรียงต่อกัน";
// No repeat pattern
stroke.alphaWrap.none = "ไม่มี";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alphaWrap.repeat = "ทำซ้ำ";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alphaWrap.mirror = "มิเรอร์";
stroke.alphaFetch = "วิธี";
// Project the alpha perpendicularly onto the surface
stroke.alphaFetch.surface = "พื้นผิว";
// Project the alpha onto the surface in the direction of the camera view
stroke.alphaFetch.screen = "ฉายภาพโปรเจ็กต์";
stroke.alphaRotation = "การหมุน";
stroke.alphaRotation.lock.help = "";
// Repeat the image
stroke.alphaTiling = "เรียงต่อกัน";
// Scale the image (make it bigger or smaller)
stroke.alphaScale = "การปรับขนาด";
stroke.alphaScale.help = "ที่ค่าต่ำสุด สี่เหลี่ยมอัลฟาจะอยู่ภายในรัศมีวงกลมของเครื่องมือ";
// Middle-point value at which no deformation occurs
stroke.alphaMidValue = "ค่ากลาง";
stroke.alphaMidValue.help = "ค่าจุดกึ่งกลางที่ไม่มีดีฟอร์เมชัน

(ค่ากลาง = 0)
- สีดำ: ไม่มีการแทนที่
- สีขาว: มีการแทนที่

(ค่ากลาง = 0.5)
- สีดำ: การแทนที่เชิงลบ
- สีขาว: มีการแทนที่

(ค่ากลาง = 1)
- สีดำ: การแทนที่เชิงลบ
- สีขาว: ไม่มีการแทนที่";
// Synonymous: Scatter/Jitter/Randomize
stroke.jitter = "";
// Sculpt and paint along the brush stroke at regular spacing
stroke.type.dot = "จุด";
// Sculpt continuously
stroke.type.drag = "ลาก";
// Lock a region and move it around
stroke.type.grab = "คว้า";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.type.grabRadius = "คว้า - รัศมีไดนามิก";
// Lock a region and sculpt it by changing the tool intensity
stroke.type.grabIntensity = "คว้า - ความเข้มแบบไดนามิก";

// Symmetry
symmetry = "สมมาตร";
symmetry.enable = "เปิดใช้งาน";
// Display a warning (the feature is only available for mesh object)
symmetry.primitiveWarning = "ความสมมาตรของแปรงใช้ได้เฉพาะกับรูปทรงพื้นฐานที่ผ่านการตรวจสอบแล้ว ยกเว้นสามระนาบ";
symmetry.plane.title = "ระนาบ";
symmetry.toolIgnore = "เครื่องมือปัจจุบันไม่เกี่ยวกับความสมมาตร";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "เรเดียล";
symmetry.radialX = "เรเดียล X";
symmetry.radialY = "เรเดียล Y";
symmetry.radialZ = "เรเดียล Z";
// A warning indicating that we limit the number of repetitions ($0 is a number)
symmetry.limited = "";
// Synonym: Offset
symmetry.offset.title = "ออฟเซ็ต";
symmetry.offsetX = "ออฟเซ็ต X";
symmetry.offsetY = "ออฟเซ็ต Y";
symmetry.offsetZ = "ออฟเซ็ต Z";
// Number of clones
symmetry.count.title = "จำนวน";
symmetry.countX = "จำนวน X";
symmetry.countY = "จำนวน Y";
symmetry.countZ = "จำนวน Z";
// method
symmetry.method = "วิธี";
symmetry.method.help = "-- โลคอล
ระนาบสมมาตรจะเคลื่อนที่ไปตามเมชเมื่อคุณใช้เครื่องมือปรับแต่ง (กิซโม่ หรือการปรับแต่ง)

-- เวิลด์
ระนาบสมมาตรได้รับการแก้ไขและจะไม่เคลื่อนที่";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.method.world = "เวิลด์";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.method.local = "โลคอล";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "พลิกออบเจ็กต์";
// Mirror the mesh
symmetry.mirror = "การมิเรอร์";
symmetry.mirror.help = "ลองใช้การทำสมมาตรอีกครั้งโดยไม่กระทบต่อโทโพโลยี

สมมาตรในแนวรัศมีจะถูกละเว้น

หากไม่สามารถรักษาโทโพโลยีได้เนื่องจากไม่ถือว่าสมมาตร คุณจะได้รับตัวเลือกเพื่อบังคับใช้การมิเรอร์";
symmetry.mirrorLeftToRight = "ซ้ายไปขวา";
symmetry.mirrorRightToLeft = "ขวาไปซ้าย";
symmetry.mirrorFail = "ใช้สมมาตรไม่สำเร็จ

คุณต้องการบังคับใช้สมมาตรโดยมิเรอร์เมชหรือไม่?";
symmetry.mirrorUseMasking = "ปกป้องพื้นที่ที่มาส์กไว้";
symmetry.mirrorUseMasking.help = "รักษาพื้นที่ที่มาส์กไว้

ตัวเลือกนี้จะถูกละเว้นด้วยโทโพโลยีที่ไม่สมมาตร (หรือพื้นผิวที่ไม่ได้เชื่อมต่อ เช่น ดวงตาคู่หนึ่ง)";
// Reset the symmetry plane position
symmetry.reset = "รีเซ็ต";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "ศูนย์กลางออบเจ็กต์";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "ศูนย์กลางของเวิลด์";
// Reset the symmetry plane orientation
symmetry.reset.direction = "การวางแนว";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "แสดงเส้น";
// Display the symmetry plane in 3d
symmetry.showPlane = "แสดงระนาบ";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "แก้ไขกิซโม่";
symmetry.edit.warning = "การแก้ไขสมมาตรอยู่ในขั้นทดลอง";
symmetry.edit.help = "คุณสามารถตั้งค่าระนาบสมมาตรได้อย่างอิสระ

คุณลักษณะนี้ยังคงเป็นแบบทดลองอยู่ และคุณอาจจะไม่ควรใช้คุณลักษณะนี้";

// Ideally <10 chars
tool.dynTopo = "DynTopo";
// Ideally <10 chars (Symmetry)
tool.symmetry = "สมมาตร";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "มิเรอร์";
// Ideally <10 chars
tool.clay = "ดินเหนียว";
// Ideally <10 chars (Subtract)
tool.clay.sub = "ซับ";
// Ideally <10 chars
tool.brush = "แปรง";
// Ideally <10 chars
tool.move = "ย้าย";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "ปกติ";
// Ideally <10 chars
tool.drag = "ลาก";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "เรียบ";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "อ่อนลง";
// Ideally <10 chars (Paint mask)
tool.mask = "มาส์ก";
// Ideally <10 chars
tool.mask.unmask = "ไม่มาส์ก";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "SelMask";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "เกลี่ย";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "ทำให้เรียบ";
// Ideally <10 chars (Flatten the surface, more strongly than Flatten)
tool.planar = "";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "เติม";
// Ideally <10 chars (Layer brush)
tool.layer = "เลเยอร์";
// Ideally <10 chars
tool.crease = "รอยพับ";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "ตกแต่ง";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "แยก";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "โปรเจ็กต์";
// Ideally <10 chars
tool.inflate = "พอง";
// Ideally <10 chars
tool.pinch = "กระจุก";
// Ideally <10 chars
tool.nudge = "นัดจ์";
// Ideally <10 chars
tool.stamp = "สแตมป์";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "ลบเลเยอร์";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.select = "เลือก";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "กิซโม่";
// Ideally <10 chars
tool.gizmo.editPivot = "จุดหมุน";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "สแนป";
// Ideally <10 chars (Snap translation)
tool.gizmo.moveSnap = "สแนป";
// Ideally <10 chars (Local/Relative space)
tool.gizmo.local = "โลคอล";
// Ideally <10 chars (Align/Snap the gizmo to world axis)
tool.gizmo.align = "";
// Ideally <10 chars (Pin the gizmo, so that it stays in place when switching between objects)
tool.gizmo.pin = "";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "ปรับแต่ง";
// Ideally <10 chars (Translate the object)
tool.transform.move = "ย้าย";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "หมุน";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "สเกล";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "สแนป";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "วัด";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "มุมมอง";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "กลึง";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "ท่อ";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "แทรก";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "พลิก";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "มุมมอง";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "ลัสโซ";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "เคิร์ฟ";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "โพลีกอน";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "พาธ";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "สี่เหลี่ยมผืนผ้า";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "วงรี";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "เส้น";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "ปิด";

// Radius of the tool (size)
tool.radius = "รัศมี";
// Intensity of the tool (force)
tool.intensity = "ความเข้ม";

tool.settings = "การตั้งค่า";
tool.settings.none = "เครื่องมือนี้ไม่มีการตั้งค่าเฉพาะใดๆ";

tool.crease.pinchFactor = "แรงหยิก";

tool.layer.removeInfluence = "ใช้ข้อมูลเลเยอร์";
tool.layer.removeInfluence.help = "ตัวเลือกนี้จะใช้งานได้ก็ต่อเมื่อมีการเลือกเลเยอร์ไว้

จะใช้ข้อมูลเลเยอร์เพื่อจำกัดการเคลื่อนเกินไปนอกเส้นวาด";
tool.layer.noLayerSelected = "ตัวเลือกนี้จะใช้ได้ก็ต่อเมื่อได้เลือกเลเยอร์ไว้";

tool.flatten.planeLockOrigin = "ล็อคกำเนิดระนาบ";
tool.flatten.planeLockNormal = "ล็อคทิศทางระนาบ";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "";
tool.syncInstance.message = "";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "จุดยอดอยู่กับที่บนขอบเขต";

tool.paint = "ลงสี";
// Erase the painting
tool.paint.erase = "ลบ";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "การกรองเลเยอร์";
tool.paint.layerFilter.help = "ใช้ตัวเลือกนี้หากคุณต้องการทาสีใหม่อีกบนพื้นที่ที่ลงสีแล้วของเลเยอร์เท่านั้น";

// Clear the painted mask
tool.mask.clear = "ล้าง";
// Invert the painted mask
tool.mask.invert = "กลับด้าน";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "พลิกที่เชื่อมโยงกัน";
// Blur the painted mask
tool.mask.blur = "เบลอ";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "ความคมชัด";
// Smoothing strategy
tool.mask.polish.all = "";
tool.mask.polish.sharp = "";
tool.mask.polish.border = "";
// Smooth the border in a way that it matches completely with its dual
tool.mask.polish.syncBorder = "";
// topology of extracted mesh
tool.mask.autoDivision = "";
tool.mask.division = "";
// The thickness of the extracted mesh (from the painted mask)
tool.mask.thickness = "ความหนา";
// The extracted mesh has the same height everywhere
tool.mask.thicknessUniform = "";
tool.mask.thicknessUniform.help = "";
// Carve the mask into the surface
tool.mask.carve = "แกะสลัก";
// Extract a new mesh from the painted mask
tool.mask.extract = "สกัด";
// Extract two new mesh from the painted mask and from the unmasked area
tool.mask.split = "แยก";
// How should we close the topology of the extracted object
tool.mask.split.mask = "การดำเนินการปิด (มาส์ก)";
// How should we close the topology of the extracted object
tool.mask.split.unmask = "การดำเนินการปิด (ไม่มาส์ก)";
// How should we close the topology of the extracted object
tool.mask.action = "การดำเนินการปิด";
tool.mask.action.help = "-- ไม่มี
เพียงสกัดส่วนนี้แล้วปล่อยให้ส่วนที่สกัดออกมาเปิดออก

-- เติม
หลุมถูกเติมและทำให้เรียบ
อย่าใช้ตัวเลือกนี้สำหรับพื้นผิวเรียบ

-- เปลือก
ปิดรูปร่างที่สกัดออกมาโดยใช้ค่าความหนา

-- เลเยอร์
แยกความแตกต่างของเลเยอร์ (เฉพาะเมนูย่อยของเลเยอร์)";
// Do not close the mesh (leave it open)
tool.mask.action.none = "ไม่มี";
// Close the mesh with a hole-filling algorithm
tool.mask.action.fill = "เติม";
// Close the mesh by adding a thickness on the surface
tool.mask.action.shell = "เปลือก";
// Close the mesh by using the layer data as a difference thickness
tool.mask.action.layer = "เลเยอร์";

// Transform/Matrix
tool.matrix = "แมทริกซ์";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.apply = "เป้าหมาย";
// Automatic
tool.matrix.apply.auto = "อัตโนมัติ";
// Transform the object alone (the children stands still)
tool.matrix.apply.object = "ออบเจ็กต์";
// Auto apply the transform on the vertices
tool.matrix.apply.vertex = "จุดยอด";
// Transform the object and its children
tool.matrix.apply.group = "กลุ่ม";
tool.matrix.apply.help = "-- อัตโนมัติ
โดยค่าเริ่มต้น ฟังก์ชั่นนี้จะทำงานเหมือนกับตัวเลือกกลุ่ม
หากเมชมีการทำมาส์กไว้ หรือหากเปิดใช้สมมาตรในกิซโม่ ก็จะทำงานเหมือนกับจุดยอด

-- จุดยอด
จะใช้กับการปรับแต่งบนจุดยอด จะไม่ทำงานบนรูปทรงพื้นฐานที่ไม่ผ่านการตรวจสอบรูปทรงพื้นฐาน
อินสแตนซ์จะได้รับผลกระทบเช่นกัน

-- ออบเจ็กต์
ย้ายออบเจ็กต์เท่านั้น โดยไม่รวมความสมมาตรและการมาส์ก
เฉพาะโหนดที่แก้ไขแล้วเท่านั้นที่จะย้าย โหลดลูกจะคงเดิม

-- กลุ่ม
ย้ายโหนดโดยไม่รวมความสมมาตรและมาส์ก ลำดับชั้นที่เหลือจะถูกปรับแต่งเช่นกัน";
// Operation on the mesh
tool.matrix.action = "การทำงาน";
tool.matrix.action.help = "--ย้ายต้นทาง
ย้ายเมชไปยังต้นกำเนิด

-- รีเซ็ต
รีเซ็ตการปรับแต่งเมชเป็นข้อมูลประจำตัว

-- เบค
ใช้เมทริกซ์กับจุดยอดและรีเซ็ตเมทริกซ์ หากมองดูจะไม่เห็นความเปลี่ยนแปลง";
tool.matrix.translation = "การแปลง";
tool.matrix.rotation = "การหมุน";
tool.matrix.scale = "สเกล";
// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "เฉือน";
tool.matrix.uniformScale = "ทำให้เป็นขนาดเดียวกัน";
tool.matrix.moveToOrigin = "ย้ายต้นทาง";
tool.matrix.resetTransform = "รีเซ็ต";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "เบค";

tool.transform.tip = "";

// Size of the gizmo
tool.gizmo.size = "ขนาดวิดเจ็ต";
// If true, there is less spacing between gizmo handlers (rotate, scale, etc)
tool.gizmo.compact = "";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "อินพุตตัวเลข";
tool.gizmo.allowInput.help = "อนุญาตให้ป้อนตัวเลขเมื่อบันทึกวิดเจ็ตกิซโม่ตัวใดตัวหนึ่ง";
// Angle threshold
tool.gizmo.linearRollThreshold = "เกณฑ์การม้วนของสัมผัสวง";
tool.gizmo.linearRollThreshold.help = "ค่าเกณฑ์ของมุมเพื่อเลือกระหว่างวิธีการม้วนแบบเชิงเส้นหรือแบบวงกลม

ค่าที่สูงกว่าเกณฑ์นี้จะใช้การม้วนแบบวงกลม

หากคุณต้องการม้วนเชิงเส้น (ทิศทางของเส้นสัมผัส) ให้ตั้งค่านี้เป็น 90°";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "ซ่อนในการโต้ตอบ";
tool.gizmo.tap = "แตะเดียว";
tool.gizmo.tap.help = "ตัวเลือกนี้มีผลเฉพาะในโหมดกำหนดจุดหมุนแบบกำหนดเอง (ปิดใช้งานออโต้)

-- ไม่มี
ไม่มีอะไรเกิดขึ้นเมื่อแตะเมช

-- ตีแรก
ย้ายกิซโม่ที่อินเตอร์เซ็กชั่นแรก

-- จิ้มกึ่งกลาง
ย้ายกิซโม่ไปโดยใช้ค่าเฉลี่ยของสองอินเตอร์เซ็กชั่นแรก";
tool.gizmo.tap.none = "ไม่มี";
tool.gizmo.tap.normal = "ปกติ";
tool.gizmo.tap.first = "การตีครั้งที่หนึ่ง";
tool.gizmo.tap.medial = "สแต็ปกลาง";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "อยู่กับที่";

// Fill the object's hole
tool.hole = "การอุดรู";
tool.hole.fillHoles = "อุดรู";
// synonym: Alternative method
tool.hole.bridges = "บูลีนพื้นที่หน้าจอ";
tool.hole.bridges.help = "หากเปิดใช้งานตัวเลือกนี้ คุณสามารถเจาะรูในวอลุ่มได้
ความชันของการตัดจะเป็นไปตามรูปร่างการตัดที่ใกล้ชิดมากขึ้น";
tool.hole.threshold = "เกณฑ์เอปซิลอน";
tool.hole.threshold.help = "การปรับค่านี้อาจช่วยเกี่ยวกับอัลกอริธึมการเติมรู";
tool.hole.smoothing = "ปรับรูให้เรียบ";

tool.smudge.quality = "คุณภาพ";
tool.smudge.quality.help = "จะเปลี่ยนความละเอียดของพิกเซลที่แสดง ค่าที่ต่ำกว่าหมายถึงจังหวะเส้นวาดที่เร็วขึ้น";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "รูปร่าง";
// Auto-validate the drawn shape
tool.shape.autoValidate = "";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "สี่เหลี่ยม";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "อยู่กึ่งกลาง";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "วงกลม";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "อยู่กึ่งกลาง";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "หมุนสเต็ป";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "แสดงอัตราส่วนโกลด์";


// Always display the camera shortcut buttons on the viewport
tool.view.stickyCamera = "";

// Topology
topology = "โทโพโลยี";
// Synynom: detail value, density
topology.dynamic.detail = "รายละเอียด";
// See glossary
topology.multires = "ความละเอียดหลายระดับ";
topology.multires.help = "รักษาความละเอียดหลายระดับของเมช

หากคุณเปลี่ยนแปลงค่าความละเอียดให้ต่ำกว่า รายละเอียดจากความละเอียดที่สูงกว่าจะแสดงซ้ำเมื่อคุณเปลี่ยนกลับ

มีเลเยอร์ในทุกความละเอียด";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "ย้อนกลับ";
topology.multires.reverse.confirm = "ไม่สามารถสร้างซับดิวิชันฐาน

โทโพโลยีในปัจจุบันอาจไม่ได้เป็นผลมาจากซับดิวิชัน";
topology.multires.subdivide = "แบ่ง";
topology.multires.subdivide.confirm = "เมชจะมีจุดยอด $0M คุณแน่ใจหรือไม่";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "การแบ่งเกินขีดจำกัด โปรดดู $0";
topology.multires.deleteLower = "ลบที่ต่ำกว่า";
topology.multires.deleteHigher = "ลบที่สูงกว่า";
topology.multires.keepTriangles = "เก็บสามเหลี่ยม";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "";
// Synonym: Flat subdivision
topology.multires.linear = "ซับดิวิชันเชิงเส้น";
topology.multires.linear.help = "เพียงแบ่งเมชออกโดยไม่ต้องปรับให้เรียบ";
// Create a new object by recomputing a new topology
topology.remesh = "รีเมช";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "การรีเมชว็อกเซล";
topology.voxel.help = "การรีเมชโดยการสุ่มตัวอย่างเมชบนกริด

หากออบเจ็กต์ไม่ปิด (กันน้ำ) จะใช้อัลกอริทึมการเติมรูก่อน

เลเยอร์ถูกฉายซ้ำหลังจากรีเมช แต่คุณภาพจะลดลง";
topology.voxel.resolution = "ความละเอียด";
topology.voxel.sharp = "รักษาขอบคมไว้";
topology.voxel.sharp.help = "ตัวเลือกนี้มีประโยชน์ส่วนใหญ่สำหรับการทำบูลีนที่รูปทรงพื้นฐานอย่างง่ายๆ

จะทำให้เกิดการบิดเบี้ยวในบางพื้นที่เนื่องจากมีจุดที่ถูกสแนปที่ขอบ";
topology.voxel.subLevel = "สร้างหลายรายละเอียด";
topology.voxel.subLevel.help = "คุณสามารถสร้างใหม่ลำดับชั้นแบบหลายความละเอียดได้จากเอาต์พุตรีเมชเชอร์ของว็อกเซล

นอกจากนี้ยังจะทำงานเร็วขึ้นและใช้หน่วยความจำน้อยลง โดยเฉพาะอย่างยิ่งถ้าค่ารายละเอียดว็อกเซลสูง
อย่างไรก็ตาม หากค่ารายละเอียดว็อกเซลต่ำและคุณขอระดับหลายความละเอียดจำนวนมาก คุณจะสูญเสียรายละเอียดไป";
// Dynamic topology (DynTopo)
topology.surface.remesh = "รีเมช";
topology.surface.detail = "รายละเอียด";
topology.surface.detail.help = "ไม่เหมือนกับการรีเมชว็อกเซล การรีเมชพื้นผิไม่จำเป็นต้องปิดเมช

นอกจากนี้ยังรองรับการมาสก์เพื่อให้คุณสามารถป้องกันบางส่วนของเมชจากการเปลี่ยนแปลงโทโพโลยี

เลเยอร์ได้รับการอัพเดทอย่างถูกต้อง";
topology.surface.method = "วิธี";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "รวมให้เป็นแบบเดียว";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "ซับดิวิชัน";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "การลบ";
topology.surface.method.help = "ลักษณะของโทโพโลยีแบบไดนามิก:
- รวมให้เป็นแบบเดียว: เพิ่มและลบรายละเอียด
- ซับดิวิชัน: เพิ่มรายละเอียด
- การลบ: ลบรายละเอียด";
topology.surface.useMasking = "ปกป้องพื้นที่ที่มาส์กไว้";
topology.surface.useMasking.help = "พื้นที่มาส์กไว้จะป้องกันโทโพโลยีไม่ให้เปลี่ยนแปลง";
topology.surface.extrapolate = "การคำนวนค่านอกช่วงของพื้นฐาน";
// DynTopo
topology.dynamic = "โทโพโลยีแบบไดนามิก";
topology.dynamic.activate = "เปิดใช้งาน";
topology.dynamic.activate.help = "ด้วยโทโพโลยีแบบไดนามิก เครื่องมือการปั้นรูปสามารถแบ่งย่อยหรือลดความซับซ้อนของเมชในแบบเรียลไทม์

คุณลักษณะนี้อาจมีผลกระทบต่อประสิทธิภาพอย่างเห็นได้ชัด

เลเยอร์ได้รับการอัพเดทอย่างถูกต้อง";
topology.dynamic.method = "รายละเอียดตาม...";
topology.dynamic.method.zoom = "ซูม";
topology.dynamic.method.radius = "รัศมี";
topology.dynamic.method.constant = "คงที่";
topology.dynamic.method.help = "-- ซูม
ระดับของรายละเอียดขึ้นอยู่กับว่าคุณอยู่ไกลจากพื้นผิวมากแค่ไหน

--รัศมี
รัศมีเครื่องมือกำหนดจำนวนรายละเอียด

-- คงที่
รายละเอียดได้รับการแก้ไขแล้ว ค่ารายละเอียดจะถูกแชร์กับตัวเลื่อนว็อกเซลเช่นกัน";
topology.dynamic.quality = "เลื่อน...";
topology.dynamic.quality.help = "หากคุณเลือกคุณภาพ มีความแตกต่างหลัก 2 ประการคือ
- การปรับแต่งจะถูกนำไปใช้ก่อนผู้ดำเนินการปั้นรูป คุณจะได้รับสิ่งประดิษฐ์ที่สอดแทรกน้อยลงเมื่อทาสีหรือปั้นรูปรายละเอียดเล็กๆ น้อยๆ
- การปรับแต่งจะไม่ถูกนำไปใช้ทีละส่วน หากคุณปั้นรูปรายละเอียดเล็กๆ น้อยๆ หรือทำการสโตรกอย่างรวดเร็ว โทโพโลยีจะได้รับการขัดเกลาอย่างถูกต้องเสมอ

เพื่อประสิทธิภาพที่ดีขึ้น และหากคุณวางแผนที่จะใช้ตัวเลือกนี้ คุณอาจลองเปิดใช้งานตัวเลือก 'การวาดบางส่วน' ในแผงการตั้งค่า";
topology.dynamic.quality.speed = "ความเร็ว";
topology.dynamic.quality.quality = "คุณภาพ";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "ใช้แรงกดบนรัศมี";
topology.dynamic.usePressure.help = "ใช้ตัวเลือกนี้หากคุณต้องการให้แรงกดของปากกาส่งผลต่อรัศมีของเครื่องมือ เพื่อที่จะส่งผลต่อระดับของรายละเอียด";
// Decimate
topology.decimate.title = "การลบ";
topology.decimate.title.help = "ลดจำนวนรูปหลายเหลี่ยมโดยพยายามเก็บรายละเอียดให้มากที่สุด

คุณสมบัตินี้จะมีประโยชน์หากคุณต้องการนำออกสำหรับการพิมพ์ 3D
อย่างไรก็ตาม คุณไม่ควรใช้คุณสมบัตินี้หากคุณต้องการทำงานต่อ เนื่องจากจะทำให้เกิดสามเหลี่ยมที่ไม่สม่ำเสมอได้

โปรดทราบว่าพื้นที่ที่มาส์กไว้จะไม่ถูกทำลาย";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "ลบล้าง";
topology.decimatePaintWeight = "รักษาภาพวาด";
topology.decimatePaintWeight.help = "ค่าที่สูงขึ้นจะพยายามรักษาภาพวาด

ตั้งค่านี้เป็น 0 หากคุณไม่สนใจเกี่ยวกับภาพวาด";
topology.decimateUniform = "เฟสที่ทำให้เหมือนกัน";
topology.decimateUniform.help = "ค่าที่สูงกว่าจะทำให้เกิดรูปสามเหลี่ยมที่มีขนาดใกล้เคียงกัน";
topology.decimatePreserveBorders = "";
topology.decimatePreserveBorders.help = "";
// Target a certain number of triangles, faces and vertices
topology.target.triangles = "สามเหลี่ยมเป้าหมาย";
topology.target.faces = "";
topology.target.quads = "";
topology.target.points = "";
// Quad remesher
topology.qremesh = "";
topology.qremesh.angle = "";
topology.qremesh.border = "";
topology.qremesh.onlyQuad = "";
topology.qremesh.hole = "";
topology.qremesh.hole.help = ""

// Unwrapping means compute UV (texture coordinates), with uvs you can appliy (wrap) a texture onto the model
topology.uv.title = "คำนวน UV";
// UV Unwrap but as a Verb
topology.uv.unwrap = "คำนวน";
// The operation can be very slow
topology.uv.atlas.warning = "อาจช้ามาก กำหนดเป้าหมาย <100k จุดยอด";
// Handles are topological holes (synonym: genus, hole)
topology.uv.bff.warning = "ทับซ้อนกันได้ถ้าถ้าเมชมีแฮนเดิ้ล!";
// Synonym: Point count? Singularity count ?
topology.uv.bff.cones = "จำนวนโคน";
topology.uv.bff.help = "ค่าที่สูงขึ้นจะลดการบิดเบือนของวัตถุที่ซับซ้อน

ค่าที่สูงขึ้นหมายถึงเวลาประมวลผลนานขึ้น";
topology.uv.delete = "ลบ UVs";

// Transfer the vertex painting in the texture, bake means "create texture (from mesh data)"
topology.bake.title = "เบค";
// Bake here means "create texture (from mesh data)"
topology.bake.title.help = "";
// Bake here means "create texture (from mesh data)"
topology.bakeSelf = "";
// Bake here means "create texture (from another mesh data)"
topology.bakeOther = "";
topology.bakeResolution = "ความละเอียด";
// Cage is a specific term, synonyom: "Bake offset"
topology.bakeOffset = "";
topology.bakeRadius = "";
// Bake opacity (from mask data)
topology.bake.opacityFromMask = "";

// project a high resolution mesh details onto another
topology.reproject.title = "";
topology.reproject.title.help = "";
// tweaking value
topology.reproject.rayBias = "";
topology.reproject.rayBias.help = "";
topology.reproject.normalOffset = "";
// number of iteration the algorithm will take
topology.reproject.iterations = "";
topology.reproject.relax = "";
topology.reproject.relax.help = "";

topology.manifold = "";
topology.nonManifold = "";
topology.manifold.clean = "";
topology.manifold.title = "";
topology.manifold.title.help = "";

// Reset key-bindings/shortcuts
binding.reset = "รีเซ็ตการมัดรวม";
// Binding option
binding.toggleTool = "";
binding.toggleTool.help = "";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.materialPicker = "การเลือกวัสดุ";
// Edit the tool brush size/radius
binding.editRadius = "รัศมีเครื่องมือ";
// Edit the tool brush size/radius
binding.editIntensity = "ความเข้มของเครื่องมือ";
// Snap the camera
binding.viewFront = "มุมมองด้านหน้า";
// Snap the camera
binding.viewLeft = "มุมมองด้านซ้าย";
// Snap the camera
binding.viewTop = "มุมมองด้านบน";
// Move/Translate the view
binding.panLeft = "แพนซ้าย (มุมมอง)";
// Move/Translate the view
binding.panRight = "แพนขวา (มุมมอง)";
// Move/Translate the view
binding.panForward = "แพนไปข้างหน้า (มุมมอง)";
// Move/Translate the view
binding.panBackward = "แพนไปข้างหลัง (มุมมอง)";
// Move/Translate the view
binding.panUp = "แพนขึ้นข้างบน (มุมมอง)";
// Move/Translate the view
binding.panDown = "แพนลงด้านล่าง (มุมมอง)";
// Snap the view (while rotating)
binding.snapViewOnRotate = "มุมมองแบบสแนป (ขณะหมุน)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "เปิด (โปรเจ็กต์)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "เพิ่ม (โปรเจ็กต์)";
// Import an external scene file (replace current scene)
binding.import.open = "เปิด (นำเข้า)";
// Import an external scene file (add it to the current scene)
binding.import.add = "เพิ่ม (นำเข้า)";
// Select all the objects in the scene
binding.selectAll = "เลือกทั้งหมด";
// Rotate environment and the lighting
binding.rotateLighting = "หมุนแสง";

// Privacy policy
privacyPolicy.title = "นโยบายความเป็นส่วนตัว";
privacyPolicy.reject = "ปฏิเสธ";
// Hexanomad is the company name
privacyPolicy = "Hexanomad ไม่ได้รวบรวมข้อมูลใดๆ จาก Nomad Sculpt";

// Color disc mode
widget.color.disc = "";
// Color square mode
widget.color.square = "";

// version trial
version.buyWeb = "เวอร์ชันเว็บเป็นเพียงตัวอย่างเท่านั้น";
version.buyFull = "อัพเกรดเป็นเวอร์ชันเต็ม";
version.restorePurchase = "กู้คืนการซื้อ";

version.trialHistory = "เวอร์ชันทดลอง เลิกทำ/ทำซ้ำได้ 4 ครั้ง";
version.trialLayer = "เวอร์ชันทดลอง 1 เลเยอร์ต่อเมช";
version.trialOneProject = "เวอร์ชันทดลอง: 1 โปรเจ็กต์ที่ใช้งานอยู่เท่านั้น!";
version.trialNoImport = "เวอร์ชันทดลอง ไม่นำเข้า";
version.trialNoExport = "เวอร์ชันทดลอง ไม่นำออก";

version.fullFeatures = "- ซื้อครั้งเดียว
- เลิกทำ/ทำซ้ำได้ไม่จำกัด
- ไม่จำกัดเลเยอร์
- บันทึกและโหลด
- นำออกนำเข้า";

meta.colon = "";