// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "ยืนยัน?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "ใช่";
// Answer to a question (Are you sure you want to do that? [yes, no, cancel])
confirm.no = "ไม่";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "ตกลง";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "ยกเลิก";
// Restart nomad
confirm.restart = "หลังจากเปลี่ยนค่าตัวนี้ คุณต้องรีสตาร์ท Nomad";

// Experimental feature
experimental = "ที่ทดลอง!";

status.exit = "การเปลี่ยนแปลงที่ไม่ได้บันทึก! บันทึกก่อนปิดหรือไม่?";
status.exit.yes = "บันทึก";
status.exit.no = "ไม่บันทึก";

// On single tap (should be short)
ontap = "แตะ";

all = "ทั้งหมด";
error = "ข้อผิดพลาด";

reset = "รีเซ็ต";
resetOrder = "รีเซ็ตลำดับ";

clipboard = "คลิปบอร์ด";
clipboard.copy = "คัดลอก";
clipboard.paste = "วาง";

// memory size
bytes = "ไบต์";
kB = "กิโลไบต์";
MB = "เมกะไบต์";
GB = "กิกะไบต์";
TB = "เทระไบต์";

// Noun
instance = "อินสแตนซ์";
object = "ออบเจ็กต์";

// Same value (usually for axis, e.g: x == y == z)
uniform = "สม่ำเสมอ";

sync = "ซิงค์";

// position
position.top = "บน";
position.bottom = "ล่าง";
position.left = "ซ้าย";
position.right = "ขวา";
position.center = "อยู่กึ่งกลาง";
// direction
direction.up = "บน";
direction.down = "ล่าง";
direction.left = "ซ้าย";
direction.right = "ขวา";
// 3D cube
cube.top = "บน";
cube.bottom = "ล่าง";
cube.left = "ซ้าย";
cube.right = "ขวา";
cube.front = "หน้า";
cube.back = "หลัง";

// Name of an item (object, tool, etc)
item.name = "ชื่อ";
// Add a new item (object, tool, etc)
item.new = "ใหม่";
// Rename an item (object, tool, etc)
item.rename = "เปลี่ยนชื่อ";
// Add a new item (object, tool, project, etc)
item.add = "เพิ่ม";
// Update an item image with a new image (synonym: Update)
item.replace = "แทนที่";
// Save an item (object, tool, etc)
item.save = "บันทึก";
item.save.confirm = "ยืนยันการบันทึก?";
// Update an item (update camera view point, etc)
item.update = "อัปเดต";
// Reload last save of an item (object, tool, etc)
item.lastSave = "บันทึกล่าสุด";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "โหลดการบันทึกล่าสุด?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "รีเซ็ต";
item.reset.confirm = "ยืนยันการรีเซ็ต?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "อินสแตนซ์";
// Uninstance the object, make the object real
item.uninstance = "ยกเลิกอินสแตนซ์";
// Clone an item (object, tool, etc)
item.clone = "โคลนนิ่ง";
// Delete an item (object, tool, etc)
item.delete = "ลบ";
item.delete.confirm = "ยืนยันการลบ?";
item.delete.confirm.yes = "ใช่ ลบทิ้ง";
// When we delete the item but the image is used somewhere
item.delete.used = "รูปภาพที่ใช้";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "เป็นโหนด";
// Item visibility (object, layer, etc)
item.visible = "ที่เห็นได้";
// Show an item (object, layer, etc)
item.show = "แสดง";
// Hide an item (object, layer, etc)
item.hide = "ซ่อน";
// Select an item (object, layer, etc)
item.select = "เลือก";
// Unselect an item (object, layer, etc)
item.unselect = "ยกเลิกการเลือก";
// Merge an item with another one below (layer)
item.mergeDown = "รวมล่าง";
// The order of an item in a list
item.order = "เรียง";
// Focus on previous item
item.previous = "ก่อนหน้า";
// Focus on next item
item.next = "ถัดไป";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "ล็อค";
// No item selected
item.none = "ไม่มี";
// Draggable, moveable
item.draggable = "สามารถเคลื่อนย้ายได้";

// Search something (text entry to filter item)
search = "ค้นหา";

// Three-state toggle button (Auto, Off, On)
toggle.on = "เปิด";
// Three-state toggle button (Auto, Off, On)
toggle.off = "ปิด";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "อัตโนมัติ";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "ไม่มีภาพขนาดย่อ กำลังประมวลผลไฟล์ใหม่...";
loading.reprocess.cancel = "ข้ามการสร้างภาพขนาดย่อหรือไม่?";

access.title = "การเข้าถึง";
access.window = "หน้าต่างช่วยเหลือ";
access.pinch = "กระจุก";
access.drag = "ลาก";
access.rotate = "หมุน";
access.roll = "หมุน";

// Color of an object
material.color = "คัลเลอร์";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "ความหยาบ";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "ความมันวาว";
// Whether the material is a metal or not
material.metalness = "ความเป็นโลหะ";
// How much light a surface will reflect
material.specular = "ความสะท้อนแสง";
// Light that the surface can emit (glow)
material.emissive = "ความเรืองแสง";
// Normal map (synonym: detail, bump)
material.normal = "ปกติ";
// flip y coordinate
material.normal.flipY = "พลิกแกน Y";
// Ambient Occlusion (AO)
material.occlusion = "แสงเงาระหว่างวัตถุ";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "พื้นผิว";
// Textures/Image
material.texture = "พื้นผิว";
// A warning indicating that the mesh has no UVs
material.warningNoUVs = "ไม่มี UVs!";
// Texture filtering https://en.wikipedia.org/wiki/Texture_filtering
material.texture.filter = "การกรอง";
// Nearest Filtering (closest sample)
material.texture.nearest = "ใกล้ที่สุด";
// Bilinear Filter
material.texture.linear = "เชิงเส้น";
// Mipmap filtering
material.texture.mipmap = "มิปแมป";
// Triplanar mapping
material.projection = "การฉายภาพ";
material.projection.triplanar = "สามระนาบ";

// Prefer low power
about.lowPower = "GPU พลังงานต่ำ";
// Wintab wacom API
about.wintab = "ใช้ WinTab";
about.wintab.help = "หากเปิดใช้ WinTab คุณควรปิด Windows Ink ในการตั้งค่า Wacom ของคุณ 

ในทำนองเดียวกัน หาก WinTab ถูกปิดใช้แล้ว คุณควรเปิดใช้ Windows Ink ในการตั้งค่า Wacom";
// Wacom Multi Touch API
about.touch = "ใช้ Wacom Multi-Touch";
about.touch.help = "เปิดใช้งานตัวเลือกนี้เพื่อรองรับการใช้งานหลายๆ นิ้วบนแท็บเล็ต Wacom";
// Prefer low power
about.fullScreen = "เต็มจอ";
// Minify
about.minify = "ลดขนาด UI";
about.minify.help = "คุณสามารถใช้นิ้ว 4 นิ้วแตะหน้าจอ หากอุปกรณ์ของคุณรองรับ";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "แท่นหมุน";
// Rotation center of the turntable
about.turntable.pivot = "ศูนย์หมุน";
// Keep current pivot
about.turntable.pivot.keep = "เก็บสภาพปัจจุบัน";
// Turntable pivot will be at the center of the scene
about.turntable.pivot.scene = "ซีน";
// Make the entire scene turn around (speed of the animation)
about.turntable.speed = "ความเร็ว";
// Speed easing (linear vs non-linaer)
about.turntable.linear = "ความเร็วคงที่";
// Stuffs that I used to make the app
about.credits = "เครดิต";
// Link to open source projects that I used for the app
about.credits.openSource = "โอเพนซอร์ซ";
// Only translate the &
about.credits.arts = "MatCaps & HDRIs";
// Change languages of the app
about.languages = "ภาษา";
about.languages.help = "ไฟล์แปลงพร้อมใช้งานที่ $0";
// Link to the App Website
about.website = "เว็บไซต์";
// Link to the App Forum
about.forum = "ฟอรั่ม";
// Link to the App Manual
about.manual = "คู่มือ";
// Link to the App Email
about.mail = "บริการช่วยเหลือ";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";
// Link to the App Threads account
about.threads = "Threads";

// The user canceled an operation that was running
alert.aborted = "การดำเนินการถูกยกเลิก!";
// Empty mesh
alert.mirror.empty = "ผลลัพธ์ว่างเปล่า!";
// Mesh already mirrored
alert.mirror.same = "ผลลัพธ์เดียวกัน!";
// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "ออบเจ็กต์ไม่มีรู!";
// No operation occured because the mesh is already manifold
alert.manifold.already = "ตาข่ายนี้มีความหนาแน่นเพียงพอแล้ว!";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "มองไม่เห็นออบเจ็กต์นี้!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "ไม่มีสิ่งที่ให้ตัดแต่ง";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "ยกเลิกการตัดแต่ง ออบเจ็กต์ถูกตัดแต่งสมบูรณ์แล้ว";
// In order to extract something, the mesh needs to have painted mask
alert.extract.none = "ไม่มีสิ่งที่ให้สกัด!";
// In order to split something, the mesh needs to have painted mask
alert.extract.split.none = "ไม่มีสิ่งที่ให้แยก!";
// List of disabled features when View Mode is selected
alert.view.disabled = "คุณสมบัติที่ปิดใช้งานในโหมดดู";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "วิดเจ็ตของรูปทรงพื้นฐาน";
// The object needs to have two parts disconnected
alert.separate.fail = "ไม่สามารถแยกออก ออบเจ็กต์มีเพียงส่วนเดียว!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "รีเมช!";
alert.voxelRemesh.empty = "ยกเลิกรีเมช ผลคือทำให้เมชไม่มีเฟส";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "อินพุตไม่ถูกต้อง!";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "จะทำสำเนาออบเจ็กต์";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "จะทำอินสแตนซ์ออบเจ็กต์";
// A pivot refers the gizmo 3D position, this mode means we are moving the pivot
alert.gizmo.editPivot = "แก้ไขโหมดจุดหมุน";
alert.mask.full = "มาส์ก = 100%!";
// A pivot refers the gizmo 3D position
alert.gizmo.editObject = "แก้ไขโหมดของออบเจ็กต์";
// See Glossary (DynTopo)
alert.dynamic.enable = "โทโพโลยีแบบไดนามิกที่ใช้งานอยู่";
// See Glossary (DynTopo)
alert.dynamic.disable = "ปิดใช้งานโทโพโลยีแบบไดนามิก";
alert.colorPicker = "ลากนิ้วของคุณบนออบเจ็กต์เพื่อเลือกสี";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "แค่แตะเพื่อออกจากโหมดการแปลง";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "แตะเพียงครั้งเดียวเพื่อออกจากโหมดแก้ไขความสมมาตร.";
// Show the painted mask on the mesh
alert.mask.show = "แสดงมาส์ก";
// Hide the painted mask on the mesh
alert.mask.hide = "ซ่อนมาส์ก";
// Selection refers to the objects that are currently selected
alert.selection.lock = "ล็อคการเลือก";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "ปลดล็อกการเลือก";
// Hide the objects that are not selected
alert.selection.isolate = "แยกการเลือก";
// Show the objects that are hidden
alert.selection.showAll = "แสดงทั้งหมด";
// Project quick saving
alert.quickSave = "กำลังบันทึก...";
// Painting on the object was hidden but the user did paint the object
alert.forcePainting.fill = "แสดงการวาดลงสีที่เปิดใช้งาน [ระบายสีทั้งหมด] ถูกใช้แล้ว";
// Painting on the object was hidden but the user started to paint on the object
alert.forcePainting.tool = "แสดงการวาดลงสีที่เปิดใช้งาน ออบเจ็กต์ถูกทาสีแล้ว";
// See Glossary (Multiresolution)
alert.multiresLost = "ความละเอียดแบบหลายระดับจะหายไป!";
// Boolean cut mode will ignore some features
alert.booleanIgnored = "Boolean จะไม่สนใจพื้นที่ที่ถูกมาสก์หรือซ่อนอยู่!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "ค่ารายละเอียดสูงและอาจต้องใช้หน่วยความจำมาก!";
// Autosave popup
alert.autoSave.auto = "บันทึกอัตโนมัติใน... $0วิ.";
// The selected object doesn't have any layers
alert.needLayer = "เครื่องมือปัจจุบันต้องการเลเยอร์ที่ใช้งานอยู่";
// The user decided to hide the painting on the objects
alert.paintingHidden = "การวาดลงสีที่ซ่อนอยู่!";
// The user decided to hide the masking on the objects
alert.maskingHidden = "มาสก์ถูกซ่อน!";
// The user decided to display hidden faces
alert.hideIgnored = "ซ่อนถูกละเว้น!";
// The selected object doesn't have any layers
alert.noPartialWireframe = "การวาดบางส่วนถูกปิดใช้งานเมื่อแสดงโครงร่าง";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "พิจารณาใช้กล้องออร์โธกราฟิกหากคุณต้องการหลีกเลี่ยงความผิดเพี้ยนของฟรัสตัม เปอร์สเป็คทีฟ เมื่อใช้โปรเจ็กเตอร์หน้าจอ";
// Trial version has a limited number of undo
alert.state.trial = "เวอร์ชันทดลอง เลิกทำรายการที่ยกเลิกแล้ว";

background = "พื้นหลัง";
// A flat color will be displayed in the background of the scene
background.color = "คัลเลอร์";
// 2 color with rotation
background.gradient = "การไล่ระดับสี";
// The environment (HDRI) will be displayed in the background
background.environment = "สภาพแวดล้อม";
background.blur = "เบลอ";
background.exposure = "การเปิดรับแสง";

// Image that the artist uses as a reference
background.reference = "ภาพอ้างอิง";
// Image that the artist uses as a reference
background.imageEnable = "ภาพอ้างอิง";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "โอเวอร์เลย์";
// Opposite of transparency (Alpha)
background.imageAlpha = "ความทึบ";
background.imageReset = "รีเซ็ตการตั้งค่า";
background.imageTransform = "ปรับแต่ง";
// X screen coordinate of the image reference
background.imageX = "ตำแหน่ง X";
// Y screen coordinate of the image reference
background.imageY = "ตำแหน่ง Y";
// Rotation of the reference image
background.imageRotation = "การหมุน";
// Scale of the reference image
background.imageScale = "สเกล";
// Auto adjust the reference when moving the camera
background.lock.image = "ซิงค์กับการล็อคกล้อง";
background.lock.image.help = "เมื่อกล้องถูกล็อคด้วย Snap Cube, ภาพอ้างอิงจะติดตามการเคลื่อนไหวของกล้อง";
// When exiting camera lock
background.lock.exit = "รีเซ็ตเมื่อปลดล็อค:";
background.lock.exit.none = "ปรับ Fov";
background.lock.exit.none.help = "คงภาพและกล้องไว้ 
หากเป็นในเพอร์สเปกทีฟ, ปรับแค่สนามทัศน์";
background.lock.exit.all = "รีเซ็ตทั้งหมด";
background.lock.exit.all.help = "รีเซ็ตทั้งตำแหน่งภาพและกล้อง";
background.lock.exit.perspective = "หากเป็นในเพอร์สเปกทีฟ";
background.lock.exit.perspective.help = "หากเป็นในเพอร์สเปกทีฟ, รีเซ็ตตำแหน่งภาพและกล้อง";

// Blend: normal
blend.normal = "ปกติ";
// Blend: darker
blend.darker = "เข้มขึ้น";
blend.darker.darken = "ทำให้เข้มขึ้น";
blend.darker.multiply = "คูณ";
blend.darker.linearBurn = "เบิร์นแบบเชิงเส้น";
blend.darker.colorBurn = "เบิร์นสี";
// Blend: lighter
blend.lighter = "สว่างขึ้น";
blend.lighter.lighten = "ทำให้สว่างขึ้น";
blend.lighter.screen = "สกรีน";
blend.lighter.linearDodge = "เพิ่มแสงเชิงเส้น";
blend.lighter.colorDodge = "เพิ่มแสงตามสี";
// Blend: contrast
blend.contrast = "ความต่างระดับสี";
blend.contrast.hardLight = "แสงแรง";
blend.contrast.softLight = "แสงนุ่ม";
blend.contrast.overlay = "โอเวอร์เลย์";
blend.contrast.hardMix = "การผสมแบบแข็ง";
blend.contrast.linearLight = "แสงเชิงเส้น";
blend.contrast.vividLight = "แสงสดใส";
blend.contrast.average = "เฉลี่ย";
// Blend: inversion
blend.inversion = "การกลับกัน";
blend.inversion.exclusion = "การแยกออก";
blend.inversion.difference = "ความแตกต่าง";
// Blend: cancelation
blend.cancelation = "การยกเลิก";
blend.cancelation.divide = "หาร";
blend.cancelation.subtract = "ลบออก";
// Blend: component
blend.component = "ส่วนประกอบ";
blend.component.luminosity = "ความสว่าง";

// Camera (point of view in 3D)
camera = "กล้อง";
cameras = "กล้องถ่ายรูป";
camera.view = "มุมมอง";
// Copy the views
camera.updateView = "อัพเดทมุมมอง?";
// Add a new camera
camera.addView = "เพิ่มมุมมอง";
// Focus on the camera
camera.focus = "โฟกัส";
// Add on the camera camera
camera.focusOn = "โฟกัสที่ $0";
// Camera projection, Orthographic or Perspective
camera.projection = "การฉายภาพ";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "ออร์โทกราฟฟิก";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "เพอร์สเปกทีฟ";
// camera Vertical Field of View
camera.fov = "Fov แล้วตั้ง";
// Camera Field of View hint
camera.focal = "โฟกัส $0มม. (เซนเซอร์ 35 มม.)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "การหมุน";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "แท่นหมุน";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "แทร็กบอล";
camera.rotation.trackball.help = "แทร็กบอลให้อิสระในระดับที่มากขึ้น คุณยังสามารถหมุนกล้องด้วย 2 นิ้วได้อีกด้วย";
// Camera interaction mode, 1st person view
camera.firstPerson = "บุคคลแรก";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "ความเร็ว";
// Camera rotation sensitivity
camera.speed.rotation = "การหมุน";
// Camera translation sensitivity
camera.speed.panning = "การแพน";
// Camera zooming sensitivity
camera.speed.zooming = "การซูม";
// Reset camera position
camera.resetView = "รีเซ็ตมุมมอง";
// Align the view (snap to nearest 90° angle)
camera.snapView = "มุมมองแบบสแนป";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "กล้องถูกสแน็ป (ออร์โธกราฟิก)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "สแนปแบบออร์โทกราฟฟิก";
camera.snapOrthographic.help = "ตัวเลือกนี้ยังคงทำงานอยู่เมื่อใช้สแนปคิวบ์ที่มุม";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "จุดหมุน";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "แตะสองครั้งที่ออบเจ็กต์";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "แตะสองครั้งที่พื้นหลัง";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "สลับ";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "การเลือก";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "ซีน";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "อัพเดทเมื่อแตะสองครั้ง";
camera.doubleTapPivot.help = "จะอัพเดทจุดหมุนเมื่อแตะสองครั้งบนพื้นผิวของออบเจ็กต์";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "จุดหมุนลอย";
camera.airPivot.help = "ให้ตั้งจุดหมุนใหม่แม้ในขณะที่ซูมออกนอกพื้นผิวออบเจ็กต์";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "ในกล้องการควบคุมด้วยท่าทางจะเริ่ม";
camera.autoPivot.help = "อัพเดทจุดหมุนเมื่อคุณเริ่มโต้ตอบกับกล้อง";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "โฟกัส";
camera.doubleTapFocus.help = "เมื่อแตะสองครั้งที่ออบเจ็กต์ กล้องจะเลื่อนและโฟกัสที่จุดที่เลือก";
// Disable XY panning when unzomming
camera.centerZoomOut = "กึ่งกลางมุมมองเมื่อซูมออก";
camera.panZoomOut.help = "เมื่อปิดตัวเลือกนี้ ตำแหน่งหมุนนี้จะยังคงอยู่เหมือนเดิม";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "การเลือกหลายรายการ";
// There is 0 nodes/items selected
context.noSelection = "ไม่มีการเลือก";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "พรีเซ็ต";
// Quick curve x side shift
curve.shift = "ชิฟต์";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "แคทมูลรอม";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "สลัก";
curve.bspline = "สลัก";
curve.precision = "ความแม่นยำ";
// merge or collapse 1 point into another
curve.merge = "รวม";
// snap
curve.snap = "สแนป";
curve.snap.offset = "ออฟเซ็ต";
curve.snap.offset.help = "ค่า 100% เท่ากับรัศมีของท่อ";
curve.snap.surface = "พื้นผิว";
curve.snap.vertex = "จุดยอด";
curve.snap.grid = "ตาราง (ถ้าสแนป)";
// Regular spaced sampling
curve.uniform = "สม่ำเสมอ";
curve.uniform.help = "เส้นโค้งจะถูกสุ่มอย่างสม่ำเสมอเพื่อให้มีความหนาแน่นที่เท่ากัน

คุณสามารถปิดการใช้งานตัวเลือกนี้เพื่อควบคุมขอบวงโดยการเพิ่มจุดควบคุมใหม่บนเส้นโค้ง";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "แสดงการลดลงในลักษณะที่สมมาตร

ตัวเลือกนี้เป็นเพียงสัญญาณทางสายตา, ไม่มีผลต่อการลดลงเอง";
curve.radius = "รัศมี";
curve.twist = "บิด";
curve.spiral = "เกลียว";
curve.spiral.twist = "มุมบิด";
curve.spiral.scale = "สเกล";
curve.spiral.offset = "ออฟเซ็ต";
curve.spiral.angle = "ออฟเซ็ตของมุม";
curve.pivot = "จุดหมุน";
curve.pivot.self = "เคิร์ฟ";
curve.pivot.children = "โหนดลูก";

// Set the desired FPS (frame per second, refresh rate)
debug.targetFps = "เป้าหมาย FPS";
debug.targetFps.help = "เมื่อปิดใช้งาน, ค่าเริ่มต้นหมายความว่าจะซิงค์กับอัตราการรีเฟรชของจอแสดงผล";

// Warning about UVs (using extra memory)
debug.uvPrimitive.warning = "ปิดใช้งานตัวเลือกนี้หากคุณไม่ต้องการ UVs (หน่วยความจำเพิ่มเติม)";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "ปรับ UVs ให้เป็นปกติ";
debug.uvNormalize.help = "Nomad จะทำให้ UVs ภายในไทล์ [0-1] เป็นปกติ";

// Debug option, display an window with some debugging logs
debug.logs = "บันทึก";
// Model shortcut window
debug.shortcut = "หน้าต่างทางลัด";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "แผนที่ความสูง";
// Debug options, graphical stuffs
debug.graphics = "กราฟฟิก";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "สร้างภาพขนาดย่อของสโตร์";

// Open file explorer
file.explore = "สำรวจ";
// Open file explorer
file.scope = "ขอบเขต";
file.scope.internal = "ภายใน";
file.scope.internal.help = "พฤติกรรมเริ่มต้น, เหมือนกับมือถือ 
โครงการจะถูกบันทึกเฉพาะในโฟลเดอร์หลักของ Nomad";
file.scope.external = "ในตำแหน่ง";
file.scope.external.help = "เมื่อมีการนำเข้าโครงการจากภายนอก, การบันทึกจะเขียนทับไฟล์ต้นฉบับ 
ไม่รองรับการบันทึกอัตโนมัติสำหรับโครงการภายนอก";
// Empty list: there is no projects
file.project.load = "โหลดโปรเจกต์เมื่อเริ่มต้น";
// Empty list: there is no projects
file.project.empty = "คุณยังไม่มีโปรเจกต์ที่บันทึกไว้!";
// The current opened project has some unsaved changes
file.project.unsaved = "การเปลี่ยนแปลงที่ไม่ได้บันทึก!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "การเปลี่ยนแปลงที่ไม่ได้บันทึกจะหายไป";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "ดูตัวอย่างการบันทึกด้วยตนเองล่าสุด";

file.project = "โปรเจ็กต์";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "บันทึก";
// E.g: Save "my_project"?
file.project.save.confirm = "บันทึก$0?";
// Make a copy
file.project.saveAs = "บันทึกเป็น";
// Overwrite another project
file.project.overwrite = "เขียนทับ";
// E.g: Overwrite "my_other_project"?
file.project.overwrite.confirm = "เขียนทับ $0 หรือไม่?";
// Open a project
file.project.open = "เปิด";
// E.g: Open "my_project"?
file.project.open.confirm = "เปิด $0?";
// E.g: Clone "my_project"?
file.project.clone.confirm = "โคลนนิ่ง $0?";
// Load another project and add/append all its data to the current scene
file.project.add = "เพิ่มไปที่ซีน";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "เพิ่ม $0 ไปที่ซีน?";
// Reset the scene and create a new project
file.project.new = "ใหม่";
file.project.new.confirm = "สร้างซีนใหม่?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "ลบ $0?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "ลบ $0?

นี่คือโปรเจ็กต์ที่ใช้งานอยู่ในปัจจุบัน!";

// Auto save section
file.autoSave = "บันทึกอัตโนมัติ";
file.autoSave.confirm = "ปิดการบันทึกอัตโนมัติ?";
file.autoSave.help = "บันทึกโปรเจกต์ของคุณเป็นไฟล์แยกในช่วงเวลาปกติ

ไฟล์บันทึกอัตโนมัติสามารถพบได้ใน";
// Interval in minutes in which the auto save popup will appear
file.autoSave.popup = "หมดเวลาป๊อปอัพ";
// In minutes
file.autoSave.minutes = "ป๊อปอัพตัวจับเวลา";
// Delete the current autoSave data
file.autoSave.delete = "ลบบันทึกอัตโนมัติ?";
// Open the outdated auto save
file.autoSave.open.manual = "เปิดบันทึกที่เก่ากว่าแบบแมนนวล";
file.autoSave.open.auto = "เปิดบันทึกอัตโนมัติที่เก่ากว่า";

// color space (linear or srgb), do not translate linear/srgb if there is a doubt
file.colorSpace = "สี Space";
file.colorSpace.help = "ลองเปิดปิดตัวเลือกนี้หากสีดูไม่ถูกต้อง";
file.colorSpace.linear = "Linear";
file.colorSpace.srgb = "sRGB";

// Configure imports option
file.importSettings = "นำเข้าตัวเลือก";

// Load interface preference settings when opening a scene file
file.import.guiSettings = "เก็บการตั้งค่า gui";
file.import.guiSettings.help = "เมื่อเปิดหรือนำเข้าไฟล์โปรเจ็กต์ การตั้งค่าที่เกี่ยวข้องกับ gui ทั้งหมดที่ฝังอยู่ในโปรเจ็กต์จะถูกโหลด";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.import.obj.splitByGroup = "แยก OBJ ตามกลุ่ม";
file.import.obj.splitByGroup.help = "เมื่อเปิดใช้งาน Nomad จะแบ่งกลุ่ม OBJ ออกเป็นอ็อบเจ็กต์แยกกัน";
// Merge all the object layers at when loading a file (deleting them in the process)
file.import.mergeLayers = "รวมเลเยอร์";
// Ignore the textures present in the file to load
file.import.skipTextures = "ข้ามพื้นผิว";
// Do not fiddle with the object topology when loading the file
file.import.keepTopology = "เก็บโทโพโลยี";
file.import.keepTopology.help = "ใช้ตัวเลือกนี้หากคุณไม่ต้องการให้ Nomad จัดการกับโทโพโลยีของเมชที่นำเข้า

จะปิดใช้งานการจัดลำดับใหม่จุดยอด/เฟส การลบจุดยอด/เฟสที่ซ้ำกัน และการลบจุดยอดที่ไม่ได้ใช้";

// Import file section
file.import.title = "นำเข้า";
file.import.title.help = "ฟอร์แมตที่รองรับ";
// The user imports a scene file that will replace the current scene
file.import.open = "เปิด";
file.import.open.confirm = "นำเข้าไฟล์ใหม่?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "เพิ่มไปที่ซีน";
file.import.add.confirm = "นำเข้าไฟล์ใหม่?";

// Export scene file
file.export = "นำออก";

// Filter nodes that we want to export
file.select.include = "ได้แก่";
file.select.all = "ทั้งหมด";
file.select.visible = "ที่เห็นได้";
file.select.selected = "ที่เลือก";
file.select.unselected = "ยกเลิกการเลือก";

// Export each node in a separate file
file.export.separate = "ไฟล์เดียวต่อวัตถุหนึ่งชิ้น";

// Export the current selected objects instead of the entire scene
file.onlySelection = "รวมเฉพาะออบเจ็กต์ที่เลือก";
file.onlySelection.help = "รวมเฉพาะส่วนที่เลือก แทนที่จะเป็นทั้งซีน";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "สร้างรูปสี่เหลี่ยมขึ้นใหม่";
file.convertToQuad.help = "สร้างรูปสี่เหลี่ยมขึ้นใหม่จากสามเหลี่ยมโดยจับคู่สามเหลี่ยม (หากอยู่ติดกันในไฟล์)";
// ----------------------------------------------
// Whether we include the textures in the exported file
file.export.texture = "พื้นผิว";
// Baking means transfering/converting
file.export.texture.help = "ตัวเลือกนี้ไม่เบคสีของจุดยอดลงในพื้นผิว";
// ----------------------------------------------
file.export.color0 = "สีของวอร์เท็กซ์";
file.export.color1 = "การวาด pbr";
file.export.color1.help = "นำออกความหยาบ ความเป็นโลหะ และการวาดลงสีส่วนที่มาส์ก การดำเนินการนี้จะถูกละเว้นโดยซอฟต์แวร์อื่น";
// ----------------------------------------------
// Whether we include normals vector in the exported file
file.export.normal = "แนวฉาก";
file.export.normal.help = "เลือกตัวเลือกนี้หากคุณต้องการเปิดไฟล์ในซอฟต์แวร์อื่น

Nomad จะไม่สนใจแนวฉากเหล่านี้เพราะระบบจะคำนวณใหม่";
// ----------------------------------------------
file.export.tangent = "เส้นแทนเจนต์";
file.export.tangent.help = "เลือกตัวเลือกนี้หากคุณต้องการเปิดไฟล์ในซอฟต์แวร์อื่น

เส้นแทนเจนต์จะถูกใช้เฉพาะเมื่อโมเดลมีแผนที่ปกติ

Nomad จะไม่สนใจแนวฉากเหล่านี้เพราะระบบจะคำนวณใหม่";
// ----------------------------------------------
file.export.nomad.help = "รูปแบบไฟล์ภายในของ Nomad Sculpt

รูปแบบนี้จะไม่โหลดได้บนซอฟต์แวร์อื่น, ส่วนใหญ่สำหรับวัตถุประสงค์การนำเข้าใหม่";
// ----------------------------------------------
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "เลเยอร์";
file.export.gltf.layer.help = "นำออกเลเยอร์เป็นมอร์ฟ รองรับอย่างเป็นทางการโดย glTF ดังนั้นจึงใช้งานได้บนซอฟต์แวร์อื่นด้วยเช่นกัน";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "การวาดเลเยอร์";
file.export.gltf.layerPaint.help = "นำออกการวาดลงสีเลเยอร์ มักจะถูกละเว้นโดยซอฟต์แวร์อื่น";
// ----------------------------------------------
file.export.obj.warning = "เลเยอร์และการวาดลงสีเพิ่มเติม (ความหยาบ ความเป็นโลหะและมาส์ก) จะหายไป";
// Whether we include the vertex color in the exported file
file.export.obj.color = "สีของวอร์เท็กซ์";
file.export.obj.color.help = "ซอฟต์แวร์ 3D บางตัวจะสามารถอ่านได้ แต่ไม่ใช่ทั้งหมด";
file.export.obj.color.help.append = "ผนวกข้อมูลสีหลังจุดยอด";
file.export.obj.color.help.hexa = "วิธีการเข้ารหัสสีทางเลือก ยังรองรับข้อมูลมาสก์";
file.export.obj.faceGroup = "กลุ่มหน้า";
file.export.obj.object = "เขียนวัตถุ";
file.export.obj.object.help = "เก็บวัตถุแยกจากกัน

การปิดใช้งานตัวเลือกนี้จะส่งออกทุกอย่างเป็นเอนทิตีเดียว
คุณต้องปิดการใช้งานตัวเลือกนี้หากต้องการใช้คุณสมบัติ 'Mesh ID / Polygroup' ของ Substance Painter";
file.export.obj.archive = "ประเภท";
file.export.obj.archive.folder = "โฟลเดอร์";
file.export.obj.archive.zip = "ซิป";
file.export.obj.archive.help = "แอปบางตัว (Google Drive, One Drive ฯลฯ) ไม่รองรับการนำเข้าโฟลเดอร์ ดังนั้นคุณสามารถใช้ซิปแทน";
// ----------------------------------------------
file.export.ply.warning = "เลเยอร์และการวาดลงสีเพิ่มเติม (ความหยาบ ความเป็นโลหะและมาส์ก) จะหายไป";
// ----------------------------------------------
file.export.stl.warning = "เลเยอร์และการวาดลงสีเพิ่มเติม (ความหยาบ ความเป็นโลหะและมาส์ก) จะหายไป";
// Whether we include the vertex color in the exported file
file.export.stl.color = "สีของวอร์เท็กซ์";
file.export.stl.color.help = "ซอฟต์แวร์ 3D บางตัวจะสามารถอ่านได้ แต่ไม่ใช่ทั้งหมด";
// ----------------------------------------------
file.export.usd.skew = "อนุญาตให้บิดเบือน";
file.export.usd.skew.help = "อนุญาตให้บิดเบือนในเมทริกซ์การแปลง

เมื่อปิดการใช้งาน Nomad จะแยกเมทริกซ์บิดเบือนออกเป็นการแปลงสเกลและการหมุนแยกกัน";
// ----------------------------------------------
// Advanced settings
settings.advanced = "ขั้นสูง";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "ตัวเลือกเหล่านี้ไม่ถูกบันทึกไว้ในการตั้งค่า";
settings.reset.title = "การตั้งค่า";
settings.reset.title.help = "จะรีเซ็ตการตั้งค่ากำหนดแอป

ทรัพยากรบางอย่างจะถูกบันทึกแยกต่างหากและจะไม่ถูกรีเซ็ตอันได้แก่
• โปรเจ็กต์
• การผูกกุญแจ
• เครื่องมือที่ตั้งไว้ล่วงหน้า
• สภาพแวดล้อม HDRs 
• MatCaps
• อัลฟ่า
• พื้นผิว (แปรง)
• รูปภาพอ้างอิง

โปรดทราบว่าทุกอย่างที่เชื่อมโยงกับโพรเจ็กต์จะยังคงอยู่เหมือนเดิม เช่น การจัดแสง โพสต์โพรเซส มุมมองกล้อง ฯลฯ";

// Reset preference settings button
settings.reset = "รีเซ็ตเป็นค่าเริ่มต้น";
settings.reset.confirm = "รีเซ็ตการตั้งค่ากำหนด";

// Render a screenshot of the scene
file.render = "เร็นเดอร์";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "แสดงอินเตอร์เฟซ";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "อัตราส่วนของเร็นเดอร์";
file.render.renderRatio.help = "ค่า 1.0 หมายความว่า Nomad จะสร้างภาพที่ความละเอียดเดียวกันกับขนาดภาพที่ต้องการด้านล่าง

ใช้ตัวเลือกนี้หากคุณไม่สามารถสร้างได้ที่ความละเอียดที่แน่นอนได้ (หยุดทำงานเนื่องจากหน่วยความจำไม่เพียงพอ)";
// Desired size of the exported screenshot
file.render.size = "ขนาดสุดท้าย";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "กำหนดเอง";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "สกรีน";
// width of exported screenshot
file.render.width = "กว้าง";
// height of exported screenshot
file.render.height = "สูง";
// export screenshot of the scene
file.render.warn = "การนำออกมีค่าความละเอียดสูง ($0x$1)!

อย่าลืมบันทึกโปรเจ็กต์ของคุณในกรณีที่อุปกรณ์ที่คุณใช้ไม่มี VRAM และเกิดปัญหา";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "พื้นหลังโปร่งใส";
file.render.transparent.help = "ตัวเลือกนี้จะมีประโยชน์เมื่อคุณต้องการใส่เมชในซอฟต์แวร์สร้าง 2D

ในขณะนี้ไม่รองรับความโปร่งใสของออบเจ็กต์บางส่วน";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "ใช้การตั้งค่ากลาง";
pressure.useGlobal.help = "โดยค่าเริ่มต้น เครื่องมือจะใช้การตั้งค่าแรงกดเดียวกัน

ยกเลิกการเลือกตัวเลือกนี้หากคุณต้องการตั้งค่าแรงกดเฉพาะสำหรับเครื่องมือนี้";

// Pencil pressure
pressure.title = "แรงกด";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "เครื่องมือนี้ไม่ใช้แรงกดดินสอ";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "ประเภทของเส้นที่วาดที่เลือกไว้จะไม่มีผลต่อการตั้งค่าแรงกด";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "รัศมี";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "ความเข้ม";
// Average pencil pressure event to get smoother result
pressure.average = "ความเรียบของแรงกด";
pressure.average.help = "คำนวณค่าเฉลี่ยของเหตุการณ์แรงกดดินสอเพื่อผลลัพธ์ที่เรียบขึ้น";
// Limit pressure to 100%
pressure.limit = "จำกัดแรงดันที่ 100%";
pressure.limit.help = "นี่คือการตั้งค่าระดับโลก

ใช้ตัวเลือกนี้เพื่อให้แน่ใจว่าแรงดินสอไม่เกิน 100%";

// list of inputs allowing camera interaction
gesture.camera = "กล้อง";
// list of inputs allowing sculpting interaction
gesture.sculpt = "แกะสลัก";
// Select object
gesture.select = "เลือกวัตถุ";
// Finger/Touch input
gesture.finger = "นิ้ว";
// Stylus/Pencil
gesture.stylus = "สไตลัส";
// Mouse/Trackpad
gesture.mouse = "เมาส์";

gesture.wheel = "วงล้อเมาส์";
gesture.wheel.speed3d = "ความเร็ว (ซูม 3 มิติ)";
gesture.wheel.speed2d = "ความเร็ว (อินเทอร์เฟซ 2 มิติ)";

// long press to pick the color/material under the cursor
gesture.dropper = "การเลือกวัสดุ";
gesture.dropper.help = "การเลือกสี/วัสดุสามารถเปิดใช้งานได้ด้วยการกดค้างบนแคนวาส

โปรดทราบว่าใช้งานได้เฉพาะเมื่อแปรงปัจจุบันเปิดใช้งานการระบายสี";

camera.airStroke = "อนุญาตการกวาดอากาศ";
camera.airStroke.help = "อนุญาตให้เริ่มเคลื่อนไหวในการแกะสลักได้แม้ว่าตัวชี้เริ่มต้นจะไม่ตรงกับเมช

ตัวเลือกนี้ใช้งานได้เฉพาะอินพุตที่เปิดใช้งานสำหรับการแกะสลักและปิดใช้งานกล้อง";

// Three fingers on screen
gesture.three.title = "สามนิ้ว";
gesture.three.light = "หมุนแสง";
gesture.three.light.help = "หมุนสภาพแวดล้อม แสงและ MatCap";
gesture.three.radius = "รัศมีเครื่องมือ";
gesture.three.intensity = "ความเข้มของเครื่องมือ";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.finger.smooth = "นิ้วเรียบเสมอ";
gesture.finger.smooth.help = "ตัวเลือกนี้จะใช้งานได้เฉพาะเมื่อเครื่องมือปั้นกำลังใช้งาน";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "ให้ใช้แรงกดที่ไม่รู้จัก";
gesture.unknownPressure.help = "เลือกตัวเลือกนี้หากใช้งานแรงกดไม่ได้กับ Pencil ของคุณ หรือหากต้องการใช้นิ้วกด";

// Action when we press an Android pencil button
gesture.pencilAction.android = "ปุ่ม Pencil";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "แตะสองครั้งที่ Pencil";
gesture.pencilAction.ios.help = "ใช้งานได้กับ Apple Pencil รุ่นที่ 2 เท่านั้น";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "ไม่มี";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "เพิ่ม/ย่อย";

// Idle long press with pencil, mouse, finger, etc
gesture.longPress = "กดแช่";


// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "ทางลัดหนึ่งแตะ";
gesture.mask.oneTap.help = "เปิดใช้ทางลัดมาส์ก โดยแตะที่หน้าจอหนึ่งครั้ง โดยไม่ต้องกดทางลัดมาส์กค้างไว้

ด้วยท่าทางต่อไปนี้:
• แตะที่พื้นหลังเพื่อพลิกส่วนที่มาส์ก
• แตะที่พื้นที่มาส์กเพื่อเบลอการมาส์ก
• แตะที่พื่นที่ไม่ได้มาส์กเพื่อทำให้ส่วนที่มาส์กชัดเจนขึ้น";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.holdStroke = "วาดเส้น";
gesture.mask.holdStroke.help = "การกดค้างนานจะสลับระหว่าง Mask และ SelMask และเริ่มการเขียนใหม่

ที่สิ้นสุดการเขียน, เครื่องมือก่อนหน้าจะถูกเลือกกลับ";
gesture.mask.holdIdle = "เครื่องมือ";
gesture.mask.holdIdle.help = "กดค้างและปล่อยโดยไม่เคลื่อนไหวเพื่อสลับระหว่าง Mask และ SelMask";

gesture.smooth.holdSelect.help = "การกดแช่จะเปลี่ยนไปใช้เครื่องมือเลือกตลอดเวลาที่เลือกเส้น";

// Shortcut customization, choose the action that the shortcut will performan (select tool, etc)
gesture.shortcut = "ทางลัด";

// Shortcuts to undo/redo
gesture.history = "ทางลัดรายการเลิกทำและทำซ้ำ";
gesture.history.help = "• เลิกทำ แตะด้วย 2 นิ้ว
• ทำซ้ำ แตะด้วย 3 นิ้ว";
gesture.history.hold = "กดแช่";
gesture.history.hold.help = "แตะค้าง 2/3 นิ้ว (ต่อเนื่อง)";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "วางฝ่ามือได้";
gesture.palmRejection.confirm = "อย่าลืมปิดการใช้งานตัวเลือกนี้หากคุณมีปัญหาในการใช้งานแคนวาส!";
gesture.palmRejection.help = "ปฏิเสธอินพุตหากพื้นที่ที่สัมผัสมีขนาดใหญ่กว่าค่านี้

อาจจะใช้งานไม่ได้กับทุกอุปกรณ์";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "เกณฑ์ขนาดสูงสุด";

// Smoothing strategy
extract.polish.all = "ทั้งหมด";
extract.polish.sharp = "ขอบคม";
extract.polish.border = "เฉพาะขอบ";
// Smooth the border in a way that it matches completely with its dual
extract.polish.syncBorder = "ซิงค์ขอบ";
// topology of extracted mesh
extract.edgeLoop = "ลูปขอบ (ด้านข้าง)";
extract.edgeLoop.auto = "ลูปขอบอัตโนมัติ";
extract.edgeLoop.division = "การแบ่งแยก";
// The thickness of the extracted mesh (from the painted mask)
extract.thickness = "ความหนา";
// Carve the mask into the surface
extract.carve = "แกะสลัก";
// Extract a new mesh from the painted mask
extract = "สกัด";
// Preview extract
extract.preview = "พรีวิว";
// Extract two new mesh from the painted mask and from the unmasked area
extract.split = "แยก";
// How should we close the topology of the extracted object
extract.action = "การดำเนินการปิด";
extract.action.help = "• ไม่มี
เพียงสกัดส่วนนี้แล้วปล่อยให้ส่วนที่สกัดออกมาเปิดออก

• เติม
หลุมถูกเติมและทำให้เรียบ
อย่าใช้ตัวเลือกนี้สำหรับพื้นผิวเรียบ

• เปลือก
ปิดรูปร่างที่สกัดออกมาโดยใช้ค่าความหนา

• เลเยอร์
แยกความแตกต่างของเลเยอร์ (เฉพาะเมนูย่อยของเลเยอร์)";
// Do not close the mesh (leave it open)
extract.action.none = "ไม่มี";
// Close the mesh with a hole-filling algorithm
extract.action.fill = "เติม";
// Close the mesh by adding a thickness on the surface
extract.action.shell = "เปลือก";
// Close the mesh by using the layer data as a difference thickness
extract.action.layer = "เลเยอร์";

// uv part of revolution surface
genus.main = "หลัก";
genus.hole = "รู";
genus.bottom = "ล่าง";
genus.top = "บน";

// History, list of undo/redo
history = "ประวัติ";
// First "undo" state
history.root = "เริ่ม";
history.undoConfirm = "คุณยืนยันการยกเลิกการดำเนินการทั้งหมดเหล่านี้หรือไม่";
history.undoWarning = "หากคุณทำการแก้ไขในภายหลัง คุณอาจสูญเสียการเปลี่ยนแปลงหลายรายการ";
// Settings concerning the history stack of undo/redo
history.stack = "กอง";
// Actions to include in the undo/redo stack
history.include = "ได้แก่ การดำเนินการ";
// include lighting editing in the undo/redo
history.includeLights = "แสง";
history.includeLights.help = "หากปิดตัวเลือกนี้ การย้ายแสงด้วยกิซโม่จะยังรวมอยู่ด้วย เนื่องจากอาจส่งผลต่อออบเจ็กต์อื่นๆ ในลำดับชั้นของซีน";
// include postProcess editing in the undo/redo
history.includePostProcess = "PostProcess";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCaps & HDRIs";
// Can limit the stack of undo/redo size
history.limitSize = "ข้อจำกัดรายการประวัติ";
history.limitSize.help = "ขนาดสูงสุด ของประวัติ

รายการประวัติจะได้รับการอัพเดทในการดำเนินการที่บันทึกไว้ในครั้งต่อไป";
// Limit the number of undo in the history stack
history.limitStack = "ข้อจำกัดของกอง";
history.limitStack.help = "จำนวนรายการดำเนินการที่แอปพลิเคชันสามารถเก็บไว้ได้สูงสุด

จะอัพเดทประวัติการดำเนินการที่บันทึกไว้ในครั้งต่อไป";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "จำนวนสูงสุดของการเลิกทำ";
history.rangeProtect.help = "หากคุณย้อนกลับไปไกลในรายการประวัติการเลิกทำ จะต้องยืนยันกับระบบก่อนว่าต้องการเลิกทำรายการทั้งหลายเหล่านั้น";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "คืนค่ากล้อง";
history.restoreCamera.help = "เปิดใช้งานตัวเลือกนี้เพื่อกู้คืนมุมมองกล้องที่บันทึกไว้เมื่อคุณเลิกทำ/ทำซ้ำรายการนี้";
// Undo
history.undo = "เลิกทำ";
// Redo
history.redo = "ทำซ้ำ";
// Shown during undo
history.state.undo = "เลิกทำ $0";
// Shown during redo
history.state.redo = "ทำซ้ำ $0";
// Shown during undo/redo
history.state.voxelRemesh = "รีเมชว็อกเซล";
// Shown during undo/redo
history.state.surfaceRemesh = "รีเมชพื้นผิว";
// Shown during undo/redo
history.state.multiresLevel = "การเปลี่ยนแปลงของความละเอียด";

// Debugging/Inspect object material (view channel separately color, roughness, normal, uv, etc)
inspect = "ตรวจสอบ";
// Inspector but SHORT
inspect.short = "ตรวจสอบ";
// Display the material channel on the background
inspect.onBackground = "เบื้องหลัง";
// Display the material channel on the mesh
inspect.onMesh = "บนเมช";
// Show UV seams
inspect.seams = "รอยต่อ";

// Interface customization
interface = "อินเตอร์เฟซ";

// Resize window (should be short)
interface.resize = "ปรับขนาด";

// UI customization: one item row will stands on one line (synonym: Inlined)
interface.compact = "UI: กระชับ";

// UI customization: each row of the list will be bigger
interface.expandList = "UI ขยายรายการ";
// UI customization: each row of the list will be bigger
interface.expandList.help = "เฉพาะตัวเลือก UI เพื่อการจัดการรายการได้ง่ายขึ้น";

// Add shortcuts buttons to the bottom of the screen
interface.shortcut.bottom = "เพิ่มทางลัด (ล่าง)...";
// Floating window
interface.shortcut.float = "เพิ่มทางลัด (หน้าต่าง)...";

// Interface option (main base color)
interface.colorBase = "ฐานสี";
// Interface option (accent widget color)
interface.colorSelect = "วิดเจ็ตสี";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "พาเนลโปร่งใส";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "ค่าความเบลอ";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "พาเนลสี";

// Interface color style
interface.preset.title = "พรีเซ็ต";

// Reset interface settings
interface.resetAll = "รีเซ็ตสไตล์";
interface.resetAll.confirm = "รีเซ็ตการตั้งค่าอินเตอร์เฟซ?";
// Help popup when hovering
interface.hoverHelp = "หน้าต่างช่วยเหลือเมื่อเอาเมาส์ไปชี้";
// Do not use windows native dialog
interface.customDialog = "ใช้การโต้ตอบของ Nomad";
interface.customDialog.help = "แสดงการโต้ตอบข้อความของ Nomad เองแทนที่จะเป็นการโต้ตอบแบบ Native";
// Interface option (main base color)
interface.iconSupport = "ปุ่มคอนทราสต์สูง";
interface.iconSupport.help = "สไตล์ทางเลือกสำหรับปุ่มที่ทำให้พวกมันมองเห็นได้ง่ายขึ้นเมื่อพวกมันถูกเปิดใช้งาน

หากตั้งค่าเป็นอัตโนมัติ, Nomad จะใช้โหมดนี้เมื่อคอนทราสต์สี UI ระหว่างเปิด/ปิดใช้งานต่ำ";
// Interface customization
interface.flipTop = "มิเรอร์แถบด้านบน";
// Interface customization
interface.flipMiddle = "มิเรอร์แถบด้านข้าง";
// Interface customization
interface.flipBottom = "มิเรอร์แถบด้านล่าง";
// list of tools
interface.toolbox = "กล่องเครื่องมือ";
// hide toolbox by default
interface.toolbox.hide = "ซ่อน";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.columns = "คอลัมน์";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.rows = "แถว";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "รีเซ็ตลำดับ";
// Colored text and icon
interface.toolbox.color = "มีสี";
// Top bar
interface.top.title = "แถบบนสุด";
interface.top.responsive = "ตอบสนอง";
interface.top.responsive.help = "ตัวเลือกนี้เหมาะสำหรับหน้าจอขนาดเล็ก";
interface.top.responsive.multiline = "หลายบรรทัด";
interface.top.responsive.scroll = "เลื่อน";
interface.top.alt = "ลำดับ Alt";
interface.top.alt.help = "ไอคอนลำดับทางเลือกสำหรับเมนูด้านบน

เมนูที่เกี่ยวข้องกับการแก้ไขเมชจะอยู่ในด้านตรงข้ามของเมนูฉาก ซึ่งช่วยในการแก้ไขฉากได้";
// Scale the interface
interface.scale = "ขนาดโดยรวม";
// Spacing between widgets
interface.cursorStep = "ระยะแนวตั้ง";
// Width of the interface panels
interface.panelWidth = "ความกว้างของพาเนล";
// Size of fonts
interface.fontScale = "ขนาดของฟอนต์";
// Inset
interface.inset.title = "ออฟเซ็ตของขอบ";
interface.inset.title.help = "คุณสามารถเปลี่ยนค่าเหล่านี้ได้ก็ต่อเมื่อคุณมีปัญหาในการโต้ตอบกับปุ่มที่ขอบหน้าจอ

หากตัวเลื่อนถูกปิดใช้งาน Nomad จะใช้ค่าพื้นที่ปลอดภัยที่กู้กลับมาด้วยเครื่องอุปกรณ์นี้เอง";

// (see Glossary for Layer)
layer = "เลเยอร์";
layers.syncTransform = "ซิงค์การเปลี่ยนรูป";
layers.syncTransform.help = "If enabled, all the unselected layers will be adjusted depending on the transform rotation, scale and skew.

Disable this option if the other layers are meant to be used without the new transform that you are applying.

When set on auto, only the visible layers will be adjusted.";
// (see Glossary for Layer)
layers.lock = "เก็บเลเยอร์บนสุดไว้เหมือนเดิม";
// (see Glossary for Layer)
layers.lock.yes = "ล็อคเลเยอร์บนสุด?";
// (see Glossary for Layer)
layers.lock.warning = "ในระหว่างการปั้น การเสียรูปที่มาจากเลเยอร์บนสุดจะถูกละเว้น

อย่างไรก็ตาม รายละเอียดของเลเยอร์เหล่านี้จะยังคงปรากฏให้เห็น

ตัวเลือกนี้ใช้ได้เฉพาะเมื่อเลเยอร์บนสุดมีรายละเอียดขนาดค่อนข้างเล็ก";
// (see Glossary for Layer)
layers.addLayer = "เพิ่มเลเยอร์";
// (see Glossary for Layer)
layer.factors = "แฟกเตอร์ของช่อง";
// (see Glossary for Layer)
layer.factor = "แฟกเตอร์";
// (see Glossary for Layer)
layer.offset = "ออฟเซ็ต";
// Layer blend mode
layer.blendMode = "การเบลนด์";
// (see Glossary for Layer)
layer.base = "ฐาน";
layer.base.nothing = "ไม่มีสิ่งที่ให้สกัด!";
layer.base.background = "วัสดุพื้นหลัง";
layer.base.background.help = "หากใช้งาน, จะสกัดเฉพาะค่าวัสดุที่แตกต่างจากวัสดุพื้นหลังเท่านั้น";
// (see Glossary for Layer)
layers = "เลเยอร์";
layers.title = "เลเยอร์";
// (see Glossary for Layer)
layers.title.help = "เลเยอร์สามารถบันทึกตำแหน่งออฟเซ็ตและการระบายสี ซึ่งจะเป็นประโยชน์สำหรับเวิร์กโฟลว์ที่ไม่ใช่เชิงเส้น
ตัวอย่างเช่น โดยการทดลองการแสดงออกทางสีหน้าต่างๆ โดยไม่ต้องอาศัยสแต็กรายการประวัติเพื่อเลิกทำการเปลี่ยนแปลง

สำหรับข้อมูลการวาดภาพ เลเยอร์จะถูกจัดเรียงแบบบนลงล่าง ดังนั้นเลเยอร์บนจะมาส์กชั้นล่าง

คุณสามารถลบบางส่วนหนึ่งของเลเยอร์ (นั้นคือ ผลกระทบอื่นๆ ของเลเยอร์ด้วย) โดยใช้เครื่องมือ `DelLayer`";
layers.primitive = "เลเยอร์ไม่พร้อมใช้งานสำหรับรูปทรงพื้นฐาน";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "ไม่มี";

light = "แสง";
lights = "แสง";
// Intensity of light
light.intensity = "ความเข้ม";
// Color of light
light.color = "คัลเลอร์";
// Kelvin (the temperature unit)
light.kelvin = "เคลวิน";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "อุณหภูมิ";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "การผนวก";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "อยู่กับที่";
// The light will move along the camera
light.attachment.camera = "กล้อง";
light.attachment.help = "• อยู่กับที่
การวางแนวแสงจะไม่เปลี่ยนแปลง

• กล้อง
การวางแนวแสงขึ้นอยู่กับมุมมองของกล้อง";
// Light type (directional, spot, point)
light.type = "ชนิด";
// Directional light (synonym: sun light)
light.type.directional = "ทิศทาง";
light.type.sun = "ดวงอาทิตย์";
// Directional light (synonym: sun light)
light.type.environment = "สภาพแวดล้อม";
light.type.hdri = "HDRI";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "สปอต";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "จุด";
// For directional light (angle jitter)
light.angle = "มุม";
// For point/spot light (offset jitter)
light.size = "ขนาด";
// Cone angle for spot angles
light.spot.angle = "มุมกรวย";
// Softness of the spot light
light.spot.softness = "ความนุ่ม";
// Position of the light
light.position = "ตำแหน่ง";
// Enable or disable shadows for a light
light.shadow.cast = "เงา";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "จุดของแสงรองรับเฉพาะเงาของพื้นที่หน้าจอ";
light.shadow.type = "ชนิดของเงา";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "แผนที่เงา";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "พื้นที่หน้าจอ";
light.shadow.type.screenspace.help = "คุณลักษณะทดลอง อาจถูกลบออกในรุ่นต่อๆ ไป

ตัวเลือกนี้มีไว้สำหรับใช้กับคุณสมบัติเงาที่นุ่มนวล";
// Adjustment to fix artefacts
light.shadow.bias = "เอน";
// How blurry the shadow is
light.shadow.softness = "ความนุ่ม";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "สัมผัส";
light.contact.help = "ถ้าเลือกเป็นอัตโนมัติ เฉพาะแสงที่โดดเด่นที่สุดเท่านั้นที่จะมีเงาสัมผัส";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "เกณฑ์การยอมรับ";
// Activated the light
light.visible = "แสดง";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "รีเซ็นเตอร์";

// Object's material
material = "วัสดุ";
// See glossary
material.pbrRoughnessMetalness.warning = "ความหยาบและความเป็นโลหะต้องใช้โหมดแรเงา PBR";
// See glossary
material.pbrReflectance.warning = "การสะท้อนต้องใช้โหมดแรเงา PBR";
// See glossary
material.pbrRefraction.warning = "การหักเหของแสงต้องใช้โหมดแรเงา PBR";
// See glossary
material.pbrSubsurface.warning = "พื้นผิวต้องใช้โหมดแรเงา PBR";
// Value that says how much light will change direction when hitting the surface
material.ior = "ค่าดัชนีหักเห";
// an object-level value that overrides the roughness interior/surface of the mesh
material.paintingOverride = "แทนที่ภาพวาด";
// The roughness in the inside is turbidity
material.paintingOverride.help = "สามารถปรับความหยาบได้สองแบบคือ แบบที่อยู่บนพื้นผิวและด้านใน

อย่างไรก็ตาม มีความหยาบที่ลงสีได้เพียงแบบเดียว ดังนั้นความหยาบทั้งสองจึงมีค่าเท่ากัน";
// Glossiness is simply the opposite of roughness
material.refraction.surface = "พื้นผิว";
// Synonym: turbidity
material.refraction.interior = "ภายใน";
// Set the roughness of the object with a value of 0
material.paintGlossy = "เคลือบเงา";
material.paintGlossy.help = "จะทาสีออบเจ็กต์ด้วยความหยาบและความเป็นโลหะค่าเป็น 0 ซึ่งช่วยให้การหักเหที่คมชัด

นี่เหมือนกับการทำงานในเมนูสีและปิดใช้งานคุณสมบัติสีทั้งหมด";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "การกลืน";
material.absorptionEnable.help = "การจำลองแสงที่ถูกดูดกลืนเมื่อส่องผ่านปริมาตร

บริเวณส่วนที่บางจะสว่างเพราะแสงส่องผ่านได้มากกว่า ส่วนบริเวณที่หนาจะมืดกว่า

เอฟเฟกต์จะขึ้นอยู่กับรูปร่างของวัตถุเสียส่วนใหญ่ โดยใช้การประมาณความหนาของวัตถุเท่านั้น";
material.absorptionFactor = "แฟกเตอร์";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "ความลึก";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "ความโปร่งแสง";
material.translucency.help = "คุณต้องมีแสงที่ส่องเงาจึงจะมองเห็นความโปร่งแสงได้";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "ความทึบ";
// Fully opaque material
material.type.opaque = "ทึบแสง";
material.type.opaque.help = "นี่คือประเภทวัสดุเริ่มต้น

ค่าแอลฟาที่ระบาย, พื้นผิวความโปร่งใส หรือช่องทางแอลฟาของช่องทางสี จะยังคงคำนึงถึงโดยวิธีการดิดเธอริ่ง

เฉพาะแถบเลื่อนความโปร่งใสหลักเท่านั้นที่จะถูกละเว้น";
// Fully opaque material
material.type.shadowCatcher = "จับเงา";
material.type.shadowCatcher.help = "ทำให้วัตถุโปร่งใสหมด ยกเว้นเป็นเงาที่ถูกสร้างขึ้นโดยแสง

โหมดนี้มักใช้กับเรขาคณิตพื้นผิว";
material.type.shadowCatcher.warning = "ไม่มีแสงที่มีเงาในฉากของคุณ, Shadow Caster จะไม่ทำงาน

อย่างไรก็ตาม, ถ้า shadow catcher เป็นโลหะทั้งตัว, Shadow Catcher สามารถสะท้อนฉากได้หากเปิดใช้กระบวนการหลังการสะท้อน (SSR).";
// See glossary
material.type.subsurface = "ใต้พื้นผิว";
material.type.subsurface.help = "เพื่อให้ได้ผลลัพธ์ที่ดีที่สุด คุณสามารถเปลี่ยนไปใช้โหมดแรเงา PBR และใช้แสงส่องทิศทางอย่างน้อยหนึ่งดวง ซึ่งเหมาะกับสภาพแวดล้อมที่มืด";
// Transparency mode, alpha blendingd
material.type.blending = "การเบลนด์";
material.type.blending.help = "ทำให้ออบเจ็กต์กึ่งโปร่งแสงโดยปรับแต่งค่าความทึบ

โปรดทราบว่าเนื่องจากข้อจำกัดแบบเรียลไทม์ คุณสามารถมีภาพหลอกที่มองเห็นได้ชัดเจนหากวัตถุของคุณมีรูปร่างที่ซับซ้อน";
// Transparency mode
material.type.additive = "เติมแต่ง";
material.type.additive.help = "ทำให้ออบเจ็กต์กึ่งโปร่งแสงโดยปรับแต่งค่าความทึบ

วิธีนี้มีแนวโน้มที่จะมีภาพหลอกน้อยกว่าวิธีการผสม แต่ออบเจ็กต์จะสว่างกว่า";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "การรวมจุดสี";
material.type.dithering.help = "ทำให้ออบเจ็กต์กึ่งโปร่งแสงโดยลบพิกเซลบางส่วนแบบสุ่ม";
// Simulate glass-like material
material.type.refraction = "การหักเห";
material.type.refraction.help = "โหมดนี้สามารถใช้จำลองวัสดุแก้วได้

เนื่องจากข้อจำกัดตามเวลาจริง การหักเหตนเองหรือการหักเหของแสงหลายชั้นจึงถูกจำกัด";
material.castShadows = "ทอดเงา";
material.receiveShadows = "รับเงา";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "ไม่สว่างเสมอ";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "การคัดทิ้งส่วนตรงข้าม";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "การสะท้อนแสง";
material.reflectance.help = "ควบคุมปริมาณการสะท้อนที่วัสดุจะได้รับสำหรับวัสดุที่ไม่ใช่โลหะ

ส่วนใหญ่แล้วควรใช้ค่าเริ่มต้น (ซึ่งสอดคล้องกับมาตรฐานแสงสะท้อน 4% ที่มุมปกติ)";
// Material preview in the viewport
material.preview = "พรีวิวสีวัสดุ";
material.preview.help = "When you modify a material, a preview will be displayed in the viewport on the selected object.

The preview is shown while you interact with the color, roughness, metalness, opacity and intensity sliders.";
// Menu names
menu.files = "ไฟล์";
menu.scene = "ซีน";
menu.multires = "ความละเอียดหลายระดับ";
menu.voxel = "ว็อกเซล";
menu.dynamic = "DynTopo";
menu.topology = "อื่นๆ";
menu.primitive = "รูปทรงพื้นฐาน";
menu.render = "เร็นเดอร์";
menu.material = "วัสดุ";
menu.postprocess = "PostProcess";
menu.camera = "กล้อง";
menu.background = "พื้นหลัง";
menu.tool = "เครื่องมือ";
menu.stroke = "วาดเส้น";
menu.alpha = "อัลฟ่า";
menu.filter = "ตัวกรอง";
menu.falloff = "สร้างเส้นโค้ง";
menu.paint = "ลงสี";
menu.symmetry = "สมมาตร";
menu.operation = "การทำงาน";
menu.pressure = "แรงกด";
menu.gesture = "ท่าทาง";
menu.layers = "เลเยอร์";
menu.settings = "การตั้งค่า";
menu.interface = "อินเตอร์เฟซ";
menu.bindings = "การมัดรวม";
menu.shortcuts = "ทางลัด";
menu.history = "ประวัติ";
menu.historySettings = "การตั้งค่า";
menu.about = "เกี่ยวกับ";
menu.debug = "แก้จุดบกพร่อง";

// Operation on the object (action)
mesh.holes = "รู";
// If the object has holes, the algorithm will close them
mesh.holes.close = "ปิดรู";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holes.detail = "รายละเอียด";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "แยก";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "เลเยอร์ การวาดและความละเอียดหลายระดับจะหายไป";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "ความละเอียด";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "บังคับลูกบาศก์";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "แปลง";
// Static object means "static topology"
mesh.static = "ตาราง";
// See glossary
mesh.multires = "ความละเอียดหลายระดับ";
// Dynamic topology
mesh.dynamic = "DynTopo";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "วัสดุทั้งหมด";
paint.useGlobal.help = "หากเปิดใช้งานตัวเลือกนี้ วัสดุที่เลือกจะเหมือนกับเครื่องมืออื่นๆ

โปรดทราบว่าจะพิจารณาเฉพาะการตั้งค่าความหยาบ ความโลหะ และสีเท่านั้น";
// The current tool will paint the object if this option is enabled
paint.usePainting = "ภาพวาดลายเส้น";
// If true save the textures data into
paint.preset.embed = "ฝังพื้นผิว";
paint.preset.embed.help = "The textures can be found in the Nomad textures/ folder.
The material presets can be found in the Nomad materials/ folder.

When this option is off, the material preset only reference the texture inside the textures/ folder.

You can enable this option to make a copy of the textures inside the material preset.
It can be useful if you want to share a textured preset without providing the associated textures.";
paint.preset.embed.apply = "Apply to all materials";
// Factor/Opacity of paint tool
paint.intensity = "ความเข้มของการลงสี";
// Apply the paint on the object
paint.paintAll = "ทาสีทั้งหมด";
paint.paintAll.help = "นำวัสดุปัจจุบันไปใช้กับออบเจ็กต์";
paint.paintAll.help.mask = "พื้นที่ที่ถูกปิดบังจะไม่ได้รับผลกระทบ";
paint.paintAll.help.hide = "พื้นที่ที่ถูกซ่อนจะไม่ได้รับผลกระทบ";
paint.paintAll.help.opacity = "ใช้ระดับการทาสีด้านบน";
paint.paintAll.help.layer = "พื้นที่ที่ยังไม่ได้ระบายสีของ ไม่ได้รับผลกระทบ";
paint.strokePainting.title = "ทาสี";
// Brush stroke texture
paint.texture.warningEnable = "ต้องเปิดใช้งานการวาดภาพลายเส้นเพื่อให้สามารถฉายพื้นผิวได้ (ช่องทำเครื่องหมายด้านบน)!";
paint.texture.warningIgnored = "เครื่องมือปัจจุบันไม่สามารถใช้พื้นผิวได้!";
// use stencil mode
paint.stencil = "สเตนซิล";
// Inherit stroke falloff option for the painting
paint.tool.help = "ใช้เครื่องมืออลฟา, ฟอลออฟ และแรนดอมไมเซอร์ในการปรับความเข้มของการแปรงสี

ตัวเลือกเหล่านี้จะถูกละเว้นสำหรับคุณสมบัติการทาสีทั้งหมด แต่อลฟาจะถูกพิจารณาสำหรับประเภทสามแผนที่";
// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "ชื่อใหม่";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "ค่าใหม่";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "สีใหม่ (ฟอร์แมต hex)";

// Post process effect
postprocess = "โพสต์โปรเซส";
// Denoise
postprocess.denoise = "เครื่องตัดเสียงรบกวน";
postprocess.denoise.help = "เพิ่มขั้นตอนการตัดเสียงรบกวนหลังจากรวบรวมเฟรมทั้งหมด";
postprocess.denoise.warning = "นี่คือกระบวนการที่มีค่าใช้จ่ายสูง เปิดใช้งานเอฟเฟกต์นี้เฉพาะเมื่อลักษณะภาพมีเสียงรบกวนเท่านั้น";
// Quality vs performance
postprocess.quality = "คุณภาพ";
postprocess.quality.help = "เปิดใช้งานตัวเลือกเหล่านี้เพื่อปรับปรุงคุณภาพและความเสียหายของประสิทธิภาพ";
// More samples means better quality but slower performance
postprocess.maxSamples = "ตัวอย่างสูงสุด";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "ความละเอียดสูง";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "การสุ่มตัวอย่างเฟรมสูงสุด";
postprocess.accumulateCount.help = "จำนวนเฟรมสูงสุดที่จะสะสมก่อนการเร็นเดอร์จะหยุด

เมื่อการเร็นเดอร์หยุดลง Nomad จะหยุดการทำงานด้วย ซึ่งจะช่วยประหยัดแบตเตอรี่

คุณสมบัติหลายประการของการเร็นเดอร์ได้รับประโยชน์จากการสะสมเฟรม โดยเฉพาะอย่างยิ่ง
• ซอฟท์แชโดว์
• โกลบอลอินลูมิเนชัน
• การสะท้อนกลับ (SSR)
• แสงเงาระหว่างวัตถุในฉาก
• ใต้ผิว
• ความลึกของภาพ

จำนวนเฟรมที่สูงนั้นส่วนใหญ่จำเป็นสำหรับ Soft Shadows และ Global Illumination
Nomad สามารถหยุดการเรนเดอร์ได้เร็วกว่าโดยคุณสมบัติที่กล่าวไปแล้วข้างต้นจะถูกปิดใช้งาน";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "ความละเอียดการสร้างภาพ";
postprocess.renderRatio.warning = "แทนที่ด้วยเอฟเฟกต์ Pixel Art";
postprocess.renderRatio.help = "ตัวเลือกนี้ส่งผลต่อประสิทธิภาพอย่างมาก
ขอแนะนำให้รักษาค่าที่ต่ำกว่า x1.25

ตัวเลือกนี้จะไม่ถูกบันทึกในการตั้งค่า";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "เทคโนโลยีลบรอยหยัก (TAA)";
postprocess.taa.help = "ลดการกะพริบเมื่อคุณกำลังเคลื่อนกล้อง";
// Ditherhing pixel
postprocess.dithering = "การรวมจุดสี";
postprocess.dithering.help = "กระจายพิกเซลเพื่อลดข้อบกพร่องของสี.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "การสะท้อนแสง (SSR)";
postprocess.ssr.warning = "SSR ต้องใช้โหมดแรเงา PBR";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "โกลบอลอินลูมิเนชัน (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "เกณฑ์การยอมรับ";
postprocess.ssgi.warning = "SSGI ต้องใช้โหมดแรเงา PBR";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "แสงเงาระหว่างวัตถุในฉาก";
// How far the effect spreads
postprocess.ssao.radius = "ขนาด";
// How strong the effect is
postprocess.ssao.factor = "ความแข็งแรง";
// Adjustment to fix artefacts
postprocess.ssao.bias = "ความเอนของค่าความโค้ง";
postprocess.ssao.bias.help = "ความไวของเอฟเฟกต์นั้นขึ้นอยู่กับความโค้งของพื้นผิว";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "ความลึกของภาพ";
// The blur factor behind the focused point
postprocess.dof.blurFar = "เบลอไกล";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "เบลอใกล้";
postprocess.dof.focusTip = "แตะออบเจ็กต์เพื่อเปลี่ยนจุดโฟกัส";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "ฟุ้ง";
// Intensity of the effect
postprocess.bloom.intensity = "ความเข้ม";
// How far the effect spreads
postprocess.bloom.radius = "รัศมี";
postprocess.bloom.radius.help = "รัศมีความกว้างที่แสงกระจายออก";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "เกณฑ์";
postprocess.bloom.threshold.help = "เกณฑ์ความส่องสว่างเพื่อตัดสินใจว่าพิกเซลจะเปล่งแสงหรือไม่
หากค่าเป็น 0 ทุกอย่างจะเปล่งแสง";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "โทนแมพปิ้ง";
postprocess.tone.exposure = "การเปิดรับแสง";
postprocess.tone.contrast = "ความต่างระดับสี";
postprocess.tone.saturation = "ความอิ่มตัว";
postprocess.tone.hue = "เฮือ";
// No tonemapping operator is used
postprocess.tone.mapping.none = "ไม่มี";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "เป็นกลาง";
// Color curves
postprocess.curve = "เกลี่ยสี";
// Curve for pixel luminance
postprocess.curve.luminance = "หลัก";
postprocess.curve.red = "แดง";
postprocess.curve.green = "เขียว";
postprocess.curve.blue = "น้ำเงิน";
// Reset color grading curves
postprocess.curve.resetAll = "รีเซ็ตทั้งหมด";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "ความพร่าสี";
postprocess.chromatic.factor = "ความแข็งแรง";
// Darking on the edges
postprocess.vignette = "วิกเน็ตต์";
// How far the effect spreads
postprocess.vignette.size = "ขนาด";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "ความหนัก";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "ความคมชัด";
postprocess.sharpness.factor = "ความแข็งแรง";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "เกรน";
postprocess.grain.factor = "ความแข็งแรง";
// Accentuate the edges of the model
postprocess.curvature = "ความโค้ง";
// main strength of curvatre
postprocess.curvature.factor = "แฟกเตอร์";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "โพรง";
// Color/Strength of convex curvature
postprocess.curvature.bump = "บัมพ์";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "พิกเซลอาร์ต";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "อนุญาตให้สุ่มตัวอย่างเฟรม";
// Simulate scanline rendering (horizontal line)
postprocess.scanline = "สแกนไลน์";
postprocess.scanline.factor = "แฟกเตอร์";
// Spacing between lines
postprocess.scanline.spacing = "การเว้นระยะห่าง";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "รูปทรงพื้นฐาน";
primitive.box = "กล่อง";
primitive.sphereCube = "สเฟียร์ควอด";
primitive.sphereUV = "UV สเฟียร์";
primitive.icosahedron = "ไอโคซาเฮดรอน";
primitive.cylinder = "ไซลินเดอร์";
primitive.cone = "โคน";
primitive.torus = "ทอรัส";
primitive.lathe = "กลึง";
primitive.tube = "ท่อ";
primitive.plane = "ระนาบ";
primitive.triplanar = "สามระนาบ";
primitive.needValidate = "รูปทรงพื้นฐานควรได้รับการตรวจสอบ!";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "แก้ไข";
primitive.edit.help = "อนุญาตให้แก้ไข 3Dในวิวพอร์ต

คุณสามารถปิดใช้งานคุณลักษณะนี้ได้หากต้องการโต้ตอบกับ Gizmo หรือเครื่องมือปรับแต่ง โดยไม่ต้องแก้ไขของรูปทรงพื้นฐาน";

// Primitive configuration
primitive.mainConfig = "พารามิเตอร์";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "โทโพโลยี";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "เรขาคณิต";

// Validating the primitive (then it can be sculpted)
primitive.validate = "ตรวจสอบ";
// Maximum number of faces of the primitives
primitive.maxFaces = "จำนวนเฟสมากสุด";
primitive.maxFaces.help = "จำนวนเฟสสูงสุดที่รูปทรงพื้นฐานสามารถมีได้

ขีดจำกัดนี้ใช้งานได้เฉพาะในขณะที่รูปทรงพื้นฐานไม่ได้รับการตรวจสอบ หลังจากนั้นการป้องกันก็หายไป";
// Synonym: Flat subdivision
primitive.linear = "ซับดิวิชันเชิงเส้น";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "โพสต์ซับดิวิชัน";

// Radius (of a sphere, torus, etc)
primitive.radius = "รัศมี";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radius.sync = "รัศมีเดียวกัน";
primitive.radius.start = "รัศมีเริ่มต้น";
primitive.radius.end = "รัศมีสิ้นสุด";
// Size (of cube x dimension)
primitive.size = "ขนาด";
primitive.sizeX = "ขนาด X";
primitive.sizeY = "ขนาด Y";
primitive.sizeZ = "ขนาด Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "การแบ่งแยก";
primitive.divisionX = "การแบ่ง X";
primitive.divisionY = "การแบ่ง Y";
primitive.divisionZ = "การแบ่ง Z";
// Angle of torus, etc
primitive.angleX = "มุม X";
primitive.angleY = "มุม Y";
primitive.angleZ = "มุม Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "ความหนาแน่นคงที่";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "โปรเจ็กต์บนทรงกลม";
primitive.projectOnSphere.help = "สแนปจุดบนสเฟียร์ที่สมบูรณ์แบบ";

// triplanar
primitive.triplanar.title = "สามระนาบ";
primitive.triplanar.title.help = "สามระนาบกำลังใช้ข้อมูลมาสก์จากสามระนาบเพื่อเติมตารางว็อกเซลที่เป็นรูปหลายเหลี่ยม

หากคุณโต้ตอบกับแถบเลื่อนการแบ่งหรือขนาด ข้อมูลการวาดภาพจะถูกรีเซ็ต (ความเรียบจะโอเค)

คุณควรปิดการใช้งานความสมมาตรเนื่องจากอาจไม่ทำงานอย่างที่คาดหวัง

คุณสามารถใช้ตัวเลือก `เชื่อมต่อเชิงทอพอโลยี` ในพาเนลหน้ากากเพื่อทาสีระนาบที่กระทบกับระนาบอื่นๆ";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanar.sameSize = "ขนาดเดียวกัน (ลูกบาศก์)";
primitive.triplanar.polish = "ความเรียบ";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanar.resetMask = "รีเซ็ตมาส์ก";
// One side of a cube (the back plane)
primitive.isolate.back = "ย้อนกลับ";
// One side of a cube (the right plane)
primitive.isolate.right = "ขวา";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "ล่าง";
// Plane
primitive.planeSameSize = "ขนาดเดียวกัน (สี่เหลี่ยม)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "จาน";
// Box
primitive.boxRegular = "ขนาดเดียวกัน (ลูกบาศก์)";
// Torus
primitive.torus.radiusOuter = "รัศมีรอบนอก";
primitive.torus.radiusInner = "รัศมีรอบใน";
primitive.torus.angle = "มุม";
primitive.torus.angleOffset = "ออฟเซ็ตของมุม";
// Cylinder
primitive.cylinder.height = "สูง";
// Cone
primitive.cone.radius = "รัศมี";
primitive.cone.height = "สูง";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "รู";
// Make a hole in the primitive to make it hollow
primitive.hasHole = "มีรู";
// Curve profile (synonym: profile, curve)
primitive.profile = "โปรไฟล์";
primitive.profile.viewport = "แสดงในพื้นที่มองเห็น";
// If the revolution surface has caps (E.g: cylinder)
primitive.cap = "ปิดท้าย";

// Singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "ทำซ้ำ";
// All the new items will be inserted inside the bound rather than outside
repeater.array.fitInside = "พอดีภายใน";
// The object will follow the curve
repeater.curve.align = "จัดแนว";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "นำเข้า...";
// iOS Photos gallery
resource.import.ios.photos = "รูปภาพ";
// iOS Files App
resource.import.ios.files = "ไฟล์";

scene.title = "ซีน";
scene.title.help = "เมื่อใช้ปุ่มที่มองเห็น/เลือก ให้กดค้างไว้แล้วลากนิ้วเพื่อเลือกออบเจ็กต์อื่นๆ อย่างง่ายดาย

คุณยังสามารถกดปุ่มที่มองเห็น/เลือกค้างไว้เพื่อให้มีผลกับโหนดลูกได้เช่นกัน";
// The view will focus on the item when we click on it
scene.focus = "UI: โฟกัสที่รายการเมื่อแตะสองครั้ง";
// Add new object on gizmo position
scene.addOnGizmo = "บนกิซโม";
scene.addOnGizmo.help = "ย้ายโหนดไปยังตำแหน่งกิซโม (หากเครื่องมือกิซโมถูกเลือก)";
// Select the gizmo tool after adding a new object
scene.addSelectGizmo = "เลือกกิซโม";
scene.addSelectGizmo.help = "เลือกเครื่องมือกิซโมเมื่อเพิ่มโหนดใหม่";
// Icon size in pixel (min/max)
scene.iconSize = "ขนาดไอคอน";
// Min size of icon
scene.iconSize.min = "น้อย";
// Max size of icon
scene.iconSize.max = "สูงสุด";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "เส้นลำดับชั้น";
scene.showHierarchy.help = "แสดงเส้นระหว่างแพเรนต์และลูกๆ ในพื้นที่มองเห็น.";
scene.showHierarchyNomadPivot = "ใช้ปิ๊ฟของ Nomad";
scene.showHierarchyNomadPivot.help = "ปิ๊ฟของ Nomad คือปิ๊ฟที่ใช้โดยเครื่องมือ Transform และ Gizmo

หากตัวเลือกนี้ถูกปิดใช้งาน, มันจะใช้ปิ๊ฟฐานที่เป็นธรรมชาติ
ในบางกรณีปิ๊ฟฐานนี้อาจอยู่ห่างจากศูนย์กลางของวัตถุเอง!";
// The view will focus on the item when we click on it
scene.syncVisible = "ซิงค์ความเห็นได้";
scene.syncVisible.help = "เมื่อเปิดใช้งาน, การใช้ไอคอนที่มองเห็นได้ (ตา) จะส่งผลต่อรายการที่เลือกทั้งหมด.";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "รวม";
// Group the selected object with a new created Empty Node as a parent
scene.group = "กลุ่ม";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "ยกเลิกการเป็นพ่อแม่";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "มิเรอร์";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "เคิร์ฟ";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "โหนดอาเรย์";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "เรเดียล";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "ตัวทำซ้ำ";
scene.repeaters.help = "โหนดตัวทำซ้ำที่สร้างตัวอย่างของเรขาคณิตใด ๆ ที่อยู่ด้านล่างของมันในลำดับชั้นของฉาก.";
// Validate button
scene.validateGroup = "ตรวจสอบ";
// Keep instances in the scene
scene.validateGroup.keepInstances = "เก็บตัวอย่างไว้";
// If we should join children
scene.validateGroup.joinChildren = "รวมโหนดลูก";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "ผสานว็อกเซล";
scene.voxelResolution = "ความละเอียด";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "การลบ ซ่อนวัตถุ";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "จุดตัด ออบเจ็กต์ทั้งหมดที่ซ่อนอยู่";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "ไม่ได้เลือกออบเจ็กต์ โปรดเลือกอย่างน้อยหนึ่งออบเจ็กต์";
// Need to select one object only
scene.noneButNeedOne = "ไม่ได้เลือกออบเจ็กต์ โปรดเลือกหนึ่งออบเจ็กต์";
// Need to select one object only
scene.onlyOneObject = "เลือกหลายออบเจ็กต์ โปรดเลือกออบเจ็กต์เดียวเท่านั้น";
// Boolean operation
scene.boolean = "บูลีน";
scene.boolean.help = "Merge, subtract or intersect objects by performing a boolean operation.

The operation can fail if some objects are not manifold or not watertight.

If the boolean fails, you can always use the voxel remesher on the problematic object to ensure it's a watertight manifold.";
// Weld intersection
scene.boolean.mergeIntersection = "เชื่อมต่อที่ตัดกัน";

// General scene display settings
settings.display.title = "แสดงการตั้งค่า";
// Wireframe (show triangles and quad edges)
settings.wireframe = "โครงลวด";
// Display the material texture
settings.debugChannel = "แสดงเท็กซ์เจอร์";
// Display the material texture in the background
settings.debugChannel.onBackground = "ในพื้นหลัง";
// Display the material texture on the mesh
settings.debugChannel.onMesh = "บนเมช";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "สองด้าน";
settings.twoSided.help = "จะเห็นเฟสได้จากทั้งสองด้าน";
// If we colorize the inverted side of faces
settings.backface.color = "สีของเฟสที่กลับด้าน";
// Color of the inverted side of faces
settings.backface.colored = "ด้านกลับของเฟสที่ลงสีแล้ว";
// Outline (contour highlight around the selected object)
settings.outline = "เค้าร่าง";
// Outline (contour highlight around the selected object)
settings.outline.help = "ออบเจ็กต์ที่เลือกจะถูกร่าง";
settings.outline.thickness = "ความหนา";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "สแนปลูกบาศก์";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "ด้านล่าง";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "ซ้าย";
// Flip the camera (rotate 180° to see the other side)
settings.snapCube.flip = "พลิก 180°";
settings.snapCube.flip.help = "พลิกมุมมองหากมุมมองนั้นถูกจับแล้ว.";
// Alignment (can be auto/on/off)
settings.snapCube.align = "จำกัดการจัดแนว";
settings.snapCube.align.help = "จัดแนวมุมมองไปยังแกนโลก หากเปิดใช้งาน, มีเพียง 6 มุมมองที่สามารถจับได้

ในโหมดอัตโนมัติ, การจำกัดจะเกิดขึ้นเฉพาะเมื่อกล้องอยู่ในโหมดออร์บิต.";
// Stats (information logs about the scene displayed on screen)
settings.stats = "สถิติ";
settings.stats.right = "ขวา";
settings.stats.all = "แสดงหน้าจอเต็ม";
// Handles are controls that you interact with in the viewport in order to edit something
settings.handle = "โหนก";
settings.handles = "โหนก";
// Shape draw thing
settings.shape = "รูปร่าง";
settings.shape.color = "สีของรูปหลายเหลี่ยม";
// Grid
settings.grid = "เส้นตาราง";
settings.grid.snapDivision = "เกณฑ์การแบ่งเปอร์เซ็นต์การจับยึด";
settings.grid.snapDivision.help = "เกณฑ์จะถูกเปรียบเทียบกับระยะทางไปยังตารางกริด.";
// Cursor
settings.cursor.title = "เคอร์เซอร์";
// sculpting circle
settings.cursor.circle = "วงกลม";
// A small indicator dot
settings.cursor.showDot = "แสดงจุดเล็ก";
settings.cursor.showDot.help = "จุดสามารถปรากฏเป็นจุดหมุนของกล้องหรือเมื่อคุณกำลังแกะสลัก";
settings.cursor.showRope = "แสดงเชือกกันโคลง";
// indicator
settings.indicator.title = "ตัวบ่งชี้";
settings.indicator.title.help = "แสดงตัวบ่งชี้ทางภาพ (การสอน, การจับภาพหน้าจอ ฯลฯ).";
settings.indicator.size = "ขนาด";
// Highlight (the object glows when we select it)
settings.highlight.selection = "ไฮไลท์การเลือก";
// Highlight settings
settings.highlight = "ไฮไลท์";
settings.highlight.duration = "ระยะเวลา";
// Mesh that are not selected will be dark
settings.darkenUnselected = "ทำให้ออบเจ็กต์ที่ไม่ได้เลือกมืดลง";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "แรเงาเรียบ";
// Experimental feature
settings.partialDraw = "การวาดบางส่วน";
settings.partialDraw.help = "คุณสมบัติทดลอง!

ใช้ฟีเจอร์นี้เลยหากคุณกำลังทำส่วนเล็กๆ ของเมชที่ไฮโพลี

ซึ่งจะทำให้การแกะสลักราบรื่นขึ้น แต่คุณไม่ควรเปิดใช้งานโครงลวด!

นอกจากนี้ยังอาจเพิ่มสิ่งแปลกปลอมที่มองเห็นได้ในระหว่างวาดด้วยแปรงด้วย";
settings.partialDraw.warning = "อย่าลืมปิดตัวเลือกนี้หากของแปลกปลอมที่มองเห็นได้น่ารำคาญเกินไป!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "แสดงการวาดลงสี";
// Show and use the masking on the mesh
settings.showMasking = "แสดงมาส์ก";
// Disable this option to force show the hidden faces
settings.showDiscard = "ใช้ซ่อน";
// Show icon on the canvas
settings.icon = "ไอคอน";
// Show icons on the canvas
settings.icons = "ไอคอน";
// Tooltip
settings.icons.help = "แสดงไอคอนบนแคนวาสเพื่อที่ว่าคุณจะสามารถเลือกและแก้ไขได้โดยตรง";
// Hole filling settings
settings.hole = "อุดรู";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "เติมรูที่ไม่ซับซ้อน";
settings.hole.nonManifold.help = "พยายามเติมรูที่ไม่มีช่องรวม
ตัวเลือกนี้จะไม่ถูกบันทึกในการตั้งค่า";
// Maximum number of vertices (points)
settings.multires.maxVertices = "จำนวนสูงสุดของจุดยอด";
settings.multires.maxVertices.help = "Nomad ไม่ได้ทำการตรวจสอบหน่วยความจำก่อนซับดิวิชัน การนับโพลีจำนวนมากอาจนำไปสู่การขัดข้องได้ง่าย";
settings.multires.lowResVertices = "เกณฑ์ความละเอียดต่ำ";
settings.multires.lowResVertices.help = "ความละเอียดที่ต่ำกว่าของเมชสามารถแสดงได้เมื่อคุณขยับกล้อง

คุณสามารถเพิ่มค่านี้ได้หากต้องการแสดงค่าความละเอียดสูงขึ้นของเมช";

// The main rendering mode
shading = "การแรเงา";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "ให้แสง (PBR)";
shading.pbr.help = "ในโหมดนี้คุณสามารถเพิ่มแสง (กับเงา) พร้อมกับสภาพแวดล้อม HDR

คุณยังสามารถทาสีโลหะและความหยาบได้ ซึ่งช่วยให้ควบคุมรูปลักษณ์ของวัสดุได้ละเอียดยิ่งขึ้น";
// Fast rendering mode for sculpting purpose
shading.matcap = "MatCap";
shading.matcap.help = "MatCap ย่อมาจาก MAterial CAPture จะดูแลทั้งข้อมูลแสงและวัสดุในรูปภาพเดียว

โหมดนี้เป็นโหมดของการเร็นเดอร์ที่รวดเร็ว ส่วนใหญ่เหมาะสำหรับการแกะสลักแบบดิบ";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "ไม่ให้แสง";
shading.unlit.help = "โหมดแรเงาสีทึบโดยไม่มีแสง";
// Helper rendering mode that display solid colors
shading.object = "ออบเจ็กต์ ID";
shading.object.help = "โหมดการเร็นเดอร์แบบไม่มีแสงกับแต่ละอ็อบเจ็กต์ที่มีการกำหนดสีแบบสุ่ม

สิ่งนี้มีประโยชน์อย่างยิ่งเมื่อคุณมีออบเจ็กต์จำนวนมากในฉากของคุณ";
// Helper rendering mode that display solid colors
shading.instance = "อินสแตนซ์ ID";
shading.instance.help = "เหมือนกับรหัสออบเจ็กต์, แต่อินสแตนซ์จะมีสีเดียวกัน";
// Helper rendering mode that display solid colors
shading.material = "วัสดุ ID";
shading.material.help = "แสดงสีพื้นสำหรับวัสดุแต่ละอัน.";
// Randomize colors
shading.id.randomize = "สุ่ม id";
shading.textures = "ใช้พื้นผิว";
shading.textures.help = "ในขณะนี้ คุณไม่สามารถสร้างหรือแก้ไขพื้นผิวภายใน Nomad ได้

แต่ถ้าคุณนำเข้าไฟล์ที่มีพื้นผิว ก็อาจจะทำได้

• พื้นผิวที่รองรับ
ความทึบ: Lit, MatCap, Unlit
ปกติ: Lit, MatCap
สี: Lit, Unlit
ความเปล่ง: Lit
ความหยาบ: Lit
ความเป็นโลหะ: Lit";
// Lights
shading.lights = "แสง";
shading.lights.addLight = "เพิ่มแสง";
shading.lights.warning = "แสงต้องใช้โหมดแรเงา PBR";
// Environment based lighting (synonym: HDRI)
shading.environment = "สภาพแวดล้อม";
shading.environment.import = "นำเข้า HDR";
shading.environment.exposure = "การเปิดรับแสง";
shading.environment.backgroundBlur = "เบลอ (พื้นหลัง)";
shading.environment.rotation = "การหมุน";
shading.environment.rotation.help = "คุณสามารถหมุนสภาพแวดล้อมได้ด้วยการลาก 3 นิ้วในแนวนอนบนวิวพอร์ต";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "ติดกับกล้อง";
shading.environment.attachedToCamera.help = "ผนึกสภาพแวดล้อมเข้ากับกล้อง

ทำให้แสงให้สม่ำเสมอ ซึ่งอาจเป็นประโยชน์สำหรับวัตถุประสงค์ในการแกะสลัก";
shading.matcap.rotation = "การหมุน";
shading.matcap.rotation.help = "คุณสามารถหมุน MatCap ได้ด้วยการลาก 3 นิ้วในแนวนอนบนวิวพอร์ต";
shading.matcap.global = "ใช้ MatCap ทั้งหมด";
shading.matcap.global.help = "ยกเลิกการเลือกตัวเลือกนี้เพื่อใช้ MatCap อื่นสำหรับเมชนี้";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible = "มาส์ก";
shortcut.solo = "เดี่ยว";
shortcut.xray = "เอ็กซ์เรย์";
shortcut.voxelRemesh = "ว็อกเซล";
shortcut.wireframe = "ลวด";
shortcut.cameraReset = "รีเซ็ต";
shortcut.cameraSnap = "สแนป";
shortcut.lockSelection = "ล็อค";
shortcut.lockSelection.help = "เมื่อเปิดใช้งาน คุณจะไม่สามารถเปลี่ยนการเลือกได้โดยแตะที่เมช";
shortcut.grid = "เส้นตาราง";

// Memory taken by the scene
stat.ramScene = "ซีน";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Vram ซีน";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "เร็นเดอร์ Vram";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "พื้นผิว Vram";
// Memory taken by the undo/redo history
stat.ramHistory = "ประวัติ";
// Memory taken by other stuffs
stat.ramOther = "อื่นๆ";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "หน่วยความจำที่ใช้";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "หน่วยความจำที่ไม่ได้ใช้";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "ใช้อยู่ $0";
stat.free = "ว่าง $0";
stat.faces = "เฟส";
stat.triangles = "สามเหลี่ยม";
stat.vertices = "จุดยอด";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "สี่เหลี่ยม";
stat.vertex = "จุดยอด";
stat.scene.face = "เฟสต่างของซีน";
stat.scene.vertex = "จุดยอดของซีน";

// Brush stroke
stroke = "วาดเส้น";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "รัศมีแปรงมีพื้นที่ขนาดคงที่ในฉาก";
// The settings is shared among every tools
stroke.useWorldRadius.help = "มีการใช้ร่วมกันในทุกเครื่องมือ";
// Share the radius value among every tools.
stroke.useShareRadius = "แชร์รัศมี";
stroke.useShareRadius.help = "แชร์ค่ารัศมีในทุกเครื่องมือ";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.spacing = "ระยะห่างระหว่างลายเส้น";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.spacing.adjust = "ปรับความเข้มของระยะห่าง";
stroke.minSpacingAdjustIntensity.help = "ปรับความเข้มของแปรงเพื่อให้แน่ใจว่ามีการแปลงรูปที่สม่ำเสมอโดยขึ้นอยู่กับระยะห่างของลายเส้นวาด";
stroke.minSpacing.help = "ระยะห่างระหว่างแต่ละสโตรก สัมพันธ์กับรัศมีเครื่องมือ

ค่าที่ต่ำกว่าจะช่วยให้สโตรกที่เรียบขึ้น แต่ประสิทธิภาพจะลดลง";
// Brush stroke smoothing
stroke.lazySmooth = "ปรับเส้นวาดให้เรียบ";
stroke.lazySmooth.help = "ตำแหน่งตัวชี้หลายตัวแบบเฉลี่ยเพื่อให้ได้จังหวะลายเส้นวาดที่นุ่มนวลขึ้น

หากตั้งค่าที่สูง จังหวะวาดเส้นจะช้าตามหลังตัวชี้ แต่จะตามทันในที่สุด";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "ผ่อนเชือกกันโคลง";
stroke.lazyRadius.help = "สโตรกจะตามมาทีหลังตำแหน่งตัวชี้ตามระยะทางที่กำหนด

สามารถใช้วาดเส้นเรียบได้";
// It is not a per-tool settings
stroke.globalSettings = "นี่คือการตั้งค่าทั้งหมด";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "รัศมีของสแนป";
stroke.snapRadius.help = "สแนปสโตรกหากตัวชี้อยู่ใกล้กับสโตรกที่บันทึกไว้ล่าสุด

สิ่งนี้มีประโยชน์เมื่อต้องวาดเส้นต่อเนื่องยาวๆ ในขณะที่หยุดชั่วคราวบ่อยๆ";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "ออฟเซ็ตสโตรก";
stroke.sculptOffset.help = "ใช้ออฟเซ็ตคงที่ในการวาดเส้น

ตัวเลือกนี้มีประโยชน์สำหรับหน้าจอขนาดเล็กเมื่อใช้นิ้ว เพื่อไม่ให้นิ้วของคุณบังเส้นวาด";
stroke.accumulate = "สะสมเส้นวาด";
stroke.accumulate.help = "หากเปิดใช้งานตัวเลือกนี้ จะไม่มีการจำกัดจำนวนการเพิ่ม/ลบเส้นวาด";
// The tool can use DynTopo
stroke.useDynamic = "ให้ใช้โทโพโลยีแบบไดนามิก";
// Only sculpt the part that are linked topologically
stroke.connect = "โทโพโลยีที่เชื่อมต่อ";
stroke.connect.help = "ตัวเลือกนี้จะปั้นเฉพาะจุดยอดที่เชื่อมโยงกับพื้นผิวที่เลือก

โดยทั่วไปจะใช้สำหรับเครื่องมือเคลื่อนย้าย ตัวอย่างเช่น หากคุณต้องการย้ายเฉพาะส่วนที่อินเตอร์เซกต์ตัวเองกับอีกส่วนหนึ่ง";
stroke.connect.short = "ที่เชื่อมต่อ";
// sculpt on hide or mask
stroke.protect = "ปกป้องพื้นที่";
stroke.protect.hide.help = "เมื่อถูกตั้งค่าอัตโนมัติ ใบหน้าที่ซ่อนอยู่จะถูกแก้ไขหากลวดลายบนใบหน้าที่ซ่อนอยู่นั้นมองเห็นได้ (ดูที่เมนูลวดลาย)";
// Only sculpt the vertex that points toward the camera
stroke.culling = "จุดยอดด้านหน้าเท่านั้น";
stroke.culling.help = "ตัวเลือกนี้จะละเว้นจุดยอดที่หันไปด้านหลัง

อาจมีประโยชน์หากคุณต้องการทาสีบางๆ บนส่วนหนึ่งของรูปทรงเรขาคณิตโดยจะไม่กระทบอีกด้านหนึ่ง

และยังใช้งานได้สำหรับการแกะสลัก แต่คุณอาจพบสิ่งแปลกปลอมบางอย่าง";
// Infinite depth, move everything under the circle, disregarding depth
stroke.silhouette = "ซิลลูเอ็ต";
stroke.silhouette.view = "มุมมอง";
stroke.silhouette.snapped = "ถ้าถูกจับ";
stroke.silhouette.closest = "ที่ใกล้ที่สุด";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.sameSide = "จุดยอดขนาดเดียวกันเท่านั้น";
stroke.sameSide.help = "ละเว้นจุดยอดที่ชี้ไปในทิศทางตรงกันข้ามกับดีฟอร์เมชัน";
// determine normal direction
stroke.normal.direction = "ทิศทาง";
stroke.normal.direction.help = "เกี่ยวข้องเฉพาะเมื่อการเปลี่ยนรูปร่างปกติเปิดใช้งาน 
ควบคุมวิธีการที่ Nomad ตัดสินใจเลือกสัญญาณการเปลี่ยนรูปร่าง (ดัน vs ดึง)";
stroke.normal.direction.normal = "ปกติ 3D";
stroke.normal.direction.normal.help = "เปรียบเทียบตำแหน่ง XY ของตัวชี้กับปกติบนพื้นผิวที่ฉาย";
stroke.normal.direction.screen = "XY";
stroke.normal.direction.screen.help = "ใช้ตำแหน่ง XY บนหน้าจอของตัวชี้ในการตัดสินใจดันหรือดึง";
stroke.normal.direction.auto = "อัตโนมัติ";
stroke.normal.direction.auto.help = "เลือกวิธีการโดยอัตโนมัติตามมุมของปกติที่ฉาย";
stroke.normal.direction.auto.threshold = "เกณฑ์";
stroke.normal.direction.auto.threshold.help = "จำกัดมุมเมื่อเปรียบเทียบกับปกติบนพื้นผิวเพื่อกำหนดว่าวิธีการไหนถูกใช้";
// small tip/warning
stroke.onlyLasso = "การตั้งค่านี้จะเปิดใช้งานเฉพาะเครื่องมือลัสโซ";

// Here sampling refers to the app gathering information under the mouse
stroke.area = "การสุ่มพื้นที่";
stroke.area.help = "บางแปรงหรือตัวเลือกการเขียนต้องการแท่นวางแนวตั้งฉากกับพื้นผิวเพื่อให้สามารถทำงานได้
คุณสามารถควบคุมวิธีการคำนวณแท่นวางเฉลี่ยนี้ได้โดยการตั้งค่าพื้นที่การสุ่มเป็นอัตราส่วนของรัศมีเครื่องมือ

ที่ 100%, จุดทุกจุดภายในวงกลมที่เลือกจะถูกนำมาพิจารณา
ที่ 0%, เฉพาะจุดที่ใกล้ที่สุดหรือสามเหลี่ยมเท่านั้นที่จะถูกนำมาพิจารณา.";
// Sampling radius size (percent)
stroke.area.normal.radius = "รัศมีปกติ";
// Sampling radius size (percent)
stroke.area.point.radius = "รัศมีตำแหน่ง";
// Sampling averaging
stroke.area.normal.average = "การเฉลี่ยค่าปกติ";
// Sampling averaging
stroke.area.point.average = "การเฉลี่ยตำแหน่ง";
// Keep sharp edges
stroke.normalFilter = "ฟิลเตอร์ Normal";
stroke.normalFilter.help = "
การกรองความลึก";

// Only paint the part of the mesh above a certain height
stroke.depth.enable = "การมาสก์ความลึก";
stroke.depth.enable.help = "ยกเว้นจุดที่อยู่เหนือหรือต่ำกว่าระยะทางหนึ่งๆ ของแท่นวางที่คำนวณได้ (การสุ่มพื้นที่)

เป็นตัวอย่าง, สามารถใช้เพื่อทาสีบนบุ๋มหรือหลุม.";
stroke.depth.offset = "การเยื้องความสูง";
stroke.depth.falloff = "การลดระดับความลึก";
stroke.depth.max = "พื้นที่บน";
stroke.depth.min = "พื้นที่ล่าง";

// Invert the pixel (black <-> white)
stroke.alpha.invert = "สลับพิกเซล";
// Repeat the alpha image (pattern)
stroke.alpha.wrap = "เรียงต่อกัน";
// No repeat pattern
stroke.alpha.wrap.none = "ไม่มี";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alpha.wrap.repeat = "ทำซ้ำ";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alpha.wrap.mirror = "มิเรอร์";
// Tight fit when using tiling
stroke.alpha.fit = "พอดีภายใน";
stroke.alpha.fit.help = "This option is only relevant if the alpha and brushes textures are non square.

When enabled, each images will tile independently with no spacing.
You can disable this option if you want to keep the alpha and other images synchronized, in case their ratio are not the same.";
// Alpha rotation
stroke.alpha.rotation = "การหมุน";
stroke.alpha.rotation.lock.help = "ล็อกการหมุนค่าอัลฟา

หากการหมุนไม่ถูกล็อก, การเอียงจะตามทิศทางการเขียนของแปรงแบบเรียลไทม์";
// Repeat the image
stroke.alpha.tiling = "เรียงต่อกัน";
// Scale the image (make it bigger or smaller)
stroke.alpha.scale = "การปรับขนาด";
stroke.alpha.scale.help = "ที่ค่าต่ำสุด สี่เหลี่ยมอัลฟาจะอยู่ภายในรัศมีวงกลมของเครื่องมือ";
// Middle-point value at which no deformation occurs
stroke.alpha.midValue = "ค่ากลาง";
stroke.alpha.midValue.help = "ค่าจุดกึ่งกลางที่ไม่มีดีฟอร์เมชัน

(ค่ากลาง = 0)
• สีดำ: ไม่มีการแทนที่
• สีขาว: มีการแทนที่

(ค่ากลาง = 0.5)
• สีดำ: การแทนที่เชิงลบ
• สีขาว: มีการแทนที่

(ค่ากลาง = 1)
• สีดำ: การแทนที่เชิงลบ
• สีขาว: ไม่มีการแทนที่";
// Synonymous: Scatter/Jitter/Randomize
stroke.jitter = "สุ่ม";
// Sculpt and paint along the brush stroke at regular spacing
stroke.type.dot = "จุด";
// Sculpt and paint along with alpha spaced by brush radius
stroke.type.roll = "หมุน";
// Sculpt and paint with alpha projected on screen stencil
stroke.type.tile = "แบ่งช่อง";
// Sculpt and paint with alpha projected on 3 axis
stroke.type.triplanar = "สามระนาบ";
// Sculpt continuously
stroke.type.drag = "ลาก";
// Lock a region and move it around
stroke.type.grab = "คว้า";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.type.grabRadius = "คว้า • รัศมีไดนามิก";
// Lock a region and sculpt it by changing the tool intensity
stroke.type.grabIntensity = "คว้า • ความเข้มแบบไดนามิก";

stroke.falloffProject = "อิทธิพล";
stroke.falloffProject.help = "• ทรงกลม (3 มิติ)
อิทธิพลจะถูกคำนวณโดยการใช้ระยะทางจากจุดยอดไปยังศูนย์กลางของแปรง

• วงกลม (2 มิติ)
จุดยอดจะถูกฉายลงบนพื้นผิวก่อนที่จะวัดระยะทางไปยังศูนย์กลางของแปรง
นี่คล้ายกับวิธีการเลือกอัลฟา";
stroke.falloffProject.sphere = "สเฟียร์";
stroke.falloffProject.circle = "วงกลม";
stroke.falloffProject.cylinder = "ไซลินเดอร์";

// Symmetry
symmetry = "สมมาตร";
symmetry.enable = "เปิดใช้งาน";
symmetry.primitiveWarning = "ความสมมาตรของแปรงใช้ได้เฉพาะกับรูปทรงพื้นฐานที่ผ่านการตรวจสอบแล้ว ยกเว้นสามระนาบ";
symmetry.plane.title = "ระนาบ";
symmetry.toolIgnore = "เครื่องมือปัจจุบันไม่เกี่ยวกับความสมมาตร";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "เรเดียล";
symmetry.radialX = "เรเดียล X";
symmetry.radialY = "เรเดียล Y";
symmetry.radialZ = "เรเดียล Z";
// A warning indicating that we limit the number of repetitions ($0 is a number)
symmetry.limited = "จำนวนการทำซ้ำถูกจำกัดไว้ที่ $0!";
// Synonym: Offset
symmetry.offset.title = "ออฟเซ็ต";
symmetry.offsetX = "ออฟเซ็ต X";
symmetry.offsetY = "ออฟเซ็ต Y";
symmetry.offsetZ = "ออฟเซ็ต Z";
// Number of clones
symmetry.count.title = "จำนวน";
symmetry.countX = "จำนวน X";
symmetry.countY = "จำนวน Y";
symmetry.countZ = "จำนวน Z";
// method
symmetry.method = "วิธี";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.method.world = "เวิลด์";
symmetry.method.world.help = "ระนาบสมมาตรได้รับการแก้ไขและจะไม่เคลื่อนที่";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.method.local = "โลคอล";
symmetry.method.local.help = "ระนาบสมมาตรจะเคลื่อนที่ไปตามเมชเมื่อคุณใช้เครื่องมือปรับแต่ง (กิซโม่ หรือการปรับแต่ง)";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "พลิกออบเจ็กต์";
// Cut half of the mesh
symmetry.cut = "ตัด";
// after mirroring, separate into multiple output (synonym: split, separate)
symmetry.split = "แยก";
// Reapply the mesh mirror, does not impact the topology
symmetry.mirror = "กระจก";
symmetry.mirror.help = "ลองใช้การทำสมมาตรอีกครั้งโดยไม่กระทบต่อโทโพโลยี

สมมาตรในแนวรัศมีจะถูกละเว้น

หากไม่สามารถรักษาโทโพโลยีได้เนื่องจากไม่ถือว่าสมมาตร คุณจะได้รับตัวเลือกเพื่อบังคับใช้การมิเรอร์";
// indicate that applying the mirror will keep the mesh topology
symmetry.mirror.keepTopology = "รักษาโครงสร้าง";
symmetry.mirrorFail = "ใช้สมมาตรไม่สำเร็จ

คุณต้องการบังคับใช้สมมาตรโดยมิเรอร์เมชหรือไม่?";
symmetry.mirrorUseMasking = "ปกป้องพื้นที่ที่มาส์กไว้";
symmetry.mirrorUseMasking.help = "รักษาพื้นที่ที่มาส์กไว้

ตัวเลือกนี้จะถูกละเว้นด้วยโทโพโลยีที่ไม่สมมาตร (หรือพื้นผิวที่ไม่ได้เชื่อมต่อ เช่น ดวงตาคู่หนึ่ง)";
// Reset the symmetry plane position
symmetry.reset = "รีเซ็ต";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "ศูนย์กลางออบเจ็กต์";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "ศูนย์กลางของเวิลด์";
// Reset the symmetry plane orientation
symmetry.reset.direction = "การวางแนว";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "แสดงเส้น";
// Display the symmetry plane in 3D
symmetry.showPlane = "แสดงระนาบ";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "แก้ไขกิซโม่";
symmetry.edit.warning = "การแก้ไขสมมาตรอยู่ในขั้นทดลอง";
symmetry.edit.help = "คุณสามารถตั้งค่าระนาบสมมาตรได้อย่างอิสระ

คุณลักษณะนี้ยังคงเป็นแบบทดลองอยู่ และคุณอาจจะไม่ควรใช้คุณลักษณะนี้";

// Ideally short strings
tool.dynamic = "DynTopo";
// Ideally short strings (Symmetry)
tool.symmetry = "สมมาตร";
// Ideally short strings (Mirror primitive)
tool.mirror = "มิเรอร์";
// Ideally short strings
tool.clay = "ดินเหนียว";
// Ideally short strings (Subtract)
tool.clay.sub = "ซับ";
// Ideally short strings
tool.brush = "แปรง";
// Ideally short strings
tool.move = "ย้าย";
// Ideally short strings (Normal vector, perpendicular to surface)
tool.move.normal = "ปกติ";
// Ideally short strings
tool.drag = "ลาก";
// Ideally short strings (Smooth the surface by erasing the details)
tool.smooth = "เรียบ";
// Ideally short strings (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "อ่อนลง";
// Ideally short strings (Paint mask)
tool.mask = "มาส์ก";
// Ideally short strings
tool.mask.unmask = "ไม่มาส์ก";
// Ideally short strings (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "SelMask";
// Ideally short strings (Smudge the paint of the object)
tool.smudge = "เกลี่ย";
// Ideally short strings (Flatten the surface)
tool.flatten = "ทำให้เรียบ";
// Ideally short strings (Flatten the surface, more strongly than Flatten)
tool.planar = "แบน";
// Ideally short strings (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "เติม";
// Ideally short strings (Layer brush)
tool.layer = "เลเยอร์";
// Ideally short strings
tool.crease = "รอยพับ";
// Ideally short strings (Cut part of the mesh cleanly)
tool.trim = "ตกแต่ง";
// Ideally short strings (Cut part of the mesh cleanly into two separate meshes)
tool.split = "แยก";
// Ideally short strings (Project part of the object onto a curve)
tool.project = "โปรเจ็กต์";
// Ideally short strings
tool.inflate = "พอง";
// Ideally short strings
tool.pinch = "กระจุก";
// Ideally short strings
tool.nudge = "นัดจ์";
// Ideally short strings
tool.stamp = "สแตมป์";
// Ideally short strings (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "ลบเลเยอร์";
// Ideally short strings (Select multiple objects with a lasso tool)
tool.select = "เลือก";
// Ideally short strings (Rotate, Translate and Scale the object)
tool.gizmo = "กิซโม่";
// Ideally short strings
tool.gizmo.editPivot = "จุดหมุน";
// Ideally short strings (Snap angle)
tool.gizmo.rotateSnap = "สแนป";
// Ideally short strings (Snap translation)
tool.gizmo.moveSnap = "สแนป";
// Ideally short strings (Local/Relative space)
tool.gizmo.local = "โลคอล";
// Ideally short strings (Align/Snap the gizmo to world axis)
tool.gizmo.align = "จัดเรียง";
// Ideally short strings (Pin the gizmo, so that it stays in place when switching between objects)
tool.gizmo.pin = "ปักหมุด";
// Ideally short strings (Rotate, Translate and Scale the object)
tool.transform = "ปรับแต่ง";
// Ideally short strings (Translate the object)
tool.transform.move = "ย้าย";
// Ideally short strings (Rotate the object)
tool.transform.rotate = "หมุน";
// Ideally short strings (Scale the object)
tool.transform.scale = "สเกล";
// Ideally short strings (Snap the object on another object surface)
tool.transform.snap = "สแนป";
// Ideally short strings (Measure distance between 2 points)
tool.measure = "วัด";
// Ideally short strings (Lattice, deformer)
tool.lattice = "ตาข่าย";
// If an option is shared among the tools
tool.all = "ทั้งหมด";
// Ideally short strings (Quad Remesher)
tool.remesh = "Quad Remesher";
tool.remesh.guides = "คู่มือ";
tool.remesh.density = "ความหนาแน่น";
tool.remesh.same = "Same";
tool.remesh.half = "Half";
// Ideally short strings (FaceGroup)
tool.faceGroup = "กลุ่มหน้า";
tool.faceGroup.autoPick = "เลือกอัตโนมัติ";
tool.faceGroup.flush = "ลบที่ไม่ได้ใช้งาน";
tool.faceGroup.skip = "ข้ามกลุ่มขนาดเล็กตาม:";
tool.faceGroup.skipFace = "จำนวนหน้า";
tool.faceGroup.skipFace.help = "ไม่สร้างกลุ่มใหม่หากจำนวนหน้าน้อยกว่าหรือเท่ากับเกณฑ์นี้";
tool.faceGroup.skipArea = "พื้นที่ผิว";
tool.faceGroup.skipArea.help = "ไม่สร้างกลุ่มใหม่หากพื้นที่ผิวของกลุ่มใหม่น้อยกว่าเกณฑ์นี้

เกณฑ์กำหนดเป็นเปอร์เซ็นต์ของพื้นที่ทั้งหมดของวัตถุ";
// Ideally short strings (Hide)
tool.hide = "ซ่อน";
// Ideally short strings (View tool, do nothing in particular)
tool.view = "มุมมอง";
// Ideally short strings (Revolving surface along a line)
tool.lathe = "กลึง";
// Ideally short strings (Revolving surface along a curve)
tool.tube = "ท่อ";
// Ideally short strings (Insert object into the scene)
tool.insert = "แทรก";
// Ideally short strings (Flip/Invert/Negate the shape)
tool.shape.flip = "พลิก";
// Ideally short strings (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "มุมมอง";
// Ideally short strings (Lasso selection)
tool.shape.lasso = "ลัสโซ";
// Ideally short strings (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "เคิร์ฟ";
// Ideally short strings (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "โพลีกอน";
// Ideally short strings (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "พาธ";
// Ideally short strings (Rectangular selection)
tool.shape.rectangle = "สี่เหลี่ยมผืนผ้า";
// Ideally short strings (Ellipse selection)
tool.shape.ellipse = "วงรี";
// Ideally short strings (Line selection, split the screen in half)
tool.shape.line = "เส้น";
// Ideally short strings (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "ปิด";

// Radius of the tool (size)
tool.radius = "รัศมี";
// Intensity of the tool (force)
tool.intensity = "ความเข้ม";

tool.settings = "การตั้งค่า";
tool.settings.none = "เครื่องมือนี้ไม่มีการตั้งค่าเฉพาะใดๆ";

tool.crease.pinchFactor = "แรงหยิก";
tool.crease.offsetFactor = "ปัจจัยการเยื้อง";

tool.layer.removeInfluence = "ใช้ข้อมูลเลเยอร์";
tool.layer.removeInfluence.help = "ตัวเลือกนี้จะใช้งานได้ก็ต่อเมื่อมีการเลือกเลเยอร์ไว้

จะใช้ข้อมูลเลเยอร์เพื่อจำกัดการเคลื่อนเกินไปนอกเส้นวาด";
tool.layer.noLayerSelected = "ตัวเลือกนี้จะใช้ได้ก็ต่อเมื่อได้เลือกเลเยอร์ไว้";

tool.flatten.planeLockOrigin = "ล็อคกำเนิดระนาบ";
tool.flatten.planeLockNormal = "ล็อคทิศทางระนาบ";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "ซิงค์";
tool.syncInstance.message = "วัตถุใหม่จะถูกเพิ่มในทุกอินสแตนซ์อื่น!";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "จุดยอดอยู่กับที่บนขอบเขต";
tool.smooth.screen = "การปรับความเรียบของหน้าจอ";
tool.smooth.screen.help = "ใช้ตัวเลือกนี้เพื่อรับการปรับความเรียบที่ไม่ขึ้นกับตำแหน่งทอพอโลยี แม้ใน poly ที่สูง";
tool.smooth.screen.samples = "ตัวอย่างหน้าจอ";
tool.smooth.taubin = "รักษาระดับ";
tool.smooth.taubin.shrink = "ย่อ";
tool.smooth.taubin.inflate = "พอง";
tool.smooth.stable = "ปรับรูให้เรียบ";
tool.smooth.stable.help = "พยายามทำให้การปรับให้เรียบไม่ขึ้นกับโครงสร้าง

โหมดนี้ทำงานได้ดีที่สุดกับความหนาแน่นของโครงสร้างที่แตกต่างกันและด้วยค่าความแรงของการปรับให้เรียบที่สูง";

tool.paint = "ลงสี";
// Erase the painting
tool.paint.erase = "ลบ";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "การกรองเลเยอร์";
tool.paint.layerFilter.help = "ใช้ตัวเลือกนี้หากคุณต้องการทาสีใหม่อีกบนพื้นที่ที่ลงสีแล้วของเลเยอร์เท่านั้น";

// Clear the painted mask
tool.mask.clear = "ล้าง";
tool.mask.clearAll = "ล้างทั้งหมด";
// Invert the painted mask
tool.mask.invert = "กลับด้าน";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "พลิกที่เชื่อมโยงกัน";
// Blur the painted mask
tool.mask.blur = "เบลอ";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "ความคมชัด";
// Transform/Matrix
tool.matrix = "แมทริกซ์";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.target = "เป้าหมาย";
// Automatic
tool.matrix.target.auto = "อัตโนมัติ";
tool.matrix.target.auto.help = "โดยค่าเริ่มต้น ฟังก์ชั่นนี้จะทำงานเหมือนกับตัวเลือกกลุ่ม
หากเมชมีการทำมาส์กไว้ หรือหากเปิดใช้สมมาตร ก็จะทำงานเหมือนกับจุดยอด";
// Auto apply the transform on the vertices
tool.matrix.target.vertex = "จุดยอด";
tool.matrix.target.vertex.help = "จะใช้กับการปรับแต่งบนจุดยอด จะไม่ทำงานบนรูปทรงพื้นฐานที่ไม่ผ่านการตรวจสอบรูปทรงพื้นฐาน
อินสแตนซ์จะได้รับผลกระทบเช่นกัน";
// Transform the object alone (the children stands still)
tool.matrix.target.object = "ออบเจ็กต์";
tool.matrix.target.object.help = "ย้ายออบเจ็กต์เท่านั้น โดยไม่รวมความสมมาตรและการมาส์ก
เฉพาะโหนดที่แก้ไขแล้วเท่านั้นที่จะย้าย โหลดลูกจะคงเดิม";
// Transform the object and its children
tool.matrix.target.group = "กลุ่ม";
tool.matrix.target.group.help = "ย้ายโหนดโดยไม่รวมความสมมาตรและมาส์ก
ลำดับชั้นที่เหลือจะถูกปรับแต่งเช่นกัน";
// Operation on the mesh
tool.matrix.action = "การทำงาน";
tool.matrix.action.origin = "ย้ายต้นทาง";
tool.matrix.action.origin.help = "ย้ายเมชไปยังต้นกำเนิด";
tool.matrix.action.bake = "เบค";
tool.matrix.action.bake.help = "ใช้เมทริกซ์กับจุดยอดและรีเซ็ตเมทริกซ์ หากมองดูจะไม่เห็นความเปลี่ยนแปลง";
tool.matrix.action.reset = "รีเซ็ต";
tool.matrix.action.reset.help = "รีเซ็ตการปรับแต่งเมชเป็นข้อมูลประจำตัว";

// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "เฉือน";
tool.matrix.translation = "การแปลง";
tool.matrix.rotation = "การหมุน";
tool.matrix.scale = "สเกล";
tool.matrix.uniformScale = "ทำให้เป็นขนาดเดียวกัน";

tool.transform.tip = "แตะเดี่ยวด้วยนิ้วที่สองเพื่อเปลี่ยนโหมด";

// Size of the gizmo
tool.gizmo.size = "ขนาดวิดเจ็ต";
// If true, there is less spacing between gizmo handlers (rotate, scale, etc)
tool.gizmo.compact = "กระชับ";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "อินพุตตัวเลข";
tool.gizmo.allowInput.help = "อนุญาตให้ป้อนตัวเลขเมื่อบันทึกวิดเจ็ตกิซโม่ตัวใดตัวหนึ่ง";
// Angle threshold
tool.gizmo.linearRollThreshold = "เกณฑ์การม้วนของสัมผัสวง";
tool.gizmo.linearRollThreshold.help = "ค่าเกณฑ์ของมุมเพื่อเลือกระหว่างวิธีการม้วนแบบเชิงเส้นหรือแบบวงกลม

ค่าที่สูงกว่าเกณฑ์นี้จะใช้การม้วนแบบวงกลม

หากคุณต้องการม้วนเชิงเส้น (ทิศทางของเส้นสัมผัส) ให้ตั้งค่านี้เป็น 90°";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "ซ่อนในการโต้ตอบ";
tool.gizmo.tap = "แตะเดียว";
tool.gizmo.tap.help = "ตัวเลือกนี้มีผลเฉพาะในโหมดกำหนดจุดหมุนแบบกำหนดเอง (ปิดใช้งานออโต้)";
tool.gizmo.tap.none = "ไม่มี";
tool.gizmo.tap.none.help = "ไม่มีอะไรเกิดขึ้นเมื่อแตะเมช";
tool.gizmo.tap.normal = "ปกติ";
tool.gizmo.tap.normal.help = "Move the gizmo on the first intersection and align it according to the surface normal.";
tool.gizmo.tap.first = "การตีครั้งที่หนึ่ง";
tool.gizmo.tap.first.help = "ย้ายกิซโม่ที่อินเตอร์เซ็กชั่นแรก";
tool.gizmo.tap.medial = "สแต็ปกลาง";
tool.gizmo.tap.medial.help = "ย้ายกิซโม่ไปโดยใช้ค่าเฉลี่ยของสองอินเตอร์เซ็กชั่นแรก";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "อยู่กับที่";
tool.lathe.axisOnly = "แกนเท่านั้น";
tool.lathe.stable = "มั่นคง";
tool.lathe.axis = "แกน";

// Fill the object's hole
tool.hole = "การอุดรู";
tool.hole.fillHoles = "อุดรู";
// synonym: Alternative method
tool.hole.method.fill = "เติม";
tool.hole.method.legacy = "มรดก";
tool.hole.method.boolean = "บูลีน";
tool.hole.bridges = "บูลีนพื้นที่หน้าจอ";
tool.hole.bridges.help = "หากเปิดใช้งานตัวเลือกนี้ คุณสามารถเจาะรูในวอลุ่มได้
ความชันของการตัดจะเป็นไปตามรูปร่างการตัดที่ใกล้ชิดมากขึ้น";
tool.hole.threshold = "เกณฑ์เอปซิลอน";
tool.hole.threshold.help = "การปรับค่านี้อาจช่วยเกี่ยวกับอัลกอริธึมการเติมรู";
tool.hole.smoothing = "ปรับรูให้เรียบ";

tool.smudge.quality = "คุณภาพ";
tool.smudge.quality.help = "จะเปลี่ยนความละเอียดของพิกเซลที่แสดง ค่าที่ต่ำกว่าหมายถึงจังหวะเส้นวาดที่เร็วขึ้น";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "รูปร่าง";
// Auto-validate the drawn shape
tool.shape.autoValidate = "ตรวจสอบอัตโนมัติ";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "สี่เหลี่ยม";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "อยู่กึ่งกลาง";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "วงกลม";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "อยู่กึ่งกลาง";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "หมุนสเต็ป";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "อัตราส่วนทอง";
// volume of a mesh
tool.measure.volume = "ปริมาตร";
// Surface of a mesh
tool.measure.surface = "พื้นผิว";

// Always display the camera shortcut buttons on the viewport
tool.view.stickyCamera = "ทางลัดกล้อง (เสมอ)";

// Topology
topology = "โทโพโลยี";
// Synynom: detail value, density
topology.dynamic.detail = "รายละเอียด";
// See glossary
topology.multires = "ความละเอียดหลายระดับ";
topology.multires.help = "รักษาความละเอียดหลายระดับของเมช

หากคุณเปลี่ยนแปลงค่าความละเอียดให้ต่ำกว่า รายละเอียดจากความละเอียดที่สูงกว่าจะแสดงซ้ำเมื่อคุณเปลี่ยนกลับ

มีเลเยอร์ในทุกความละเอียด";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "ย้อนกลับ";
topology.multires.reverse.confirm = "ไม่สามารถสร้างซับดิวิชันฐาน

โทโพโลยีในปัจจุบันอาจไม่ได้เป็นผลมาจากซับดิวิชัน";
topology.multires.subdivide = "แบ่ง";
topology.multires.subdivide.confirm = "เมชจะมีจุดยอด $0M คุณแน่ใจหรือไม่";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "การแบ่งเกินขีดจำกัด โปรดดู $0";
topology.multires.deleteLower = "ลบที่ต่ำกว่า";
topology.multires.deleteHigher = "ลบที่สูงกว่า";
topology.multires.keepTriangles = "เก็บสามเหลี่ยม";
topology.multires.lock = "ล็อค (LV0)";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "ระดับ Multires →";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "ระดับ Multires ←";
// Synonym: Flat subdivision
topology.multires.linear = "ซับดิวิชันเชิงเส้น";
topology.multires.linear.help = "เพียงแบ่งเมชออกโดยไม่ต้องปรับให้เรียบ";
// Only show the lowest resolution wireframe
topology.multires.minWireframe = "เฉพาะระดับ 0";
// Create a new object by recomputing a new topology
topology.remesh = "รีเมช";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "การรีเมชว็อกเซล";
topology.voxel.help = "การรีเมชโดยการสุ่มตัวอย่างเมชบนกริด

หากออบเจ็กต์ไม่ปิด (กันน้ำ) จะใช้อัลกอริทึมการเติมรูก่อน

เลเยอร์ถูกฉายซ้ำหลังจากรีเมช แต่คุณภาพจะลดลง";
topology.voxel.resolution = "ความละเอียด";
topology.voxel.sharp = "รักษาขอบคมไว้";
topology.voxel.sharp.help = "ตัวเลือกนี้มีประโยชน์ส่วนใหญ่สำหรับการทำบูลีนที่รูปทรงพื้นฐานอย่างง่ายๆ

จะทำให้เกิดการบิดเบี้ยวในบางพื้นที่เนื่องจากมีจุดที่ถูกสแนปที่ขอบ";
topology.voxel.subLevel = "สร้างหลายรายละเอียด";
topology.voxel.subLevel.help = "คุณสามารถสร้างใหม่ลำดับชั้นแบบหลายความละเอียดได้จากเอาต์พุตรีเมชเชอร์ของว็อกเซล

นอกจากนี้ยังจะทำงานเร็วขึ้นและใช้หน่วยความจำน้อยลง โดยเฉพาะอย่างยิ่งถ้าค่ารายละเอียดว็อกเซลสูง
อย่างไรก็ตาม หากค่ารายละเอียดว็อกเซลต่ำและคุณขอระดับหลายความละเอียดจำนวนมาก คุณจะสูญเสียรายละเอียดไป";
// Dynamic topology (DynTopo)
topology.surface.remesh = "รีเมช";
topology.surface.detail = "รายละเอียด";
topology.surface.detail.help = "ไม่เหมือนกับการรีเมชว็อกเซล การรีเมชพื้นผิไม่จำเป็นต้องปิดเมช

นอกจากนี้ยังรองรับการมาสก์เพื่อให้คุณสามารถป้องกันบางส่วนของเมชจากการเปลี่ยนแปลงโทโพโลยี

เลเยอร์ได้รับการอัพเดทอย่างถูกต้อง";
topology.surface.method = "วิธี";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "รวมให้เป็นแบบเดียว";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "ซับดิวิชัน";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "การลบ";
topology.surface.method.help = "ลักษณะของโทโพโลยีแบบไดนามิก:
• รวมให้เป็นแบบเดียว: เพิ่มและลบรายละเอียด
• ซับดิวิชัน: เพิ่มรายละเอียด
• การลบ: ลบรายละเอียด";
topology.surface.useMasking = "ปกป้องพื้นที่ที่มาส์กไว้";
topology.surface.useMasking.help = "พื้นที่มาส์กไว้จะป้องกันโทโพโลยีไม่ให้เปลี่ยนแปลง";
topology.surface.extrapolate = "การคำนวนค่านอกช่วงของพื้นฐาน";
// DynTopo
topology.dynamic = "โทโพโลยีแบบไดนามิก";
topology.dynamic.global = "เปิด/ปิดทั่วโลก";
topology.dynamic.activate = "เปิดใช้งาน";
topology.dynamic.activate.help = "ด้วยโทโพโลยีแบบไดนามิก เครื่องมือการปั้นรูปสามารถแบ่งย่อยหรือลดความซับซ้อนของเมชในแบบเรียลไทม์

คุณลักษณะนี้อาจมีผลกระทบต่อประสิทธิภาพอย่างเห็นได้ชัด

เลเยอร์ได้รับการอัพเดทอย่างถูกต้อง";
topology.dynamic.method = "รายละเอียดตาม...";
topology.dynamic.method.screen = "สกรีน";
topology.dynamic.method.radius = "รัศมี";
topology.dynamic.method.constant = "คงที่";
topology.dynamic.method.help = "• ซูม
ระดับของรายละเอียดขึ้นอยู่กับว่าคุณอยู่ไกลจากพื้นผิวมากแค่ไหน

--รัศมี
รัศมีเครื่องมือกำหนดจำนวนรายละเอียด

• คงที่
รายละเอียดได้รับการแก้ไขแล้ว ค่ารายละเอียดจะถูกแชร์กับตัวเลื่อนว็อกเซลเช่นกัน";
topology.dynamic.quality = "เลื่อน...";
topology.dynamic.quality.help = "หากคุณเลือกคุณภาพ มีความแตกต่างหลัก 2 ประการคือ
• การปรับแต่งจะถูกนำไปใช้ก่อนผู้ดำเนินการปั้นรูป คุณจะได้รับสิ่งประดิษฐ์ที่สอดแทรกน้อยลงเมื่อทาสีหรือปั้นรูปรายละเอียดเล็กๆ น้อยๆ
• การปรับแต่งจะไม่ถูกนำไปใช้ทีละส่วน หากคุณปั้นรูปรายละเอียดเล็กๆ น้อยๆ หรือทำการสโตรกอย่างรวดเร็ว โทโพโลยีจะได้รับการขัดเกลาอย่างถูกต้องเสมอ";
topology.dynamic.quality.speed = "ความเร็ว";
topology.dynamic.quality.quality = "คุณภาพ";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "ใช้แรงกดบนรัศมี";
topology.dynamic.usePressure.help = "ใช้ตัวเลือกนี้หากคุณต้องการให้แรงกดของปากกาส่งผลต่อรัศมีของเครื่องมือ เพื่อที่จะส่งผลต่อระดับของรายละเอียด";
topology.dynamic.useFalloff = "ใช้การทำเส้นโค้งลายเส้น";
// Decimate
topology.decimate.title = "การลบ";
topology.decimate.title.help = "ลดจำนวนรูปหลายเหลี่ยมโดยพยายามเก็บรายละเอียดให้มากที่สุด

คุณสมบัตินี้จะมีประโยชน์หากคุณต้องการนำออกสำหรับการพิมพ์ 3D
อย่างไรก็ตาม คุณไม่ควรใช้คุณสมบัตินี้หากคุณต้องการทำงานต่อ เนื่องจากจะทำให้เกิดสามเหลี่ยมที่ไม่สม่ำเสมอได้

โปรดทราบว่าพื้นที่ที่มาส์กไว้จะไม่ถูกทำลาย";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "ลบล้าง";
topology.decimatePaintWeight = "รักษาภาพวาด";
topology.decimatePaintWeight.help = "ค่าที่สูงขึ้นจะพยายามรักษาภาพวาด

ตั้งค่านี้เป็น 0 หากคุณไม่สนใจเกี่ยวกับภาพวาด";
topology.decimateUniform = "เฟสที่ทำให้เหมือนกัน";
topology.decimateUniform.help = "ค่าที่สูงกว่าจะทำให้เกิดรูปสามเหลี่ยมที่มีขนาดใกล้เคียงกัน";
topology.decimatePreserveBorders = "รักษาขอบเขต";
topology.decimatePreserveBorders.help = "ไม่ลดจำนวนขอบเขตของเมช.";
// Target a certain number of triangles, faces and vertices
topology.target.triangles = "สามเหลี่ยมเป้าหมาย";
topology.target.faces = "เป้าหมายเป็นหน้า";
topology.target.quads = "เป้าหมายเป็นสี่เหลี่ยม";
topology.target.points = "เป้าหมายเป็นจุด";
// Quad remesher
topology.qremesh = "Quad Remesh";
topology.qremesh.angle = "มุม Crease";
topology.qremesh.border = "รักษาขอบเขต";
topology.qremesh.onlyQuad = "เฉพาะสี่เหลี่ยม";
topology.qremesh.hole = "Max fill hole";
topology.qremesh.hole.help = "
คำนวน UV";

// Unwrapping means compute UV (texture coordinates), with uvs you can appliy (wrap) a texture onto the model
topology.uv.title = "UV Unwrap";
// UV Unwrap but as a Verb
topology.uv.unwrap = "คำนวน";
// The operation can be very slow
topology.uv.atlas.warning = "อาจช้ามาก กำหนดเป้าหมาย <100k จุดยอด";
// Handles are topological holes (synonym: genus, hole)
topology.uv.bff.warning = "ทับซ้อนกันได้ถ้าถ้าเมชมีแฮนเดิ้ล!";
// Solo patch
topology.uv.bff.seamless = "แพทช์ที่ไม่มีรอยต่อ";
topology.uv.bff.seamless.help = "ตัวเลือกนี้อาจทำให้เกิดการบิดเบือนที่สำคัญ



โดยทั่วไป, มันสามารถใช้ได้เมื่อกลุ่มใบหน้าถูกตั้งค่าอย่างรอบคอบ";
// Synonym: Point count? Singularity count ?
topology.uv.bff.cones = "จำนวนโคน";
topology.uv.bff.help = "ค่าที่สูงขึ้นจะลดการบิดเบือนของวัตถุที่ซับซ้อน

ค่าที่สูงขึ้นหมายถึงเวลาประมวลผลนานขึ้น";
topology.uv.delete = "ลบ UVs";

// Transfer the vertex painting in the texture, bake means "create texture (from mesh data)"
topology.bake.title = "เบค";
// Bake here means "create texture (from mesh data)"
topology.bake.title.help = "การอบเนื้อหาจะสร้างเนื้อหาโดยการฉายวัตถุที่มองเห็นอื่นๆ ในฉาก.

นี่คือกระบวนการทำงานทั่วไปสำหรับการอบ:
• คุณมีเมชที่มีรายละเอียดและการวาดภาพที่ละเอียด
• โคลนมัน
• ลดจำนวนมัน (ตั้งค่า `Preserve painting` เป็น 0!)
• UV unwrap มัน
• อบมัน!

คุณควรจะมีเมชความละเอียดต่ำที่ยังคงรายละเอียดและการวาดภาพของวัตถุก่อนหน้าของคุณ.

หลังจากการดำเนินการ, สีของจุดจะถูกย้ายไปยังเลเยอร์ใหม่ที่ปิดใช้งาน, เพื่อให้มันถูกละเลยแทนที่จะถูกคูณกับเนื้อหาที่มีสี.

เพื่อเลือกว่าสิ่งของใดจะถูกใช้ในการเบค, จะใช้ตรรกะต่อไปนี้:
- ของที่ถูกเลือกทั้งหมดและสิ่งของที่ถูกเลือกเป็นหลักจะถูกเบค (ไฮไลท์ที่ชัดเจนที่สุดในเมนูฉาก)
- หากมีเพียงสิ่งเดียวที่ถูกเลือก, Nomad จะพิจารณาสิ่งของที่มองเห็นได้ทั้งหมดแทน
- มิฉะนั้น หากทุกอย่างถูกซ่อน (เช่นโดยการใช้ Solo), ฉากทั้งหมดจะถูกนำมาพิจารณา";
// Bake here means "create texture (from mesh data)"
topology.bake.self = "จากตัวมันเอง";
// Bake here means "create texture (from another mesh data)"
topology.bake.other = "จากความละเอียดสูง";
topology.bake.resolution = "ความละเอียด";
// Cage is a specific term, synonyom: "Bake offset"
topology.bake.offset = "การเบี่ยงเบนของแสง";
topology.bake.radius = "รัศมีของ Cage";
// Bake opacity (from mask data)
topology.bake.opacityFromMask = "Mask -> Opacity";
topology.bake.backup = "สำรองข้อมูล";

// project a high resolution mesh details onto another
topology.reproject.title = "Reproject";
topology.reproject.title.help = "โปรเจครายละเอียดที่ปั้นและการวาดรวมถึงเลเยอร์จากวัตถุที่มองเห็นได้ใกล้ที่สุด.

นี่มักจะใช้กับเมชความละเอียดสูงด้วยเช่นกัน, โดยทั่วไปด้วยโทโพโลยีที่สะอาด.";
// tweaking value
topology.reproject.rayBias = "Ray bias";
topology.reproject.rayBias.help = "มีวิธีการสองวิธีที่ใช้สำหรับการ reprojection:
• ใกล้ที่สุด: จุดที่ใกล้ที่สุดบนพื้นผิว
• ray: จุดตัดผ่านทิศทางของ normal

ค่า bias ที่สูงขึ้นจะเอื้ออำนวยการตัดผ่าน ray มากกว่าการหาพื้นผิวที่ใกล้ที่สุด.";
topology.reproject.normalOffset = "Normal offset";
topology.reproject.shpereCast = "ฟอลล์แบ็กของสเฟียร์แคสต์";
topology.reproject.shpereCast.help = "หากการรีโปรเจคชันเรย์ตามปกติล้มเหลว นอมัดจะกลับไปใช้การตัดกับพื้นผิวที่ใกล้ที่สุด";
// number of iteration the algorithm will take
topology.reproject.iterations = "Iterations";
topology.reproject.relax = "อ่อนลง";
topology.reproject.relax.help = "ควรใช้ Relax เมื่อเมชมีความละเอียดต่ำ.";
topology.reproject.layers.help = "โอนเลเยอร์อื่นๆ ไปยังเมชที่เลือก.";

topology.manifold = "ทับซ้อน";
topology.nonManifold = "ไม่ทับซ้อน";
topology.manifold.clean = "ทำความสะอาด";
topology.manifold.collapse = "ลบหน้าเล็กๆ";
topology.manifold.title = "บังคับให้เป็นทับซ้อน";
topology.manifold.title.help = "พยายามทำความสะอาดขอบที่ไม่ทับซ้อน

มันอาจจะมีประโยชน์สำหรับซอฟต์แวร์ภายนอกที่ไม่รองรับขอบที่มีหน้าที่มากกว่า 2 หน้าที่มีอยู่ร่วมกัน";

// Reset key-bindings/shortcuts
binding.reset = "รีเซ็ตการมัดรวม";
// Add node in a sync mode (synchronize instance)
binding.addSync = "ซิงค์";
binding.addSync.help = "ตามค่าเริ่มต้น จะใช้ค่าซิงค์ที่ตั้งไว้ในเมนูฉาก";
// Add node in a sync mode (synchronize instance)
binding.float.position = "ตำแหน่ง";
binding.float.position.keep = "คงค่าเดิม";
binding.float.position.cursor = "ที่เคอร์เซอร์";
// Binding option
binding.context.toggle = "สลับบริบท";
// quick sidebar tool shortcuts
binding.quicks = "ทางลัดที่รวดเร็ว";
// quick regular tool shortcuts
binding.tools = "ทางลัดเครื่องมือ";
// When the key is tapped once, the value will be toggled
binding.toggle = "สลับเครื่องมือก่อนหน้า";
binding.toggle.help = "ใช้การผูกเหมือนเดิมเพื่อสลับกลับไปยังเครื่องมือสุดท้าย";
// Control if hold+release reverts the tool
binding.revert = "กดค้างสำหรับการคืนค่า";
binding.revert.help = "เลือกว่าจะให้ปล่อยคีย์ที่กดค้างไว้กลับไปใช้เครื่องมือเดิมหรือไม่ แม้ว่าเครื่องมือนั้นจะถูกใช้งานอยู่แล้วก็ตาม.";
// sticky keys
binding.sticky = "ปุ่มลอย";
binding.sticky.off = "กดค้าง";
binding.sticky.off.help = "กดค้างที่ปุ่มเพื่อใช้เครื่องมือ ปล่อยเพื่อกลับไปใช้เครื่องมือก่อนหน้า";
binding.sticky.on = "สลับ";
binding.sticky.on.help = "กดครั้งเดียวเพื่อสลับเครื่องมือ";
binding.sticky.quick = "กดอย่างรวดเร็ว";
binding.sticky.quick.help = "กดค้างเพื่อใช้ชั่วคราว กดอย่างรวดเร็วเพื่อสลับ";
// The binding force camera movement
binding.forceCamera = "บังคับกล้อง";
binding.forceCamera.help = "บังคับการโต้ตอบของกล้องในกรณีที่มีความขัดแย้งกับการผูกอื่น 

โดยทั่วไปแล้วอาจเกิดขึ้นได้หากการผูกเดียวกันนี้ถูกกำหนดให้เป็นทางลัดของเครื่องมือหรือการเพิ่ม/ลบ";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickMaterial = "การเลือกวัสดุ";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickFaceGroup = "เลือกกลุ่มหน้า";
// Edit the tool brush size/radius
binding.editRadius = "รัศมีเครื่องมือ";
// Inverse direction zooming
binding.invertZoomY = "กลับด้านการซูม Y";
// Edit the tool brush size/radius
binding.editIntensity = "ความเข้มของเครื่องมือ";
// Controller dead zone
binding.joystick = "จอยสติก";
binding.controller.deadZone = "Stick Dead Zone";
binding.controller.deadZone.help = "เพิ่มค่านี้หากกล้องเคลื่อนที่แม้ว่าคันโยกของตัวควบคุมจะไม่ถูกแตะต้อง";
// Snap the camera
binding.view.front = "มุมมองด้านหน้า";
binding.view.left = "มุมมองด้านซ้าย";
binding.view.top = "มุมมองด้านบน";
// Move/Translate the view
binding.pan.left = "เลื่อนไปทางซ้าย";
binding.pan.right = "แพนขวา";
binding.pan.forward = "แพนไปข้างหน้า (มุมมอง";
binding.pan.backward = "แพนไปข้างหลัง (มุมมอง";
binding.pan.up = "แพนขึ้นข้างบน (มุมมอง";
binding.pan.down = "แพนลงด้านล่าง (มุมมอง";
// Snap the view (while rotating)
binding.snapViewOnRotate = "มุมมองแบบสแนป (ขณะหมุน)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "เปิด (โปรเจ็กต์)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "เพิ่ม (โปรเจ็กต์)";
// Select all the objects in the scene
binding.selectAll = "เลือกทั้งหมด";
// Rotate environment and the lighting
binding.rotateLighting = "หมุนแสง";
// The Camera pivot is the point around which the camera rotates
binding.updatePivot = "จุดหมุน";

quadremesh.adaptQuadCount = "จำนวนสี่เหลี่ยมที่ปรับได้";
quadremesh.curvatureAdaptivness = "ขนาดที่ปรับได้";
quadremesh.curvatureAdaptivness.help = "ที่ 100%, ขนาดของสี่เหลี่ยมจะแตกต่างกันไปตามความโค้งของวัตถุ, อนุญาตให้มีสี่เหลี่ยมเล็กๆ บนพื้นผิวที่มีความโค้งสูง
ที่ 0%, ขนาดของสี่เหลี่ยมจะเท่ากันทั่วไป";
quadremesh.useVertexColors = "รักษาภาพวาด";
quadremesh.autoDetectHardEdges = "ตรวจจับขอบแข็งอัตโนมัติ";
quadremesh.autoDetectHardEdges.short = "ขอบหนา";
quadremesh.reprojectVertex = "ทำให้จุดยอดเกิดใหม่";
quadremesh.reprojectVertex.short = "ทำให้จุดยอดเกิดใหม่";
quadremesh.reprojectVertex.label = "เมื่อเปิดการทำงาน Nomad จะทำให้ตำแหน่งดีที่สุดบนเมชก่อนหน้า

โปรดทราบว่า หากเมชมีเลเยอร์ การทำให้เกิดใหม่จะใช้เสมอ";

// Privacy policy
privacyPolicy.title = "นโยบายความเป็นส่วนตัว";
privacyPolicy.reject = "ปฏิเสธ";
// Hexanomad is the company name
privacyPolicy = "Hexanomad ไม่ได้รวบรวมข้อมูลใดๆ จาก Nomad Sculpt";

sonar.disconnect = "ยกเลิกการเชื่อมต่อ SonarPen";
sonar.connect = "เชื่อมต่อ SonarPen";
sonar.connect.confirm = "เชื่อมต่อ SonarPen?";
sonar.connect.confirm.warning = "Sonar Pen จะใช้ไมโครโฟน (ลูปแบ็คเสียง) เพื่อตรวจจับแรงกดของปากกา";

// Color disc mode
widget.color.disc = "ดิสก์";
widget.color.ring = "แหวน";
widget.color.square = "สี่เหลี่ยม";

nomad.mainFolder = "โฟลเดอร์หลัก Nomad";
nomad.mainFolder.help = "หากคุณเพิ่มไฟล์ลงในโฟลเดอร์หลักของ Nomad โปรดรีสตาร์ท Nomad เพื่อให้มีผลการเปลี่ยนแปลง

ไฟล์ที่ไม่ถูกของในซับโฟลเดอร์อาจถูกย้ายไปยัง can_be_deleted/

ตัวอย่างเช่น โฟลเดอร์โครงการยอมรับเฉพาะไฟล์ 3 มิติ ในขณะที่อัลฟาหรือ matcaps ยอมรับเฉพาะภาพเท่านั้น";
nomad.mainFolder.warning = "ไฟล์จะไม่ถูกแตะต้อง
ไม่ถูกคัดลอก ลบ หรือย้าย";
nomad.mainFolder.error = "หลังจากที่คุณเลือกใช่ Nomad จะปิดลงและคุณสามารถเปิดใช้งานได้ทันที";

license.title = "ใบอนุญาต";
license.retry = "ลองอีกครั้ง";
license.key = "คีย์ใบอนุญาต";
license.activate = "เปิดใช้งานใบอนุญาต";
// ----------------------------------------------
license.newest = "มีเวอร์ชันใหม่!";
license.encrypt.error = "ไม่สามารถเข้ารหัสได้!";
// ----------------------------------------------
license.grace = "ออฟไลน์ - ช่วงเวลาผ่อนผันที่เหลืออยู่:";
license.grace.hours = "ชั่วโมง";
license.grace.days = "วัน";
// ----------------------------------------------
license.portal.title = "ผู้ใช้ที่มีอยู่";
license.portal.label = "พอร์ทัลใบอนุญาต";
// ----------------------------------------------
license.checkout.title = "ผู้ใช้ใหม่";
license.checkout.label = "ซื้อ Nomad";
// ----------------------------------------------
license.device.error = "ไม่สามารถรับ ID อุปกรณ์ได้";
license.device.mismatch = "ID อุปกรณ์ไม่ตรงกัน!";
// ----------------------------------------------
license.error429 = "คำขอมากเกินไป (โปรดรอ).";
// ----------------------------------------------
license.validate.error404 = "ไม่พบคีย์ใบอนุญาต";
license.validate.error422 = "หน่วยงานไม่สามารถประมวลผลได้";
// ----------------------------------------------
license.activate.error403 = "ถึงจำนวนอุปกรณ์สูงสุดแล้ว!
คุณสามารถยกเลิกใช้งานอุปกรณ์อื่นบนพอร์ทัลใบอนุญาตของคุณ";
license.activate.error404 = "ไม่พบคีย์ใบอนุญาต";
license.activate.error422 = "หน่วยงานไม่สามารถประมวลผลได้";
// ----------------------------------------------
// version
version.update = "อัปเดตใหม่พร้อมใช้งาน!";
version.restore = "คืนค่าการซื้อ";
version.buyWeb = "เวอร์ชันเว็บเป็นเพียงตัวอย่างเท่านั้น";
version.buyFull = "อัพเกรดเป็นเวอร์ชันเต็ม";
// ----------------------------------------------
// QuadRemesh
version.qr.unlock = "ปลดล็อก (ซื้อ, กู้คืน, ทดลองใช้)";
version.qr.desktop = "บนเดสก์ท็อป QuadRemesher ถูกแจกจ่ายโดย Hexanomad แต่ว่า Hexanomad ไม่ได้จัดการการขายหรือการออกใบอนุญาต
การจัดการใบอนุญาตทั้งหมดดำเนินการโดย Exoside";
version.qr.buy = "ซื้อ";
version.qr.promo = "
Quad Remesher เป็นอัลกอริทึมที่ผลิตเมชที่มีสี่เหลี่ยมเป็นหลัก
การกระจายสี่เหลี่ยมจะพยายามตามความโค้งธรรมชาติของวัตถุ

อัลกอริทึมยังสามารถปรับขนาดสี่เหลี่ยมตามความโค้งท้องถิ่นได้

คุณยังสามารถนำทางทอพอโลยีที่ได้ผลด้วย:

• กลุ่มหน้า $0 (ตรวจสอบให้แน่ใจว่าขอบของพวกเขานุ่มนวลเพื่อผลลัพธ์ที่ดีกว่า!)

• ความสมมาตรแบบแผน X/Y/Z $1

• ไกด์เส้นโค้ง $2

• การวาดความหนาแน่น $3

Quad Remesher พัฒนาโดย https://exoside.com/.";
// ----------------------------------------------
version.trialLayer = "เวอร์ชันทดลอง 1 เลเยอร์ต่อเมช";
version.trialNoExport = "เวอร์ชันทดลอง ไม่นำออก";
// ----------------------------------------------
version.fullFeatures = "• ซื้อครั้งเดียว
• เลิกทำ/ทำซ้ำได้ไม่จำกัด
• ไม่จำกัดเลเยอร์
• นำออกนำเข้า";
// ----------------------------------------------
version.demo.purpose = "แอพเวอร์ชั่นนี้จัดทำขึ้นสำหรับการสาธิตโดยเฉพาะ.";
version.demo.disable = "คุณสมบัติไม่ได้เปิดให้ใช้สำหรับการสาธิตนี้.";
// ----------------------------------------------
version.demo = "ทดสอบสาธิต";
version.demo.sculpt = "การแกะสลัก";
version.demo.sculpt.help = "แปรงทั้งหมดสามารถใช้งานได้ แต่คุณไม่สามารถบันทึกหรือส่งออกได้

โหมดนี้มีไว้เพื่อทดลองใช้แปรงหรือทดสอบการรองรับแรงกด

คุณลักษณะอื่นๆ อาจถูกจำกัดเช่นกัน (ประวัติ, ชั้น)";
version.demo.file = "การนำเข้าและส่งออก";
version.demo.file.help = "คุณสามารถนำเข้าและส่งออกโมเดลได้ แต่ว่าแปรงแกะสลักจะถูกปิดใช้งาน

โหมดนี้จะเป็นประโยชน์สำหรับผู้ใช้มือถือที่ไม่สามารถเปิดโครงการ .nom ขนาดใหญ่ได้เนื่องจากข้อจำกัดของหน่วยความจำมือถือ";
// ----------------------------------------------
// app store main page
store.name = "Nomad Sculpt";
store.headline = "สลัก, วาด, และสร้างใน 3 มิติ";
store.tag = "sculpt, 3d, nomad, paint, modeling, สลัก, วาด, หล่อแบบ";
// ----------------------------------------------
store.description.sculpt = "• เครื่องมือสลัก
ดิน, ทำให้เรียบ, ปรับระดับ, และแปรงอื่นๆ ที่จะช่วยให้คุณปั้นสร้างสรรค์ของคุณได้
คุณยังสามารถใช้เครื่องมือตัดแบบบูลีนทริมด้วยลาสซู, สี่เหลี่ยมผืนผ้า และรูปทรงอื่นๆ สำหรับวัตถุประสงค์การสร้างผิวแข็ง.";
// ----------------------------------------------
store.description.stroke = "• การปรับแต่งการกรีด
การลดลง, , การปูกระเบื้อง, แรงกดดินสอ และพารามิเตอร์อื่นๆ ของการกรีดสามารถปรับได้
คุณยังสามารถบันทึกและโหลดการตั้งค่าเครื่องมือของคุณเช่นกัน";
// ----------------------------------------------
store.description.paint = "• เครื่องมือวาดภาพ
การระบายสีด้วย Vertex พร้อมสี, และ 
คุณสามารถจัดการชุดวัสดุของคุณได้อย่างง่ายดายด้วย";
// ----------------------------------------------
store.description.layer = "• เลเยอร์
บันทึกการดำเนินการสลักและวาดภาพของคุณในแยกต่างหากเพื่อการวนซ้ำที่ง่ายขึ้นระหว่างกระบวนการสร้าง
การเปลี่ยนแปลงทั้งในการสลักและการวาดภาพจะถูกบันทึก";
// ----------------------------------------------
store.description.multires = "• การสลักหลายความละเอียด
ไปมาหาสู่ระหว่างความละเอียดหลายแบบของตาข่ายของคุณเพื่อการทำงานที่ยืดหยุ่น";
// ----------------------------------------------
store.description.voxel = "• รีเมชว็อกเซล
รีเมช อย่างรวดเร็วให้กับ ของคุณเพื่อรับระดับรายละเอียดที่เป็นเอกภาพ
สามารถใช้เพื่อร่างรูปแบบที่หยาบได้อย่างรวดเร็วตั้งแต่เริ่มต้นกระบวนการสร้าง";
// ----------------------------------------------
store.description.dynamic = "• โทโพโลยีไดนามิก
ปรับ ของคุณภายใต้แปรงของคุณเพื่อรับระดับรายละเอียดของอัตโนมัติ
คุณสามารถเก็บ ของคุณไว้, เนื่องจากจะได้รับการอัปเดตโดยอัตโนมัติ!";
// ----------------------------------------------
store.description.topology = "• ลดรูปหลายเหลี่ยม
ลดจำนวนรูปหลายเหลี่ยมโดยรักษารายละเอียดไว้ให้มากที่สุด";
// ----------------------------------------------
store.description.group = "• กลุ่มหน้า
แบ่ง ของคุณออกเป็นกลุ่มย่อยด้วยเครื่องมือกลุ่มหน้า";
// ----------------------------------------------
store.description.unwrap = "• การคลาย อัตโนมัติ
การคลาย อัตโนมัติสามารถใช้กลุ่มหน้าในการควบคุมกระบวนการคลาย";
// ----------------------------------------------
store.description.baking = "• การอบเนื้อหา
คุณสามารถโอนข้อมูล Vertex เช่นสี, , และรายละเอียดขนาดเล็กเข้าสู่เท็กซ์เจอร์
คุณยังสามารถทำในทางตรงกันข้าม, โอนเท็กซ์เจอร์ข้อมูลเข้าสู่ข้อมูล Vertex หรือ ได้";
// ----------------------------------------------
store.description.primitive = "• รูปทรงประเภทต้นแบบ
กระบอก, โดนัท, ท่อ, เครื่องกลึง และรูปทรงประเภทต้นแบบอื่นๆ สามารถใช้เพื่อเริ่มต้นรูปร่างใหม่จากเริ่มแรก";
// ----------------------------------------------
store.description.rendering = "• การเรนเดอร์ PBR
การเรนเดอร์ PBR ที่สวยงามโดยค่าเริ่มต้น, พร้อมการส่องสว่างและเงา
คุณสามารถสลับไปยัง MatCap สำหรับการเงาที่มาตรฐานมากขึ้นสำหรับวัตถุประสงค์ในการสลัก";
// ----------------------------------------------
store.description.postprocess = "• การประมวลผลการตกแต่ง
การสะท้อนพื้นที่หน้าจอ, ระยะการมองเห็น, การการันต์ร่องรอย, การทำแผนผังโทน, ฯลฯ";
// ----------------------------------------------
store.description.files = "• การส่งออกและนำเข้า
รูปแบบที่รองรับ ได้แก่ ไฟล์ glTF, OBJ, STL หรือ PLY";
// ----------------------------------------------
store.description.interface = "• อินเตอร์เฟส
อินเตอร์เฟสที่ใช้งานง่าย, ออกแบบมาสำหรับประสบการณ์มือถือ
การปรับแต่งก็เป็นไปได้เช่นกัน!";
// ----------------------------------------------
store.description.remesher = "• Quad Remesher (ซื้อภายในแอปแยกต่างหากเท่านั้น)
รีเมชวัตถุของคุณโดยอัตโนมัติด้วยเมชที่ครอบงำด้วย quad ซึ่งติดตามความโค้งของเมช
รองรับคำแนะนำ, กลุ่มหน้า และการวาดความหนาแน่น";
// ----------------------------------------------