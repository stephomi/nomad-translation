// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "Potwierdzić?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Tak";
// Answer to a question (Are you sure you want to do that? [yes, no, cancel])
confirm.no = "Nie";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "OK";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Anuluj";
// Restart nomad
confirm.restart = "Po zmianie tej wartości musisz ponownie uruchomić Nomad.";

// Experimental feature
experimental = "Funkcja eksperymentalna!";

status.exit = "Niezapisane zmiany! Zapisać przed zamknięciem?";
status.exit.yes = "Zachowaj";
status.exit.no = "Nie zapisuj";

// On single tap (should be short)
ontap = "Stuknięciu";

all = "Wszystkie";
error = "Błąd";

reset = "Wyzeruj";
resetOrder = "Zresetuj kolejność";

clipboard = "Schowek";
clipboard.copy = "Kopiuj";
clipboard.paste = "Wklej";

// memory size
bytes = "bajtów";
kB = "kB";
MB = "MB";
GB = "GB";
TB = "TB";

// Noun
instance = "Utwórz instancję";
object = "Obiekt";

// Same value (usually for axis, e.g: x == y == z)
uniform = "Jednolity";

sync = "Synchronizacja";

// position
position.top = "Góra";
position.bottom = "Dół";
position.left = "Lewo";
position.right = "Prawo";
position.center = "Wyśrodkowany";
// direction
direction.up = "Góra";
direction.down = "Dół";
direction.left = "Lewo";
direction.right = "Prawo";
// 3D cube
cube.top = "Góra";
cube.bottom = "Dół";
cube.left = "Lewo";
cube.right = "Prawo";
cube.front = "Przód";
cube.back = "Tył";

// Name of an item (object, tool, etc)
item.name = "Nazwa";
// Add a new item (object, tool, etc)
item.new = "Nowy";
// Rename an item (object, tool, etc)
item.rename = "Zmień nazwę";
// Add a new item (object, tool, project, etc)
item.add = "Dodaj";
// Update an item image with a new image (synonym: Update)
item.replace = "Zastąp";
// Save an item (object, tool, etc)
item.save = "Zachowaj";
item.save.confirm = "Potwierdzić zapisanie?";
// Update an item (update camera view point, etc)
item.update = "Aktualizacja";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Ostatni zapis";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "Załadować ostatni zapis?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Wyzeruj";
item.reset.confirm = "Potwierdzić zresetowanie?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "Utwórz instancję";
// Uninstance the object, make the object real
item.uninstance = "Anuluj instancję";
// Clone an item (object, tool, etc)
item.clone = "Klonuj";
// Delete an item (object, tool, etc)
item.delete = "Usuń";
item.delete.confirm = "Potwierdzić usunięcie?";
item.delete.confirm.yes = "Tak, usuń";
// When we delete the item but the image is used somewhere
item.delete.used = "Użyty obraz";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "Do węzła";
// Item visibility (object, layer, etc)
item.visible = "Widoczne";
// Show an item (object, layer, etc)
item.show = "Pokaż";
// Hide an item (object, layer, etc)
item.hide = "Ukryj";
// Select an item (object, layer, etc)
item.select = "Wybierz";
// Unselect an item (object, layer, etc)
item.unselect = "Anuluj zaznaczenie";
// Merge an item with another one below (layer)
item.mergeDown = "Scal w dół";
// The order of an item in a list
item.order = "Kolejność";
// Focus on previous item
item.previous = "Poprzedni";
// Focus on next item
item.next = "Dalej";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "Zablokuj";
// No item selected
item.none = "Brak";
// Draggable, moveable
item.draggable = "Przenośny";

// Search something (text entry to filter item)
search = "Przeszukaj";

// Three-state toggle button (Auto, Off, On)
toggle.on = "Wł.";
// Three-state toggle button (Auto, Off, On)
toggle.off = "Wył.";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "Auto";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Brak miniatur, ponowne przetwarzanie plików...";
loading.reprocess.cancel = "Pominąć generowanie miniatur?";

access.title = "Dostępność";
access.window = "Okno pomocnicze";
access.pinch = "Ściśnięcie";
access.drag = "Przeciągnij";
access.rotate = "Obróć";
access.roll = "Rolka";

// Color of an object
material.color = "Kolor";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "Nierówność";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "Połysk";
// Whether the material is a metal or not
material.metalness = "Metaliczność";
// How much light a surface will reflect
material.specular = "Zwierciadlane";
// Light that the surface can emit (glow)
material.emissive = "Emisyjne";
// Normal map (synonym: detail, bump)
material.normal = "Normalna";
// flip y coordinate
material.normal.flipY = "Odwróć Y";
// Ambient Occlusion (AO)
material.occlusion = "Okluzja";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "Tekstury";
// Textures/Image
material.texture = "Tekstura";
// A warning indicating that the mesh has no UVs
material.warningNoUVs = "Brak map UV!";
// Texture filtering https://en.wikipedia.org/wiki/Texture_filtering
material.texture.filter = "Filtrowanie";
// Nearest Filtering (closest sample)
material.texture.nearest = "Najbliższy";
// Bilinear Filter
material.texture.linear = "Liniowy";
// Mipmap filtering
material.texture.mipmap = "Mipmapa";
// Triplanar mapping
material.projection = "Projekcja";
material.projection.triplanar = "Trzypłaszczyznowy";

// Prefer low power
about.lowPower = "GPU niskiej mocy";
// Wintab wacom API
about.wintab = "Użyj WinTab";
about.wintab.help = "Jeśli WinTab jest włączony, prawdopodobnie powinieneś wyłączyć Windows Ink w ustawieniach Wacom.

Podobnie, jeśli WinTab jest wyłączony, należy włączyć Windows Ink w ustawieniach Wacom";
// Wacom Multi Touch API
about.touch = "Użyj Wacom Multi-Touch";
about.touch.help = "Włącz tę opcję, aby obsługiwać wiele palców na tabletach Wacom.";
// Prefer low power
about.fullScreen = "Pełny ekran";
// Minify
about.minify = "Minimalizuj interfejs użytkownika";
about.minify.help = "Możesz także stuknąć ekran 4 palcami, jeśli Twoje urządzenie to obsługuje.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Obrotnica";
// Rotation center of the turntable
about.turntable.pivot = "Centrum obrotu";
// Keep current pivot
about.turntable.pivot.keep = "Zachowaj aktualne";
// Turntable pivot will be at the center of the scene
about.turntable.pivot.scene = "Scena";
// Make the entire scene turn around (speed of the animation)
about.turntable.speed = "Szybkość";
// Stuffs that I used to make the app
about.credits = "Autorzy";
// Link to open source projects that I used for the app
about.credits.openSource = "Open Source";
// Only translate the &
about.credits.arts = "MatCap i HDRI";
// Change languages of the app
about.languages = "Języki";
about.languages.help = "Pliki tłumaczenia dostępne na stronie $0";
// Link to the App Website
about.website = "Witryna";
// Link to the App Forum
about.forum = "Forum";
// Link to the App Manual
about.manual = "Instrukcja obsługi";
// Link to the App Email
about.mail = "Wsparcie techniczne";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";
// Link to the App Threads account
about.threads = "Threads";

// The user canceled an operation that was running
alert.aborted = "Operacja przerwana!";
// Empty mesh
alert.mirror.empty = "Pusty wynik!";
// Mesh already mirrored
alert.mirror.same = "Taki sam wynik!";
// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "Obiekt nie ma żadnych otworów!";
// No operation occured because the mesh is already manifold
alert.manifold.already = "Siatka jest już szczelna!";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "Bieżący obiekt jest niewidoczny!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Nie ma nic do przycięcia.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Przerwij przycinanie: obiekt jest w pełni przycięty.";
// In order to extract something, the mesh needs to have painted mask
alert.extract.none = "Nie ma nic do wyodrębnienia!";
// In order to split something, the mesh needs to have painted mask
alert.extract.split.none = "Nie ma nic do podziału!";
// List of disabled features when View Mode is selected
alert.view.disabled = "Funkcje wyłączone w trybie wyświetlania:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Widżety prymitywów";
// The object needs to have two parts disconnected
alert.separate.fail = "Nie można rozdzielić: obiekt ma tylko jedną część!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "Ponownie utworzono siatkę!";
alert.voxelRemesh.empty = "Przerwij ponowne tworzenie siatki: siatka wynikowa nie ma powierzchni.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "Nieprawidłowe dane wejściowe!";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "Obiekt zostanie zduplikowany";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "Zostanie utworzona instancja obiektu";
// A pivot refers the gizmo 3D position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Edytuj tryb punktu obrotu.";
alert.mask.full = "Maska = 100%!";
// A pivot refers the gizmo 3D position
alert.gizmo.editObject = "Edytuj tryb obiektu.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Aktywna topologia dynamiczna";
// See Glossary (DynTopo)
alert.dynamic.disable = "Wyłącz topologię dynamiczną";
alert.colorPicker = "Przeciągnij palcem po obiekcie, aby wybrać kolor.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Po prostu stuknij, aby opuścić tryb transformacji.";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "Prosty dotyk, aby wyjść z trybu edycji symetrii.";
// Show the painted mask on the mesh
alert.mask.show = "Pokaż maskę";
// Hide the painted mask on the mesh
alert.mask.hide = "Ukryj maskę";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Zablokuj zaznaczenie";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Odblokuj zaznaczenie";
// Hide the objects that are not selected
alert.selection.isolate = "Izoluj zaznaczenie";
// Show the objects that are hidden
alert.selection.showAll = "Pokaż wszystko";
// Project quick saving
alert.quickSave = "Zapisywanie...";
// Painting on the object was hidden but the user did paint the object
alert.forcePainting.fill = "Aktywowano wyświetlanie malowania, użyto [Maluj wszystko].";
// Painting on the object was hidden but the user started to paint on the object
alert.forcePainting.tool = "Aktywowano wyświetlanie malowania, obiekt został pomalowany.";
// See Glossary (Multiresolution)
alert.multiresLost = "Wielokrotna rozdzielczość zostanie utracona!";
// Boolean cut mode will ignore some features
alert.booleanIgnored = "Tryb Boolean zignoruje obszary maskowane lub ukryte!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "Wartość szczegółów jest wysoka i może wymagać dużej ilości pamięci!";
// Autosave popup
alert.autoSave.auto = "Automatyczny zapis za... $0s";
// The selected object doesn't have any layers
alert.needLayer = "Bieżące narzędzie wymaga aktywnej warstwy.";
// The user decided to hide the painting on the objects
alert.paintingHidden = "Malowanie ukryte!";
// The user decided to hide the masking on the objects
alert.maskingHidden = "Maska jest ukryta!";
// The user decided to display hidden faces
alert.hideIgnored = "Ukrycie jest ignorowane!";
// The selected object doesn't have any layers
alert.noPartialWireframe = "Częściowy rysunek jest wyłączony, gdy wyświetlany jest szkielet.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Rozważ użycie kamery ortograficznej, jeśli chcesz uniknąć zniekształcenia obszaru perspektywy podczas korzystania z projektora ekranowego.";
// Trial version has a limited number of undo
alert.state.trial = "Wersja próbna: anulowano cofanie";

background = "Tło";
// A flat color will be displayed in the background of the scene
background.color = "Kolor";
// 2 color with rotation
background.gradient = "Gradient";
// The environment (HDRI) will be displayed in the background
background.environment = "Środowisko";
background.blur = "Rozmycie";
background.exposure = "Ekspozycja";

// Image that the artist uses as a reference
background.imageEnable = "Obraz referencyjny";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Nakładka";
// Opposite of transparency (Alpha)
background.imageAlpha = "Krycie";
background.imageReset = "Resetuj ustawienia";
background.imageTransform = "Przekształcenie";
// X screen coordinate of the image reference
background.imageX = "Pozycja X";
// Y screen coordinate of the image reference
background.imageY = "Pozycja Y";
// Rotation of the reference image
background.imageRotation = "Obrót";
// Scale of the reference image
background.imageScale = "Skala";
// Auto adjust the reference when moving the camera
background.lock.image = "Synchronizuj z blokadą kamery";
background.lock.image.help = "Gdy kamera jest zablokowana z Snaphikiem, obraz referencyjny podąża za ruchem kamery.";
// When exiting camera lock
background.lock.exit = "Reset przy odblokowaniu:";
background.lock.exit.none = "Dostosuj kąt widzenia";
background.lock.exit.none.help = "Zachowaj obraz i kamerę bez zmian. 
Jeśli w perspektywie, dostosuj tylko pole widzenia.";
background.lock.exit.all = "Resetuj wszystkie";
background.lock.exit.all.help = "Zresetuj zarówno pozycję obrazu, jak i kamery.";
background.lock.exit.perspective = "Jeśli Perspektywa";
background.lock.exit.perspective.help = "Jeśli w perspektywie, zresetuj pozycję obrazu i kamery.";

// Blend: normal
blend.normal = "Normalna";
// Blend: darker
blend.darker = "Ciemniejsza";
blend.darker.darken = "Przyciemnij";
blend.darker.multiply = "Mnożenie";
blend.darker.linearBurn = "Spalanie liniowe";
blend.darker.colorBurn = "Spalanie kolorów";
// Blend: lighter
blend.lighter = "Jasniejszy";
blend.lighter.lighten = "Rozjaśnij";
blend.lighter.screen = "Raster";
blend.lighter.linearDodge = "Liniowe Omiijanie";
blend.lighter.colorDodge = "Omiń Kolor";
// Blend: contrast
blend.contrast = "Kontrast";
blend.contrast.hardLight = "Intensywne Światło";
blend.contrast.softLight = "Miękkie Światło";
blend.contrast.overlay = "Nakładka";
blend.contrast.hardMix = "Twarde Mieszanie";
blend.contrast.linearLight = "Liniowe Światło";
blend.contrast.vividLight = "Intensywne światło";
blend.contrast.average = "Średnia";
// Blend: inversion
blend.inversion = "Inwersja";
blend.inversion.exclusion = "Wyłączenie";
blend.inversion.difference = "Różnica";
// Blend: cancelation
blend.cancelation = "Anulowanie";
blend.cancelation.divide = "Podziel";
blend.cancelation.subtract = "Odejmij";
// Blend: component
blend.component = "Komponent";
blend.component.luminosity = "Luminancja";

// Camera (point of view in 3D)
camera = "Aparat";
cameras = "Aparaty";
camera.view = "Wyświetl";
// Copy the views
camera.updateView = "Zaktualizować punkt widoku?";
// Add a new camera
camera.addView = "Dodaj widok";
// Focus on the camera
camera.focus = "Ostrość";
// Add on the camera camera
camera.focusOn = "Ostrość na $0";
// Camera projection, Orthographic or Perspective
camera.projection = "Projekcja";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Ortograficzne";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Perspektywa";
// camera Vertical Field of View
camera.fov = "Pionowe pole widzenia";
// Camera Field of View hint
camera.focal = "ogniskowa $0 mm (matryca 35 mm)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Obrót";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "Obrotnica";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Trackball";
camera.rotation.trackball.help = "Trackball daje większy stopień swobody, można też obracać kamerą za pomocą 2 palców.";
// Camera interaction mode, 1st person view
camera.firstPerson = "Pierwsza osoba";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Szybkość";
// Camera rotation sensitivity
camera.speed.rotation = "Obrót";
// Camera translation sensitivity
camera.speed.panning = "Przesuwanie";
// Camera zooming sensitivity
camera.speed.zooming = "Powiększanie";
// Reset camera position
camera.resetView = "Resetuj widok";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Przyciągnij widok";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "Kamera jest wyrównana (ortograficznie)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "Wyrównanie ortograficzne";
camera.snapOrthographic.help = "Ta opcja działa także w przypadku użycia opcji Przyciągnij kostkę w narożniku.";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Punkt obrotu";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Stuknij dwukrotnie obiekt";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Stuknij dwukrotnie tło";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "Przełącz";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "Zaznaczenie";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "Scena";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "Zaktualizuj po podwójnym stuknięciu";
camera.doubleTapPivot.help = "Zaktualizuj punkt obrotu po dwukrotnym stuknięciu powierzchni obiektu.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "Punkt obrotu w powietrzu";
camera.airPivot.help = "Zezwól na nowy punkt obrotu nawet przy powiększaniu poza powierzchnię obiektu.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "Przy geście uruchomienia kamery";
camera.autoPivot.help = "Zaktualizuj punkt obrotu przy rozpoczynaniu interakcji z kamerą.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Ostrość";
camera.doubleTapFocus.help = "Po dwukrotnym stuknięciu obiektu kamera przesunie się i ustawi ostrość na wybranym punkcje.";
// Disable XY panning when unzomming
camera.centerZoomOut = "Wyśrodkuj widok podczas oddalania";
camera.panZoomOut.help = "Gdy ta opcja jest wyłączona, pozycja obrotu pozostanie niezmieniona.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "Wielokrotne zaznaczenie";
// There is 0 nodes/items selected
context.noSelection = "Brak zaznaczenia";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "Zestawienia";
// Quick curve x side shift
curve.shift = "Shift";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "Splajn";
curve.bspline = "Splajn";
curve.precision = "Dokładność";
// merge or collapse 1 point into another
curve.merge = "Scal";
// snap
curve.snap = "Przyciągnij";
curve.snap.offset = "Przesunięcie";
curve.snap.offset.help = "Wartość 100% jest równa promieniowi rury.";
curve.snap.surface = "Powierzchnia";
curve.snap.vertex = "Wierzchołek";
curve.snap.grid = "Siatka (jeśli przyciągnięta)";
// Regular spaced sampling
curve.uniform = "Jednolity";
curve.uniform.help = "Krzywa będzie próbkowana w regularnych odstępach, aby zapewnić jednolitą gęstość.

Możesz wyłączyć tę opcję, aby nieco kontrolować pętle krawędzi, dodając nowe punkty kontrolne na krzywej.";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "Wyświetl zanikanie w sposób symetryczny.

Ta opcja jest tylko wizualną wskazówką, nie wpływa na samo zanikanie";
curve.radius = "Promień";
curve.twist = "Skręt";
curve.spiral = "Spirala";
curve.spiral.twist = "Kąt skrętu";
curve.spiral.scale = "Skala";
curve.spiral.offset = "Przesunięcie";
curve.spiral.angle = "Przesunięcie kąta";
curve.pivot = "Pkt obrotu";
curve.pivot.self = "Krzywa";
curve.pivot.children = "Obiekty podrzędne";

// Set the desired FPS (frame per second, refresh rate)
debug.targetFps = "Docelowe FPS";
debug.targetFps.help = "Gdy wyłączone, wartość domyślna oznacza synchronizację z częstotliwością odświeżania wyświetlacza.";

// Warning about UVs (using extra memory)
debug.uvPrimitive.warning = "Wyłącz tę opcję, jeśli nie potrzebujesz UV (dodatkowa pamięć).";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "Normalizuj UV";
debug.uvNormalize.help = "Nomad będzie normalizować UV w kafelku [0-1].";

// Debug option, display an window with some debugging logs
debug.logs = "Dzienniki";
// Model shortcut window
debug.shortcut = "Okno skrótów";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Mapa wysokości";
// Debug options, graphical stuffs
debug.graphics = "Grafika";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Utwórz miniatury dla sklepu";

// Open file explorer
file.explore = "Eksploruj";
// Open file explorer
file.scope = "Zakres";
file.scope.internal = "Wewnętrzny";
file.scope.internal.help = "Domyślne zachowanie, takie samo jak na urządzeniach mobilnych. 
Projekty są zapisywane wyłącznie w głównym folderze Nomad.";
file.scope.external = "Na miejscu";
file.scope.external.help = "Podczas importowania projektu z zewnątrz, zapis nadpisze oryginalny plik.
Automatyczne zapisywanie nie jest obsługiwane dla projektów zewnętrznych.";
// Empty list: there is no projects
file.project.load = "Załaduj projekt przy uruchomieniu";
// Empty list: there is no projects
file.project.empty = "Nie zapisano jeszcze żadnego projektu!";
// The current opened project has some unsaved changes
file.project.unsaved = "Niezapisane zmiany!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "Utracisz niezapisane zmiany!";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Podgląd ostatniego zapisu ręcznego";

file.project = "Projekt";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Zachowaj";
// E.g: Save "my_project"?
file.project.save.confirm = "Zapisać $0?";
// Make a copy
file.project.saveAs = "Zapisz jako";
// Overwrite another project
file.project.overwrite = "Nadpisać";
// E.g: Overwrite "my_other_project"?
file.project.overwrite.confirm = "Nadpisać $0?";
// Open a project
file.project.open = "Otwórz";
// E.g: Open "my_project"?
file.project.open.confirm = "Otworzyć $0?";
// E.g: Clone "my_project"?
file.project.clone.confirm = "Klonować $0?";
// Load another project and add/append all its data to the current scene
file.project.add = "Dodaj do sceny";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "Dodać $0 do sceny?";
// Reset the scene and create a new project
file.project.new = "Nowy";
file.project.new.confirm = "Utworzyć nową scenę?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "Usunąć $0?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "Usunąć $0?

To jest bieżący aktywny projekt!";

// Auto save section
file.autoSave = "Automatyczny zapis";
file.autoSave.confirm = "Wyłączyć automatyczny zapis?";
file.autoSave.help = "Zapisuj regularnie projekt w oddzielnym pliku.

Plik automatycznego zapisu można znaleźć w:";
// Interval in minutes in which the auto save popup will appear
file.autoSave.popup = "Przekroczenie limitu czasu okienka wyskakującego";
// In minutes
file.autoSave.minutes = "Okno wyskakujące czasomierza";
// Delete the current autoSave data
file.autoSave.delete = "Odrzuć automatyczny zapis";
// Open the outdated auto save
file.autoSave.open.manual = "Otwórz przestarzały zapis ręczny";
file.autoSave.open.auto = "Otwórz przestarzały autozapis";

// color space (linear or srgb), do not translate linear/srgb if there is a doubt
file.colorSpace = "Przestrzeń kolorów";
file.colorSpace.help = "Spróbuj przełączyć tę opcję, jeśli kolory wydają się nieprawidłowe.";
file.colorSpace.linear = "Liniowy";
file.colorSpace.srgb = "sRGB";

// Configure imports option
file.importSettings = "Opcje importu";

// Load interface preference settings when opening a scene file
file.import.guiSettings = "Zachowaj ustawienia interfejsu GUI";
file.import.guiSettings.help = "Podczas otwierania lub importowania pliku projektu zostaną załadowane wszystkie ustawienia związane z interfejsem GUI, które są osadzone w projekcie.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.import.obj.splitByGroup = "Podziel OBJ według grup";
file.import.obj.splitByGroup.help = "Po włączeniu Nomad podzieli grupy OBJ na oddzielne obiekty.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.import.mergeLayers = "Scal warstwy";
// Ignore the textures present in the file to load
file.import.skipTextures = "Pomiń tekstury";
// Do not fiddle with the object topology when loading the file
file.import.keepTopology = "Zachowaj topologię";
file.import.keepTopology.help = "Użyj tej opcji, jeśli nie chcesz, by Nomad zmodyfikował topologię importowanej siatki.

Wyłączy ona zmianę kolejności wierzchołków/powierzchni, usuwanie duplikatów wierzchołków/powierzchni i usuwanie nieużywanych wierzchołków.";

// Import file section
file.import.title = "Importuj";
file.import.title.help = "Obsługiwany format:";
// The user imports a scene file that will replace the current scene
file.import.open = "Otwórz";
file.import.open.confirm = "Zaimportować nowy plik?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Dodaj do sceny";
file.import.add.confirm = "Zaimportować nowy plik?";

// Export scene file
file.export = "Eksportuj";

// Filter nodes that we want to export
file.select.include = "Dołącz";
file.select.all = "Wszystkie";
file.select.visible = "Widoczne";
file.select.selected = "Wybrane";
file.select.unselected = "Nie zaznaczony";

// Export each node in a separate file
file.export.separate = "Jeden plik na obiekt";

// Export the current selected objects instead of the entire scene
file.onlySelection = "Dołącz tylko zaznaczone obiekty";
file.onlySelection.help = "Dołącz tylko zaznaczenie, a nie całą scenę.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Rekonstruuj czworokąty";
file.convertToQuad.help = "Rekonstruuj czworokąty z trójkątów poprzez parowanie trójkątów (jeśli są sąsiadujące w plikach).";
// ----------------------------------------------
// Whether we include the textures in the exported file
file.export.texture = "Tekstury";
// Baking means transfering/converting
file.export.texture.help = "Ta opcja nie zapisuje kolorów wierzchołków w teksturach.";
// ----------------------------------------------
file.export.color0 = "Kolory wierzchołków";
file.export.color1 = "Malowanie PBR";
file.export.color1.help = "Eksportuj chropowatość, metaliczność i malowanie masek. Będzie to ignorowane przez inne programy.";
// ----------------------------------------------
// Whether we include normals vector in the exported file
file.export.normal = "Normalne";
file.export.normal.help = "Zaznacz tę opcję, jeśli chcesz otworzyć plik w innym programie.

Nomad zawsze ignoruje normale, ponieważ będzie je ponownie obliczać.";
// ----------------------------------------------
file.export.tangent = "Styczne";
file.export.tangent.help = "Zaznacz tę opcję, jeśli chcesz otworzyć plik w innym programie.

Styczne są używane tylko jeśli model posiada mapę normalną.

Nomad zawsze ignoruje styczne, ponieważ będzie je ponownie obliczać.";
// ----------------------------------------------
file.export.nomad.help = "Wewnętrzny format pliku Nomad Sculpt.

Ten format nie będzie się ładował w innych oprogramowaniach, jest głównie do celów ponownego importu.";
// ----------------------------------------------
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Warstwy";
file.export.gltf.layer.help = "Eksportuj warstwy jako morfy. Oficjalnie obsługiwane przez glTF więc powinno to działać również w innych programach.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Malowanie warstwy";
file.export.gltf.layerPaint.help = "Eksportuj malowanie warstwy. Zwykle jest to ignorowane przez inne programy.";
// ----------------------------------------------
file.export.obj.warning = "Warstwy i dodatkowe malowanie (chropowatość, metaliczność i maski) zostaną utracone.";
// Whether we include the vertex color in the exported file
file.export.obj.color = "Kolory wierzchołków";
file.export.obj.color.help = "Niektóre programy 3D będą w stanie to odczytać, ale nie wszystkie.";
file.export.obj.color.help.append = "Dodaj informacje o kolorze po wierzchołkach.";
file.export.obj.color.help.hexa = "Alternatywny sposób kodowania koloru. Obsługuje również dane maski.";
file.export.obj.faceGroup = "Grupa powierzchni";
file.export.obj.object = "Zapisz obiekty";
file.export.obj.object.help = "Zachowaj oddzielne obiekty.

Wyłączenie tej opcji spowoduje eksport wszystkiego jako pojedynczej jednostki.
Musisz wyłączyć tę opcję, jeśli chcesz użyć funkcji 'Mesh ID / Polygroup' w Substance Painter.";
file.export.obj.archive = "Typ";
file.export.obj.archive.folder = "Folder";
file.export.obj.archive.zip = "Zip";
file.export.obj.archive.help = "Niektóre aplikacje (Google Drive, One Drive itp.) nie obsługują importu folderów, dlatego możesz użyć zamiast tego Zipa.";
// ----------------------------------------------
file.export.ply.warning = "Warstwy i dodatkowe malowanie (chropowatość, metaliczność i maski) zostaną utracone.";
// ----------------------------------------------
file.export.stl.warning = "Warstwy i dodatkowe malowanie (chropowatość, metaliczność i maski) zostaną utracone.";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Kolory wierzchołków";
file.export.stl.color.help = "Niektóre programy 3D będą w stanie to odczytać, ale nie wszystkie.";
// ----------------------------------------------
file.export.usd.skew = "Zezwalaj na warpowanie";
file.export.usd.skew.help = "Zezwalaj na warpowanie w przekształceniach macierzowych.

Gdy wyłączone, Nomad podzieli macierze warpowania na dwa oddzielne przekształcenia skalujące i obrotowe.";
// ----------------------------------------------
// Advanced settings
settings.advanced = "Zaawansowane";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "Te opcje nie są zapisywane w ustawieniach.";
settings.reset.title = "Ustawienia";
settings.reset.title.help = "Spowoduje to zresetowanie ustawień preferencji aplikacji.

Niektóre zasoby są zapisywane osobno i NIE zostaną zresetowane; obejmuje to:
• Projekty
• Powiązania klawiszy
• Ustawienia domyśłne narzędzi
• Środowiska HDR
• MatCap
• Alfa
• Tekstury (pędzel)
• Obrazy referencyjne

Należy pamiętać, że wszystko, co jest związane z projektem, zostanie zachowane w nienaruszonym stanie, np. oświetlenie, postprocessing i widoki kamery.";

// Reset preference settings button
settings.reset = "Przywróć domyślne";
settings.reset.confirm = "Zresetować ustawienia preferencji?";

// Render a screenshot of the scene
file.render = "Renderuj";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Pokaż interfejs";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Współczynnik renderowania";
file.render.renderRatio.help = "Wartość 1,0 oznacza, że Nomad będzie renderować z tą samą rozdzielczością co żądany rozmiar obrazu poniżej.

Użyj tej opcji, jeśli nie można renderować w określonej rozdzielczości (awarie ze względu na brak pamięci).";
// Desired size of the exported screenshot
file.render.size = "Końcowy rozmiar";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Niestandardowy";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "Raster";
// width of exported screenshot
file.render.width = "Szerokość";
// height of exported screenshot
file.render.height = "Wysokość";
// export screenshot of the scene
file.render.warn = "Rozdzielczość eksportu jest wysoka ($0x$1)!

Pamiętaj, aby zapisać projekt na wypadek, gdyby w urządzeniu zabrakło pamięci VRAM i nastąpiła awaria.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Przezroczyste tło";
file.render.transparent.help = "Ta opcja może być przydatna, jeśli chcesz wstawić siatkę do programu do tworzenia 2D.

Częściowa przezroczystość obiektu nie jest na razie obsługiwana.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Użyj ustawień globalnych";
pressure.useGlobal.help = "Domyślnie narzędzia mają takie same ustawienia nacisku.

Usuń zaznaczenie tej opcji, jeśli chcesz uzyskać określone ustawienia nacisku dla tego narzędzia.";

// Pencil pressure
pressure.title = "Nacisk";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "To narzędzie nie używa nacisku ołówka.";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "Typ przechwytywania pociągnięć będzie ignorować ustawienia nacisku.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Promień";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Intensywność";
// Average pencil pressure event to get smoother result
pressure.average = "Wygładzanie nacisku";
pressure.average.help = "Uśredniaj zdarzenia nacisku ołówka dla uzyskania gładszego rezultatu.";
// Limit pressure to 100%
pressure.limit = "Ogranicz ciśnienie do 100%";
pressure.limit.help = "To jest ustawienie globalne.

Skorzystaj z tej opcji, aby upewnić się, że nacisk rysika nigdy nie przekracza 100%.";

// list of inputs allowing camera interaction
gesture.camera = "Aparat";
// list of inputs allowing sculpting interaction
gesture.sculpt = "Rzeźbienie";
// Select object
gesture.select = "Wybierz obiekt";
// Finger/Touch input
gesture.finger = "Palec";
// Stylus/Pencil
gesture.stylus = "Piórko";
// Mouse/Trackpad
gesture.mouse = "Mysz";

gesture.wheel = "Kółko myszy";
gesture.wheel.speed3d = "Prędkość (3d zoom)";
gesture.wheel.speed2d = "Prędkość (interfejs 2d)";

// long press to pick the color/material under the cursor
gesture.dropper = "Wybór materiału";
gesture.dropper.help = "Selektor kolorów/materiałów można wyzwolić przez długie naciśnięcie na obszarze roboczym.

Działa to tylko wtedy, gdy dla bieżącego pędzla jest włączone malowanie.";

camera.airStroke = "Zezwól na ruch w powietrzu";
camera.airStroke.help = "Zezwól na rozpoczęcie modelowania, nawet jeśli początkowy kursor pominie siatkę.

Ta opcja jest aktywna tylko dla wejść z włączonym modelowaniem i wyłączoną kamerą.";

// Three fingers on screen
gesture.three.title = "Trzy palce";
gesture.three.light = "Obróć oświetlenie";
gesture.three.light.help = "Obrócić środowisko, światła i MatCap.";
gesture.three.radius = "Promień narzędzia";
gesture.three.intensity = "Intensywność narzędzia";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.finger.smooth = "Palec zawsze wygładza";
gesture.finger.smooth.help = "Ta opcja jest aktywna tylko, gdy aktywne jest narzędzie do rzeźbienia.";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Zezwól na nierozpoznany nacisk";
gesture.unknownPressure.help = "Zaznacz tę opcję, jeśli nacisk nie działa z Twoim ołówkiem lub jeśli potrzebujesz palca do nacisku.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Przycisk ołówka";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Dwukrotne stuknięcie ołówkiem";
gesture.pencilAction.ios.help = "Aktywny tylko dla rysika Apple Pencil 2. generacji.";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "Brak";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Dodaj/odejmij";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "Skróty jednym stuknięciem";
gesture.mask.oneTap.help = "Zezwól na skrót Maska poprzez jednokrotne stuknięcie ekranu, bez konieczności przytrzymania skrótu przycisku Maska.

Umożliwia to następujące gesty:
• stuknięcie tła w celu odwrócenia maski
• stuknięcie zamaskowanego obszaru w celu rozmycia maski
• stuknięcie niezamaskowanego obszaru w celu wyostrzenia maski";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.holdStroke = "Pociągnięcie";
gesture.mask.holdStroke.help = "Długie naciśnięcie przełącza między Mask a SelMask i rozpoczyna nowy ruch.

Po zakończeniu ruchu wybierane jest poprzednie narzędzie.";
gesture.mask.holdIdle = "Narzędzie";
gesture.mask.holdIdle.help = "Długie naciśnięcie i zwolnienie bez poruszania się, aby przełączyć między Mask a SelMask.";

// Shortcut customization, choose the action that the shortcut will performan (select tool, etc)
gesture.shortcut = "Skrót";

// Shortcuts to undo/redo
gesture.history = "Skróty historii";
gesture.history.help = "• Cofnij: stuknięcie 2 palcami
• Ponów: stuknięcie 3 palcami";
gesture.history.hold = "Naciśnięcie i przytrzymanie";
gesture.history.hold.help = "Naciśnięcie i przytrzymanie 2/3 palcami (w sposób ciągły).";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Odrzucenie przypadkowego dotknięcia nadgarstkiem";
gesture.palmRejection.confirm = "Pamiętaj, aby wyłączyć tę opcję, jeśli masz trudności z interakcją z obszarem roboczym!";
gesture.palmRejection.help = "Odrzuć wprowadzanie, jeśli rozmiar obszaru kontaktu jest większy niż ta wartość.

Może nie działać na każdym urządzeniu.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Maks. próg rozmiaru";

// Smoothing strategy
extract.polish.all = "Wszystkie";
extract.polish.sharp = "Ostre brzegi";
extract.polish.border = "Tylko brzegi";
// Smooth the border in a way that it matches completely with its dual
extract.polish.syncBorder = "Synchronizuj brzeg";
// topology of extracted mesh
extract.edgeLoop = "Pętla krawędziowa (bok)";
extract.edgeLoop.auto = "Automatyczna pętla krawędziowa";
extract.edgeLoop.division = "Podział";
// The thickness of the extracted mesh (from the painted mask)
extract.thickness = "Grubość";
// Carve the mask into the surface
extract.carve = "Wyryj";
// Extract a new mesh from the painted mask
extract = "Wyodrębnij";
// Preview extract
extract.preview = "Podgląd";
// Extract two new mesh from the painted mask and from the unmasked area
extract.split = "Podziel";
// How should we close the topology of the extracted object
extract.action = "Działanie zamykania:";
extract.action.help = "• Brak
Po prostu wyodrębnij część i pozostaw otwartą wyodrębnioną część.

• Wypełnij
Otwór zostanie wypełniony i wygładzony.
Nie używaj tej opcji dla płaskich powierzchni.

• Powłoka
Zamknij wyodrębniony kształt za pomocą wartości grubości.

• Warstwa
Wyodrębnij różnicę warstw (tylko podmenu warstwy).";
// Do not close the mesh (leave it open)
extract.action.none = "Brak";
// Close the mesh with a hole-filling algorithm
extract.action.fill = "Wypełnienie";
// Close the mesh by adding a thickness on the surface
extract.action.shell = "Powłoka";
// Close the mesh by using the layer data as a difference thickness
extract.action.layer = "Warstwa";

// uv part of revolution surface
genus.main = "Główna";
genus.hole = "Otwór";
genus.bottom = "Dół";
genus.top = "Góra";

// History, list of undo/redo
history = "Historia";
// First "undo" state
history.root = "Początek";
history.undoConfirm = "Czy potwierdzasz cofnięcie wszystkich tych operacji?";
history.undoWarning = "Jeśli dokonasz później zmiany, możesz utracić wiele zmian.";
// Settings concerning the history stack of undo/redo
history.stack = "Stos";
// Actions to include in the undo/redo stack
history.include = "Dołącz działania";
// include lighting editing in the undo/redo
history.includeLights = "Światła";
history.includeLights.help = "Jeśli ta opcja jest wyłączona, przesuwanie świateł za pomocą Gizmo nadal będzie uwzględniane, ponieważ może mieć wpływ na inne obiekty w hierarchii sceny.";
// include postProcess editing in the undo/redo
history.includePostProcess = "Postprocessing";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCap i HDRI";
// Can limit the stack of undo/redo size
history.limitSize = "Limit historii";
history.limitSize.help = "Maksymalny rozmiar historii.

Historia zostanie zaktualizowana przy następnej zarejestrowanej operacji.";
// Limit the number of undo in the history stack
history.limitStack = "Limit stosu";
history.limitStack.help = "Maksymalna liczba operacji, którą aplikacja może zachować.

Historia zostanie zaktualizowana przy kolejnej zapisanej operacji.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Maks. liczba operacji do cofnięcia";
history.rangeProtect.help = "Jeśli zajdziesz daleko w historii, przed cofnięciem wielu operacji wyświetli się okno dialogowe potwierdzenia.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Przywróć kamerę";
history.restoreCamera.help = "Włącz tę opcję, aby przywrócić zapisany punkt widzenia kamery w przypadku cofnięcia/ponownego wykonania czynności.";
// Undo
history.undo = "Cofnij";
// Redo
history.redo = "Przywróć";
// Shown during undo
history.state.undo = "Cofnij: $0";
// Shown during redo
history.state.redo = "Ponów: $0";
// Shown during undo/redo
history.state.voxelRemesh = "Ponowne tworzenie siatki wokseli";
// Shown during undo/redo
history.state.surfaceRemesh = "Ponowne tworzenie siatki powierzchni";
// Shown during undo/redo
history.state.multiresLevel = "Zmiana rozdzielczości";

// Debugging/Inspect object material (view channel separately color, roughness, normal, uv, etc)
inspect = "Inspektor";
// Inspector but SHORT
inspect.short = "Inspekcja";
// Display the material channel on the background
inspect.onBackground = "Na tle";
// Display the material channel on the mesh
inspect.onMesh = "Na siatce";
// Show UV seams
inspect.seams = "Szwy";

// Interface customization
interface = "Interfejs";

// Resize window (should be short)
interface.resize = "Zmień rozmiar";

// UI customization: one item row will stands on one line (synonym: Inlined)
interface.compact = "UI: Kompaktowe";

// UI customization: each row of the list will be bigger
interface.expandList = "Interfejs użytkownika: rozwiń listę";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Po prostu opcja interfejsu użytkownika do łatwiejszego zarządzania listą.";

// Add shortcuts buttons to the bottom of the screen
interface.shortcut.bottom = "Dodaj skróty (u dołu)...";
// Floating window
interface.shortcut.float = "Dodaj skróty (okno)...";

// Interface option (main base color)
interface.colorBase = "Podstawa kolorystyczna";
// Interface option (accent widget color)
interface.colorSelect = "Widżet kolorów";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Przezroczysty panel";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Siła rozmycia";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Panel kolorów";

// Interface color style
interface.preset.title = "Ustawienia wstępne";

// Reset interface settings
interface.resetAll = "Zresetuj styl";
interface.resetAll.confirm = "Zresetować ustawienia interfejsu?";
// help popup when hovering
interface.hoverHelp = "Okienko pomocy po najechaniu kursorem";
// Interface option (main base color)
interface.iconSupport = "Przycisk wysokiego kontrastu";
interface.iconSupport.help = "Alternatywny styl dla przycisków, który sprawia, że są one bardziej widoczne, gdy są aktywne.

Jeśli ustawione na Auto, Nomad będzie używał tego trybu, gdy kontrast kolorów UI między włączonym/wyłączonym jest niski.";
// Interface customization
interface.flipTop = "Dubluj górny pasek";
// Interface customization
interface.flipBottom = "Dubluj dolny pasek";
// Interface customization
interface.flipMiddle = "Dubluj paski boczne";
// list of tools
interface.toolbox = "przybornik";
// hide toolbox by default
interface.toolbox.hide = "Ukryj";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.columns = "liczbą kolumn";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.rows = "Rzędy";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Zresetuj kolejność";
// Colored text and icon
interface.toolbox.color = "Kolorowy";
// Top bar
interface.top.title = "Górny pasek";
interface.top.responsive = "Responsywność";
interface.top.responsive.help = "Ta opcja jest zazwyczaj istotna dla małych ekranów.";
interface.top.responsive.multiline = "Wiele linii";
interface.top.responsive.scroll = "Przewiń";
interface.top.responsive.collapse = "Zwiń";
interface.top.alt = "Alternatywna kolejność";
interface.top.alt.help = "Alternatywna ikona kolejności dla górnego menu.

Menu związane z edycją siatki są głównie po przeciwnej stronie menu sceny, co może pomóc w edycji sceny.";
// Scale the interface
interface.scale = "Ogólna skala";
// Spacing between widgets
interface.cursorStep = "Odstęp pionowy";
// Width of the interface panels
interface.panelWidth = "Szerokość panelu";
// Size of fonts
interface.fontScale = "Skala czcionki";
// Inset
interface.inset.title = "Przesunięcia krawędzi";
interface.inset.title.help = "Możesz zmienić te wartości, tylko jeśli masz problemy z interakcją z przyciskami na krawędziach ekranu..

Jeśli suwak jest wyłączony, Nomad będzie używać wartości bezpiecznego obszaru zwracanych przez samo urządzenie.";

// (see Glossary for Layer)
layer = "Warstwa";
layers.syncTransform = "Synchronizuj transformację";
layers.syncTransform.help = "If enabled, all the unselected layers will be adjusted depending on the transform rotation, scale and skew.

Disable this option if the other layers are meant to be used without the new transform that you are applying.

When set on auto, only the visible layers will be adjusted.";
// (see Glossary for Layer)
layers.lock = "Zachowaj szczegóły warstwy górnej";
// (see Glossary for Layer)
layers.lock.yes = "Zablokować górne warstwy?";
// (see Glossary for Layer)
layers.lock.warning = "Podczas rzeźbienia deformacja pochodząca z górnych warstw będzie ignorowana.

Jednak szczegóły tych warstw będą nadal widoczne.

Opcja ta działa tylko wtedy, gdy górne warstwy mają szczegóły w stosunkowo małej skali.";
// (see Glossary for Layer)
layers.addLayer = "Dodaj warstwę";
// (see Glossary for Layer)
layer.factors = "Współczynniki kanału";
// (see Glossary for Layer)
layer.factor = "Współczynnik";
// (see Glossary for Layer)
layer.offset = "Przesunięcie";
// Layer blend mode
layer.blendMode = "Mieszanie";
// (see Glossary for Layer)
layer.base = "Podstawowa";
layer.base.nothing = "Nie ma nic do wyodrębnienia!";
layer.base.background = "Materiał tła";
layer.base.background.help = "Jeśli aktywne, zostaną wyodrębnione tylko te wartości materiału, które różnią się od materiału tła.";
// (see Glossary for Layer)
layers = "Warstwy";
layers.title = "Warstwy";
// (see Glossary for Layer)
layers.title.help = "Warstwy mogą rejestrować przesunięcia pozycji i malowanie; może to być przydatne dla nieliniowego przepływu pracy.
Na przykład podczas eksperymentowania z różnymi wyrazami twarzy bez polegania na stosie historii, aby cofnąć zmiany.

W przypadku danych malowania warstwy są sortowane w od góry do dołu, więc warstwy na górze będą maskować niższe.

Można wymazać część warstwy za pomocą narzędzia „Usuń warstwę”.";
layers.primitive = "Warstwy są niedostępne dla prymitywów.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "Brak";

light = "Światło";
lights = "Światła";
// Intensity of light
light.intensity = "Intensywność";
// Color of light
light.color = "Kolor";
// Kelvin (the temperature unit)
light.kelvin = "Kelwin";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "Temperatura";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Połączenie";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Stałe";
// The light will move along the camera
light.attachment.camera = "Aparat";
light.attachment.help = "• Stałe
Orientacja światła nie będzie się zmieniać.

• Kamera
Orientacja światła będzie zależna od widoku kamery.";
// Light type (directional, spot, point)
light.type = "Typ";
// Directional light (synonym: sun light)
light.type.directional = "Kierunkowe";
light.type.sun = "Słońce";
// Directional light (synonym: sun light)
light.type.environment = "Środowisko";
light.type.hdri = "HDRI";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Punktowe";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Wielokierunkowe";
// For directional light (angle jitter)
light.angle = "Kąt";
// For point/spot light (offset jitter)
light.size = "Rozmiar";
// Cone angle for spot angles
light.spot.angle = "Kąt stożkowy";
// Softness of the spot light
light.spot.softness = "Miękkość";
// Position of the light
light.position = "Pozycja";
// Enable or disable shadows for a light
light.shadow.cast = "Cień";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "Światło wielokierunkowe obsługuje tylko cienie w przestrzeni ekranu.";
light.shadow.type = "Typ cienia";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "Mapa cieni";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "Przestrzeń ekranu";
light.shadow.type.screenspace.help = "Funkcja eksperymentalna, która może zostać usunięta w przyszłym wydaniu.

Ta opcja jest przeznaczona do użycia z funkcją miękkości cienia.";
// Adjustment to fix artefacts
light.shadow.bias = "Odchylenie";
// How blurry the shadow is
light.shadow.softness = "Miękkość";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "Kontaktowe";
light.contact.help = "Jeśli wybrano opcję automatyczną, tylko najbardziej dominujące światło będzie miało cień kontaktowy.";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "Tolerancja";
// Activated the light
light.visible = "Pokaż";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Wyśrodkuj";

// Object's material
material = "Materiał";
// See glossary
material.pbrRoughnessMetalness.warning = "Opcje Chropowatość i Metaliczność wymagają trybu cieniowania PBR.";
// See glossary
material.pbrReflectance.warning = "Opcja Refleksyjność wymaga trybu cieniowania PBR.";
// See glossary
material.pbrRefraction.warning = "Opcja Refrakcja wymaga trybu cieniowania PBR.";
// See glossary
material.pbrSubsurface.warning = "Opcja Podpowierzchnia wymaga trybu cieniowania PBR.";
// Value that says how much light will change direction when hitting the surface
material.ior = "Indeks refrakcji";
// an object-level value that overrides the roughness interior/surface of the mesh
material.paintingOverride = "Zastąp malowanie";
// The roughness in the inside is turbidity
material.paintingOverride.help = "Chropowatość jest stosowana dwa razy – dla powierzchni i dla wnętrza.

Jednak istnieje tylko jedna chropowatość, którą można pomalować, więc obie chropowatości mają te same wartości.";
// Glossiness is simply the opposite of roughness
material.refraction.surface = "Powierzchni";
// Synonym: turbidity
material.refraction.interior = "Wnętrza";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Malowanie błyszczące";
material.paintGlossy.help = "Spowoduje to pomalowanie obiektu z chropowatością i metalicznością równą 0, co pozwoli na ostre załamanie światła.

Działa to identycznie jak wejście do menu malowania i użycie funkcji Maluj wszystko z wyłączonym kolorem.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Pochłanianie";
material.absorptionEnable.help = "Symuluj pochłanianie światła podczas jego przechodzenia przez objętość.

Cienkie części będą jasne, ponieważ przepuszczają więcej światła, podczas gdy grube obszary będą ciemniejsze.

Efekt w dużym stopniu zależy od kształtu obiektu, używane jest tylko przybliżenie grubości obiektu.";
material.absorptionFactor = "Współczynnik";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "Głębia";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "Przezroczystość";
material.translucency.help = "Aby zobaczyć przezroczystość, musisz mieć światło, które rzuca cienie.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Krycie";
// Fully opaque material
material.type.opaque = "Nieprzezroczysty";
material.type.opaque.help = "To jest domyślny typ materiału.

Przezroczystość pomalowanego wierzchołka, tekstura nieprzezroczystości lub kanał alfa w kanale kolorów będą nadal uwzględniane przez dithering.

Tylko główny suwak nieprzezroczystości zostanie zignorowany.";
// Fully opaque material
material.type.shadowCatcher = "Łapacz cienia";
material.type.shadowCatcher.help = "Spraw, aby obiekt był całkowicie przezroczysty, z wyjątkiem cieni rzuconutych przez światła.

Ten tryb jest zwykle używany na geometrii płaszczyzn.";
material.type.shadowCatcher.warning = "Nie ma żadnych świateł z cieniami w twojej scenie, Rzucacz Cieni będzie nieaktywny.

W przeciwnym razie, jeśli catcher cieni jest w pełni metaliczny, Catcher Cieni może odbijać scenę, jeśli Post Process SSR (Odbicie) jest włączony.";
// See glossary
material.type.subsurface = "Podpowierzchnia";
material.type.subsurface.help = "Aby uzyskać najlepszy efekt, możesz przełączyć się na tryb cieniowania PBR i użyć przynajmniej jednego światła kierunkowego, najlepiej z przyciemnionym otoczeniem.";
// Transparency mode, alpha blendingd
material.type.blending = "Mieszanie";
material.type.blending.help = "Spraw, by obiekt był półprzezroczysty, zmieniając wartość krycia.

Zauważ, że ze względu na ograniczenia czasu rzeczywistego mogą pojawiać się zauważalne artefakty wizualne, jeśli twój obiekt ma złożony kształt.";
// Transparency mode
material.type.additive = "Addytywny";
material.type.additive.help = "Spraw, by obiekt był półprzezroczysty, zmieniając wartość krycia.

Ta metoda powoduje mniej artefaktów niż metoda Mieszanie, ale obiekt będzie jaśniejszy.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Dithering";
material.type.dithering.help = "Spraw, by obiekt był półprzezroczysty, odrzucając losowo niektóre piksele.";
// Simulate glass-like material
material.type.refraction = "Refrakcja";
material.type.refraction.help = "Tryb ten może być używany do symulacji szklanego materiału.

Ze względu na ograniczenia czasu rzeczywistego, autorefrakcja lub refrakcja wielowarstwowa jest ograniczona.";
material.castShadows = "Rzucanie cieni";
material.receiveShadows = "Przyjmowanie cieni";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Zawsze nieoświetlone";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Ignorowanie odwróconych";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Refleksyjność";
material.reflectance.help = "Kontroluj wielkość odbicia, jaką otrzyma materiał dla materiałów niemetalicznych.

Przez większość czasu należy używać wartości domyślnej (co odpowiada standardowej wartości 4% odbitego światła pod normalnym kątem).";
// Material preview in the viewport
material.preview = "Podgląd koloru materiału";
material.preview.help = "When you modify a material, a preview will be displayed in the viewport on the selected object.

The preview is shown while you interact with the color, roughness, metalness, opacity and intensity sliders.";
// Menu name
menu.files = "Pliki";
// Menu name
menu.scene = "Scena";
// Menu name
menu.multires = "Wielokrotna rozdzielczość";
// Menu name
menu.voxel = "Woksel";
// Menu name
menu.dynamic = "DynTopo";
// Menu name (Synonym: Misc, Other)
menu.topology = "Różne";
// Menu name
menu.primitive = "Prymityw";
// Menu name
menu.render = "Renderuj";
// Menu name
menu.material = "Materiał";
// Menu name
menu.postprocess = "Postprocessing";
// Menu name
menu.camera = "Aparat";
// Menu name
menu.background = "Tło";
// Menu name
menu.tool = "Narzędzie";
// Menu name
menu.stroke = "Pociągnięcie";
// Menu name
menu.alpha = "Alfa";
// Menu name
menu.filter = "Filtr";
// Menu name
menu.falloff = "Zanikanie";
// Menu name
menu.paint = "Farba";
// Menu name
menu.symmetry = "Symetria";
// Menu name
menu.operation = "Operacja";
// Menu name (pencil pressure)
menu.pressure = "Nacisk";
// Menu name
menu.gesture = "Gest";
// Menu name
menu.layers = "Warstwy";
// Menu name
menu.settings = "Ustawienia";
// Menu name
menu.interface = "Interfejs";
// Menu name
menu.bindings = "Powiązania";
// Menu name
menu.history = "Historia";
// Menu name
menu.historySettings = "Ustawienia";
// Menu name
menu.about = "Informacje";
// Menu name
menu.debug = "Debuguj";

// Operation on the object (action)
mesh.holes = "Otwory";
// If the object has holes, the algorithm will close them
mesh.holes.close = "Zamknij otwory";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holes.detail = "Szczegół";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Rozdziel";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "Warstwy, malowanie i wielokrotna rozdzielczość zostaną utracone.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Rozdzielczość";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Wymuś formę sześcienną";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Konwertuj";
// Static object means "static topology"
mesh.static = "Siatka";
// See glossary
mesh.multires = "Wielokrotna rozdzielczość";
// Dynamic topology
mesh.dynamic = "DynTopo";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Materiał globalny";
paint.useGlobal.help = "Jeśli ta opcja jest włączona, wybrany materiał będzie taki sam jak inne narzędzia.

Uwzględnia ona tylko ustawienia chropowatości, metaliczności i koloru.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Malowanie pociągnięciami";
// If true save the textures data into
paint.preset.embed = "Osadź tekstury";
paint.preset.embed.help = "The textures can be found in the Nomad textures/ folder.
The material presets can be found in the Nomad materials/ folder.

When this option is off, the material preset only reference the texture inside the textures/ folder.

You can enable this option to make a copy of the textures inside the material preset.
It can be useful if you want to share a textured preset without providing the associated textures.";
paint.preset.embed.apply = "Apply to all materials";
// Factor/Opacity of paint tool
paint.intensity = "Intensywność farby";
// Apply the paint on the object
paint.paintAll = "Maluj wszystko";
paint.paintAll.help = "Zastosuj bieżący materiał do obiektu.";
paint.paintAll.help.mask = "Obszar zamaskowany nie będzie dotknięty.";
paint.paintAll.help.hide = "Ukryty obszar nie będzie dotknięty.";
paint.paintAll.help.opacity = "Użyj powyższego współczynnika malowania narzędziem.";
paint.paintAll.help.layer = "Niepomalowana obszar warstwy nie będzie dotknięty.";
paint.strokePainting.title = "Malarskie";
// Brush stroke texture
paint.texture.warningEnable = "Malowanie pociągnięciami musi być włączone, aby umożliwić rzutowanie tekstur (pole wyboru na górze)!";
paint.texture.warningIgnored = "Bieżące narzędzie nie może używać tekstur!";
// use stencil mode
paint.stencil = "Szablon";
// Inherit stroke falloff option for the painting
paint.tool.help = "Użyj narzędzia alpha, zanikania i randomizatora, aby modulować intensywność pociągnięcia pędzla.

Te opcje są ignorowane dla funkcji malowania całościowego, ale alpha jest uwzględnione dla wariantu triplanar.";
// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "Nowa nazwa";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "Nowa wartość";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "Nowy kolor (format szesnastkowy)";

// Post process effect
postprocess = "Postprocessing";
// Denoise
postprocess.denoise = "Denoiser";
postprocess.denoise.help = "Zastosuj proces redukcji szumu po zsumowaniu wszystkich klatek.";
postprocess.denoise.warning = "To operacja o wysokim koszcie obliczeniowym, włącz ten efekt tylko, jeśli obraz jest zaszumiony.";
// Quality vs performance
postprocess.quality = "Jakość";
postprocess.quality.help = "Aktywuj te opcje, aby poprawić jakość kosztem wydajności.";
// More samples means better quality but slower performance
postprocess.maxSamples = "Maks. liczba próbek";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Pełna rozdzielczość";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "Maks. próbkowanie klatek";
postprocess.accumulateCount.help = "Maksymalna liczba klatek do akumulacji przed zatrzymaniem renderowania.

Kiedy renderowanie się zatrzyma, Nomad nie będzie nic robić, oszczędzając w ten sposób baterię.

Wiele funkcji renderingu korzysta z akumulacji klatek, w szczególności:
• Miękkie cienie
• Globalne oświetlenie
• Odbicie (SSR)
• Okluzja otoczenia
• Podpowierzchnia
• Głębia pola

Duża liczba klatek na sekundę jest niezbędna dla miękkich cieni i globalnego oświetlenia.
Nomad może zatrzymać renderowanie szybciej, jeśli wymienione powyżej funkcje są wyłączone.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Rozdzielczość renderowania";
postprocess.renderRatio.warning = "Zastąpione przez efekt Pixel Art.";
postprocess.renderRatio.help = "Ta opcja ma duży wpływ na wydajność.
Zaleca się zachowanie wartości niższej niż x1,25.

Ta opcja nie jest zapisywana w ustawieniach.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "Antyaliasing (TAA)";
postprocess.taa.help = "Redukuje migotanie podczas poruszania kamerą.";
// Ditherhing pixel
postprocess.dithering = "Dithering";
postprocess.dithering.help = "Rozmyj piksele, aby zredukować artefakty pasmowania.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "Odbicie (SSR)";
postprocess.ssr.warning = "Opcja SSR wymaga trybu cieniowania PBR.";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "Globalne oświetlenie (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "Tolerancja";
postprocess.ssgi.warning = "Opcja SSGI wymaga trybu cieniowania PBR.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "Okluzja otoczenia";
// How far the effect spreads
postprocess.ssao.radius = "Rozmiar";
// How strong the effect is
postprocess.ssao.factor = "Siła";
// Adjustment to fix artefacts
postprocess.ssao.bias = "Odchylenie krzywizny";
postprocess.ssao.bias.help = "Czułość efektu zależy od krzywizny powierzchni.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "Głębia pola";
// The blur factor behind the focused point
postprocess.dof.blurFar = "Dalekie rozmycie";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "Bliskie rozmycie";
postprocess.dof.focusTip = "Stuknij obiekt, aby zmienić punkt ostrości.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "Rozświetlenie";
// Intensity of the effect
postprocess.bloom.intensity = "Intensywność";
// How far the effect spreads
postprocess.bloom.radius = "Promień";
postprocess.bloom.radius.help = "Zakres efektu cieniowania.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "Próg";
postprocess.bloom.threshold.help = "Próg jasności, który decyduje o tym, czy piksel będzie emitować cieniowanie czy nie.
Jeśli wartość jest równa 0, cieniowanie będzie stosowane do wszystkiego.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "Mapowanie odcienia";
postprocess.tone.exposure = "Ekspozycja";
postprocess.tone.contrast = "Kontrast";
postprocess.tone.saturation = "Nasycenie";
postprocess.tone.hue = "Odcień";
// No tonemapping operator is used
postprocess.tone.mapping.none = "Brak";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "Neutralne";
// Color curves
postprocess.curve = "Gradacja kolorów";
// Curve for pixel luminance
postprocess.curve.luminance = "Główna";
postprocess.curve.red = "Czerwony";
postprocess.curve.green = "Zielony";
postprocess.curve.blue = "Niebieski";
// Reset color grading curves
postprocess.curve.resetAll = "Resetuj wszystkie";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "Aberracja chromatyczna";
postprocess.chromatic.factor = "Siła";
// Darking on the edges
postprocess.vignette = "Winieta";
// How far the effect spreads
postprocess.vignette.size = "Rozmiar";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "Twardość";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "Ostrość";
postprocess.sharpness.factor = "Siła";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "Tekstura";
postprocess.grain.factor = "Siła";
// Accentuate the edges of the model
postprocess.curvature = "Krzywizna";
// main strength of curvatre
postprocess.curvature.factor = "Współczynnik";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "Wgłębienie";
// Color/Strength of convex curvature
postprocess.curvature.bump = "Wypukłość";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "Pixel Art";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "Zezwól na próbkowanie klatek";
// Simulate scanline rendering (horizontal line)
postprocess.scanline = "Linia skanowania";
postprocess.scanline.factor = "Współczynnik";
// Spacing between lines
postprocess.scanline.spacing = "Odstępy";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Prymityw";
primitive.box = "Równoległościan";
primitive.sphereCube = "Kula Sześcienna";
primitive.sphereUV = "Kula UV";
primitive.icosahedron = "Dwudziestościan";
primitive.cylinder = "Walec";
primitive.cone = "Stożek";
primitive.torus = "Torus";
primitive.lathe = "Bryła obrotowa";
primitive.tube = "Rura";
primitive.plane = "Płaszczyzna";
primitive.triplanar = "Trzypłaszczyznowy";
primitive.needValidate = "Prymitywy powinny być zweryfikowane!";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Edytuj";
primitive.edit.help = "Pozwól na edycję 3D w rzutni.

Możesz wyłączyć tę funkcję, jeśli chcesz prowadzić interakcję z Gizmo lub narzędziem Transformacja bez modyfikowania prymitywu.";

// Primitive configuration
primitive.mainConfig = "Parametr";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Topologia";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Geometria";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Zweryfikuj";
// Maximum number of faces of the primitives
primitive.maxFaces = "Maks. liczba powierzchni";
primitive.maxFaces.help = "Maksymalna liczba powierzchni, jaką może mieć prymityw.

Limit ten jest aktywny tylko wtedy, gdy prymityw nie jest zatwierdzony, potem to zabezpieczenie znika.";
// Synonym: Flat subdivision
primitive.linear = "Podział liniowy";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Podział następczy";

// Radius (of a sphere, torus, etc)
primitive.radius = "Promień";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radius.sync = "Ten sam promień";
primitive.radius.start = "Początek promienia";
primitive.radius.end = "Koniec promienia";
// Size (of cube x dimension)
primitive.size = "Rozmiar";
primitive.sizeX = "Rozmiar X";
primitive.sizeY = "Rozmiar Y";
primitive.sizeZ = "Rozmiar Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "Podział";
primitive.divisionX = "Podział X";
primitive.divisionY = "Podział Y";
primitive.divisionZ = "Podział Z";
// Angle of torus, etc
primitive.angleX = "Kąt X";
primitive.angleY = "Kąt Y";
primitive.angleZ = "Kąt Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Stała gęstość";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Rzutuj na kulę";
primitive.projectOnSphere.help = "Przyciąga punkty na idealnej kuli.";

// triplanar
primitive.triplanar.title = "Trzypłaszczyznowy";
primitive.triplanar.title.help = "Obiekt trójpłaszczyznowy używa informacji o masce z 3 płaszczyzn, aby wypełnić siatkę wokseli, która jest następnie przekształcana w wielokąty.

Jeśli wejdziesz w interakcję z suwakami podziału lub rozmiaru, informacje o malowaniu zostaną zresetowane (gładkość jest OK).

Prawdopodobnie należy wyłączyć symetrię, ponieważ może nie działać zgodnie z oczekiwaniami.

Możesz użyć opcji „Topologicznie połączony” w panelu maski, aby pomalować płaszczyznę wpływającą na inne płaszczyzny.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanar.sameSize = "Ten sam rozmiar (sześcian)";
primitive.triplanar.polish = "Gładkość";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanar.resetMask = "Resetuj maskę";
// One side of a cube (the back plane)
primitive.isolate.back = "Wstecz";
// One side of a cube (the right plane)
primitive.isolate.right = "Prawa";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Dolna";
// Plane
primitive.planeSameSize = "Ten sam rozmiar (kwadrat)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "Dysk";
// Box
primitive.boxRegular = "Ten sam rozmiar (sześcian)";
// Torus
primitive.torus.radiusOuter = "Zewnętrzny promień";
primitive.torus.radiusInner = "Wewnętrzny promień";
primitive.torus.angle = "Kąt";
primitive.torus.angleOffset = "Przesunięcie kąta";
// Cylinder
primitive.cylinder.height = "Wysokość";
// Cone
primitive.cone.radius = "Promień";
primitive.cone.height = "Wysokość";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Otwór";
// Make a hole in the primitive to make it hollow
primitive.hasHole = "Ma otwór";
// Curve profile (synonym: profile, curve)
primitive.profile = "Profil";
primitive.profile.viewport = "Pokaż w widoku";
// If the revolution surface has caps (E.g: cylinder)
primitive.cap = "Zakończenie";

// Singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "Powtarzacz";
// All the new items will be inserted inside the bound rather than outside
repeater.array.fitInside = "Dopasuj do wewnątrz";
// The object will follow the curve
repeater.curve.align = "Wyrównaj";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Importuj...";
// iOS Photos gallery
resource.import.ios.photos = "Zdjęcia";
// iOS Files App
resource.import.ios.files = "Pliki";

scene.title = "Scena";
scene.title.help = "Podczas korzystania z widocznych przycisków/przycisków zaznaczenia, przytrzymaj i przeciągnij palec, aby łatwo zaznaczyć inne obiekty.

Możesz również nacisnąć i przytrzymać widoczne przyciski/przyciski zaznaczenia, aby wpływać również na obiekty podrzędne.";
// The view will focus on the item when we click on it
scene.focus = "UI: Skup się na elemencie przy podwójnym stuknięciu";
// Add new object on gizmo position
scene.addOnGizmo = "Na manipulatorze";
scene.addOnGizmo.help = "Przenieś węzeł na pozycję manipulatora (jeśli wybrane jest narzędzie manipulatora)";
// Select the gizmo tool after adding a new object
scene.addSelectGizmo = "Wybierz manipulator";
scene.addSelectGizmo.help = "Wybierz narzędzie manipulatora podczas dodawania nowego węzła";
// Icon size in pixel (min/max)
scene.iconSize = "Rozmiar ikony";
// Min size of icon
scene.iconSize.min = "Min.";
// Max size of icon
scene.iconSize.max = "Max.";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "Linie hierarchii";
scene.showHierarchy.help = "Wyświetl linię między rodzicem a jego dziećmi w widoku.";
scene.showHierarchyNomadPivot = "Użyj pivot Nomad";
scene.showHierarchyNomadPivot.help = "Pivot Nomad to pivot używany przez narzędzia Transformacji i Manipulatora.

Jeśli ta opcja jest wyłączona, będzie używać naturalnego pivot podstawowego.
W niektórych przypadkach ten podstawowy pivot może być daleko od centrum samego obiektu!";
// The view will focus on the item when we click on it
scene.syncVisible = "Synchronizuj widoczność";
scene.syncVisible.help = "Gdy włączone, używanie ikony oka (widoczne) będzie miało wpływ na wszystkie wybrane elementy.";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "Połącz";
// Group the selected object with a new created Empty Node as a parent
scene.group = "Grupuj";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "Odłącz";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "Odbicie lustrzane";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "Krzywa";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "Macierz";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "Radialna";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "Repeatery";
scene.repeaters.help = "Węzły repeaterów, które tworzą instancje dowolnych geometrii poniżej nich w hierarchii sceny.";
// Validate button
scene.validateGroup = "Zweryfikuj";
// Keep instances in the scene
scene.validateGroup.keepInstances = "Zachowaj instancje";
// If we should join children
scene.validateGroup.joinChildren = "Połącz obiekty podrzędne";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Scalanie wokseli";
scene.voxelResolution = "Rozdzielczość";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Odejmowanie: ukryj obiekt";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Przecięcie: wszystkie obiekty ukryte";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "Brak zaznaczonych obiektów, zaznacz co najmniej jeden obiekt.";
// Need to select one object only
scene.noneButNeedOne = "Brak zaznaczonych obiektów, zaznacz jeden obiekt.";
// Need to select one object only
scene.onlyOneObject = "Zaznaczono wiele obiektów, zaznacz tylko jeden obiekt.";
// Boolean operation
scene.boolean = "Boolean";
scene.boolean.help = "Merge, subtract or intersect objects by performing a boolean operation.

The operation can fail if some objects are not manifold or not watertight.

If the boolean fails, you can always use the voxel remesher on the problematic object to ensure it's a watertight manifold.";
// Weld intersection
scene.boolean.mergeIntersection = "Spawanie przecięcia";

// General scene display settings
settings.display.title = "Ustawienia wyświetlania";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Szkielet";
// Display the material texture
settings.debugChannel = "Pokaż Teksturę";
// Display the material texture in the background
settings.debugChannel.onBackground = "W Tle";
// Display the material texture on the mesh
settings.debugChannel.onMesh = "Na siatce";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Dwustronny";
settings.twoSided.help = "Powierzchnie będą widoczne z obu stron.";
// If we colorize the inverted side of faces
settings.backface.color = "Kolor tylnej powierzchni";
// Color of the inverted side of faces
settings.backface.colored = "Kolorowa powierzchnia tylna";
// Outline (contour highlight around the selected object)
settings.outline = "Kontur";
// Outline (contour highlight around the selected object)
settings.outline.help = "Zaznaczone obiekty zostaną obrysowane.";
settings.outline.thickness = "Grubość";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Sześcian przyciągania";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "Do dołu";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "W lewo";
// Flip the camera (rotate 180° to see the other side)
settings.snapCube.flip = "Obróć o 180°";
settings.snapCube.flip.help = "Obróć widok, jeśli widok jest już przyciągnięty.";
// Alignment (can be auto/on/off)
settings.snapCube.align = "Ogranicz wyrównanie";
settings.snapCube.align.help = "Wyrównaj widoki do osi świata. Jeśli włączone, możliwych jest tylko 6 widoków przyciągnięcia.

Na Auto, ograniczenie będzie miało miejsce tylko jeśli kamera jest w trybie Orbit.";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Statystyki";
settings.stats.right = "W prawo";
settings.stats.all = "Pokaż pełną scenę";
// Grid
settings.grid = "Siatka";
settings.grid.divideThreshold = "Próg podziału";
// Cursor
settings.cursor.title = "Kursor";
settings.cursor.whileSculpting = "Pokaż okrąg podczas rzeźbienia";
// A small indicator dot
settings.cursor.showDot = "Pokaż małą kropkę";
settings.cursor.showDot.help = "Kropka może pojawić się jako punkt obrotu kamery lub podczas rzeźbienia.";
settings.cursor.showRope = "Pokaż stabilizator liny";
// indicator
settings.indicator.title = "Wskaźnik";
settings.indicator.title.help = "Wyświetla wizualny wskaźnik (tutoriale, przechwytywanie ekranu itp.).";
settings.indicator.size = "Rozmiar";
// Highlight (the object glows when we select it)
settings.highlight.selection = "Wyróżnij zaznaczenie";
// Highlight settings
settings.highlight = "Wyróżnianie";
settings.highlight.duration = "Czas trwania";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Przyciemnij niezaznaczone obiekty";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Płynne cieniowanie";
// Experimental feature
settings.partialDraw = "Częściowy rysunek";
settings.partialDraw.help = "Funkcja eksperymentalna!

Użyj jej, jeśli rzeźbisz stosunkowo małą część siatki o wysokiej polaryzacji.

Powinno to sprawić, że rzeźbienie będzie płynniejsze, ale nie należy włączać szkieletu!

Może również dodać wizualne artefakty podczas pociągnięć pędzla.";
settings.partialDraw.warning = "Nie zapomnij wyłączyć tej opcji, jeśli artefakty wizualne są zbyt uciążliwe!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Pokaż malowanie";
// Show and use the masking on the mesh
settings.showMasking = "Pokaż maskę";
// Disable this option to force show the hidden faces
settings.showDiscard = "Użyj funkcji Ukryj";
// Show icon on the canvas
settings.icon = "Ikona";
// Show icons on the canvas
settings.icons = "Ikony";
// Tooltip
settings.icons.help = "Wyświetl ikonę na obszarze roboczym, aby można było zaznaczyć je i bezpośrednio edytować.";
// Hole filling settings
settings.hole = "Wypełnianie otworów";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Wypełnij nieforemne";
settings.hole.nonManifold.help = "Spróbuj wypełnić niewymierny otwór.
Ta opcja nie jest zapisywana w ustawieniach.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Maks. liczba wierzchołków";
settings.multires.maxVertices.help = "Nomad nie wykonuje sprawdzania pamięci przed podziałem, duża liczba poligonów może łatwo doprowadzić do awarii.";
settings.multires.lowResVertices = "Próg niskiej rozdzielczości";
settings.multires.lowResVertices.help = "Podczas przesuwania kamery może być wyświetlana niższa rozdzielczość siatki.

Możesz zwiększyć tę wartość, jeśli chcesz wyświetlić wyższą rozdzielczość siatki.";

// The main rendering mode
shading = "Cieniowanie";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "Oświetlony (PBR)";
shading.pbr.help = "W tym trybie możesz dodać światła (z cieniami) wraz ze środowiskiem HDR.

Możesz również malować metaliczność i chropowatość, co pozwala na dokładniejszą kontrolę nad wyglądem materiału.";
// Fast rendering mode for sculpting purpose
shading.matcap = "MatCap";
shading.matcap.help = "Skrót od MATerial CAPture (przechwytywanie materiału). MatCap uwzględnia zarówno oświetlenie, jak i informacje o materiałach w jednym obrazie.

Jest to szybki tryb renderowania, nadający się głównie do surowego rzeźbienia.";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "Nieoświetlony";
shading.unlit.help = "Tryb cieniowania w kolorze jednolitym, bez oświetlenia.";
// Helper rendering mode that display solid colors
shading.object = "Obiekt ID";
shading.object.help = "Tryb renderowania bez oświetlenia, w którym każdy obiekt ma przypisany losowy kolor.

Jest to przydatne głównie w sytuacji, gdy na scenie znajduje się wiele obiektów.";
// Helper rendering mode that display solid colors
shading.instance = "Utwórz instancję ID";
shading.instance.help = "To samo co ID obiektu, ale instancje będą miały ten sam kolor.";
// Helper rendering mode that display solid colors
shading.material = "ID Materiału";
shading.material.help = "Pokaż solidny kolor dla każdej instancji materiału.";
// Randomize colors
shading.id.randomize = "Losowy ID";
shading.textures = "Użyj tekstur";
shading.textures.help = "Obecnie w aplikacji Nomad nie można tworzyć ani edytować tekstur.

Jeśli jednak zaimportujesz plik, w którym są tekstury, powinno to zdziałać.

• Obsługiwane tekstury
Krycie: Oświetlone, MatCap, Nieoświetlone
Normalne: Oświetlone, MatCap
Kolor: Oświetlone, Oświetlone
Emisyjne: Oświetlone
Chropowatość: Oświetlone
Metaliczność: Oświetlone";
// Lights
shading.lights = "Światła";
shading.lights.addLight = "Dodaj światło";
shading.lights.warning = "Opcja Światła wymaga trybu cieniowania PBR.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Środowisko";
shading.environment.import = "Importuj HDR";
shading.environment.exposure = "Ekspozycja";
shading.environment.backgroundBlur = "Rozmycie (tło)";
shading.environment.rotation = "Obrót";
shading.environment.rotation.help = "Możesz obrócić środowisko, przeciągając 3 palcami w poziomie na rzutni.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "Przyłączono do kamery";
shading.environment.attachedToCamera.help = "Przyłącz środowisko do kamery.

Wymusi to spójność oświetlenia, co może być przydatne do celów rzeźbienia.";
shading.matcap.rotation = "Obrót";
shading.matcap.rotation.help = "Możesz obrócić MatCap, przeciągając 3 palcami w poziomie na rzutni.";
shading.matcap.global = "Użyj globalnego MatCap";
shading.matcap.global.help = "Odznacz tę opcję, aby użyć innego MatCap dla tej konkretnej siatki.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible = "Maska";
shortcut.solo = "Solo";
shortcut.xray = "Prześwietlenie";
shortcut.voxelRemesh = "Woksel";
shortcut.wireframe = "Drut";
shortcut.cameraReset = "Wyzeruj";
shortcut.cameraSnap = "Przyciągnij";
shortcut.lockSelection = "Zablokuj";
shortcut.lockSelection.help = "Po włączeniu nie można zmienić zaznaczenia przez stuknięcie siatki.";
shortcut.grid = "Siatka";

// Memory taken by the scene
stat.ramScene = "Scena";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Pamięć VRAM sceny";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "Pamięć VRAM renderowania";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "Pamięć VRAM tekstur";
// Memory taken by the undo/redo history
stat.ramHistory = "Historia";
// Memory taken by other stuffs
stat.ramOther = "Inne";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "Użyta pamięć";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "Wolna pamięć";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "Użyta: $0";
stat.free = "Wolna: $0";
stat.faces = "Powierzchnie";
stat.triangles = "Trójkąty";
stat.vertices = "Wierzchołki";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Czworokąty";
stat.vertex = "Wierzchołek";
stat.scene.face = "Powierzchnie sceny";
stat.scene.vertex = "Wierzchołki sceny";

// Brush stroke
stroke = "Pociągnięcie";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "Promień przestrzeni świata";
// The settings is shared among every tools
stroke.useWorldRadius.help = "Jest to współużytkowane przez wszystkie narzędzia.";
// Share the radius value among every tools.
stroke.useShareRadius = "Udostępnij promień";
stroke.useShareRadius.help = "Udostępnij wartość promienia dla wszystkich narzędzi.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.spacing = "Odstęp pociągnięć";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.spacing.adjust = "Dostosuj intensywność odstępów";
stroke.minSpacingAdjustIntensity.help = "Dostosuj intensywność pędzla, aby zapewnić spójne odkształcenie w zależności od odstępu między pociągnięciami.";
stroke.minSpacing.help = "Odstęp pomiędzy poszczególnymi pociągnięciami w stosunku do promienia narzędzia.

Niższa wartość pozwoli na gładsze pociągnięcie, ale pogorszy się wydajność.";
// Brush stroke smoothing
stroke.lazySmooth = "Wygładzanie pociągnięć";
stroke.lazySmooth.help = "Uśrednij wiele pozycji wskaźnika, aby uzyskać bardziej płynne pociągnięcie.

Przy wysokich wartościach pociągnięcie będzie się opóźniać za wskaźnikiem, ale w końcu go dogoni.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Stabilizator powolnej liny";
stroke.lazyRadius.help = "Pociągnięcia będą opóźnione w stosunku do pozycji wskaźnika zgodnie z określoną odległością.

Można to wykorzystać do rysowania gładkich linii.";
// It is not a per-tool settings
stroke.globalSettings = "To jest ustawienie globalne";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Promień przyciągania";
stroke.snapRadius.help = "Przyciągnij pociągnięcie, jeśli wskaźnik znajduje się w pobliżu ostatniego zarejestrowanego pociągnięcia.

Może to być przydatne podczas rysowania długich linii ciągłych przy jednoczesnym robieniu częstych przerw.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Przesunięcie pociągnięć";
stroke.sculptOffset.help = "Zastosuj stałe przesunięcie pociągnięć.

Ta opcja ma pomóc w przypadku małych ekranów, gdy używa się palców, aby palec nie zakrywał pociągnięcia.";
stroke.accumulate = "Akumulacja pociągnięć";
stroke.accumulate.help = "Jeśli ta opcja jest włączona, nie ma limitu ilości materii, którą można dodać/usunąć na jedno pociągnięcie.";
// The tool can use DynTopo
stroke.useDynamic = "Zezwól na topologię dynamiczną";
// Only sculpt the part that are linked topologically
stroke.connect = "Połączona topologia";
stroke.connect.help = "Ta opcja powoduje rzeźbienie tylko tych wierzchołków, które są powiązane z wybraną powierzchnią.

Jest to zwykle używane w narzędziu Przesuń, na przykład jeśli chcesz przesunąć tylko część, która przecina się z inną częścią.";
stroke.connect.short = "Połączona";
// sculpt on hide or mask
stroke.protect = "Chroń obszar";
stroke.protect.hide.help = "Gdy ustawione na auto, ukryte powierzchnie będą edytowane, jeśli linie siatki na ukrytych powierzchniach są widoczne (zobacz menu linii siatki).";
// Only sculpt the vertex that points toward the camera
stroke.culling = "Tylko wierzchołek skierowany do przodu";
stroke.culling.help = "Ta opcja zignoruje wierzchołki skierowane do tyłu.

Może być przydatna, jeśli chcesz pomalować część cienkiej geometrii bez wpływu na drugą stronę.

Działa również w przypadku rzeźbienia, ale mogą wystąpić pewne artefakty.";
// Infinite depth, move everything under the circle, disregarding depth
stroke.silhouette = "Sylwetka";
stroke.silhouette.view = "Wyświetl";
stroke.silhouette.snapped = "Jeśli przyciągnięte";
stroke.silhouette.closest = "Najbliższe";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.sameSide = "Tylko wierzchołek po tej samej stronie";
stroke.sameSide.help = "Ignoruj wierzchołki, które wskazują w kierunku przeciwnym do deformacji.";
// determine normal direction
stroke.normal.direction = "Kierunek";
stroke.normal.direction.help = "Istotne tylko wtedy, gdy włączone jest odkształcenie normalne.

Kontroluje, jak Nomad decyduje o znaku odkształcenia (wypychanie vs wciąganie).";
stroke.normal.direction.normal = "Normalna 3D";
stroke.normal.direction.normal.help = "Porównuje pozycję XY wskaźnika z rzutowaną normą powierzchni.";
stroke.normal.direction.screen = "XY";
stroke.normal.direction.screen.help = "Używa pozycji XY ekranu wskaźnika do decyzji wypychania lub wciągania.";
stroke.normal.direction.auto = "Auto";
stroke.normal.direction.auto.help = "Automatycznie wybiera metodę na podstawie kąta normalnej.";
stroke.normal.direction.auto.threshold = "Próg";
stroke.normal.direction.auto.threshold.help = "Limit kąta porównany z normą powierzchni w celu decyzji, która metoda jest używana.";
// small tip/warning
stroke.onlyLasso = "Ustawienia aktywne tylko dla narzędzia lasso.";

// Here sampling refers to the app gathering information under the mouse
stroke.area = "Próbkowanie obszaru";
stroke.area.help = "Niektóre pędzle lub opcje ruchów wymagają płaszczyzny prostopadłej do powierzchni, aby działać.
Możesz kontrolować, jak obliczyć tę średnią płaszczyznę, ustawiając obszar próbkowania jako stosunek do promienia narzędzia.

Przy 100%, wszystkie punkty wewnątrz koła wyboru są brane pod uwagę.
Przy 0%, brany pod uwagę jest tylko najbliższy wierzchołek lub trójkąt.";
// Sampling radius size (percent)
stroke.area.normal.radius = "Promień normalny";
// Sampling radius size (percent)
stroke.area.point.radius = "Promień pozycji";
// Sampling averaging
stroke.area.normal.average = "Uśrednianie normalne";
// Sampling averaging
stroke.area.point.average = "Uśrednianie pozycji";
// Keep sharp edges
stroke.normalFilter = "Filtr normalny";
stroke.normalFilter.help = "
Filtrowanie głębi";

// Only paint the part of the mesh above a certain height
stroke.depth.enable = "Maskowanie głębokości";
stroke.depth.enable.help = "Wyklucz punkty, które są powyżej lub poniżej pewnej odległości od obliczonej płaszczyzny (Próbkowanie obszaru).

Na przykład, może być użyte do malowania wypukłości lub wgłębień.";
stroke.depth.offset = "Przesunięcie wysokości";
stroke.depth.falloff = "Szum głębokości";
stroke.depth.max = "Górny obszar";
stroke.depth.min = "Dolny obszar";

// Invert the pixel (black <-> white)
stroke.alpha.invert = "Odwróć piksele";
// Repeat the alpha image (pattern)
stroke.alpha.wrap = "Rozmieszczenie sąsiadująco";
// No repeat pattern
stroke.alpha.wrap.none = "Brak";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alpha.wrap.repeat = "Powtarzanie";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alpha.wrap.mirror = "Odbicie lustrzane";
// Tight fit when using tiling
stroke.alpha.fit = "Dopasuj do wewnątrz";
stroke.alpha.fit.help = "This option is only relevant if the alpha and brushes textures are non square.

When enabled, each images will tile independently with no spacing.
You can disable this option if you want to keep the alpha and other images synchronized, in case their ratio are not the same.";
// Alpha rotation
stroke.alpha.rotation = "Obrót";
stroke.alpha.rotation.lock.help = "Zablokuj orientację alfa.

Jeśli rotacja jest odblokowana, orientacja będzie podążać za kierunkiem pociągnięcia w czasie rzeczywistym.";
// Repeat the image
stroke.alpha.tiling = "Rozmieszczenie sąsiadująco";
// Scale the image (make it bigger or smaller)
stroke.alpha.scale = "Skalowanie";
stroke.alpha.scale.help = "Przy minimalnej wartości kwadrat alfa znajduje się wewnątrz promienia okręgu narzędzia.";
// Middle-point value at which no deformation occurs
stroke.alpha.midValue = "Średnia wartość";
stroke.alpha.midValue.help = "Wartość środkowa, przy której nie występuje deformacja.

(Wartość środkowa = 0)
• Czarny: brak przesunięcia
• Biały: przesunięcie dodatnie

(Wartość środkowa = 0,5)
• Czarny: przesunięcie ujemne
• Biały: przesunięcie dodatnie

(Wartość środkowa = 1)
• Czarny: przesunięcie ujemne
• Biały: brak przesunięcia";
// Synonymous: Scatter/Jitter/Randomize
stroke.jitter = "Zrandomizuj";
// Sculpt and paint along the brush stroke at regular spacing
stroke.type.dot = "Kropka";
// Sculpt and paint along with alpha spaced by brush radius
stroke.type.roll = "Rolka";
// Sculpt and paint with alpha projected on screen stencil
stroke.type.tile = "Kafelkowanie";
// Sculpt and paint with alpha projected on 3 axis
stroke.type.triplanar = "Trzypłaszczyznowy";
// Sculpt continuously
stroke.type.drag = "Przeciągnij";
// Lock a region and move it around
stroke.type.grab = "Przechwyć";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.type.grabRadius = "Przechwytywanie – dynamiczny promień";
// Lock a region and sculpt it by changing the tool intensity
stroke.type.grabIntensity = "Przechwytywanie – dynamiczna intensywność";

stroke.falloffProject = "Wpływ";
stroke.falloffProject.help = "• Sfera (3d)
Wpływ jest obliczany, biorąc pod uwagę odległość wierzchołka od centrum pędzla.

• Koło (2d)
Wierzchołek jest najpierw rzutowany na płaszczyznę obszaru, zanim zostanie obliczona jego odległość od centrum pędzla.
Jest to podobne do sposobu próbkowania alfa.";
stroke.falloffProject.sphere = "Kula";
stroke.falloffProject.circle = "Okrąg";
stroke.falloffProject.cylinder = "Walec";

// Symmetry
symmetry = "Symetria";
symmetry.enable = "Włączona";
symmetry.primitiveWarning = "Symetria pędzla jest dostępna tylko dla prymitywów, które są zatwierdzone, z wyjątkiem trójpłaszczyznowych.";
symmetry.plane.title = "Płaszczyzny";
symmetry.toolIgnore = "Bieżące narzędzie ignoruje symetrię.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Radialna";
symmetry.radialX = "Radialna X";
symmetry.radialY = "Radialna Y";
symmetry.radialZ = "Radialna Z";
// A warning indicating that we limit the number of repetitions ($0 is a number)
symmetry.limited = "Liczba powtórzeń ograniczona do $0!";
// Synonym: Offset
symmetry.offset.title = "Przesunięcie";
symmetry.offsetX = "Przesunięcie X";
symmetry.offsetY = "Przesunięcie Y";
symmetry.offsetZ = "Przesunięcie Z";
// Number of clones
symmetry.count.title = "Liczba";
symmetry.countX = "Liczba X";
symmetry.countY = "Liczba Y";
symmetry.countZ = "Liczba Z";
// method
symmetry.method = "Metoda:";
symmetry.method.help = "• Lokalna
Płaszczyzna symetrii będzie się przesuwać wzdłuż siatki, gdy użyjesz jednego z narzędzi transformacji (Gizmo lub Transformacja).

• Świat
Płaszczyzna symetrii jest stała i nie będzie się poruszać.";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.method.world = "Świat";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.method.local = "Lokalna";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Przerzuć obiekt";
// Cut half of the mesh
symmetry.cut = "Wytnij";
// after mirroring, separate into multiple output (synonym: split, separate)
symmetry.split = "Podziel";
// Reapply the mesh mirror, does not impact the topology
symmetry.mirror = "Lustro";
symmetry.mirror.help = "Spróbuj ponownie zastosować symetrię bez wpływu na topologię.

Symetria radialna będzie ignorowana.

Jeśli topologia nie może być zachowana, ponieważ nie jest uważana za symetryczną, otrzymasz opcję wymuszenia odbicia lustrzanego.";
// indicate that applying the mirror will keep the mesh topology
symmetry.mirror.keepTopology = "zachowaj topologię";
symmetry.mirrorFail = "Nie udało się zastosować symetrii.

Czy chcesz wymusić symetrię poprzez odbicie lustrzane siatki?";
symmetry.mirrorUseMasking = "Chroń zamaskowany obszar";
symmetry.mirrorUseMasking.help = "Zachowaj zamaskowany obszar w stanie nienaruszonym.

Ta opcja będzie ignorowana w przypadku niesymetrycznej topologii (lub rozłącznej powierzchni, jak para oczu).";
// Reset the symmetry plane position
symmetry.reset = "Wyzeruj";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Środek obiektu";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "Środek świata";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Orientacja";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Pokaż linię";
// Display the symmetry plane in 3D
symmetry.showPlane = "Pokaż płaszczyznę";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Edycja gizmo";
symmetry.edit.warning = "Edycja symetrii jest funkcją eksperymentalną.";
symmetry.edit.help = "Możesz dowolnie ustawić płaszczyznę symetrii.

Ta funkcja jest nieco eksperymentalna i prawdopodobnie nigdy nie należy jej używać.";

// Ideally short strings
tool.dynamic = "DynTopo";
// Ideally short strings (Symmetry)
tool.symmetry = "Sym";
// Ideally short strings (Mirror primitive)
tool.mirror = "Lustro";
// Ideally short strings
tool.clay = "Glina";
// Ideally short strings (Subtract)
tool.clay.sub = "Odejmij";
// Ideally short strings
tool.brush = "Pędzel";
// Ideally short strings
tool.move = "Przenieś";
// Ideally short strings (Normal vector, perpendicular to surface)
tool.move.normal = "Normalna";
// Ideally short strings
tool.drag = "Przeciągnij";
// Ideally short strings (Smooth the surface by erasing the details)
tool.smooth = "Gładkie";
// Ideally short strings (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Złagodź";
// Ideally short strings (Paint mask)
tool.mask = "Maska";
// Ideally short strings
tool.mask.unmask = "Usuń maskę";
// Ideally short strings (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "Zaz. maskę";
// Ideally short strings (Smudge the paint of the object)
tool.smudge = "Smużenie";
// Ideally short strings (Flatten the surface)
tool.flatten = "Spłaszcz";
// Ideally short strings (Flatten the surface, more strongly than Flatten)
tool.planar = "Płaski";
// Ideally short strings (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Wypełnij";
// Ideally short strings (Layer brush)
tool.layer = "Warstwa";
// Ideally short strings
tool.crease = "Zagnij";
// Ideally short strings (Cut part of the mesh cleanly)
tool.trim = "Przytnij";
// Ideally short strings (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Podziel";
// Ideally short strings (Project part of the object onto a curve)
tool.project = "Rzutuj";
// Ideally short strings
tool.inflate = "Napełnij";
// Ideally short strings
tool.pinch = "Ściśnięcie";
// Ideally short strings
tool.nudge = "Przesuń";
// Ideally short strings
tool.stamp = "Stempel";
// Ideally short strings (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "Us. warstwę";
// Ideally short strings (Select multiple objects with a lasso tool)
tool.select = "Wybierz";
// Ideally short strings (Rotate, Translate and Scale the object)
tool.gizmo = "Gizmo";
// Ideally short strings
tool.gizmo.editPivot = "Pkt obrotu";
// Ideally short strings (Snap angle)
tool.gizmo.rotateSnap = "Przyciągnij";
// Ideally short strings (Snap translation)
tool.gizmo.moveSnap = "Przyciągnij";
// Ideally short strings (Local/Relative space)
tool.gizmo.local = "Lokalne";
// Ideally short strings (Align/Snap the gizmo to world axis)
tool.gizmo.align = "Wyrównaj";
// Ideally short strings (Pin the gizmo, so that it stays in place when switching between objects)
tool.gizmo.pin = "Przypnij";
// Ideally short strings (Rotate, Translate and Scale the object)
tool.transform = "Przekształcenie";
// Ideally short strings (Translate the object)
tool.transform.move = "Przenieś";
// Ideally short strings (Rotate the object)
tool.transform.rotate = "Obróć";
// Ideally short strings (Scale the object)
tool.transform.scale = "Skala";
// Ideally short strings (Snap the object on another object surface)
tool.transform.snap = "Przyciągnij";
// Ideally short strings (Measure distance between 2 points)
tool.measure = "Zmierz";
// Ideally short strings (Lattice, deformer)
tool.lattice = "Krata";
// If an option is shared among the tools
tool.all = "Wszystkie";
// Ideally short strings (Quad Remesher)
tool.remesh = "Przeprojektowanie siatki";
tool.remesh.guides = "Przewodniki";
tool.remesh.density = "Gęstość";
tool.remesh.same = "Same";
tool.remesh.half = "Half";
// Ideally short strings (FaceGroup)
tool.faceGroup = "Grupa powierzchni";
tool.faceGroup.autoPick = "Auto-wybór";
tool.faceGroup.flush = "Usuń nieużywane";
tool.faceGroup.skip = "Pomiń małe grupy na podstawie:";
tool.faceGroup.skipFace = "Liczba ścianek";
tool.faceGroup.skipFace.help = "Nie twórz nowej grupy, jeśli liczba ścianek jest mniejsza lub równa tej wartości progowej.";
tool.faceGroup.skipArea = "Powierzchnia";
tool.faceGroup.skipArea.help = "Nie twórz nowej grupy, jeśli powierzchnia nowej grupy jest mniejsza niż ta wartość progowa.

Wartość progowa podana jest jako procent całkowitej powierzchni obiektu.";
// Ideally short strings (Hide)
tool.hide = "Ukryj";
// Ideally short strings (View tool, do nothing in particular)
tool.view = "Wyświetl";
// Ideally short strings (Revolving surface along a line)
tool.lathe = "Bryła obrotowa";
// Ideally short strings (Revolving surface along a curve)
tool.tube = "Rura";
// Ideally short strings (Insert object into the scene)
tool.insert = "Wstaw";
// Ideally short strings (Flip/Invert/Negate the shape)
tool.shape.flip = "Odwróć";
// Ideally short strings (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "Widok";
// Ideally short strings (Lasso selection)
tool.shape.lasso = "Lasso";
// Ideally short strings (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Krzywa";
// Ideally short strings (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Wielokąt";
// Ideally short strings (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Ścieżka";
// Ideally short strings (Rectangular selection)
tool.shape.rectangle = "Prostokąt";
// Ideally short strings (Ellipse selection)
tool.shape.ellipse = "Elipsa";
// Ideally short strings (Line selection, split the screen in half)
tool.shape.line = "Linia";
// Ideally short strings (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Zamknięty";

// Radius of the tool (size)
tool.radius = "Promień";
// Intensity of the tool (force)
tool.intensity = "Intensywność";

tool.settings = "Ustawienia";
tool.settings.none = "To narzędzie nie ma żadnych konkretnych ustawień.";

tool.crease.pinchFactor = "Siła ściskania";
tool.crease.offsetFactor = "Współczynnik przesunięcia";

tool.layer.removeInfluence = "Użyj danych warstwy";
tool.layer.removeInfluence.help = "Ta opcja jest aktywna tylko wtedy, gdy jest zaznaczona warstwa.

Użyje ona danych warstwy do ograniczenia przesunięcia nad pociągnięciami.";
tool.layer.noLayerSelected = "Ta opcja jest dostępna tylko wtedy, gdy jest zaznaczona warstwa";

tool.flatten.planeLockOrigin = "Zablokuj początek płaszczyzny";
tool.flatten.planeLockNormal = "Zablokuj kierunek płaszczyzny";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "Synchronizacja";
tool.syncInstance.message = "Nowy obiekt zostanie dodany do wszystkich innych instancji!";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Lepki wierzchołek na granicy";
tool.smooth.screen = "Wygładzanie ekranu";
tool.smooth.screen.help = "Użyj tej opcji, aby uzyskać wygładzanie niezależne od topologii, nawet przy wysokiej liczbie wielokątów.";
tool.smooth.screen.samples = "Próbki ekranu";
tool.smooth.stable = "Stabilne wygładzanie";
tool.smooth.stable.help = "Stara się uczynić wygładzanie niezależnym od topologii.

Ten tryb najlepiej działa przy zróżnicowanej gęstości topologii i przy wysokiej wartości intensywności wygładzania.";

tool.paint = "Farba";
// Erase the painting
tool.paint.erase = "Wymaż";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Filtrowanie warstwy";
tool.paint.layerFilter.help = "Użyj tej opcji tylko wtedy, gdy chcesz przemalować już pomalowany obszar warstwy.";

// Clear the painted mask
tool.mask.clear = "Wyczyść";
tool.mask.clearAll = "Wyczyść wszystko";
// Invert the painted mask
tool.mask.invert = "Odwróć";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Przerzuć połączony";
// Blur the painted mask
tool.mask.blur = "Rozmycie";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Wyostrzenie";
// Transform/Matrix
tool.matrix = "Macierz";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.target = "Cel";
// Automatic
tool.matrix.target.auto = "Auto";
tool.matrix.target.auto.help = "Domyślnie będzie to działać podobnie do opcji Grupa.
Jeśli siatka ma maskowanie lub jeśli symetria jest włączona, będzie to działać tak samo jak Wierzchołek.";
// Auto apply the transform on the vertices
tool.matrix.target.vertex = "Wierzchołek";
tool.matrix.target.vertex.help = "Spróbuj zastosować transformację wierzchołków, nie będzie ona działać w przypadku niezweryfikowanych prymitywów.
Wpłynie to również na instancje.";
// Transform the object alone (the children stands still)
tool.matrix.target.object = "Obiekt";
tool.matrix.target.object.help = "Przesuń tylko obiekt, ignorując symetrię i maskowanie.
Tylko edytowany węzeł będzie się poruszać, węzły podrzędne pozostaną na miejscu.";
// Transform the object and its children
tool.matrix.target.group = "Grupuj";
tool.matrix.target.group.help = "Przesuń węzeł, ignorując symetrię i maskowanie.
Pozostała część hierarchii również zostanie przekształcona.";
// Operation on the mesh
tool.matrix.action = "Operacja";
tool.matrix.action.origin = "Przenieś początek";
tool.matrix.action.origin.help = "Przesuwa siatkę do początku świata.";
tool.matrix.action.bake = "Zastosuj";
tool.matrix.action.bake.help = "Zastosuj macierz do wierzchołka i zresetuj macierz. Wizualnie nic nie powinno się zmienić.";
tool.matrix.action.reset = "Wyzeruj";
tool.matrix.action.reset.help = "Resetuje transformację siatki do tożsamości.";

// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "Ścinanie";
tool.matrix.translation = "Translacja";
tool.matrix.rotation = "Obrót";
tool.matrix.scale = "Skala";
tool.matrix.uniformScale = "Jednolite skalowanie";

tool.transform.tip = "Pojedyncze stuknięcie drugim palcem, aby przełączyć tryb";

// Size of the gizmo
tool.gizmo.size = "Rozmiar widżetu";
// If true, there is less spacing between gizmo handlers (rotate, scale, etc)
tool.gizmo.compact = "Kompaktowy";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "Wprowadzanie numeryczne";
tool.gizmo.allowInput.help = "Zezwól na wprowadzanie numeryczne po stuknięciu jednego z widżetów gizmo";
// Angle threshold
tool.gizmo.linearRollThreshold = "Próg przechyłu stycznego";
tool.gizmo.linearRollThreshold.help = "Próg kąta do wyboru pomiędzy metodą liniową a kołową.

Wartość powyżej tego progu spowoduje zastosowanie zwijania kołowego.

Jeśli wolisz liniowe zwijanie (kierunek stycznej), po prostu ustaw tę wartość na 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Ukryj przy interakcji";
tool.gizmo.tap = "Po jednym stuknięciu";
tool.gizmo.tap.help = "Ta opcja działa tylko w trybie niestandardowego obrotu (tryb automatyczny wyłączony).";
tool.gizmo.tap.none = "Brak";
tool.gizmo.tap.none.help = "Nic się nie dzieje po stuknięciu siatki.";
tool.gizmo.tap.normal = "Normalna";
tool.gizmo.tap.normal.help = "Move the gizmo on the first intersection and align it according to the surface normal.";
tool.gizmo.tap.first = "Pierwsze trafienie";
tool.gizmo.tap.first.help = "Przesuń gizmo do pierwszego przecięcia.";
tool.gizmo.tap.medial = "Środkowa pozycja";
tool.gizmo.tap.medial.help = "Przesuń gizmo do średniej z dwóch pierwszych przecięć.";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "Stałe";
tool.lathe.axisOnly = "Tylko oś";
tool.lathe.stable = "Stabilny";
tool.lathe.axis = "Oś";

// Fill the object's hole
tool.hole = "Wypełnianie otworów";
tool.hole.fillHoles = "Wypełnij otwory";
// synonym: Alternative method
tool.hole.method.fill = "Wypełnij";
tool.hole.method.legacy = "Dziedzictwo";
tool.hole.method.boolean = "Boolean";
tool.hole.bridges = "Wartość logiczna dla przestrzeni na ekranie";
tool.hole.bridges.help = "Jeśli ta opcja jest włączona, można wykrawać otwory w objętości.
Nachylenie cięcia będzie również bardziej zbliżone do kształtu cięcia.";
tool.hole.threshold = "Epsilon progu";
tool.hole.threshold.help = "Dostosowanie tej wartości może ulepszyć algorytm wypełniania dziur.";
tool.hole.smoothing = "Wygładzanie otworów";

tool.smudge.quality = "Jakość";
tool.smudge.quality.help = "Zmienia rozdzielczość wyświetlanych pikseli, niższe wartości oznaczają szybsze pociągnięcia.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Kształt";
// Auto-validate the drawn shape
tool.shape.autoValidate = "Auto-zatwierdzanie";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Kwadrat";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Wyśrodkowany";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Okrąg";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Wyśrodkowana";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Krok obrotu";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Złoty podział";
// volume of a mesh
tool.measure.volume = "Objętość siatki";
// Surface of a mesh
tool.measure.surface = "Powierzchnia";

// Always display the camera shortcut buttons on the viewport
tool.view.stickyCamera = "Skrót kamery (zawsze)";

// Topology
topology = "Topologia";
// Synynom: detail value, density
topology.dynamic.detail = "Szczegół";
// See glossary
topology.multires = "Wielokrotna rozdzielczość";
topology.multires.help = "Zachowaj wiele rozdzielczości siatki.

Jeśli dokonasz zmian w niższej rozdzielczości, szczegóły z wyższych rozdzielczości zostaną znowu wyświetlone po ponownym przełączeniu.

Warstwy są dostępne w każdej rozdzielczości.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "Odwróć";
topology.multires.reverse.confirm = "Nie można utworzyć podziału podstawowego.

Obecna topologia prawdopodobnie nie jest wynikiem podziału.";
topology.multires.subdivide = "Podziel";
topology.multires.subdivide.confirm = "Siatka będzie mieć $0 mln wierzchołków. Czy na pewno?";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "Przekroczono limit podziału. Zobacz $0";
topology.multires.deleteLower = "Usuń niższe";
topology.multires.deleteHigher = "Usuń wyższe";
topology.multires.keepTriangles = "Zachowaj trójkąty";
topology.multires.lock = "Zablokuj (LV0)";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "Poziom wielokrotnych rozdzielczości →";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "Poziom Multires ←";
// Synonym: Flat subdivision
topology.multires.linear = "Podział liniowy";
topology.multires.linear.help = "Po prostu podziel siatkę bez stosowania wygładzania";
// Only show the lowest resolution wireframe
topology.multires.minWireframe = "Tylko poziom 0";
// Create a new object by recomputing a new topology
topology.remesh = "Ponownie utwórz siatkę";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Ponowne tworzenie siatki wokseli";
topology.voxel.help = "Ponowne tworzenie siatki poprzez próbkowanie na siatce.

Jeśli obiekt nie jest zamknięty (wodoszczelny), najpierw zastosowany zostanie algorytm wypełniania otworów.

Warstwy są ponownie rzutowane po utworzeniu siatki, ale jakość ulegnie pogorszeniu.";
topology.voxel.resolution = "Rozdzielczość";
topology.voxel.sharp = "Zachowaj ostre krawędzie";
topology.voxel.sharp.help = "Opcja ta jest przydatna głównie do prostych operacji logicznych na prymitywach.

Wprowadzi ona zniekształcenia w pewnym obszarze ze względu na to, że punkty są przyciągane do krawędzi.";
topology.voxel.subLevel = "Utwórz wielokrotną rozdzielczość";
topology.voxel.subLevel.help = "Możesz odbudować hierarchię wielokrotnej rozdzielczości z danych wyjściowych narzędzia ponownego tworzenia siatki wokseli.

Będzie również działać szybciej i zużywać mniej pamięci, zwłaszcza jeśli wartość szczegółowości wokseli jest wysoka.
Jeśli jednak wartość szczegółowości wokseli jest niska i chcesz uzyskać wysoki poziom wielokrotnej rozdzielczości, utracisz szczegóły.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Ponownie utwórz siatkę";
topology.surface.detail = "Szczegół";
topology.surface.detail.help = "W przeciwieństwie do ponownego tworzenia siatki wokseli, ponowne tworzenie siatki powierzchni nie wymaga zamknięcia siatki.

Może również obsługiwać maskowanie, dzięki czemu można chronić niektóre części siatki przed zmianami topologii.

Warstwy są aktualizowane poprawnie.";
topology.surface.method = "Metoda";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Uniformizacja";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Podział";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Upraszczanie";
topology.surface.method.help = "Zachowanie topologii dynamicznej:
• Uniformizacja: dodawanie i usuwanie szczegółów
• Podział: dodawanie szczegółów
• Upraszczanie: usuwanie szczegółów";
topology.surface.useMasking = "Chroń zamaskowany obszar";
topology.surface.useMasking.help = "Zamaskowane obszary będą chronić topologię przed zmianami.";
topology.surface.extrapolate = "Ekstrapolacja wierzchołków";
// DynTopo
topology.dynamic = "Topologia dynamiczna";
topology.dynamic.global = "Globalnie wł./wył.";
topology.dynamic.activate = "Włączona";
topology.dynamic.activate.help = "W przypadku topologii dynamicznej narzędzia do rzeźbienia mogą lokalnie dzielić lub upraszczać siatkę w czasie rzeczywistym.

Ta funkcja może mieć zauważalny wpływ na wydajność.

Warstwy są aktualizowane prawidłowo.";
topology.dynamic.method = "Szczegóły oparte na...";
topology.dynamic.method.screen = "Raster";
topology.dynamic.method.radius = "Promień";
topology.dynamic.method.constant = "Stała";
topology.dynamic.method.help = "• Powiększenie
Poziom szczegółowości zależy od tego, jak daleko jesteś od powierzchni.

• Promień
Promień narzędzia określa ilość szczegółów.

• Stały
Szczegółowość jest stała, wartość szczegółowości jest wspólna również z suwakiem wokseli.";
topology.dynamic.quality = "Preferuj...";
topology.dynamic.quality.help = "Jeśli wybierzesz opcję Jakość, dwie główne różnice to:
• Ulepszanie jest stosowane przed operatorem rzeźbienia; otrzymasz mniej artefaktów interpolacyjnych podczas malowania lub rzeźbienia bardzo małych szczegółów.
• Ulepszanie nie jest stosowane przyrostowo; jeśli rzeźbisz bardzo małe szczegóły lub wykonujesz szybkie pociągnięcia, topologia zawsze będzie poprawnie ulepszana.";
topology.dynamic.quality.speed = "Szybkość";
topology.dynamic.quality.quality = "Jakość";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Użyj nacisku dla promienia";
topology.dynamic.usePressure.help = "Użyj tej opcji, jeśli chcesz, aby nacisk pióra na promień narzędzia miał wpływ na poziom szczegółowości.";
topology.dynamic.useFalloff = "Użyj zanikania pociągnięcia";
// Decimate
topology.decimate.title = "Upraszczanie";
topology.decimate.title.help = "Zmniejsz liczbę wielokątów, starając się zachować jak najwięcej szczegółów.

Ta funkcja może być przydatna, jeśli chcesz eksportować do druku 3D.
Jednak prawdopodobnie nie należy jej używać, jeśli chcesz kontynuować rzeźbienie, ponieważ może to spowodować powstanie nierównych trójkątów.

Zamaskowany obszar nie zostanie uproszczony.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Uprość";
topology.decimatePaintWeight = "Zachowaj malowanie";
topology.decimatePaintWeight.help = "Wyższa wartość będzie starała się zachować malowanie.

Ustaw tę wartość na 0, jeśli malowanie nie jest ważne.";
topology.decimateUniform = "Jednolite powierzchnie";
topology.decimateUniform.help = "Wyższa wartość pozwoli na uzyskanie trójkątów o podobnym rozmiarze.";
topology.decimatePreserveBorders = "Zachowaj krawędzie";
topology.decimatePreserveBorders.help = "Nie redukuj liczby krawędzi siatki.";
// Target a certain number of triangles, faces and vertices
topology.target.triangles = "Docelowe trójkąty";
topology.target.faces = "Docelowe ściany";
topology.target.quads = "Docelowe czworokąty";
topology.target.points = "Docelowe punkty";
// Quad remesher
topology.qremesh = "Przebudowa na czworokąty";
topology.qremesh.angle = "Kąt zagięcia";
topology.qremesh.border = "Zachowaj krawędzie";
topology.qremesh.onlyQuad = "Tylko czworokąty";
topology.qremesh.hole = "Maksymalne wypełnienie otworu";
topology.qremesh.hole.help = "
Obliczanie UV";

// Unwrapping means compute UV (texture coordinates), with uvs you can appliy (wrap) a texture onto the model
topology.uv.title = "Obliczać UV";
// UV Unwrap but as a Verb
topology.uv.unwrap = "Obliczać";
// The operation can be very slow
topology.uv.atlas.warning = "Może być bardzo powolne, cel < 100 tys. wierzchołków!";
// Handles are topological holes (synonym: genus, hole)
topology.uv.bff.warning = "Może mieć nakładki, jeśli siaka ma uchwyty!";
// Solo patch
topology.uv.bff.seamless = "Szwy niewidoczne";
topology.uv.bff.seamless.help = "Ta opcja może spowodować znaczne zniekształcenia.

Zazwyczaj może być używana, gdy grupy twarzy są starannie ustawione.";
// Synonym: Point count? Singularity count ?
topology.uv.bff.cones = "Liczba stożków";
topology.uv.bff.help = "Wyższa wartość zredukuje zniekształcenia złożonych obiektów.

Wyższa wartość oznacza dłuższy czas obliczeń.";
topology.uv.delete = "Usuń UV";

// Transfer the vertex painting in the texture, bake means "create texture (from mesh data)"
topology.bake.title = "Zastosuj";
// Bake here means "create texture (from mesh data)"
topology.bake.title.help = "Mapowanie tekstur utworzy tekstury przez rzutowanie innych widocznych obiektów w scenie.

Oto typowy przepływ pracy dla mapowania:
• Masz siatkę z drobnymi szczegółami i malowaniem
• Sklonuj ją
• Zredukuj jej rozdzielczość (ustaw `Zachowaj malowanie` na 0!)
• Rozwiń mapę UV
• Przeprowadź mapowanie!

Powinieneś teraz mieć siatkę o niskiej rozdzielczości, która zachowuje większość malowania i szczegółów poprzedniego obiektu.

Po operacji, kolory wierzchołków zostaną przeniesione do nowej wyłączonej warstwy, tak aby były ignorowane zamiast być mnożone przez teksturę kolorów.

Aby wybrać, które obiekty są używane do wypalania, będzie stosowana następująca logika: 
- wszystkie wybrane obiekty używane oraz główny wybrany obiekt zostaną wypalone (najsilniejsze podświetlenie w menu sceny)
- jeśli jest tylko jeden wybrany obiekt, Nomad uwzględni zamiast tego wszystkie widoczne obiekty
- w przeciwnym razie, jeśli wszystkie obiekty są ukryte (na przykład poprzez użycie Solo), uwzględniana będzie cała scena";
// Bake here means "create texture (from mesh data)"
topology.bake.self = "Od samego siebie";
// Bake here means "create texture (from another mesh data)"
topology.bake.other = "Od wysokiej rozdzielczości";
topology.bake.resolution = "Rozdzielczość";
// Cage is a specific term, synonyom: "Bake offset"
topology.bake.offset = "Przesunięcie promienia";
topology.bake.radius = "Promień klatki";
// Bake opacity (from mask data)
topology.bake.opacityFromMask = "Maska -> Przezroczystość";
topology.bake.backup = "Kopia zapasowa";

// project a high resolution mesh details onto another
topology.reproject.title = "Rzutowanie";
topology.reproject.title.help = "Rzutuj szczegóły rzeźbienia, malowanie i warstwy z najbliższych widocznych obiektów.

To jest głównie przeznaczone do użycia na siatce o wysokiej rozdzielczości, zwykle z czystą topologią.";
// tweaking value
topology.reproject.rayBias = "Uchyb promienia";
topology.reproject.rayBias.help = "Dwie metody są używane do rzutowania:
• najbliższy: najbliższy punkt na powierzchni
• promień: punkt przecięcia przez kierunek normalny

Wyższe wartości uchybu będą faworyzować przecięcie promienia zamiast najbliższej powierzchni.";
topology.reproject.normalOffset = "Przesunięcie normalne";
topology.reproject.shpereCast = "Zapasowa metoda rzutowania sfery";
topology.reproject.shpereCast.help = "Jeśli reproiekcja promieniem normalnym zawiedzie, Nomad przełączy się na najbliższe przecięcie powierzchni.";
// number of iteration the algorithm will take
topology.reproject.iterations = "Iteracje";
topology.reproject.relax = "Złagodź";
topology.reproject.relax.help = "Relaksacja powinna być preferowana, gdy siatka jest niskiej jakości.";
topology.reproject.layers.help = "Przenieś inne warstwy na wybraną siatkę.";

topology.manifold = "Foremny";
topology.nonManifold = "Nieforemny";
topology.manifold.clean = "Oczyść";
topology.manifold.collapse = "Usuń małe ściany";
topology.manifold.title = "Wymuś rozmaitość";
topology.manifold.title.help = "Próbuje wyczyścić krawędzie nie będące rozmaitością.

Może to być przydatne dla zewnętrznych programów, które nie obsługują krawędzi mających więcej niż 2 wspólne ściany.";

// Reset key-bindings/shortcuts
binding.reset = "Resetuj powiązania";
// Add node in a sync mode (synchronize instance)
binding.addSync = "Synchronizacja";
binding.addSync.help = "Domyślnie, będzie używał wartości synchronizacji ustawionej w menu sceny.";
// Binding option
binding.context.toggle = "Przełącz kontekst";
// quick sidebar tool shortcuts
binding.quicks = "Szybkie skróty";
// quick regular tool shortcuts
binding.tools = "Skróty narzędzi";
// When the key is tapped once, the value will be toggled
binding.toggle = "Przełącz poprzednie narzędzie";
binding.toggle.help = "Użyj tego samego skrótu, aby wrócić do ostatniego narzędzia.";
// sticky keys
binding.sticky = "Klawisze lepne";
binding.sticky.off = "Przytrzymaj";
binding.sticky.off.help = "Przytrzymaj klawisz, aby użyć narzędzia, zwolnij, aby wrócić do poprzedniego narzędzia.";
binding.sticky.on = "Przełącz";
binding.sticky.on.help = "Naciśnij raz, aby zmienić narzędzie.";
binding.sticky.quick = "Szybkie naciśnięcie";
binding.sticky.quick.help = "Przytrzymaj, aby użyć tymczasowo, szybkie naciśnięcie, aby zmienić.";
// The binding force camera movement
binding.forceCamera = "Wymuś kamerę";
binding.forceCamera.help = "Wymuś interakcję kamery w przypadku konfliktu z innym wiązaniem.

Zwykle może się to zdarzyć, jeśli to samo wiązanie jest przypisane do skrótu narzędzia lub Dodaj/Odejmij.";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickMaterial = "Selektor materiału";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickFaceGroup = "Wybierz grupę ścian";
// Edit the tool brush size/radius
binding.editRadius = "Promień narzędzia";
// Inverse direction zooming
binding.invertZoomY = "Odwróć zoom Y";
// Edit the tool brush size/radius
binding.editIntensity = "Intensywność narzędzia";
// Controller dead zone
binding.joystick = "Joystick";
binding.controller.deadZone = "Strefa martwego pola";
binding.controller.deadZone.help = "Zwiększ tę wartość, jeśli kamera porusza się, nawet gdy drążek kontrolera jest nietknięty.";
// Snap the camera
binding.view.front = "Widok z przodu";
binding.view.left = "Widok z lewej";
binding.view.top = "Widok z góry";
// Move/Translate the view
binding.pan.left = "Przesuń w lewo";
binding.pan.right = "Przesuń w prawo";
binding.pan.forward = "Przesuń do przodu";
binding.pan.backward = "Przesuń do tyłu";
binding.pan.up = "Przesuń do góry";
binding.pan.down = "Przesuń do dołu";
// Snap the view (while rotating)
binding.snapViewOnRotate = "Przyciągnij widok (podczas obracania)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "Otwórz (projekt)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "Dodaj (projekt)";
// Select all the objects in the scene
binding.selectAll = "Zaznacz wszystko";
// Rotate environment and the lighting
binding.rotateLighting = "Obróć oświetlenie";
// The Camera pivot is the point around which the camera rotates
binding.updatePivot = "Punkt obrotu";

quadremesh.adaptQuadCount = "Adaptacyjna liczba czworoboków";
quadremesh.curvatureAdaptivness = "Adaptacyjny rozmiar";
quadremesh.curvatureAdaptivness.help = "Przy 100%, rozmiar czworoboków będzie się zmieniał w zależności od krzywizny obiektu, pozwalając na mniejsze czworoboki na obszarach o dużej krzywiźnie.
Przy 0%, rozmiar czworoboków będzie jednolity.";
quadremesh.useVertexColors = "Zachowaj malowanie";
quadremesh.autoDetectHardEdges = "Automatyczne wykrywanie twardych krawędzi";
quadremesh.autoDetectHardEdges.short = "Intensywne Światło";
quadremesh.reprojectVertex = "Przeprojektuj Wierzchołek";
quadremesh.reprojectVertex.short = "Przeprojektuj Wierzchołek";
quadremesh.reprojectVertex.label = "Po włączeniu, Nomad przeprojektuje pozycję na poprzedniej siatce.

Uwaga, jeśli siatka ma warstwy, to przeprojektowanie będzie zawsze używane.";

// Privacy policy
privacyPolicy.title = "Polityka prywatności";
privacyPolicy.reject = "Odrzuć";
// Hexanomad is the company name
privacyPolicy = "Hexanomad nie gromadzi żadnych danych z aplikacji Nomad Sculpt.";

sonar.disconnect = "Odłącz SonarPen";
sonar.connect = "Połącz SonarPen";
sonar.connect.confirm = "Połączyć SonarPen?";
sonar.connect.confirm.warning = "Sonar Pen będzie używać mikrofonu (powrotne sprzężenie audio) do wykrywania nacisku pióra.";

// Color disc mode
widget.color.disc = "Dysk";
widget.color.ring = "Pierścień";
widget.color.square = "Kwadrat";

nomad.mainFolder = "Główny folder Nomad";
nomad.mainFolder.warning = "Pliki pozostają nietknięte.
Nie są kopiowane, usuwane ani przenoszone.";
nomad.mainFolder.error = "Po wybraniu tak, Nomad zostanie zamknięty, a Ty możesz go po prostu ponownie uruchomić.";

license.title = "Licencja";
license.retry = "Ponów próbę";
license.key = "Klucz licencyjny";
license.activate = "Aktywuj licencję";
// ----------------------------------------------
license.newest = "Dostępna nowa wersja!";
license.encrypt.error = "Nie można zaszyfrować!";
// ----------------------------------------------
license.grace = "Offline - Pozostały czas przypadający:";
license.grace.hours = "godziny";
license.grace.days = "dni";
// ----------------------------------------------
license.portal.title = "Istniejący użytkownicy";
license.portal.label = "Portal licencyjny";
// ----------------------------------------------
license.checkout.title = "Nowi użytkownicy";
license.checkout.label = "Kup Nomad";
// ----------------------------------------------
license.device.error = "Nie można uzyskać ID urządzenia.";
license.device.mismatch = "Niezgodność ID urządzenia!";
// ----------------------------------------------
license.error429 = "Zbyt wiele żądań (poczekaj).";
// ----------------------------------------------
license.validate.error404 = "Nie znaleziono klucza licencyjnego.";
license.validate.error422 = "Nieprzetwarzalna jednostka.";
// ----------------------------------------------
license.activate.error403 = "Osiągnięto maksymalną liczbę urządzeń!
Możesz dezaktywować inne urządzenie w swoim portalu licencyjnym.";
license.activate.error404 = "Nie znaleziono klucza licencyjnego.";
license.activate.error422 = "Nieprzetwarzalna jednostka.";
// ----------------------------------------------
// version
version.update = "Dostępna aktualizacja!";
version.restore = "Przywróć zakup";
version.buyWeb = "Wersja internetowa to tylko demonstracja";
version.buyFull = "Przejdź na pełną wersję";
// ----------------------------------------------
// QuadRemesh
version.qr.unlock = "Odblokuj (zakup, przywrócenie, wersja próbna)";
version.qr.desktop = "Na komputerze QuadRemesher jest dystrybuowany przez Hexanomad, ale Hexanomad nie zajmuje się sprzedażą ani licencjonowaniem.
Zarządzanie licencjami jest prowadzone przez Exoside.";
version.qr.buy = "Zakup";
version.qr.promo = "
Quad Remesher to algorytm, który generuje siatkę z dominacją czworoboków.
Rozkład czworoboków będzie próbował podążać za naturalną krzywizną obiektu.

Algorytm może również dostosować rozmiar czworoboków w zależności od lokalnej krzywizny.

Możesz również kierować wynikową topologią za pomocą:

• Grupa ścian $0 (upewnij się, że ich granice są wygładzone dla lepszego rezultatu!)

• Symetria płaszczyznowa X/Y/Z $1

• Przewodniki krzywych $2

• Malowanie gęstości $3

Quad Remesher jest rozwijany przez https://exoside.com/.";
// ----------------------------------------------
version.trialLayer = "Wersja próbna: 1 warstwa na siatkę";
version.trialNoExport = "Wersja próbna: brak eksportu";
// ----------------------------------------------
version.fullFeatures = "• Jednorazowy zakup
• Nieograniczona liczba operacji cofnięcia/ponowienia
• Nieograniczona liczba warstw
• Eksport i import";
// ----------------------------------------------
version.demo.purpose = "Ta wersja została stworzona specjalnie na potrzeby demonstracji.";
version.demo.disable = "Funkcja nie jest dostępna w wersji demonstracyjnej.";
// ----------------------------------------------
version.demo = "Demo Test";
version.demo.sculpt = "Rzeźbienie";
version.demo.sculpt.help = "Wszystkie pędzle są dostępne, ale nie można zapisać ani eksportować.

Ten tryb głównie służy do eksperymentowania z pędzlami lub testowania wsparcia dla czułości nacisku.

Inne funkcje mogą być również ograniczone (historia, warstwy).";
version.demo.file = "Import i eksport";
version.demo.file.help = "Można importować i eksportować model, ale pędzle rzeźbiarskie są wyłączone.

Ten tryb jest głównie przydatny dla użytkowników mobilnych, którzy nie mogą otworzyć dużych projektów .nom ze względu na ograniczenia pamięci w urządzeniach mobilnych.";
// ----------------------------------------------
// app store main page
store.name = "Nomad Sculpt";
store.headline = "Rzeźb, maluj i twórz w 3D";
store.tag = "sculpt, 3d, nomad, paint, modeling, rzeźba, malowanie, modelowanie";
// ----------------------------------------------
store.description.sculpt = "• Narzędzia do rzeźbienia
Glinka, spłaszczanie, wygładzanie, maska i wiele innych pędzli pozwoli Ci kształtować Twoje dzieło.
Możesz również użyć narzędzia do cięcia booleanowego z lasso, prostokątem i innymi kształtami, dla celów hardsurface.";
// ----------------------------------------------
store.description.stroke = "• Dostosowywanie pociągnięć
Zanikanie, alpha, układanie, nacisk ołówka i inne parametry pociągnięcia mogą być dostosowane.
Możesz również zapisać i wczytać swój zestaw narzędzi.";
// ----------------------------------------------
store.description.paint = "• Narzędzia do malowania
Malowanie wierzchołków kolorem, chropowatością i metalicznością.
Możesz również łatwo zarządzać wszystkimi swoimi predefiniowanymi materiałami.";
// ----------------------------------------------
store.description.layer = "• Warstwy
Zapisuj swoje operacje rzeźbienia i malowania w oddzielnych warstwach dla łatwiejszej iteracji podczas procesu tworzenia.
Zmiany zarówno w rzeźbieniu, jak i malowaniu są zapisywane.";
// ----------------------------------------------
store.description.multires = "• Rzeźbienie wielorozdzielczościowe
Przechodź w tę i z powrotem między wieloma rozdzielczościami siatki dla elastycznego przepływu pracy.";
// ----------------------------------------------
store.description.voxel = "• Voxel remeshing
Szybko zmień swoją siatkę, aby uzyskać jednolity poziom szczegółów.
Może być używane do szybkiego szkicowania przybliżonego kształtu na początku procesu tworzenia.";
// ----------------------------------------------
store.description.dynamic = "• Dynamiczna topologia
Lokalnie dopracuj swoją siatkę pod pędzlem, aby uzyskać automatyczny poziom szczegółowości.
Możesz nawet zachować swoje warstwy, ponieważ zostaną one automatycznie zaktualizowane!";
// ----------------------------------------------
store.description.topology = "• Decymacja
Zmniejsz liczbę wielokątów, zachowując jak najwięcej szczegółów.";
// ----------------------------------------------
store.description.group = "• Grupa twarzy
Podziel swoją siatkę na podgrupy za pomocą narzędzia do grupowania twarzy.";
// ----------------------------------------------
store.description.unwrap = "• Automatyczne rozwijanie UV
Automatyczny rozwijacz UV może używać grup twarzy do kontrolowania procesu rozwijania.";
// ----------------------------------------------
store.description.baking = "• Baking
Możesz przenosić dane wierzchołków takie jak kolor, chropowatość, metaliczność i małe szczegóły na tekstury.
Możesz również robić odwrotnie, przenosząc dane tekstur na dane wierzchołków lub warstwy.";
// ----------------------------------------------
store.description.primitive = "• Kształty pierwotne
Cylinder, torus, rura, tokarka i inne pierwotne mogą być używane do szybkiego rozpoczynania nowych kształtów od zera.";
// ----------------------------------------------
store.description.rendering = "• Renderowanie PBR
Piękne domyślne renderowanie PBR, z oświetleniem i cieniami.
Zawsze możesz przełączyć się na MatCap dla bardziej standardowego cieniowania do celów rzeźbienia.";
// ----------------------------------------------
store.description.postprocess = "• Post processing
Screen Space Reflection, Depth of Field, Ambient Occlusion, Tone mapping itp.";
// ----------------------------------------------
store.description.files = "• Eksport i import
Obsługiwane formaty obejmują pliki glTF, OBJ, STL lub PLY.";
// ----------------------------------------------
store.description.interface = "• Interfejs
Łatwy w użyciu interfejs, zaprojektowany z myślą o doświadczeniu mobilnym.
Dostosowanie jest również możliwe!";
// ----------------------------------------------
store.description.remesher = "• Quad Remesher (dostępny tylko jako oddzielny zakup w aplikacji)
Automatycznie zmień siatkę swojego obiektu na siatkę zdominowaną przez kwady, która śledzi krzywizny siatki.
Wspiera przewodniki, grupy twarzy i malowanie gęstości.";
// ----------------------------------------------