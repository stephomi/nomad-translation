// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "Potwierdzić?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Tak";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "OK";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Anuluj";

// Name of an item (object, tool, etc)
item.name = "Nazwa";
// Add a new item (object, tool, etc)
item.new = "Nowy";
// Rename an item (object, tool, etc)
item.rename = "Zmień nazwę";
// Add a new item (object, tool, project, etc)
item.add = "Dodaj";
// Save an item (object, tool, etc)
item.save = "Zachowaj";
item.save.confirm = "Potwierdzić zapisanie?";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Ostatni zapis";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "Załadować ostatni zapis?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Wyzeruj";
item.reset.confirm = "Potwierdzić zresetowanie?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "Utwórz instancję";
// Uninstance the object, make the object real
item.uninstance = "Anuluj instancję";
// Clone an item (object, tool, etc)
item.clone = "Klonuj";
// Delete an item (object, tool, etc)
item.delete = "Usuń";
item.delete.confirm = "Potwierdzić usunięcie?";
item.delete.confirm.yes = "Tak, usuń";
// When we delete the item but the image is used somewhere
item.delete.imageUsed = "Używane przez następujące narzędzia:";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "Do węzła";
// Item visibility (object, layer, etc)
item.visible = "Widoczne";
// Show an item (object, layer, etc)
item.show = "Pokaż";
// Hide an item (object, layer, etc)
item.hide = "Ukryj";
// Select an item (object, layer, etc)
item.select = "Wybierz";
// Unselect an item (object, layer, etc)
item.unselect = "Anuluj zaznaczenie";
// Merge an item with another one below (layer)
item.mergeDown = "Scal w dół";
// The order of an item in a list
item.order = "Kolejność";
// Focus on previous item
item.previous = "Poprzedni";
// Focus on next item
item.next = "Dalej";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "Zablokuj";

// Three-state toggle button (Auto, Off, On)
toggle.on = "Wł.";
// Three-state toggle button (Auto, Off, On)
toggle.off = "Wył.";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "Auto";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Brak miniatur, ponowne przetwarzanie plików... ($0/$1)

$2";
loading.reprocess.cancel = "";

// Color of an object
material.color = "Kolor";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "Nierówność";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "Połysk";
// Whether the material is a metal or not
material.metalness = "Metaliczność";
// How much light a surface will reflect
material.specular = "Zwierciadlane";
// Light that the surface can emit (glow)
material.emissive = "Emisyjne";
// Normal map (synonym: detail, bump)
material.normal = "Normalna";
// Ambient Occlusion (AO)
material.occlusion = "Okluzja";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "Tekstury";

// Minify
about.minify = "Minimalizuj interfejs użytkownika";
about.minify.help = "Możesz także stuknąć ekran 4 palcami, jeśli Twoje urządzenie to obsługuje.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Obrotnica";
// Make the entire scene turn around (speed of the animation)
about.turntableSpeed = "Prędkość obrotnicy";
// Stuffs that I used to make the app
about.credits = "Autorzy";
// Link to open source projects that I used for the app
about.credits.openSource = "Open Source";
// Only translate the &
about.credits.arts = "MatCap i HDRI";
// Change languages of the app
about.languages = "Języki";
about.languages.help = "Pliki tłumaczenia dostępne na stronie $0";
// Link to the App Website
about.website = "Witryna";
// Link to the App Forum
about.forum = "Forum";
// Link to the App Manual
about.manual = "Instrukcja obsługi";
// Link to the App Email
about.mail = "Wsparcie techniczne";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";

// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "Obiekt nie ma żadnych otworów!";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "Bieżący obiekt jest niewidoczny!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Nie ma nic do przycięcia.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Przerwij przycinanie: obiekt jest w pełni przycięty.";
// In order to extract something, the mesh needs to have painted mask
alert.mask.noExtract = "Nie ma nic do wyodrębnienia!";
// In order to split something, the mesh needs to have painted mask
alert.mask.noSplit = "Nie ma nic do podziału!";
// List of disabled features when View Mode is selected
alert.view.disabled = "Funkcje wyłączone w trybie wyświetlania:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Widżety prymitywów";
// The object needs to have two parts disconnected
alert.separate.fail = "Nie można rozdzielić: obiekt ma tylko jedną część!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "Ponownie utworzono siatkę!";
alert.voxelRemesh.empty = "Przerwij ponowne tworzenie siatki: siatka wynikowa nie ma powierzchni.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "Nieprawidłowe dane wejściowe!";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "Obiekt zostanie zduplikowany";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "Zostanie utworzona instancja obiektu";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Edytuj tryb punktu obrotu.";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "Edytuj tryb obiektu.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Aktywna topologia dynamiczna";
// See Glossary (DynTopo)
alert.dynamic.disable = "Wyłącz topologię dynamiczną";
alert.colorPicker = "Przeciągnij palcem po obiekcie, aby wybrać kolor.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Po prostu stuknij, aby opuścić tryb transformacji.";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "";
alert.view.reset = "Resetuj widok";
// Snap the view to the nearest aligned 90° angle
alert.view.snap = "Przyciągnij widok";
// Show the painted mask on the mesh
alert.mask.show = "Pokaż maskę";
// Hide the painted mask on the mesh
alert.mask.hide = "Ukryj maskę";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Zablokuj zaznaczenie";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Odblokuj zaznaczenie";
// Hide the objects that are not selected
alert.selection.isolate = "Izoluj zaznaczenie";
// Show the objects that are hidden
alert.selection.showAll = "Pokaż wszystko";
// Project quick saving
alert.quickSave = "Zapisywanie...";
// Painting on the object was hidden but the user did paint the object
alert.forceShowPainting.fill = "Aktywowano wyświetlanie malowania, użyto [Maluj wszystko].";
// Painting on the object was hidden but the user started to paint on the object
alert.forceShowPainting.tool = "Aktywowano wyświetlanie malowania, obiekt został pomalowany.";
// See Glossary (Multiresolution)
alert.multiresLost = "Wielokrotna rozdzielczość zostanie utracona!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "Wartość szczegółów jest wysoka i może wymagać dużej ilości pamięci!";
// Autosave popup
alert.autoSave.auto = "Automatyczny zapis za... $0s";
// The selected object doesn't have any layers
alert.needLayer = "Bieżące narzędzie wymaga aktywnej warstwy.";
// The user decides to hide the painting on the objects
alert.paintingHidden = "Malowanie ukryte: pokaż je ponownie w panelu Ustawienia.";
// The selected object doesn't have any layers
alert.noPartialWireframe = "Częściowy rysunek jest wyłączony, gdy wyświetlany jest szkielet.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Rozważ użycie kamery ortograficznej, jeśli chcesz uniknąć zniekształcenia obszaru perspektywy podczas korzystania z projektora ekranowego.";
// Trial version has a limited number of undo
alert.state.trial = "Wersja próbna: anulowano cofanie";

background = "Tło";
// A flat color will be displayed in the background of the scene
background.color = "Kolor";
// The environment (HDRI) will be displayed in the background
background.environment = "Środowisko";
background.blur = "Rozmycie";
background.exposure = "Ekspozycja";

// Image that the artist uses as a reference
background.imageEnable = "Obraz referencyjny";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Nakładka";
// Opposite of transparency (Alpha)
background.imageAlpha = "Krycie";
background.imageReset = "Resetuj ustawienia";
background.imageTransform = "Przekształcenie";
// X screen coordinate of the image reference
background.imageX = "Pozycja X";
// Y screen coordinate of the image reference
background.imageY = "Pozycja Y";
// Rotation of the reference image
background.imageRotation = "Obrót";
// Scale of the reference image
background.imageScale = "Skala";

// Camera (point of view in 3d)
camera = "Aparat";
// Copy the views
camera.updateView = "Zaktualizować punkt widoku?";
// Add a new camera
camera.addView = "Dodaj widok";
// Focus on the camera
camera.focus = "Ostrość";
// Add on the camera camera
camera.focusOn = "Ostrość na $0";
// Camera projection, Orthographic or Perspective
camera.projection = "Projekcja";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Ortograficzne";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Perspektywa";
// camera Vertical Field of View
camera.fov = "Pionowe pole widzenia";
// Camera Field of View hint
camera.focal = "ogniskowa $0 mm (matryca 35 mm)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Obrót";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "Obrotnica";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Trackball";
camera.rotation.trackball.help = "Trackball daje większy stopień swobody, można też obracać kamerą za pomocą 2 palców.";
// Camera interaction mode, 1st person view
camera.firstPerson = "Pierwsza osoba";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Szybkość";
// Camera rotation sensitivity
camera.speed.rotation = "Obrót";
// Camera panning sensitivity
camera.speed.panning = "Przesuwanie";
// Camera zooming sensitivity
camera.speed.zooming = "Powiększanie";
// Reset camera position
camera.resetView = "Resetuj widok";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Przyciągnij widok";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "Kamera jest wyrównana (ortograficznie)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "Wyrównanie ortograficzne";
camera.snapOrthographic.help = "Ta opcja działa także w przypadku użycia opcji Przyciągnij kostkę w narożniku.";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Punkt obrotu";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Stuknij dwukrotnie obiekt";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Stuknij dwukrotnie tło";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "Przełącz";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "Zaznaczenie";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "Scena";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "Zaktualizuj po podwójnym stuknięciu";
camera.doubleTapPivot.help = "Zaktualizuj punkt obrotu po dwukrotnym stuknięciu powierzchni obiektu.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "Punkt obrotu w powietrzu";
camera.airPivot.help = "Zezwól na nowy punkt obrotu nawet przy powiększaniu poza powierzchnię obiektu.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "Przy geście uruchomienia kamery";
camera.autoPivot.help = "Zaktualizuj punkt obrotu przy rozpoczynaniu interakcji z kamerą.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Ostrość";
camera.doubleTapFocus.help = "Po dwukrotnym stuknięciu obiektu kamera przesunie się i ustawi ostrość na wybranym punkcje.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "Wielokrotne zaznaczenie";
// There is 0 nodes/items selected
context.noSelection = "Brak zaznaczenia";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "Ustawienie wstępne";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "Splajn";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "";

// set the desired FPS (frame per second, refresh rate)
debug.targetFPS = "";
debug.targetFPS.help = "";

// Debug option, the newly created primitives will contains texture coordinates (UVs)
debug.uvPrimitive = "Zachowaj UV prymitywów";
debug.uvPrimitive.warning = "Wyłącz tę opcję, jeśli nie potrzebujesz UV (dodatkowa pamięć).";
debug.uvPrimitive.help = "Obecnie obsługiwane są tylko typy Równoległościan i Kula.

Inne typy będą obsługiwane w przyszłości.";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "Normalizuj UV";
debug.uvNormalize.help = "Nomad będzie normalizować UV w kafelku [0-1].";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "Dodaj UV BFF";
debug.uvBFF.help = "Dodaj alternatywną metodę obliczania (boundary first flattening).

BFF będzie generować nakładki, jeśli topologia twojej siatki jest inna niż dysk lub kula.";
// Debug option, display an window with some debugging logs
debug.logs = "Dzienniki";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Mapa wysokości";
// Debug options, graphical stuffs
debug.graphics = "Grafika";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Utwórz miniatury dla sklepu";

// Empty list: there is no projects
file.project.empty = "Nie zapisano jeszcze żadnego projektu!";
// The current opened project has some unsaved changes
file.project.unsaved = "Niezapisane zmiany!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "Utracisz niezapisane zmiany!";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Podgląd ostatniego zapisu ręcznego";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "Wersja próbna: nie będzie możliwe ponowne otwarcie bieżącego projektu!";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "Wersja próbna: można otworzyć ponownie tylko bieżący projekt!";

file.project = "Projekt";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Zachowaj";
// E.g: Save "my_project"?
file.project.save.confirm = "Zapisać $0?";
// Save to another project (either new one or overriding existing one)
file.project.saveAs = "Zapisz jako";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "Nadpisać $0?";
// Open a project
file.project.open = "Otwórz";
// E.g: Open "my_project"?
file.project.open.confirm = "Otworzyć $0?";
// Load another project and add/append all its data to the current scene
file.project.add = "Dodaj do sceny";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "Dodać $0 do sceny?";
// Reset the scene and create a new project
file.project.new = "Nowy";
file.project.new.confirm = "Utworzyć nową scenę?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "Usunąć $0?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "Usunąć $0?

To jest bieżący aktywny projekt!";

// Auto save section
file.project.autoSave = "Automatyczny zapis";
file.project.autoSave.confirm = "Wyłączyć automatyczny zapis?";
file.project.autoSave.help = "Zapisuj regularnie projekt w oddzielnym pliku.
Plik automatycznego zapisu można znaleźć w:

$0";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "Przekroczenie limitu czasu okienka wyskakującego";
// In minutes
file.project.autoSave.minutes = "Okno wyskakujące czasomierza";
// Delete the current autoSave data
file.project.autoSave.delete = "Odrzuć automatyczny zapis";

// Load interface preference settings when opening a scene file
file.load.guiSettings = "Zachowaj ustawienia interfejsu GUI";
file.load.guiSettings.help = "Podczas otwierania lub importowania pliku projektu zostaną załadowane wszystkie ustawienia związane z interfejsem GUI, które są osadzone w projekcie.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.load.objSplitByGroup = "Podziel OBJ według grup";
file.load.objSplitByGroup.help = "Po włączeniu Nomad podzieli grupy OBJ na oddzielne obiekty.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.load.mergeLayers = "Scal warstwy";
// Ignore the textures present in the file to load
file.load.skipTextures = "Pomiń tekstury";
// Do not fiddle with the object topology when loading the file
file.load.keepTopology = "Zachowaj topologię";
file.load.keepTopology.help = "Użyj tej opcji, jeśli nie chcesz, by Nomad zmodyfikował topologię importowanej siatki.

Wyłączy ona zmianę kolejności wierzchołków/powierzchni, usuwanie duplikatów wierzchołków/powierzchni i usuwanie nieużywanych wierzchołków.";
// If the object has more vertices than this value, then we won't attemp to reverse (multiresolution) the object
file.load.reverseVertices = "Odwróć próg";
file.load.reverseVertices.help = "Aby zużywać mniej pamięci, Nomad nie zapisuje niższej rozdzielczości siatki.

Odbuduje jednak niższą rozdzielczość, jeśli liczba wierzchołków jest mniejsza niż ten próg.";


// Configure imports option
file.importSettings = "Opcje importu";

// Import file section
file.import.title = "Importuj";
file.import.title.help = "Obsługiwany format:
- Wavefront (.obj)
- glTF 2.0 (.glb .gltf)
- STL (.stl)";
// The user imports a scene file that will replace the current scene
file.import.open = "Otwórz";
file.import.open.confirm = "Zaimportować nowy plik?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Dodaj do sceny";
file.import.add.confirm = "Zaimportować nowy plik?";

// Export scene file
file.export.title = "Eksportuj";
file.export.title.help = "Jeśli to możliwe, preferuj eksport glTF, ponieważ obsługuje on więcej funkcji niż inne formaty.";

// Export the current selected objects instead of the entire scene
file.onlySelection = "Dołącz tylko zaznaczone obiekty";
file.onlySelection.help = "Dołącz tylko zaznaczenie, a nie całą scenę.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Rekonstruuj czworokąty";
file.convertToQuad.help = "Rekonstruuj czworokąty z trójkątów poprzez parowanie trójkątów (jeśli są sąsiadujące w plikach).";

// Whether we include the textures in the exported file
file.export.texture = "Eksportuj tekstury";
// Baking means transfering/converting
file.export.texture.help = "Ta opcja nie zapisuje kolorów wierzchołków w teksturach.";
// Whether we include normals vector in the exported file
file.export.normal = "Eksportuj normalne";
file.export.normal.help = "Zaznacz tę opcję, jeśli chcesz otworzyć plik w innym programie.

Nomad zawsze ignoruje normale, ponieważ będzie je ponownie obliczać.";

file.export.gltf = "Eksportuj glTF 2.0";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Eksportuj warstwy";
file.export.gltf.layer.help = "Eksportuj warstwy jako morfy. Oficjalnie obsługiwane przez glTF więc powinno to działać również w innych programach.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Eksportuj malowanie warstwy";
file.export.gltf.layerPaint.help = "Eksportuj malowanie warstwy. Zwykle jest to ignorowane przez inne programy.";
// Whether the exported layer will use the non-standard Nomad encoding (smaller size)
file.export.gltf.layerNomad = "Kodowanie warstw Nomad";
file.export.gltf.layerNomad.help = "Może zmniejszyć plik, zapisując warstwę farby w 8 bitach zamiast 16-bitach.

To kodowanie działa tylko w aplikacji Nomad, ponieważ będzie używać malowania bezwzględnego.
Inne programy będą miały nieprawidłowe wyniki, ponieważ glTF wymaga kodowania względnego.";
// Whether we include the vertex color in the exported file
file.export.gltf.color0 = "Eksportuj kolory wierzchołków";
file.export.gltf.color0.help = "Eksportuj kolory wierzchołków. Oficjalnie obsługiwane przez glTF więc powinno to działać również w innych programach.";
// Whether we include the vertex roughness and vertex metalness in the exported file
file.export.gltf.color1 = "Eksportuj malowanie PBR";
file.export.gltf.color1.help = "Eksportuj chropowatość, metaliczność i malowanie masek. Będzie to ignorowane przez inne programy.";

file.export.obj = "Eksportuj OBJ";
file.export.obj.warning = "Warstwy i dodatkowe malowanie (chropowatość, metaliczność i maski) zostaną utracone.";
// Whether we include the vertex color in the exported file
file.export.obj.colorAppend = "Eksportuj kolory wierzchołków";
file.export.obj.colorAppend.help = "Dodaj informacje o kolorze po wierzchołkach.

Niektóre programy 3D będą w stanie to odczytać, ale nie wszystkie.";

file.export.stl = "Eksportuj STL";
file.export.stl.warning = "Warstwy i dodatkowe malowanie (chropowatość, metaliczność i maski) zostaną utracone.";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Eksportuj kolory wierzchołków";
file.export.stl.color.help = "Niektóre programy 3D będą w stanie to odczytać, ale nie wszystkie.";
file.export.stl.ascii = "Domyślny format to binarny.

Możesz wybrać eksport do formatu tekstowego (ASCII), ale plik będzie większy.";

// Advanced settings
settings.advanced = "Zaawansowane";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "Te opcje nie są zapisywane w ustawieniach.";
settings.reset.title = "Ustawienia";
settings.reset.title.help = "Spowoduje to zresetowanie ustawień preferencji aplikacji.

Niektóre zasoby są zapisywane osobno i NIE zostaną zresetowane; obejmuje to:
- Projekty
- Powiązania klawiszy
- Ustawienia domyśłne narzędzi
- Środowiska HDR
- MatCap
- Alfa
- Tekstury (pędzel)
- Obrazy referencyjne

Należy pamiętać, że wszystko, co jest związane z projektem, zostanie zachowane w nienaruszonym stanie, np. oświetlenie, postprocessing i widoki kamery.";

// Reset preference settings button
settings.reset = "Przywróć domyślne";
settings.reset.confirm = "Zresetować ustawienia preferencji?";

// Render a screenshot of the scene
file.render = "Renderuj";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Pokaż interfejs";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Współczynnik renderowania";
file.render.renderRatio.help = "Wartość 1,0 oznacza, że Nomad będzie renderować z tą samą rozdzielczością co żądany rozmiar obrazu poniżej.

Użyj tej opcji, jeśli nie można renderować w określonej rozdzielczości (awarie ze względu na brak pamięci).";
// Desired size of the exported screenshot
file.render.size = "Końcowy rozmiar";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Niestandardowy";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "raster";
// width of exported screenshot
file.render.width = "Szerokość";
// height of exported screenshot
file.render.height = "Wysokość";
// export screenshot of the scene
file.render.export = "Eksportuj PNG";
file.render.warn = "Rozdzielczość eksportu jest wysoka ($0x$1)!

Pamiętaj, aby zapisać projekt na wypadek, gdyby w urządzeniu zabrakło pamięci VRAM i nastąpiła awaria.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Przezroczyste tło";
file.render.transparent.help = "Ta opcja może być przydatna, jeśli chcesz wstawić siatkę do programu do tworzenia 2D.

Częściowa przezroczystość obiektu nie jest na razie obsługiwana.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Użyj ustawień globalnych";
pressure.useGlobal.help = "Domyślnie narzędzia mają takie same ustawienia nacisku.

Usuń zaznaczenie tej opcji, jeśli chcesz uzyskać określone ustawienia nacisku dla tego narzędzia.";

// Pencil pressure
pressure.title = "Nacisk";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "To narzędzie nie używa nacisku ołówka.";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "Typ przechwytywania pociągnięć będzie ignorować ustawienia nacisku.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Promień";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Intensywność";

// Customize whether finger and/or stylus can move the Camera
gesture.cameraInteraction = "Aparat:";
// Customize whether finger and/or stylus can sculpt on object
gesture.sculptInteraction = "Rzeźbienie:";
// Both the finger and the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.fingerAndStylus = "Palec i piórko";
// Only the finger can perform a certain action (move camera, sculpt, etc)
gesture.interaction.finger = "Palec";
// Only the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.stylus = "Piórko";
// Disable the action
gesture.interaction.none = "Brak";
// Allow the action for any inputs
gesture.interaction.any = "Dowolne";

// long press to pick the color/material under the cursor
gesture.materialPicking = "Wybór materiału";
gesture.materialPicking.help = "Selektor kolorów/materiałów można wyzwolić przez długie naciśnięcie na obszarze roboczym.

Działa to tylko wtedy, gdy dla bieżącego pędzla jest włączone malowanie.";

// Three fingers on screen
gesture.three.title = "Trzy palce";
// Drag 3 fingers horizontally on the canvas to rotate the environment, lights and MatCap
gesture.fingerLighting = "Obróć oświetlenie (3 palce)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerLighting.help = "Przeciągnij 3 palcami poziomo po obszarze roboczym, aby obrócić środowisko, światła i MatCap.";
// Drag 3 fingers vertically to edit the tool radius
gesture.fingerRadius = "Edytuj promień narzędzia (3 palce)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerRadius.help = "Przeciągnij 3 palcami pionowo po obszarze roboczym, aby edytować promień narzędzia.";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.fingerSmooth = "Palec zawsze wygładza";
gesture.fingerSmooth.help = "";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Zezwól na nierozpoznany nacisk";
gesture.unknownPressure.help = "Zaznacz tę opcję, jeśli nacisk nie działa z Twoim ołówkiem lub jeśli potrzebujesz palca do nacisku.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Przycisk ołówka";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Dwukrotne stuknięcie ołówkiem";
gesture.pencilAction.ios.help = "Aktywny tylko dla rysika Apple Pencil 2. generacji.";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "Brak";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Dodaj/odejmij";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "Skróty jednym stuknięciem";
gesture.mask.oneTap.help = "Zezwól na skrót Maska poprzez jednokrotne stuknięcie ekranu, bez konieczności przytrzymania skrótu przycisku Maska.

Umożliwia to następujące gesty:
- stuknięcie tła w celu odwrócenia maski
- stuknięcie zamaskowanego obszaru w celu rozmycia maski
- stuknięcie niezamaskowanego obszaru w celu wyostrzenia maski";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress = "Naciśnięcie i przytrzymanie (Maska ↔ Zaz. maskę)";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress.help = "Gdy aktywna jest Maska lub Zaz. maskę, naciśnięcie i przytrzymanie palcem powoduje przełączanie między tymi narzędziami.

Jeśli naciśniesz i przytrzymasz bez przesuwania palca, nowe narzędzie będzie używane jako domyślny skrót dla maski.";
// Indicator that the tool has been set as the new shortcut
gesture.mask.infoShortcut = "$0 ustawiono jako skrót maski.";

// Shortcuts to undo/redo
gesture.history = "Skróty historii";
gesture.history.help = "- Cofnij: stuknięcie 2 palcami
- Ponów: stuknięcie 3 palcami
- Cofnij/Ponów: naciśnięcie i przytrzymanie 2/3 palcami (w sposób ciągły)";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Odrzucenie przypadkowego dotknięcia nadgarstkiem";
gesture.palmRejection.confirm = "Pamiętaj, aby wyłączyć tę opcję, jeśli masz trudności z interakcją z obszarem roboczym!";
gesture.palmRejection.help = "Odrzuć wprowadzanie, jeśli rozmiar obszaru kontaktu jest większy niż ta wartość.

Może nie działać na każdym urządzeniu.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Maks. próg rozmiaru";

// History, list of undo/redo
history = "Historia";
// First "undo" state
history.root = "Początek";
history.undoConfirm = "Czy potwierdzasz cofnięcie wszystkich tych operacji?";
history.undoWarning = "Jeśli dokonasz później zmiany, możesz utracić wiele zmian.";
// Settings concerning the history stack of undo/redo
history.stack = "Stos";
// Actions to include in the undo/redo stack
history.include = "Dołącz działania";
// include lighting editing in the undo/redo
history.includeLights = "Światła";
history.includeLights.help = "Jeśli ta opcja jest wyłączona, przesuwanie świateł za pomocą Gizmo nadal będzie uwzględniane, ponieważ może mieć wpływ na inne obiekty w hierarchii sceny.";
// include postProcess editing in the undo/redo
history.includePostProcess = "Postprocessing";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCap i HDRI";
// Can limit the stack of undo/redo size
history.limitSize = "Limit historii (MB)";
history.limitSize.help = "Maksymalny rozmiar historii (w MB).

Historia zostanie zaktualizowana przy następnej zarejestrowanej operacji.";
// Limit the number of undo in the history stack
history.limitStack = "Limit stosu";
history.limitStack.help = "Maksymalna liczba operacji, którą aplikacja może zachować.

Historia zostanie zaktualizowana przy kolejnej zapisanej operacji.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Maks. liczba operacji do cofnięcia";
history.rangeProtect.help = "Jeśli zajdziesz daleko w historii, przed cofnięciem wielu operacji wyświetli się okno dialogowe potwierdzenia.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Przywróć kamerę";
history.restoreCamera.help = "Włącz tę opcję, aby przywrócić zapisany punkt widzenia kamery w przypadku cofnięcia/ponownego wykonania czynności.";
// Undo
history.undo = "Cofnij";
// Redo
history.redo = "Przywróć";
// Shown during undo
history.state.undo = "Cofnij: $0";
// Shown during redo
history.state.redo = "Ponów: $0";
// Shown during undo/redo
history.state.symmetrySplit = "Podział symetryczny";
// Shown during undo/redo
history.state.voxelRemesh = "Ponowne tworzenie siatki wokseli";
// Shown during undo/redo
history.state.surfaceRemesh = "Ponowne tworzenie siatki powierzchni";
// Shown during undo/redo
history.state.multiresLevel = "Zmiana rozdzielczości";
// Shown during undo/redo
history.state.multiresToDynamic = "Wielokrotna rozdzielczość do DynTopo";
// Shown during undo/redo (mesh type conversion)
history.state.meshDynamicToStatic = "DynTopo do statycznej";
// Shown during undo/redo (mesh type conversion)
history.state.meshStaticToDynamic = "Statyczna do DynTopo";

// Interface customization
interface = "Interfejs";

// UI customization: each row of the list will be bigger
interface.expandList = "Interfejs użytkownika: rozwiń listę";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Po prostu opcja interfejsu użytkownika do łatwiejszego zarządzania listą.";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "Dodaj skróty (u dołu)...";

// Interface option (main base color)
interface.colorBase = "Podstawa kolorystyczna";
// Interface option (accent widget color)
interface.colorSelect = "Widżet kolorów";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Przezroczysty panel";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Siła rozmycia";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Panel kolorów";

// Interface color style
interface.preset.title = "Ustawienia wstępne kolorów";
// Interface color style (original color of Nomad Sculpt)
interface.preset.classic = "Klasyczne";
// Interface color style
interface.preset.orange = "Pomarańczowy";
// Interface color style (~red)
interface.preset.cardinal = "Purpurowy";
// Interface Color style (~pink)
interface.preset.mulberry = "Morwowy";
// Interface color style
interface.preset.brown = "Brązowy";
// Interface color style (~green)
interface.preset.emerald = "Szmaragdowy";
// Interface color style (~blue)
interface.preset.neon = "Neon";
// Interface color style
interface.preset.violet = "Fioletowy";
// Interface color style
interface.preset.grey = "Szary";
// Interface color style
interface.preset.black = "Czarny";
// Interface color style
interface.preset.white = "Biały";

// Reset interface settings
interface.resetAll = "Zresetuj styl";
interface.resetAll.confirm = "Zresetować ustawienia interfejsu?";
// Interface option (main base color)
interface.iconSupport = "";
interface.iconSupport.help = "";
// Interface customization
interface.flipTop = "Dubluj górny pasek";
// Interface customization
interface.flipBottom = "Dubluj dolny pasek";
// Interface customization
interface.flipMiddle = "Dubluj paski boczne";
// Interface customization (preview material in the viewport when editing material color)
interface.materialPreview = "Podgląd koloru materiału";
// Interface customization
interface.materialPreview.help = "Po wybraniu koloru dla materiału na aktualnie wybranym obiekcie wyświetlany jest podgląd tego materiału.";
interface.toolbox.hide = "Ukryj przybornik";
interface.toolboxHide.help = "Włącz tę opcję, jeśli chcesz ukryć przybornik.";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.maxColumn = "Przybornik z maksymalną liczbą kolumn";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Zresetuj kolejność przybornika";
// Scale the interface
interface.scale = "Ogólna skala";
// Spacing between widgets
interface.cursorStep = "Odstęp pionowy";
// Width of the interface panels
interface.panelWidth = "Szerokość panelu";
// Size of fonts
interface.fontScale = "Skala czcionki";
// Inset
interface.inset.title = "Przesunięcia krawędzi";
interface.inset.title.help = "Możesz zmienić te wartości, tylko jeśli masz problemy z interakcją z przyciskami na krawędziach ekranu..

Jeśli suwak jest wyłączony, Nomad będzie używać wartości bezpiecznego obszaru zwracanych przez samo urządzenie.";
interface.inset.left = "Lewo";
interface.inset.right = "Prawo";
interface.inset.bottom = "Dół";
interface.inset.top = "Góra";

// (see Glossary for Layer)
layer = "Warstwa";
// (see Glossary for Layer)
layers.lock = "Zachowaj szczegóły warstwy górnej";
// (see Glossary for Layer)
layers.lock.yes = "Zablokować górne warstwy?";
// (see Glossary for Layer)
layers.lock.warning = "Podczas rzeźbienia deformacja pochodząca z górnych warstw będzie ignorowana.

Jednak szczegóły tych warstw będą nadal widoczne.

Opcja ta działa tylko wtedy, gdy górne warstwy mają szczegóły w stosunkowo małej skali.";
// (see Glossary for Layer)
layers.addLayer = "Dodaj warstwę";
// (see Glossary for Layer)
layer.factors = "Współczynniki kanału";
// (see Glossary for Layer)
layer.factor = "Współczynnik";
// (see Glossary for Layer)
layer.offset = "Przesunięcie";
// (see Glossary for Layer)
layers.title = "Warstwy";
// (see Glossary for Layer)
layers.title.help = "Warstwy mogą rejestrować przesunięcia pozycji i malowanie; może to być przydatne dla nieliniowego przepływu pracy.
Na przykład podczas eksperymentowania z różnymi wyrazami twarzy bez polegania na stosie historii, aby cofnąć zmiany.

W przypadku danych malowania warstwy są sortowane w od góry do dołu, więc warstwy na górze będą maskować niższe.

Można wymazać część warstwy za pomocą narzędzia „Usuń warstwę”.";
layers.primitive = "Warstwy są niedostępne dla prymitywów.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "Brak";

light = "Światło";
// Intensity of light
light.intensity = "Intensywność";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "Temperatura";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Połączenie";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Stałe";
// The light will move along the camera
light.attachment.camera = "Aparat";
light.attachment.help = "-- Stałe
Orientacja światła nie będzie się zmieniać.

-- Kamera
Orientacja światła będzie zależna od widoku kamery.";
// Light type (directional, spot, point)
light.type = "Typ";
// Directional light (synonym: sun light)
light.type.directional = "Kierunkowe";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Punktowe";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Wielokierunkowe";
// Cone angle for spot angles
light.spot.angle = "Kąt stożkowy";
// Softness of the spot light
light.spot.softness = "Miękkość";
// Position of the light
light.position = "Pozycja";
// Enable or disable shadows for a light
light.shadow.cast = "Cień";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "Światło wielokierunkowe obsługuje tylko cienie w przestrzeni ekranu.";
light.shadow.type = "Typ cienia";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "Mapa cieni";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "Przestrzeń ekranu";
light.shadow.type.screenspace.help = "Funkcja eksperymentalna, która może zostać usunięta w przyszłym wydaniu.

Ta opcja jest przeznaczona do użycia z funkcją miękkości cienia.";
// Adjustment to fix artefacts
light.shadow.bias = "Odchylenie";
// How blurry the shadow is
light.shadow.softness = "Miękkość";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "Kontaktowe";
light.contact.help = "Jeśli wybrano opcję automatyczną, tylko najbardziej dominujące światło będzie miało cień kontaktowy.";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "Tolerancja";
// Activated the light
light.visible = "Pokaż";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Wyśrodkuj";

// Object's material
material = "Materiał";
// See glossary
material.pbrRoughnessMetalness.warning = "Opcje Chropowatość i Metaliczność wymagają trybu cieniowania PBR.";
// See glossary
material.pbrReflectance.warning = "Opcja Refleksyjność wymaga trybu cieniowania PBR.";
// See glossary
material.pbrRefraction.warning = "Opcja Refrakcja wymaga trybu cieniowania PBR.";
// See glossary
material.pbrSubsurface.warning = "Opcja Podpowierzchnia wymaga trybu cieniowania PBR.";
// Value that says how much light will change direction when hitting the surface
material.ior = "Indeks refrakcji";
// an object-level value that overrides the painting of the mesh
material.paintingOverride = "Zastąp malowanie";
// The roughness in the inside is turbidity
material.paintingOverride.help = "Chropowatość jest stosowana dwa razy – dla powierzchni i dla wnętrza.

Jednak istnieje tylko jedna chropowatość, którą można pomalować, więc obie chropowatości mają te same wartości.

Możesz użyć tego suwaka, aby zastąpić chropowatość powierzchni i uzyskać większy połysk.";
// Glossiness is simply the opposite of roughness
material.refractionSurfaceGlossiness = "Połysk powierzchni";
material.refractionSurfaceGlossiness.help = "- przy wartości 0 powierzchnia korzysta z namalowanej chropowatości
- przy wartości 1 powierzchnia jest całkowicie gładka";
// Synonym: turbidity
material.refractionInteriorRoughness = "Chropowatość wnętrza";
material.refractionInteriorRoughness.help = "- przy wartości 0 wnętrze korzysta z namalowanej chropowatości
- przy wartości 1 wnętrze jest całkowicie chropowate";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Malowanie błyszczące";
material.paintGlossy.help = "Spowoduje to pomalowanie obiektu z chropowatością i metalicznością równą 0, co pozwoli na ostre załamanie światła.

Działa to identycznie jak wejście do menu malowania i użycie funkcji Maluj wszystko z wyłączonym kolorem i metalicznością.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Pochłanianie";
material.absorptionEnable.help = "Symuluj pochłanianie światła podczas jego przechodzenia przez objętość.

Cienkie części będą jasne, ponieważ przepuszczają więcej światła, podczas gdy grube obszary będą ciemniejsze.

Efekt w dużym stopniu zależy od kształtu obiektu, używane jest tylko przybliżenie grubości obiektu.";
material.absorptionFactor = "Współczynnik";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "Głębia";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "Przezroczystość";
material.translucency.help = "Aby zobaczyć przezroczystość, musisz mieć światło, które rzuca cienie.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Krycie";
// Fully opaque material
material.type.opaque = "Nieprzezroczysty";
// See glossary
material.type.subsurface = "Podpowierzchnia";
material.type.subsurface.help = "Aby uzyskać najlepszy efekt, możesz przełączyć się na tryb cieniowania PBR i użyć przynajmniej jednego światła kierunkowego, najlepiej z przyciemnionym otoczeniem.";
// Transparency mode, alpha blending
material.type.blending = "Mieszanie";
material.type.blending.help = "Spraw, by obiekt był półprzezroczysty, zmieniając wartość krycia.

Zauważ, że ze względu na ograniczenia czasu rzeczywistego mogą pojawiać się zauważalne artefakty wizualne, jeśli twój obiekt ma złożony kształt.";
// Transparency mode
material.type.additive = "Addytywny";
material.type.additive.help = "Spraw, by obiekt był półprzezroczysty, zmieniając wartość krycia.

Ta metoda powoduje mniej artefaktów niż metoda Mieszanie, ale obiekt będzie jaśniejszy.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Dithering";
material.type.dithering.help = "Spraw, by obiekt był półprzezroczysty, odrzucając losowo niektóre piksele.";
// Simulate glass-like material
material.type.refraction = "Refrakcja";
material.type.refraction.help = "Tryb ten może być używany do symulacji szklanego materiału.

Ze względu na ograniczenia czasu rzeczywistego, autorefrakcja lub refrakcja wielowarstwowa jest ograniczona.";
material.castShadows = "Rzucanie cieni";
material.receiveShadows = "Przyjmowanie cieni";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Zawsze nieoświetlone";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Ignorowanie odwróconych";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Refleksyjność";
material.reflectance.help = "Kontroluj wielkość odbicia, jaką otrzyma materiał dla materiałów niemetalicznych.

Przez większość czasu należy używać wartości domyślnej (0,5, co odpowiada standardowej wartości 4% odbitego światła pod normalnym kątem).";

// Menu name
menu.files = "Pliki";
// Menu name
menu.scene = "Scena";
// Menu name
menu.multires = "Wielokrotna rozdzielczość";
// Menu name
menu.voxel = "Woksel";
// Menu name
menu.dynTopo = "DynTopo";
// Menu name
menu.topology = "Upraszczanie/UV...";
// Menu name
menu.primitive = "Prymityw";
// Menu name
menu.render = "Renderuj";
// Menu name
menu.material = "Materiał";
// Menu name
menu.postProcess = "Postprocessing";
// Menu name
menu.camera = "Aparat";
// Menu name
menu.background = "Tło";
// Menu name
menu.tool = "Narzędzie";
// Menu name
menu.stroke = "Pociągnięcie";
// Menu name
menu.paint = "Farba";
// Menu name
menu.symmetry = "Symetria";
// Menu name (pencil pressure)
menu.pressure = "Nacisk";
// Menu name
menu.gesture = "Gest";
// Menu name
menu.layers = "Warstwy";
// Menu name
menu.settings = "Ustawienia";
// Menu name
menu.interface = "Interfejs";
// Menu name
menu.bindings = "Powiązania";
// Menu name
menu.history = "Historia";
// Menu name
menu.historySettings = "Ustawienia";
// Menu name
menu.about = "Informacje";
// Menu name
menu.debug = "Debuguj";

// Operation on the object (action)
mesh.action = "Operacja";
// If the object has holes, the algorithm will close them
mesh.holeClose = "Zamknij otwory";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holeDetail = "Szczegół";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Rozdziel";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "Warstwy, malowanie i wielokrotna rozdzielczość zostaną utracone.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Rozdzielczość";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Wymuś formę sześcienną";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Konwertuj";
// Static object means "static topology"
mesh.typeStatic = "Siatka";
// See glossary
mesh.typeMultiresolution = "Wielokrotna rozdzielczość";
// Dynamic topology
mesh.typeDynamic = "DynTopo";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Materiał globalny";
paint.useGlobal.help = "Jeśli ta opcja jest włączona, wybrany materiał będzie taki sam jak inne narzędzia.

Uwzględnia ona tylko ustawienia chropowatości, metaliczności i koloru.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Malowanie pociągnięciami";
// Factor/Opacity of paint tool
paint.intensity = "Intensywność farby";
// Apply the paint on the object
paint.paintAll = "Maluj wszystko";
paint.paintAll.help = "Zastosuj bieżący materiał do obiektu.

Zamaskowany obszar i wyłączone kanały nie będą malowane.";
// Apply the paint on the object but ignore painting intensity (force full intensity)
paint.paintAllForce = "Wymuś malowanie wszystkiego";
paint.strokePainting.title = "Malarskie";
// Brush stroke texture
paint.texture.title = "Tekstura";
paint.texture.title.help = "Obraz, który będzie kolorować pociągnięcie pędzla.

Będzie on współdzielić ustawienia nakładania i skali alfy.";
paint.texture.warningEnable = "Malowanie pociągnięciami musi być włączone, aby umożliwić rzutowanie tekstur (pole wyboru na górze)!";
paint.texture.warningIgnored = "Bieżące narzędzie nie może używać tekstur!";
// Whether the Brush Alpha will be used to module painting
paint.useAlpha = "Użyj alfy pociągnięć";
paint.useAlpha.help = "Użycie zestawu alfa w menu pociągnięć do modulowania obrazu.";
// Whether the Brush Falloff will be used to module painting
paint.useFalloff = "Użyj zanikania pociągnięcia";
paint.useFalloff.help = "Użycie zestawu zanikania w menu pociągnięć do modulowania obrazu.";

// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "Nowa nazwa";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "Nowa wartość";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "Nowy kolor (format szesnastkowy)";

// Post process effect
postprocess = "Postprocessing";
// Quality vs performance
postprocess.quality = "Jakość";
postprocess.quality.help = "Aktywuj te opcje, aby poprawić jakość kosztem wydajności.";
// More samples means better quality but slower performance
postprocess.maxSamples = "Maks. liczba próbek";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Pełna rozdzielczość";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "Maks. próbkowanie klatek";
postprocess.accumulateCount.help = "Maksymalna liczba klatek do akumulacji przed zatrzymaniem renderowania.

Kiedy renderowanie się zatrzyma, Nomad nie będzie nic robić, oszczędzając w ten sposób baterię.

Wiele funkcji renderingu korzysta z akumulacji klatek, w szczególności:
- Miękkie cienie
- Globalne oświetlenie
- Odbicie (SSR)
- Okluzja otoczenia
- Podpowierzchnia
- Głębia pola

Duża liczba klatek na sekundę jest niezbędna dla miękkich cieni i globalnego oświetlenia.
Nomad może zatrzymać renderowanie szybciej, jeśli wymienione powyżej funkcje są wyłączone.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Rozdzielczość renderowania";
postprocess.renderRatio.warning = "Zastąpione przez efekt Pixel Art.";
postprocess.renderRatio.help = "Ta opcja ma duży wpływ na wydajność.
Zaleca się zachowanie wartości niższej niż x1,25.

Ta opcja nie jest zapisywana w ustawieniach.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "Antyaliasing (TAA)";
postprocess.taa.help = "Redukuje migotanie podczas poruszania kamerą.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "Odbicie (SSR)";
postprocess.ssr.warning = "Opcja SSR wymaga trybu cieniowania PBR.";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "Globalne oświetlenie (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "Tolerancja";
postprocess.ssgi.experimental = "Funkcja eksperymentalna!";
postprocess.ssgi.warning = "Opcja SSGI wymaga trybu cieniowania PBR.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "Okluzja otoczenia";
// How far the effect spreads
postprocess.ssao.radius = "Rozmiar";
// How strong the effect is
postprocess.ssao.factor = "Siła";
// Adjustment to fix artefacts
postprocess.ssao.bias = "Odchylenie krzywizny";
postprocess.ssao.bias.help = "Czułość efektu zależy od krzywizny powierzchni.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "Głębia pola";
// The blur factor behind the focused point
postprocess.dof.blurFar = "Dalekie rozmycie";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "Bliskie rozmycie";
postprocess.dof.focusTip = "Stuknij obiekt, aby zmienić punkt ostrości.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "Rozświetlenie";
// Intensity of the effect
postprocess.bloom.intensity = "Intensywność";
// How far the effect spreads
postprocess.bloom.radius = "Promień";
postprocess.bloom.radius.help = "Zakres efektu cieniowania.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "Próg";
postprocess.bloom.threshold.help = "Próg jasności, który decyduje o tym, czy piksel będzie emitować cieniowanie czy nie.
Jeśli wartość jest równa 0, cieniowanie będzie stosowane do wszystkiego.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "Mapowanie odcienia";
postprocess.tone.exposure = "Ekspozycja";
postprocess.tone.contrast = "Kontrast";
postprocess.tone.saturation = "Nasycenie";
// No tonemapping operator is used
postprocess.tone.mapping.none = "Brak";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "Neutralne";
// Color curves
postprocess.curve = "Gradacja kolorów";
// Curve for pixel luminance
postprocess.curve.luminance = "Główna";
postprocess.curve.red = "Czerwony";
postprocess.curve.green = "Zielony";
postprocess.curve.blue = "Niebieski";
postprocess.curve.reset = "Wyzeruj";
// Reset color grading curves
postprocess.curve.resetAll = "Resetuj wszystkie";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "Aberracja chromatyczna";
postprocess.chromatic.factor = "Siła";
// Darking on the edges
postprocess.vignette = "Winieta";
// How far the effect spreads
postprocess.vignette.size = "Rozmiar";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "Twardość";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "Ostrość";
postprocess.sharpness.factor = "Siła";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "Tekstura";
postprocess.grain.factor = "Siła";
// Accentuate the edges of the model
postprocess.curvature = "Krzywizna";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "Wgłębienie";
// Color/Strength of convex curvature
postprocess.curvature.bump = "Wypukłość";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "Pixel Art";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "Zezwól na próbkowanie klatek";
// Simulate scanline rendering (horizonal line)
postprocess.scanline = "Linia skanowania";
postprocess.scanline.factor = "Współczynnik";
// Spacing between lines
postprocess.scanline.spacing = "Odstępy";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Prymityw";
primitive.box = "Równoległościan";
primitive.sphereCube = "Kula";
primitive.sphereUV = "Kula UV";
primitive.icosahedron = "Dwudziestościan";
primitive.cylinder = "Walec";
primitive.cone = "Stożek";
primitive.torus = "Torus";
primitive.lathe = "Bryła obrotowa";
primitive.tube = "Rura";
primitive.plane = "Płaszczyzna";
primitive.triplanar = "Trzypłaszczyznowy";
primitive.faceXYZ = "Powierzchnia XYZ";
primitive.faceXYZ.help = "Podstawowa siatka z obliczoną mapą UV dostarczona przez https://texturing.xyz/";
primitive.needValidate = "Prymitywy powinny być zweryfikowane, aby można było je rzeźbić.";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Edytuj";
primitive.edit.help = "Pozwól na edycję 3D w rzutni.

Możesz wyłączyć tę funkcję, jeśli chcesz prowadzić interakcję z Gizmo lub narzędziem Transformacja bez modyfikowania prymitywu.";

// Primitive configuration
primitive.mainConfig = "Parametr";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Topologia";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Geometria";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Zweryfikuj";
// Maximum number of faces of the primitives
primitive.maxFaces = "Maks. liczba powierzchni";
primitive.maxFaces.help = "Maksymalna liczba powierzchni, jaką może mieć prymityw.

Limit ten jest aktywny tylko wtedy, gdy prymityw nie jest zatwierdzony, potem to zabezpieczenie znika.";
// Synonym: Flat subdivision
primitive.linear = "Podział liniowy";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Podział następczy";

// Radius (of a sphere, torus, etc)
primitive.radius = "Promień";
// Size (of cube x dimension)
primitive.size = "Rozmiar";
primitive.sizeX = "Rozmiar X";
primitive.sizeY = "Rozmiar Y";
primitive.sizeZ = "Rozmiar Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "Podział";
primitive.divisionX = "Podział X";
primitive.divisionY = "Podział Y";
primitive.divisionZ = "Podział Z";
// Angle of torus, etc
primitive.angleX = "Kąt X";
primitive.angleY = "Kąt Y";
primitive.angleZ = "Kąt Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Stała gęstość";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Rzutuj na kulę";
primitive.projectOnSphere.help = "Przyciąga punkty na idealnej kuli.";

// triplanar
primitive.triplanar.title = "Trzypłaszczyznowy";
primitive.triplanar.title.help = "Obiekt trójpłaszczyznowy używa informacji o masce z 3 płaszczyzn, aby wypełnić siatkę wokseli, która jest następnie przekształcana w wielokąty.

Jeśli wejdziesz w interakcję z suwakami podziału lub rozmiaru, informacje o malowaniu zostaną zresetowane (gładkość jest OK).

Prawdopodobnie należy wyłączyć symetrię, ponieważ może nie działać zgodnie z oczekiwaniami.

Możesz użyć opcji „Topologicznie połączony” w panelu maski, aby pomalować płaszczyznę wpływającą na inne płaszczyzny.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanarSameSize = "Ten sam rozmiar (sześcian)";
primitive.triplanarPolish = "Gładkość";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanarResetMask = "Resetuj maskę";
// One side of a cube (the back plane)
primitive.isolate.back = "Wstecz";
// One side of a cube (the right plane)
primitive.isolate.right = "Prawa";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Dolna";
// Plane
primitive.planeSameSize = "Ten sam rozmiar (kwadrat)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "Dysk";
// Box
primitive.boxRegular = "Ten sam rozmiar (sześcian)";
// Distance to the snapping point
primitive.tubeSnapOffset = "Przesunięcie przyciągania";
primitive.tubeSnapOffset.help = "Wartość 1,0 jest równa promieniowi rury.";
// Radius of the tube (starting end-point of the tube)
primitive.tubeThicknessStart = "Początek promienia";
// Radius of the tube (ending end-point of the tube)
primitive.tubeThicknessEnd = "Koniec promienia";
primitive.tubeTwist = "Skręt";
primitive.tubeTwistRotate = "Obrót";
primitive.tubeTwistRadius = "Wielkość";
primitive.tubeTwistOffset = "Przesunięcie";
primitive.tubeSnap = "Przyciągnij";
primitive.torusRadiusOuter = "Zewnętrzny promień";
primitive.torusRadiusInner = "Wewnętrzny promień";
primitive.torusAngle = "Kąt";
primitive.torusAngleOffset = "Przesunięcie kąta";
primitive.cylinderHeight = "Wysokość";
primitive.coneRadius = "Promień";
primitive.coneHeight = "Wysokość";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Otwór";
// Make a hole in the primtive to make it hollow
primitive.hasHole = "Ma otwór";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radiusSync = "Ten sam promień";
primitive.radiusStart = "Początek promienia";
primitive.radiusEnd = "Koniec promienia";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Importuj...";

scene.title = "Scena";
scene.title.help = "Podczas korzystania z widocznych przycisków/przycisków zaznaczenia, przytrzymaj i przeciągnij palec, aby łatwo zaznaczyć inne obiekty.

Możesz również nacisnąć i przytrzymać widoczne przyciski/przyciski zaznaczenia, aby wpływać również na obiekty podrzędne.";
// The view will focus on the item when we click on it
scene.focus = "Ostrość na elemencie";
// Icon size in pixel (min/max)
scene.iconSize = "";
// Min size of icon
scene.iconSize.min = "Min.";
// Max size of icon
scene.iconSize.max = "Max.";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "";
scene.showHierarchy.help = "";
scene.showHierarchyNomadPivot = "";
scene.showHierarchyNomadPivot.help = "";
// The view will focus on the item when we click on it
scene.syncVisible = "";
scene.syncVisible.help = "";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "Połącz";
// Group the selected object with a new created Empty Node as a parent
scene.group = "Grupuj";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "Odbicie lustrzane";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "Krzywa";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "Macierz";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "Radialna";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "";
scene.repeaters.help = "";
// singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "";
// Validate button
scene.validateGroup = "Zweryfikuj";
// Keep instances in the scene
scene.validateGroup.keepInstances = "";
// If we should join children
scene.validateGroup.joinChildren = "Połącz obiekty podrzędne";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Scalanie wokseli";
scene.voxelResolution = "Rozdzielczość";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Odejmowanie: ukryj obiekt (ikona oka)";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Przecięcie: wszystkie obiekty ukryte";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "Brak zaznaczonych obiektów, zaznacz co najmniej jeden obiekt.";
// Need to select one object only
scene.noneButNeedOne = "Brak zaznaczonych obiektów, zaznacz jeden obiekt.";
// Need to select one object only
scene.onlyOneObject = "Zaznaczono wiele obiektów, zaznacz tylko jeden obiekt.";

// General scene display settings
settings.display.title = "Ustawienia wyświetlania";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Szkielet";
// Display UV
settings.debugUV = "Debuguj UV";
settings.debugUV.help = "Ta opcja jest istotna tylko wtedy, gdy model posiada UV.

Spowoduje ona wyświetlenie szkieletu UV w tle.

Zostanie również wyświetlona kolorowa tekstura szachownicy na modelu.";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Dwustronny";
settings.twoSided.help = "Powierzchnie będą widoczne z obu stron.";
// If we colorize the inverted side of faces
settings.backface.color = "Kolor tylnej powierzchni";
// Color of the inverted side of faces
settings.backface.colored = "Kolorowa powierzchnia tylna";
// Outline (contour highlight around the selected object)
settings.outline = "Kontur";
// Outline (contour highlight around the selected object)
settings.outline.help = "Zaznaczone obiekty zostaną obrysowane.";
settings.outline.thickness = "Grubość";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Sześcian przyciągania";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "Do dołu";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "W lewo";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Statystyki";
settings.stats.right = "W prawo";
settings.stats.all = "Pokaż pełną scenę";
// Grid
settings.grid = "Siatka";
// Cursor
settings.cursor.whileSculpting = "Pokaż okrąg podczas rzeźbienia";
// A small indicator dot
settings.cursor.showDot = "Pokaż małą kropkę";
settings.cursor.showDot.help = "Kropka może pojawić się jako punkt obrotu kamery lub podczas rzeźbienia.";
settings.cursor.showRope = "Pokaż stabilizator liny";
// Highlight (the object glows when we select it)
settings.highlight.selection = "Wyróżnij zaznaczenie";
// Highlight settings
settings.highlight = "Wyróżnianie";
settings.highlight.duration = "Czas trwania";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Przyciemnij niezaznaczone obiekty";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Płynne cieniowanie";
// Experimental feature
settings.partialDraw = "Częściowy rysunek";
settings.partialDraw.help = "Funkcja eksperymentalna!

Użyj jej, jeśli rzeźbisz stosunkowo małą część siatki o wysokiej polaryzacji.

Powinno to sprawić, że rzeźbienie będzie płynniejsze, ale nie należy włączać szkieletu!

Może również dodać wizualne artefakty podczas pociągnięć pędzla.";
settings.partialDraw.warning = "Nie zapomnij wyłączyć tej opcji, jeśli artefakty wizualne są zbyt uciążliwe!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Pokaż malowanie";
// Display the light icons in the viewport
settings.lightIcon = "Ikony świateł";
// Display the camera icons in the viewport
settings.cameraIcon = "Ikony kamery";
// Show icon on the canvas
settings.icon = "Ikona";
// Show icons on the canvas
settings.icons = "Ikony";
// Tooltip
settings.icons.help = "Wyświetl ikonę na obszarze roboczym, aby można było zaznaczyć je i bezpośrednio edytować.";
// Hole filling settings
settings.hole = "Wypełnianie otworów";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Wypełnij nieforemne";
settings.hole.nonManifold.help = "Spróbuj wypełnić niewymierny otwór.
Ta opcja nie jest zapisywana w ustawieniach.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Maks. liczba wierzchołków";
settings.multires.maxVertices.help = "Nomad nie wykonuje sprawdzania pamięci przed podziałem, duża liczba poligonów może łatwo doprowadzić do awarii.";
settings.multires.lowResVertices = "Próg niskiej rozdzielczości";
settings.multires.lowResVertices.help = "Podczas przesuwania kamery może być wyświetlana niższa rozdzielczość siatki.

Możesz zwiększyć tę wartość, jeśli chcesz wyświetlić wyższą rozdzielczość siatki.";

// The main rendering mode
shading = "Cieniowanie";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "Oświetlony (PBR)";
shading.pbr.help = "W tym trybie możesz dodać światła (z cieniami) wraz ze środowiskiem HDR.

Możesz również malować metaliczność i chropowatość, co pozwala na dokładniejszą kontrolę nad wyglądem materiału.";
// Fast rendering mode for sculpting purpose (do not translate)
shading.matcap = "MatCap";
shading.matcap.help = "Skrót od MATerial CAPture (przechwytywanie materiału). MatCap uwzględnia zarówno oświetlenie, jak i informacje o materiałach w jednym obrazie.

Jest to szybki tryb renderowania, nadający się głównie do surowego rzeźbienia.";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "Nieoświetlony";
shading.unlit.help = "Tryb cieniowania w kolorze jednolitym, bez oświetlenia.";
// Helper rendering mode that display a (do not translate)
shading.id = "ID";
shading.id.help = "Tryb renderowania bez oświetlenia, w którym każdy obiekt ma przypisany losowy kolor.

Jest to przydatne głównie w sytuacji, gdy na scenie znajduje się wiele obiektów.";
// Randomize colors
shading.id.randomize = "Losowy ID";
shading.textures = "Użyj tekstur";
shading.textures.help = "Obecnie w aplikacji Nomad nie można tworzyć ani edytować tekstur.

Jeśli jednak zaimportujesz plik, w którym są tekstury, powinno to zdziałać.

-- Obsługiwane tekstury --.
Krycie: Oświetlone, MatCap, Nieoświetlone
Normalne: Oświetlone, MatCap
Kolor: Oświetlone, Oświetlone
Emisyjne: Oświetlone
Chropowatość: Oświetlone
Metaliczność: Oświetlone";
// Lights
shading.lights = "Światła";
shading.lights.addLight = "Dodaj światło";
shading.lights.warning = "Opcja Światła wymaga trybu cieniowania PBR.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Środowisko";
shading.environment.import = "Importuj HDR";
shading.environment.exposure = "Ekspozycja";
shading.environment.backgroundBlur = "Rozmycie (tło)";
shading.environment.rotation = "Obrót";
shading.environment.rotation.help = "Możesz obrócić środowisko, przeciągając 3 palcami w poziomie na rzutni.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "Przyłączono do kamery";
shading.environment.attachedToCamera.help = "Przyłącz środowisko do kamery.

Wymusi to spójność oświetlenia, co może być przydatne do celów rzeźbienia.";
shading.matcap.rotation = "Obrót";
shading.matcap.rotation.help = "Możesz obrócić MatCap, przeciągając 3 palcami w poziomie na rzutni.";
shading.matcap.global = "Użyj globalnego MatCap";
shading.matcap.global.help = "Odznacz tę opcję, aby użyć innego MatCap dla tej konkretnej siatki.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible.short = "Maska";
shortcut.maskVisible.long = "Maska";
// bottom shortcut buttons (should be SHORT)
shortcut.solo.short = "Solo";
shortcut.solo.long = "Solo";
// bottom shortcut buttons (should be SHORT)
shortcut.voxelRemesh.short = "Woksel";
shortcut.voxelRemesh.long = "Ponowne tworzenie siatki wokseli";
// bottom shortcut buttons (should be SHORT)
shortcut.wireframe.short = "Drut";
shortcut.wireframe.long = "Szkielet";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraReset.short = "Wyzeruj";
shortcut.cameraReset.long = "Reset kamery";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraSnap.short = "Przyciągnij";
shortcut.cameraSnap.long = "Przyciąganie kamery";
// bottom shortcut buttons (should be SHORT)
shortcut.lockSelection.short = "Zablokuj";
shortcut.lockSelection.long = "Zablokuj zaznaczenie";
shortcut.lockSelection.long.help = "Po włączeniu nie można zmienić zaznaczenia przez stuknięcie siatki.";
// bottom shortcut buttons (should be SHORT)
shortcut.perspective.short = "Persp.";
shortcut.perspective.long = "Perspektywa";
// bottom shortcut buttons (should be SHORT)
shortcut.grid.short = "Siatka";
shortcut.grid.long = "Siatka";
// bottom shortcut buttons (should be SHORT)
shortcut.uv.short = "uv";
shortcut.uv.long = "uv";

// Memory taken by the scene
stat.ramScene = "Scena";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Pamięć VRAM sceny";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "Pamięć VRAM renderowania";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "Pamięć VRAM tekstur";
// Memory taken by the undo/redo history
stat.ramHistory = "Historia";
// Memory taken by other stuffs
stat.ramOther = "Inne";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "Użyta pamięć";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "Wolna pamięć";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "Użyta: $0 MB";
stat.free = "Wolna: $0 MB";
stat.faces = "Powierzchnie";
stat.triangles = "Trójkąty";
stat.vertices = "Wierzchołki";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Czworokąty";
stat.sceneFaces = "Powierzchnie sceny";
stat.sceneVertices = "Wierzchołki sceny";

// Brush stroke
stroke = "Pociągnięcie";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "Promień przestrzeni świata";
// The settings is shared among every tools
stroke.useWorldRadius.help = "Jest to współużytkowane przez wszystkie narzędzia.";
// Share the radius value among every tools.
stroke.useShareRadius = "Udostępnij promień";
stroke.useShareRadius.help = "Udostępnij wartość promienia dla wszystkich narzędzi.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.minSpacing = "Odstęp pociągnięć";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.minSpacing.adjustIntensity = "Dostosuj intensywność odstępów";
stroke.minSpacingAdjustIntensity.help = "Dostosuj intensywność pędzla, aby zapewnić spójne odkształcenie w zależności od odstępu między pociągnięciami.";
stroke.minSpacing.help = "Odstęp pomiędzy poszczególnymi pociągnięciami w stosunku do promienia narzędzia.

Niższa wartość pozwoli na gładsze pociągnięcie, ale pogorszy się wydajność.";
// Brush stroke smoothing
stroke.lazySmooth = "Wygładzanie pociągnięć";
stroke.lazySmooth.help = "Uśrednij wiele pozycji wskaźnika, aby uzyskać bardziej płynne pociągnięcie.

Przy wysokich wartościach pociągnięcie będzie się opóźniać za wskaźnikiem, ale w końcu go dogoni.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Stabilizator powolnej liny";
stroke.lazyRadius.help = "Pociągnięcia będą opóźnione w stosunku do pozycji wskaźnika zgodnie z określoną odległością.

Można to wykorzystać do rysowania gładkich linii.";
// It is not a per-tool settings
stroke.globalSettings = "To jest ustawienie globalne";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Promień przyciągania";
stroke.snapRadius.help = "Przyciągnij pociągnięcie, jeśli wskaźnik znajduje się w pobliżu ostatniego zarejestrowanego pociągnięcia.

Może to być przydatne podczas rysowania długich linii ciągłych przy jednoczesnym robieniu częstych przerw.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Przesunięcie pociągnięć";
stroke.sculptOffset.help = "Zastosuj stałe przesunięcie pociągnięć.

Ta opcja ma pomóc w przypadku małych ekranów, gdy używa się palców, aby palec nie zakrywał pociągnięcia.";
stroke.accumulate = "Akumulacja pociągnięć";
stroke.accumulate.help = "Jeśli ta opcja jest włączona, nie ma limitu ilości materii, którą można dodać/usunąć na jedno pociągnięcie.";
// The tool can use DynTopo
stroke.useDynamicTopology = "Zezwól na topologię dynamiczną";
// Only sculpt the part that are linked topologically
stroke.connectedTopology = "Połączona topologia";
stroke.connectedTopology.help = "Ta opcja powoduje rzeźbienie tylko tych wierzchołków, które są powiązane z wybraną powierzchnią.

Jest to zwykle używane w narzędziu Przesuń, na przykład jeśli chcesz przesunąć tylko część, która przecina się z inną częścią.";
// Only sculpt the vertex that points toward the camera
stroke.onlyFrontFace = "Tylko wierzchołek skierowany do przodu";
stroke.onlyFrontFace.help = "Ta opcja zignoruje wierzchołki skierowane do tyłu.

Może być przydatna, jeśli chcesz pomalować część cienkiej geometrii bez wpływu na drugą stronę.

Działa również w przypadku rzeźbienia, ale mogą wystąpić pewne artefakty.";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.onlySameSide = "Tylko wierzchołek po tej samej stronie";
stroke.onlySameSide.help = "Ignoruj wierzchołki, które wskazują w kierunku przeciwnym do deformacji.";
// Module the intensity of the sculpting operation by using a falloff curve
stroke.curveFalloff = "Zanikanie";
stroke.onlyLasso = "Ustawienia aktywne tylko dla narzędzia lasso.";
// Alpha
stroke.alpha = "Alfa";
// Invert the pixel (black <-> white)
stroke.alphaInvert = "Odwróć piksele";
// Repeat the alpha image (pattern)
stroke.alphaWrap = "Rozmieszczenie sąsiadująco";
// No repeat pattern
stroke.alphaWrap.none = "Brak";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alphaWrap.repeat = "Powtarzanie";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alphaWrap.mirror = "Odbicie lustrzane";
stroke.alphaProject = "Metoda";
// Project the alpha perpendicularly onto the surface
stroke.alphaProject.surfaceContinuous = "Powierzchnia";
// Project the alpha onto the surface in the direction of the camera view
stroke.alphaProject.screenFixed = "Rzutowanie ekranu";
stroke.alphaRotation = "Obrót";
stroke.alphaRotation.lock.help = "";
// Repeat the image
stroke.alphaTiling = "Rozmieszczenie sąsiadująco";
// Scale the image (make it bigger or smaller)
stroke.alphaScale = "Skalowanie";
stroke.alphaScale.help = "Przy minimalnej wartości kwadrat alfa znajduje się wewnątrz promienia okręgu narzędzia.";
// Middle-point value at which no deformation occurs
stroke.alphaMidValue = "Średnia wartość";
stroke.alphaMidValue.help = "Wartość środkowa, przy której nie występuje deformacja.

(Wartość środkowa = 0)
- Czarny: brak przesunięcia
- Biały: przesunięcie dodatnie

(Wartość środkowa = 0,5)
- Czarny: przesunięcie ujemne
- Biały: przesunięcie dodatnie

(Wartość środkowa = 1)
- Czarny: przesunięcie ujemne
- Biały: brak przesunięcia";
// Stroke type
stroke.strokeType = "Typ pociągnięcia";
// Sculpt and paint along the brush stroke at regular spacing
stroke.strokeTypeDot = "Kropka";
// Sculpt continuously
stroke.strokeTypeDrag = "Przeciągnij";
// Lock a region and move it around
stroke.strokeTypeGrab = "Przechwyć";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.strokeTypeGrabRadius = "Przechwytywanie – dynamiczny promień";
// Lock a region and sculpt it by changing the tool intensity
stroke.strokeTypeGrabIntensity = "Przechwytywanie – dynamiczna intensywność";

// Symmetry
symmetry = "Symetria";
symmetry.enable = "Włączona";
// Display a warning (the feature is only available for mesh object)
symmetry.primitiveWarning = "Symetria pędzla jest dostępna tylko dla prymitywów, które są zatwierdzone, z wyjątkiem trójpłaszczyznowych.";
symmetry.plane.title = "Płaszczyzny";
symmetry.toolIgnore = "Bieżące narzędzie ignoruje symetrię.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Radialna";
symmetry.radialX = "Radialna X";
symmetry.radialY = "Radialna Y";
symmetry.radialZ = "Radialna Z";
// Synonym: Offset
symmetry.offset.title = "Przesunięcie";
symmetry.offsetX = "Przesunięcie X";
symmetry.offsetY = "Przesunięcie Y";
symmetry.offsetZ = "Przesunięcie Z";
// Number of clones
symmetry.count.title = "Liczba";
symmetry.countX = "Liczba X";
symmetry.countY = "Liczba Y";
symmetry.countZ = "Liczba Z";
// method
symmetry.method = "Metoda:";
symmetry.method.help = "-- Lokalna
Płaszczyzna symetrii będzie się przesuwać wzdłuż siatki, gdy użyjesz jednego z narzędzi transformacji (Gizmo lub Transformacja).

-- Świat
Płaszczyzna symetrii jest stała i nie będzie się poruszać.";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.methodWorld = "Świat";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.methodLocal = "Lokalna";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Przerzuć obiekt";
// Mirror the mesh
symmetry.mirror = "Odbicie lustrzane";
symmetry.mirror.help = "Spróbuj ponownie zastosować symetrię bez wpływu na topologię.

Symetria radialna będzie ignorowana.

Jeśli topologia nie może być zachowana, ponieważ nie jest uważana za symetryczną, otrzymasz opcję wymuszenia odbicia lustrzanego.";
symmetry.mirrorLeftToRight = "Od lewej do prawej";
symmetry.mirrorRightToLeft = "Od prawej do lewej";
symmetry.mirrorFail = "Nie udało się zastosować symetrii.

Czy chcesz wymusić symetrię poprzez odbicie lustrzane siatki?";
symmetry.mirrorUseMasking = "Chroń zamaskowany obszar";
symmetry.mirrorUseMasking.help = "Zachowaj zamaskowany obszar w stanie nienaruszonym.

Ta opcja będzie ignorowana w przypadku niesymetrycznej topologii (lub rozłącznej powierzchni, jak para oczu).";
// Reset the symmetry plane position
symmetry.reset = "Wyzeruj";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Środek obiektu";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "Środek świata";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Orientacja";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Pokaż linię";
// Display the symmetry plane in 3d
symmetry.showPlane = "Pokaż płaszczyznę";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Edycja gizmo";
symmetry.edit.warning = "Edycja symetrii jest funkcją eksperymentalną.";
symmetry.edit.help = "Możesz dowolnie ustawić płaszczyznę symetrii.

Ta funkcja jest nieco eksperymentalna i prawdopodobnie nigdy nie należy jej używać.";

// Ideally <10 chars
tool.dynTopo = "DynTopo";
// Ideally <10 chars (Symmetry)
tool.symmetry = "Sym";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "Lustro";
// Ideally <10 chars
tool.clay = "Glina";
// Ideally <10 chars (Subtract)
tool.clay.sub = "Odejmij";
// Ideally <10 chars
tool.brush = "Pędzel";
// Ideally <10 chars
tool.move = "Przenieś";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "Normalna";
// Ideally <10 chars
tool.drag = "Przeciągnij";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "Gładkie";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Złagodź";
// Ideally <10 chars (Paint mask)
tool.mask = "Maska";
// Ideally <10 chars
tool.mask.unmask = "Usuń maskę";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "Zaz. maskę";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "Smużenie";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "Spłaszcz";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Wypełnij";
// Ideally <10 chars (Layer brush)
tool.layer = "Warstwa";
// Ideally <10 chars
tool.crease = "Zagnij";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "Przytnij";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Podziel";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "Rzutuj";
// Ideally <10 chars
tool.inflate = "Napełnij";
// Ideally <10 chars
tool.pinch = "Ściśnięcie";
// Ideally <10 chars
tool.nudge = "Przesuń";
// Ideally <10 chars
tool.stamp = "Stempel";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "Us. warstwę";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.select = "Wybierz";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "Gizmo";
// Ideally <10 chars
tool.gizmo.editPivot = "Pkt obrotu";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "Przyciągnij";
// Ideally <10 chars (Snap translation)
tool.gizmo.moveSnap = "Przyciągnij";
// Ideally <10 chars (Local/Relative space)
tool.gizmo.local = "Lokalne";
// Ideally <10 chars (World/Absolute space)
tool.gizmo.world = "Świat";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "Przekształcenie";
// Ideally <10 chars (Translate the object)
tool.transform.move = "Przenieś";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "Obróć";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "Skala";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "Przyciągnij";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "Zmierz";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "Wyświetl";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "Bryła obrotowa";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "Rura";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "Wstaw";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "Odwróć";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "Widok";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "Lasso";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Krzywa";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Wielokąt";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Ścieżka";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "Prostokąt";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "Elipsa";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "Linia";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Zamknięty";

// Popup when editing the vertical sliders on the left
tool.slider.radius = "Promień $0";
// Popup when editing the vertical sliders on the left
tool.slider.intensity = "Intensywność $0%";

tool.settings = "Ustawienia";
tool.settings.none = "To narzędzie nie ma żadnych konkretnych ustawień.";

// Flatten distance offset
tool.clay.flattenOffset = "Przesunięcie spłaszczenia";
tool.crease.pinchFactor = "Siła ściskania";

tool.layer.removeInfluence = "Użyj danych warstwy";
tool.layer.removeInfluence.help = "Ta opcja jest aktywna tylko wtedy, gdy jest zaznaczona warstwa.

Użyje ona danych warstwy do ograniczenia przesunięcia nad pociągnięciami.";
tool.layer.noLayerSelected = "Ta opcja jest dostępna tylko wtedy, gdy jest zaznaczona warstwa";

tool.flatten.warning = "Te opcje są eksperymentalne i mogą zostać usunięte w przyszłości!";
tool.flatten.planeLockOrigin = "Zablokuj początek płaszczyzny";
tool.flatten.planeLockNormal = "Zablokuj kierunek płaszczyzny";
tool.flatten.planeAverageOrigin = "Uśrednij początek płaszczyzny";
tool.flatten.planeAverageNormal = "Uśrednij kierunek płaszczyzny";
tool.flatten.planeOffset = "Przesunięcie płaszczyzny";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "";
tool.syncInstance.message = "";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Lepki wierzchołek na granicy";

tool.paint = "Farba";
// Erase the painting
tool.paint.erase = "Wymaż";
// Only paint the part of the mesh above a certain height
tool.paint.depthFilter = "Filtrowanie głębi";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Filtrowanie warstwy";
tool.paint.layerFilter.help = "Użyj tej opcji tylko wtedy, gdy chcesz przemalować już pomalowany obszar warstwy.";

// Clear the painted mask
tool.mask.clear = "Wyczyść";
// Invert the painted mask
tool.mask.invert = "Odwróć";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Przerzuć połączony";
// Blur the painted mask
tool.mask.blur = "Rozmycie";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Wyostrzenie";
// The thickness of the extracted mesh (from the painted mask)
tool.mask.thickness = "Grubość powłoki";
// Smooth the border of the extracted mesh (from the painted mask)
tool.mask.polish = "Gładkość granicy";
// Extract a new mesh from the painteed mask and carve/emboss the base mesh
tool.mask.engraveEmboss = "Wyryj / wytłocz";
// Extract a new mesh from the painted mask
tool.mask.extract = "Wyodrębnij";
// Extract two new mesh from the painted mask and from the unmasked area
tool.mask.split = "Podziel";
// How should we close the topology of the extracted object
tool.mask.closeMask = "Działanie zamykania (zamaskowane):";
// How should we close the topology of the extracted object
tool.mask.closeUnmask = "Działanie zamykania (niezamaskowane):";
// How should we close the topology of the extracted object
tool.mask.closeAction = "Działanie zamykania:";
// Do not close the mesh (leave it open)
tool.mask.closeActionNone = "Brak";
// Close the mesh with a hole-filling algorithm
tool.mask.closeActionFill = "Wypełnienie";
// Close the mesh by adding a thickness on the surface
tool.mask.closeActionShell = "Powłoka";
// Close the mesh by using the layer data as a difference thickness
tool.mask.closeActionLayer = "Warstwa";
tool.mask.closeAction.help = "-- Brak
Po prostu wyodrębnij część i pozostaw otwartą wyodrębnioną część.

-- Wypełnij
Otwór zostanie wypełniony i wygładzony.
Nie używaj tej opcji dla płaskich powierzchni.

-- Powłoka
Zamknij wyodrębniony kształt za pomocą wartości grubości.

-- Warstwa
Wyodrębnij różnicę warstw (tylko podmenu warstwy).";

// Transform/Matrix
tool.matrix = "Macierz";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.apply = "Cel";
// Automatic
tool.matrix.apply.auto = "Auto";
// Transform the object alone (the children stands still)
tool.matrix.apply.object = "Obiekt";
// Auto apply the transform on the vertices
tool.matrix.apply.vertex = "Wierzchołek";
// Transform the object and its children
tool.matrix.apply.group = "Grupuj";
tool.matrix.apply.help = "-- Auto
Domyślnie będzie to działać podobnie do opcji Grupa.
Jeśli siatka ma maskowanie lub jeśli symetria gizmo jest włączona, będzie to działać tak samo jak Wierzchołek.

-- Wierzchołek
Spróbuj zastosować transformację wierzchołków, nie będzie ona działać w przypadku niezweryfikowanych prymitywów.
Wpłynie to również na instancje.

-- Obiekt
Przesuń tylko obiekt, ignorując symetrię i maskowanie.
Tylko edytowany węzeł będzie się poruszać, węzły podrzędne pozostaną na miejscu.

-- Grupa
Przesuń węzeł, ignorując symetrię i maskowanie. Pozostała część hierarchii również zostanie przekształcona.";
// Operation on the mesh
tool.matrix.action = "Operacja";
tool.matrix.action.help = "-- Przenieś początek
Przesuwa siatkę do początku świata.

-- Resetuj
Resetuje transformację siatki do tożsamości.

-- Zastosuj
Zastosuj macierz do wierzchołka i zresetuj macierz. Wizualnie nic nie powinno się zmienić.";
tool.matrix.translation = "Translacja";
tool.matrix.rotation = "Obrót";
tool.matrix.scale = "Skala";
// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "Ścinanie";
tool.matrix.uniformScale = "Jednolite skalowanie";
tool.matrix.uniformScale.help = "Nomad nie może obsługiwać niejednolitego skalowania jako transformacji obiektu, więc zostanie zastosowany jako transformacja wierzchołka.";
tool.matrix.moveToOrigin = "Przenieś początek";
tool.matrix.resetTransform = "Wyzeruj";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "Zastosuj";

tool.transform.tip = "";

// Size of the gizmo
tool.gizmo.size = "Rozmiar widżetu";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "Wprowadzanie numeryczne";
tool.gizmo.allowInput.help = "Zezwól na wprowadzanie numeryczne po stuknięciu jednego z widżetów gizmo";
// Angle threshold
tool.gizmo.linearRollThreshold = "Próg przechyłu stycznego";
tool.gizmo.linearRollThreshold.help = "Próg kąta do wyboru pomiędzy metodą liniową a kołową.

Wartość powyżej tego progu spowoduje zastosowanie zwijania kołowego.

Jeśli wolisz liniowe zwijanie (kierunek stycznej), po prostu ustaw tę wartość na 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Ukryj przy interakcji";
tool.gizmo.tap = "Przesuń niestandardowy punkt obrotu po jednym stuknięciu";
tool.gizmo.tap.help = "Ta opcja działa tylko w trybie niestandardowego obrotu (tryb automatyczny wyłączony).

-- Brak
Nic się nie dzieje po stuknięciu siatki.

-- Pierwsza pozycja
Przesuń gizmo do pierwszego przecięcia.

-- Środkowa pozycja
Przesuń gizmo do średniej z dwóch pierwszych przecięć.";
tool.gizmo.tapNone = "Brak";
tool.gizmo.tapFirstHit = "Pierwsze trafienie";
tool.gizmo.tapMiddleStab = "Środkowa pozycja";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "Stałe";

// Fill the object's hole
tool.hole = "Wypełnianie otworów";
tool.hole.fillHoles = "Wypełnij otwory";
// synonym: Alternative method
tool.hole.bridges = "Wartość logiczna dla przestrzeni na ekranie";
tool.hole.bridges.help = "Jeśli ta opcja jest włączona, można wykrawać otwory w objętości.
Nachylenie cięcia będzie również bardziej zbliżone do kształtu cięcia.";
tool.hole.threshold = "Epsilon progu";
tool.hole.threshold.help = "Dostosowanie tej wartości może ulepszyć algorytm wypełniania dziur.";
tool.hole.smoothing = "Wygładzanie otworów";

tool.smudge.quality = "Jakość";
tool.smudge.quality.help = "Zmienia rozdzielczość wyświetlanych pikseli, niższe wartości oznaczają szybsze pociągnięcia.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Kształt";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Kwadrat";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Wyśrodkowany";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Okrąg";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Wyśrodkowana";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Krok obrotu";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Pokaż złoty podział";

// Topology
topology = "Topologia";
// Synynom: detail value, density
topology.dynamic.detail = "Szczegół";
// See glossary
topology.multires = "Wielokrotna rozdzielczość";
topology.multires.help = "Zachowaj wiele rozdzielczości siatki.

Jeśli dokonasz zmian w niższej rozdzielczości, szczegóły z wyższych rozdzielczości zostaną znowu wyświetlone po ponownym przełączeniu.

Warstwy są dostępne w każdej rozdzielczości.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "Odwróć";
topology.multires.reverse.confirm = "Nie można utworzyć podziału podstawowego.

Obecna topologia prawdopodobnie nie jest wynikiem podziału.";
topology.multires.subdivide = "Podziel";
topology.multires.subdivide.confirm = "Siatka będzie mieć $0 mln wierzchołków. Czy na pewno?";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "Przekroczono limit podziału. Zobacz $0";
topology.multires.deleteLower = "Usuń niższe";
topology.multires.deleteHigher = "Usuń wyższe";
topology.multires.keepTriangles = "Zachowaj trójkąty";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "";
// Synonym: Flat subdivision
topology.multires.linear = "Podział liniowy";
topology.multires.linear.help = "Po prostu podziel siatkę bez stosowania wygładzania";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Ponowne tworzenie siatki wokseli";
topology.voxel.help = "Ponowne tworzenie siatki poprzez próbkowanie na siatce.

Jeśli obiekt nie jest zamknięty (wodoszczelny), najpierw zastosowany zostanie algorytm wypełniania otworów.

Warstwy są ponownie rzutowane po utworzeniu siatki, ale jakość ulegnie pogorszeniu.";
topology.voxel.resolution = "Rozdzielczość";
topology.voxel.remesh = "Ponownie utwórz siatkę";
topology.voxel.sharp = "Zachowaj ostre krawędzie";
topology.voxel.sharp.help = "Opcja ta jest przydatna głównie do prostych operacji logicznych na prymitywach.

Wprowadzi ona zniekształcenia w pewnym obszarze ze względu na to, że punkty są przyciągane do krawędzi.";
topology.voxel.subLevel = "Utwórz wielokrotną rozdzielczość";
topology.voxel.subLevel.help = "Możesz odbudować hierarchię wielokrotnej rozdzielczości z danych wyjściowych narzędzia ponownego tworzenia siatki wokseli.

Będzie również działać szybciej i zużywać mniej pamięci, zwłaszcza jeśli wartość szczegółowości wokseli jest wysoka.
Jeśli jednak wartość szczegółowości wokseli jest niska i chcesz uzyskać wysoki poziom wielokrotnej rozdzielczości, utracisz szczegóły.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Ponownie utwórz siatkę";
topology.surface.detail = "Szczegół";
topology.surface.detail.help = "W przeciwieństwie do ponownego tworzenia siatki wokseli, ponowne tworzenie siatki powierzchni nie wymaga zamknięcia siatki.

Może również obsługiwać maskowanie, dzięki czemu można chronić niektóre części siatki przed zmianami topologii.

Warstwy są aktualizowane poprawnie.";
topology.surface.method = "Metoda";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Uniformizacja";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Podział";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Upraszczanie";
topology.surface.method.help = "Zachowanie topologii dynamicznej:
- Uniformizacja: dodawanie i usuwanie szczegółów
- Podział: dodawanie szczegółów
- Upraszczanie: usuwanie szczegółów";
topology.surface.useMasking = "Chroń zamaskowany obszar";
topology.surface.useMasking.help = "Zamaskowane obszary będą chronić topologię przed zmianami.";
topology.surface.extrapolate = "Ekstrapolacja wierzchołków";
// DynTopo
topology.dynamic = "Topologia dynamiczna";
topology.dynamic.activate = "Włączona";
topology.dynamic.activate.help = "W przypadku topologii dynamicznej narzędzia do rzeźbienia mogą lokalnie dzielić lub upraszczać siatkę w czasie rzeczywistym.

Ta funkcja może mieć zauważalny wpływ na wydajność.

Warstwy są aktualizowane prawidłowo.";
topology.dynamic.method = "Szczegóły oparte na...";
topology.dynamic.method.zoom = "Powiększenie";
topology.dynamic.method.radius = "Promień";
topology.dynamic.method.constant = "Stała";
topology.dynamic.method.help = "-- Powiększenie
Poziom szczegółowości zależy od tego, jak daleko jesteś od powierzchni.

-- Promień
Promień narzędzia określa ilość szczegółów.

-- Stały
Szczegółowość jest stała, wartość szczegółowości jest wspólna również z suwakiem wokseli.";
topology.dynamic.quality = "Preferuj...";
topology.dynamic.quality.help = "Jeśli wybierzesz opcję Jakość, dwie główne różnice to:
- Ulepszanie jest stosowane przed operatorem rzeźbienia; otrzymasz mniej artefaktów interpolacyjnych podczas malowania lub rzeźbienia bardzo małych szczegółów.
- Ulepszanie nie jest stosowane przyrostowo; jeśli rzeźbisz bardzo małe szczegóły lub wykonujesz szybkie pociągnięcia, topologia zawsze będzie poprawnie ulepszana.

Aby uzyskać lepszą wydajność, jeśli planujesz używać tej opcji, możesz rozważyć włączenie opcji „Częściowe rysowania” w panelu ustawień.";
topology.dynamic.quality.speed = "Szybkość";
topology.dynamic.quality.quality = "Jakość";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Użyj nacisku dla promienia";
topology.dynamic.usePressure.help = "Użyj tej opcji, jeśli chcesz, aby nacisk pióra na promień narzędzia miał wpływ na poziom szczegółowości.";
// Decimate
topology.decimate.title = "Upraszczanie";
topology.decimate.title.help = "Zmniejsz liczbę wielokątów, starając się zachować jak najwięcej szczegółów.

Ta funkcja może być przydatna, jeśli chcesz eksportować do druku 3D.
Jednak prawdopodobnie nie należy jej używać, jeśli chcesz kontynuować rzeźbienie, ponieważ może to spowodować powstanie nierównych trójkątów.

Zamaskowany obszar nie zostanie uproszczony.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Uprość";
topology.decimateTargetFaces = "Docelowe trójkąty";
topology.decimatePaintWeight = "Zachowaj malowanie";
topology.decimatePaintWeight.help = "Wyższa wartość będzie starała się zachować malowanie.

Ustaw tę wartość na 0, jeśli malowanie nie jest ważne.";
topology.decimateUniform = "Jednolite powierzchnie";
topology.decimateUniform.help = "Wyższa wartość pozwoli na uzyskanie trójkątów o podobnym rozmiarze.";
topology.decimatePreserveBorders = "";
topology.decimatePreserveBorders.help = "";

// Unwrapping means compute UV (texture coordinates), it allows the object to receive on texture (wrap the texturing on the object)
topology.uv.title = "Automatyczne obliczanie UV";
// UV Unwrapping
topology.uvAtlas = "Oblicz";
// The operation can be very slow
topology.uvAtlas.warning = "Może być bardzo powolne, cel < 100 tys. wierzchołków!";
// UV Unwrapping (BFF best left untranslated, stands for Boundary First Flattening)
topology.uvBFF = "Oblicz BFF";
// Handles are topological holes (synonym: genus, hole)
topology.uvBFF.warning = "Może mieć nakładki, jeśli siaka ma uchwyty!";
// Synonym: Point count? Singularity count ?
topology.uvBFFCones = "Liczba stożków";
topology.uvBFFCones.help = "Wyższa wartość zredukuje zniekształcenia złożonych obiektów.

Wyższa wartość oznacza dłuższy czas obliczeń.";
topology.uvDelete = "Usuń UV";

// Transfer the vertex painting in the texture
topology.bake = "Zastosuj malowanie wierzchołków";
topology.bake.help = "Przeniesienie malowania wierzchołków na teksturę.

Kolor wierzchołków jest resetowany podczas tego procesu.";
topology.bakeResolution = "Rozdzielczość";

// Reset key-bindings/shortcuts
binding.reset = "Resetuj powiązania";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.materialPicker = "Selektor materiału";
// Edit the tool brush size/radius
binding.editRadius = "Promień narzędzia";
// Edit the tool brush size/radius
binding.editIntensity = "Intensywność narzędzia";
// Snap the camera
binding.viewFront = "Widok z przodu";
// Snap the camera
binding.viewLeft = "Widok z lewej";
// Snap the camera
binding.viewTop = "Widok od góry";
// Move/Translate the view
binding.panLeft = "Przesuń w lewo (widok)";
// Move/Translate the view
binding.panRight = "Przesuń w prawo (widok)";
// Move/Translate the view
binding.panForward = "Przesuń do przodu (widok)";
// Move/Translate the view
binding.panBackward = "Przesuń do tyłu (widok)";
// Move/Translate the view
binding.panUp = "Przesuń do góry (widok)";
// Move/Translate the view
binding.panDown = "Przesuń do dołu (widok)";
// Snap the view (while rotating)
binding.snapViewOnRotate = "Przyciągnij widok (podczas obracania)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "Otwórz (projekt)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "Dodaj (projekt)";
// Import an external scene file (replace current scene)
binding.import.open = "Otwórz (import)";
// Import an external scene file (add it to the current scene)
binding.import.add = "Dodaj (import)";
// Select all the objects in the scene
binding.selectAll = "Zaznacz wszystko";
// Rotate environment and the lighting
binding.rotateLighting = "Obróć oświetlenie";

// Privacy policy
privacyPolicy.title = "Polityka prywatności";
privacyPolicy.reject = "Odrzuć";
// Hexanomad is the company name
privacyPolicy = "Hexanomad nie gromadzi żadnych danych z aplikacji Nomad Sculpt.";

// version trial
version.buyWeb = "Wersja internetowa to tylko demonstracja";
version.buyFull = "Przejdź na pełną wersję";
version.restorePurchase = "Przywróć zakup";

version.trialHistory = "Wersja próbna: możliwe 4 operacje cofnięcia/ponowienia";
version.trialLayer = "Wersja próbna: 1 warstwa na siatkę";
version.trialOneProject = "Wersja próbna: tylko 1 aktywny projekt";
version.trialNoImport = "Wersja próbna: brak importu";
version.trialNoExport = "Wersja próbna: brak eksportu";

version.fullFeatures = "- Jednorazowy zakup
- Nieograniczona liczba operacji cofnięcia/ponowienia
- Nieograniczona liczba warstw
- Zapisywanie i ładowanie
- Eksport i import";
