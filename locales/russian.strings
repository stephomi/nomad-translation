// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "Подтвердить?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Да";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "ОК";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Отмена";

// Name of an item (object, tool, etc)
item.name = "Имя";
// Add a new item (object, tool, etc)
item.new = "Создать";
// Rename an item (object, tool, etc)
item.rename = "Переименовать";
// Add a new item (object, tool, project, etc)
item.add = "Добавить";
// Save an item (object, tool, etc)
item.save = "Сохранить";
item.save.confirm = "Подтвердить сохранение?";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Последнее сохранение";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "Загрузить последнее сохранение?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Сбросить";
item.reset.confirm = "Подтвердить сброс?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "Создать метку экземпляра";
// Uninstance the object, make the object real
item.uninstance = "Снять метку экземпляра";
// Clone an item (object, tool, etc)
item.clone = "Клонирование";
// Delete an item (object, tool, etc)
item.delete = "Удалить";
item.delete.confirm = "Подтвердить удаление?";
item.delete.confirm.yes = "Да, удалить";
// When we delete the item but the image is used somewhere
item.delete.imageUsed = "Используется следующими инструментами:";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "В узел";
// Item visibility (object, layer, etc)
item.visible = "Видимо";
// Show an item (object, layer, etc)
item.show = "Показать";
// Hide an item (object, layer, etc)
item.hide = "Скрыть";
// Select an item (object, layer, etc)
item.select = "Выбрать";
// Unselect an item (object, layer, etc)
item.unselect = "Отменить выделение";
// Merge an item with another one below (layer)
item.mergeDown = "Объединить с нижним";
// The order of an item in a list
item.order = "Порядок";
// Focus on previous item
item.previous = "Предыдущий";
// Focus on next item
item.next = "Далее";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "Блокировать";

// Three-state toggle button (Auto, Off, On)
toggle.on = "Вкл.";
// Three-state toggle button (Auto, Off, On)
toggle.off = "Выкл.";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "Авто";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Обнаружены недостающие эскизы, повторная обработка файлов... ($0/$1)

$2";
loading.reprocess.cancel = "";

// Color of an object
material.color = "Цвет";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "Шероховатость";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "Глянцевость";
// Whether the material is a metal or not
material.metalness = "Металличность";
// How much light a surface will reflect
material.specular = "Зеркальность";
// Light that the surface can emit (glow)
material.emissive = "Излучение";
// Normal map (synonym: detail, bump)
material.normal = "Обычное";
// Ambient Occlusion (AO)
material.occlusion = "Объемный свет";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "Текстуры";

// Minify
about.minify = "Уменьшение интерфейса";
about.minify.help = "Вы также можете нажать на экран четырьмя пальцами, если ваше устройство поддерживает эту функцию.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Вращающаяся платформа";
// Make the entire scene turn around (speed of the animation)
about.turntableSpeed = "Скорость вращающейся платформы";
// Stuffs that I used to make the app
about.credits = "Титры";
// Link to open source projects that I used for the app
about.credits.openSource = "Открытый исходный код";
// Only translate the &
about.credits.arts = "Маткапы и HDRI";
// Change languages of the app
about.languages = "Языки";
about.languages.help = "Файлы перевода доступны по ссылке $0";
// Link to the App Website
about.website = "Сайт";
// Link to the App Forum
about.forum = "Форум";
// Link to the App Manual
about.manual = "Руководство";
// Link to the App Email
about.mail = "Поддержка";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";

// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "У объекта нет отверстий!";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "Текущий объект не виден!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Нечего обрезать.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Отмена обрезки: объект полностью обрезан.";
// In order to extract something, the mesh needs to have painted mask
alert.mask.noExtract = "Нечего извлечь!";
// In order to split something, the mesh needs to have painted mask
alert.mask.noSplit = "Нечего разделить!";
// List of disabled features when View Mode is selected
alert.view.disabled = "Функции, отключенные в режиме просмотра:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Примитивные виджеты";
// The object needs to have two parts disconnected
alert.separate.fail = "Невозможно разделить: объект состоит только из одной части!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "Перестройка меша завершена!";
alert.voxelRemesh.empty = "Отменить перестройку меша: у нового меша нет граней.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "Неверный объект!";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "Объект будет дублирован";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "Для объекта будет создана метка экземпляра";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Редактировать режим опорной точки.";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "Редактировать режим объекта.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Динамическая топология активна";
// See Glossary (DynTopo)
alert.dynamic.disable = "Динамическая топология отключена";
alert.colorPicker = "Проведите пальцем по объекту для выбора цвета.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Простое нажатие позволяет выйти из режима трансформации.";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "";
alert.view.reset = "Сбросить просмотр";
// Snap the view to the nearest aligned 90° angle
alert.view.snap = "Привязать просмотр";
// Show the painted mask on the mesh
alert.mask.show = "Показать маску";
// Hide the painted mask on the mesh
alert.mask.hide = "Скрыть маску";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Блокировка выделения";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Разблокировка выделения";
// Hide the objects that are not selected
alert.selection.isolate = "Изолирование выделения";
// Show the objects that are hidden
alert.selection.showAll = "Показать все";
// Project quick saving
alert.quickSave = "Сохранение...";
// Painting on the object was hidden but the user did paint the object
alert.forceShowPainting.fill = "Функция \"Показать окрашивание\" активирована, функция [Окрасить все] использована.";
// Painting on the object was hidden but the user started to paint on the object
alert.forceShowPainting.tool = "Функция \"Показать окрашивание\" активирована, объект был окрашен.";
// See Glossary (Multiresolution)
alert.multiresLost = "Мультиразрешение не будет сохранено!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "Детализация находится на высоком уровне и может потребовать большое количество памяти!";
// Autosave popup
alert.autoSave.auto = "Автосохранение через... $0с";
// The selected object doesn't have any layers
alert.needLayer = "Для текущего инструмента необходим активный слой.";
// The user decides to hide the painting on the objects
alert.paintingHidden = "Рисование скрыто: снова покажите этот инструмент в панели настроек.";
// The selected object doesn't have any layers
alert.noPartialWireframe = "Частичное рисование отключено, когда каркас отображается.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Подумайте об использовании ортогональной камеры, если вы хотите избежать искажения усеченного угла при использовании проектора.";
// Trial version has a limited number of undo
alert.state.trial = "Пробная версия: отмена отключена";

background = "Фон";
// A flat color will be displayed in the background of the scene
background.color = "Цвет";
// The environment (HDRI) will be displayed in the background
background.environment = "Окружение";
background.blur = "Размытие";
background.exposure = "Экспозиция";

// Image that the artist uses as a reference
background.imageEnable = "Эталонное изображение";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Наложение";
// Opposite of transparency (Alpha)
background.imageAlpha = "Непрозрачность";
background.imageReset = "Сбросить параметры";
background.imageTransform = "Трансформация";
// X screen coordinate of the image reference
background.imageX = "Позиция X";
// Y screen coordinate of the image reference
background.imageY = "Позиция Y";
// Rotation of the reference image
background.imageRotation = "Поворот";
// Scale of the reference image
background.imageScale = "Масштаб";

// Camera (point of view in 3d)
camera = "Камера";
// Copy the views
camera.updateView = "Обновить точку просмотра?";
// Add a new camera
camera.addView = "Добавить просмотр";
// Focus on the camera
camera.focus = "Фокусировка";
// Add on the camera camera
camera.focusOn = "Фокусировка на $0";
// Camera projection, Orthographic or Perspective
camera.projection = "Проекция";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Ортогональная";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Перспектива";
// camera Vertical Field of View
camera.fov = "Вертикальное поле обзора";
// Camera Field of View hint
camera.focal = "фок. $0mm (сенсор 35мм)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Поворот";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "Вращающаяся платформа";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Шаровой манипулятор";
camera.rotation.trackball.help = "Шаровой манипулятор предоставляет больше возможностей: вы можете вращать камеру двумя пальцами.";
// Camera interaction mode, 1st person view
camera.firstPerson = "Первое лицо";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Скорость";
// Camera rotation sensitivity
camera.speed.rotation = "Поворот";
// Camera translation sensitivity
camera.speed.panning = "Панорамирование";
// Camera zooming sensitivity
camera.speed.zooming = "Масштабирование";
// Reset camera position
camera.resetView = "Сбросить просмотр";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Привязать просмотр";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "Камера привязана (ортогональная)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "Ортогональная привязка";
camera.snapOrthographic.help = "Эта функция также работает при использовании куба привязки в углу.";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Ось";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Двойное касание по объекту";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Двойное касание по фону";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "Переключатель";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "Выделение";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "Кадр";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "Обновление по двойному касанию";
camera.doubleTapPivot.help = "Обновление оси вращения при двойном касании по поверхности объекта.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "Воздушная ось";
camera.airPivot.help = "Позволить создание новой оси при масштабировании вне поверхности объекта.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "Старт жестами при запуске камеры";
camera.autoPivot.help = "Обновить ось при начале работы с камерой.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Фокусировка";
camera.doubleTapFocus.help = "При двойном нажатии по объекту камера произведет панорамирование и сфокусируется на выбранной точке.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "Выбор нескольких объектов";
// There is 0 nodes/items selected
context.noSelection = "Нет выделения";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "Пресет";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Катмалла-Рома";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "Сплайн";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "";

// set the desired FPS (frame per second, refresh rate)
debug.targetFPS = "";
debug.targetFPS.help = "";

// Debug option, the newly created primitives will contains texture coordinates (UVs)
debug.uvPrimitive = "Сохранить примитивные UV";
debug.uvPrimitive.warning = "Отключите эту функцию, если вы не работаете с UV (экономия памяти).";
debug.uvPrimitive.help = "В данный момент доступны только Сфера и Коробка.

В будущем будут поддерживаться и другие типы.";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "Нормализация UV";
debug.uvNormalize.help = "Nomad нормализует UV в плитке [0-1].";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "Добавить BFF UV";
debug.uvBFF.help = "Добавить альтернативный метод развертки (BFF).

Примечание: BFF создаст перекрытия, если топология меша отличается от диска или сферы.";
// Debug option, display an window with some debugging logs
debug.logs = "Журнал";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Карта высот";
// Debug options, graphical stuffs
debug.graphics = "Графика";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Создать пиктограммы для магазина";

// Empty list: there is no projects
file.project.empty = "Еще нет сохраненных проектов!";
// The current opened project has some unsaved changes
file.project.unsaved = "Несохраненные изменения!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "Вы потеряете несохраненные изменения!";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Предпросмотр последнего сохранения вручную";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "Пробная версия: вы не сможете снова открыть текущий проект!";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "Пробная версия: вы сможете снова открыть только текущий проект!";

file.project = "Проект";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Сохранить";
// E.g: Save "my_project"?
file.project.save.confirm = "Сохранить $0?";
// Save to another project (either new one or overriding existing one)
file.project.saveAs = "Сохранить как";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "Перезаписать $0?";
// Open a project
file.project.open = "Открыть";
// E.g: Open "my_project"?
file.project.open.confirm = "Открыть $0?";
// Load another project and add/append all its data to the current scene
file.project.add = "Добавить в кадр";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "Добавить $0 в кадр?";
// Reset the scene and create a new project
file.project.new = "Создать";
file.project.new.confirm = "Создать новый кадр?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "Удалить $0?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "Удалить $0?

Это текущий активный проект!";

// Auto save section
file.project.autoSave = "Автосохранение";
file.project.autoSave.confirm = "Отключить автосохранение?";
file.project.autoSave.help = "Регулярно сохраняйте проект в отдельном файле.
Файл автосохранения находится здесь:

$0";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "Интервал всплывающего окна";
// In minutes
file.project.autoSave.minutes = "Таймер всплывающего окна";
// Delete the current autoSave data
file.project.autoSave.delete = "Сбросить автосохранение";

// Load interface preference settings when opening a scene file
file.load.guiSettings = "Сохранить настройки интерфейса";
file.load.guiSettings.help = "При открытии или импорте файла проекта будут загружены все настройки интерфейса, установленные в проекте.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.load.objSplitByGroup = "Разбить OBJ по группам";
file.load.objSplitByGroup.help = "При включении этой функции Nomad будет разбивать группы OBJ на отдельные объекты.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.load.mergeLayers = "Объединить слои";
// Ignore the textures present in the file to load
file.load.skipTextures = "Игнорировать текстуры";
// Do not fiddle with the object topology when loading the file
file.load.keepTopology = "Сохранить топологию";
file.load.keepTopology.help = "Используйте эту функцию, если вы не хотите, чтоб Nomad вносил изменения в топологию импортированного меша.

Это отключит перестройку вершин/граней, удаление дубликатов вершин/граней и удаление неиспользованных вершин.";
// If the object has more vertices than this value, then we won't attemp to reverse (multiresolution) the object
file.load.reverseVertices = "Порог инверсии";
file.load.reverseVertices.help = "Для экономии памяти Nomad не сохраняет низкое разрешение меша.

Низкое разрешение меша будет восстановлено, если количество вершин ниже порогового значения.";


// Configure imports option
file.importSettings = "Настройки импорта";

// Import file section
file.import.title = "Импорт";
file.import.title.help = "Поддерживаемые форматы:
- Wavefront (.obj)
- glTF 2.0 (.glb .gltf)
- STL (.stl)";
// The user imports a scene file that will replace the current scene
file.import.open = "Открыть";
file.import.open.confirm = "Импортировать новый файл?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Добавить в кадр";
file.import.add.confirm = "Импортировать новый файл?";

// Export scene file
file.export.title = "Экспорт";
file.export.title.help = "Предпочтительным форматом является glTF, так как он поддерживает большее количество функций.";

// Export the current selected objects instead of the entire scene
file.onlySelection = "Включать только выбранные объекты";
file.onlySelection.help = "Включать только выбранное, а не весь кадр.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Восстановление четырехугольника";
file.convertToQuad.help = "Восстановление четырехугольников из треугольников путем сопряжения треугольников (если они прилегают друг к другу в файлах).";

// Whether we include the textures in the exported file
file.export.texture = "Экспорт текстур";
// Baking means transfering/converting
file.export.texture.help = "Эта функция не позволяет запекать цвета вершин в текстуры.";
// Whether we include normals vector in the exported file
file.export.normal = "Экспорт нормалей";
file.export.normal.help = "Выберите эту опцию, если вы хотите открыт файл в других программах.

Nomad всегда игнорирует нормали, т. к. они будут вычислены заново.";

file.export.gltf = "Экспорт glTF 2.0";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Экспортировать слои";
file.export.gltf.layer.help = "Экспорт слоев в качестве морфов. Официально поддерживается glTF и должно работать и в других программах.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Экспортировать окрашивание слоев";
file.export.gltf.layerPaint.help = "Экспорт окрашивания слоев. Обычно игнорируется другими программами.";
// Whether the exported layer will use the non-standard Nomad encoding (smaller size)
file.export.gltf.layerNomad = "Кодировка слоев Nomad";
file.export.gltf.layerNomad.help = "Может уменьшить файл путем записи окрашиванияя слоев в 8 бит (вместо 16 бит).

Эта кодировка работает только в Nomad и использует абсолютное окрашивание.
Другие программы покажут неверный результат, т. к. для glTF требуется относительная кодировка.";
// Whether we include the vertex color in the exported file
file.export.gltf.color0 = "Экспорт цветов вершин";
file.export.gltf.color0.help = "Экспорт цветов вершин. Официально поддерживается glTF и должно работать и в других программах.";
// Whether we include the vertex roughness and vertex metalness in the exported file
file.export.gltf.color1 = "Экспорт окрашивания PBR";
file.export.gltf.color1.help = "Экспорт шероховатости, металличности и окрашивания масок. Будет игнорироваться другими программами.";

file.export.obj = "Экспорт obj";
file.export.obj.warning = "Слои и другое окрашивание (шероховатость, металличность и маски) не будут сохранены.";
// Whether we include the vertex color in the exported file
file.export.obj.colorAppend = "Экспорт цветов вершин";
file.export.obj.colorAppend.help = "Прикрепление цветовой информации к вершинам.

Некоторые 3D-программы смогут прочесть эту информацию, но не все.";

file.export.stl = "Экспорт STL";
file.export.stl.warning = "Слои и другое окрашивание (шероховатость, металличность и маски) не будут сохранены.";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Экспорт цветов вершин";
file.export.stl.color.help = "Некоторые 3D-программы смогут прочесть эту информацию, но не все.";
file.export.stl.ascii = "По умолчанию используется бинарный формат.

Вы можете выбрать экспорт в текстовом формате (ASCII), но размер файла будет больше.";

// Advanced settings
settings.advanced = "Дополнительно";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "Эти опции не сохраняются в настройках.";
settings.reset.title = "Параметры";
settings.reset.title.help = "Это сбросит настройки предпочтений приложения.

Часть ресурсов сохраняется отдельно и не будет сброшена, а именно:
- Проекты
- Функциональные клавиши
- Наборы инструментов
- HDR-окружение
- MatCap
- Альфы
- Текстуры (кисти)
- Эталонные изображения

Примечание: все, связанное с проектами, будет сохранено, например, освещение, пост-обработка, просмотр камеры, и т.д.";

// Reset preference settings button
settings.reset = "Сбросить к стандартным";
settings.reset.confirm = "Сбросить настройки предпочтений?";

// Render a screenshot of the scene
file.render = "Рендеринг";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Показать интерфейс";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Разрешение рендеринга";
file.render.renderRatio.help = "Значение 1.0 значит, что Nomad будет производить рендеринг в том же разрешении, как и изображение ниже.

Используйте эту функцию, если вы не можете произвести рендеринг в определенном разрешении (аварийное завершение работы в связи с недостатком памяти).";
// Desired size of the exported screenshot
file.render.size = "Финальный размер";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Собственный";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "экран";
// width of exported screenshot
file.render.width = "Ширина";
// height of exported screenshot
file.render.height = "Высота";
// export screenshot of the scene
file.render.export = "Экспорт png";
file.render.warn = "Высокое разрешение экспорта ($0x$1)!

Обязательно сохраните проект в случае, если вашему устройству не хватит видео-ОЗУ и произойдет аварийное завершение работы.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Прозрачный фон";
file.render.transparent.help = "Эта функция может пригодиться для вставки меша в программу для создания 2D.

Частичная прозрачность объектов пока не поддерживается.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Использовать глобальные настройки";
pressure.useGlobal.help = "По умолчанию инструменты используют одинаковые настройки нажима.

Снимите галочку с этой функции, если вы хотите установить особые настройки нажима для этого инструмента.";

// Pencil pressure
pressure.title = "Нажим";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "Этот инструмент не поддерживает нажим стилуса.";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "Тип штриха «Движение» будет игнорировать настройки нажима.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Радиус";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Интенсивность";

// Customize whether finger and/or stylus can move the Camera
gesture.cameraInteraction = "Камера:";
// Customize whether finger and/or stylus can sculpt on object
gesture.sculptInteraction = "Скульптурирование:";
// Both the finger and the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.fingerAndStylus = "Палец и стилус";
// Only the finger can perform a certain action (move camera, sculpt, etc)
gesture.interaction.finger = "Палец";
// Only the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.stylus = "Стилус";
// Disable the action
gesture.interaction.none = "Нет";
// Allow the action for any inputs
gesture.interaction.any = "Любой ввод";

// long press to pick the color/material under the cursor
gesture.materialPicking = "Выбор материала";
gesture.materialPicking.help = "Выбор материала/цвета можно вызвать долгим нажатием на холст.

Примечание: это работает только в том случае, если для текущей кисти включено окрашивание.";

// Three fingers on screen
gesture.three.title = "Три пальца";
// Drag 3 fingers horizontally on the canvas to rotate the environment, lights and MatCap
gesture.fingerLighting = "Повернуть освещение (3 пальца)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerLighting.help = "Проведите горизонтально тремя пальцами по холсту для проворачивания окружения, освещения и MatCap.";
// Drag 3 fingers vertically to edit the tool radius
gesture.fingerRadius = "Редактировать радиус инструмента (3 пальца)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerRadius.help = "Проведите вертикально тремя пальцами по холсту для изменения радиуса инструмента.";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.fingerSmooth = "Палец производит сглаживание";
gesture.fingerSmooth.help = "";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Разрешить неопознанное давление";
gesture.unknownPressure.help = "Выберите эту функцию, если нажим не поддерживается для вашего стилуса или вам нужна регулировка нажима стилусом.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Кнопка стилуса";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Двойное касание стилусом";
gesture.pencilAction.ios.help = "Активно только для стилуса Apple Pencil второго поколения.";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "Нет";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Добавить/убрать";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "Быстрая клавиша для одного касания";
gesture.mask.oneTap.help = "Позволяет быстрой клавише произвести действие «Маска», однократно нажав на экран, не зажимая быструю клавишу маски.

Это включит следующие жесты:
- нажатие на фон произведет инверсию маски
- нажатие на зону маски произведет размытие маски
- нажатие на зону без маски усилит резкость маски";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress = "Долгое нажатие (Маска↔ Выб. маску)";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress.help = "Когда «Маска» или «Выб. маску» активно, долгое нажатие пальцем позволит выбирать один из этих инструментов.

При долгом нажатии без перемещения пальца новый инструмент будет использоваться как быстра клавиша маски по умолчанию.";
// Indicator that the tool has been set as the new shortcut
gesture.mask.infoShortcut = "Функция «$0» установлена как быстрая клавиша маски.";

// Shortcuts to undo/redo
gesture.history = "Быстрая клавиша истории";
gesture.history.help = "- Отмена: нажатие двумя пальцами
- Возврат: нажатие тремя пальцами
- Отмена/Возврат: продолжительно зажать 2/3 пальца";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Отторжение ладони";
gesture.palmRejection.confirm = "Отключите эту функцию, если у вас возникают сложности при работе с холстом!";
gesture.palmRejection.help = "Отклоняет ввод, если контактная поверхность больше этого значения.

Может работать не на всех устройствах.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Порог макс. размера";

// History, list of undo/redo
history = "История";
// First "undo" state
history.root = "Первое действие";
history.undoConfirm = "Вы точно хотите отменить все эти действия?";
history.undoWarning = "Если вы отредактируете что-то, вы можете потерять большое количество изменений.";
// Settings concerning the history stack of undo/redo
history.stack = "Стек";
// Actions to include in the undo/redo stack
history.include = "Включать действия";
// include lighting editing in the undo/redo
history.includeLights = "Освещение";
history.includeLights.help = "Если эта функция включена, перемещение освещения с помощью гизмо все еще будет включено, т. к. оно может повлиять на другие объекты в иерархии кадра.";
// include postProcess editing in the undo/redo
history.includePostProcess = "Пост-обработка";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "Маткапы и HDRI";
// Can limit the stack of undo/redo size
history.limitSize = "Лимит истории (Мб)";
history.limitSize.help = "Максимальный размер истории в Мб.

История будет обновлена при следующем записанном действии.";
// Limit the number of undo in the history stack
history.limitStack = "Лимит стека";
history.limitStack.help = "Максимальное количество регистрируемых действий.

История будет обновлена при следующем записанном действии.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Максимум возвратов";
history.rangeProtect.help = "Если вы вернетесь в истории, автоматически возникнет диалог подтверждения до удаления многих изменений.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Восстановление камеры";
history.restoreCamera.help = "Включите эту функцию для восстановления сохраненной позиции камеры при отмене/возврате.";
// Undo
history.undo = "Отмена действия";
// Redo
history.redo = "Повторить";
// Shown during undo
history.state.undo = "Отмена: $0";
// Shown during redo
history.state.redo = "Возврат: $0";
// Shown during undo/redo
history.state.symmetrySplit = "Симметричное разделение";
// Shown during undo/redo
history.state.voxelRemesh = "Воксельная перестройка меша";
// Shown during undo/redo
history.state.surfaceRemesh = "Поверхностная перестройка меша";
// Shown during undo/redo
history.state.multiresLevel = "Изменение разрешения";
// Shown during undo/redo
history.state.multiresToDynamic = "Мультиразрешение в дин.топ.";
// Shown during undo/redo (mesh type conversion)
history.state.meshDynamicToStatic = "Дин.топ. в статику";
// Shown during undo/redo (mesh type conversion)
history.state.meshStaticToDynamic = "Статика в дин.топ.";

// Interface customization
interface = "Интерфейс";

// UI customization: one item row will stands on one line (synonym: Inlined)
interface.compact = "";

// UI customization: each row of the list will be bigger
interface.expandList = "Интерфейс: расширить список";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Опция интерфейса для упрощения работы со списками.";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "Добавить быстрые клавиши (низ)...";

// Interface option (main base color)
interface.colorBase = "Базовый цвет";
// Interface option (accent widget color)
interface.colorSelect = "Цвет виджета";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Прозрачные панели";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Интенсивность размытия";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Цвета панелей";

// Interface color style
interface.preset.title = "Наборы цветов";
// Interface color style (original color of Nomad Sculpt)
interface.preset.classic = "Классический";
// Interface color style
interface.preset.orange = "Оранжевый";
// Interface color style (~red)
interface.preset.cardinal = "Охра";
// Interface Color style (~pink)
interface.preset.mulberry = "Багровый";
// Interface color style
interface.preset.brown = "Коричневый";
// Interface color style (~green)
interface.preset.emerald = "Изумрудный";
// Interface color style (~blue)
interface.preset.neon = "Neon";
// Interface color style
interface.preset.violet = "Фиолетовый";
// Interface color style
interface.preset.grey = "Серый";
// Interface color style
interface.preset.black = "Черный";
// Interface color style
interface.preset.white = "Белый";

// Reset interface settings
interface.resetAll = "Сбросить стиль";
interface.resetAll.confirm = "Сбросить настройки интерфейса?";
// Interface option (main base color)
interface.iconSupport = "";
interface.iconSupport.help = "";
// Interface customization
interface.flipTop = "Отражение верхней панели";
// Interface customization
interface.flipBottom = "Отражение нижней панели";
// Interface customization
interface.flipMiddle = "Отражение боковой панели";
// Interface customization (preview material in the viewport when editing material color)
interface.materialPreview = "Предпросмотр цвета материала";
// Interface customization
interface.materialPreview.help = "При выборе цвета для материала, предпросмотр материала отображается на текущем выбранном объекте.";
interface.toolbox.hide = "Скрыть панель инструментов";
interface.toolboxHide.help = "Включите эту функцию, если вы хотите скрыть панель инструментов.";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.maxColumn = "Макс. колонок панели инструментов";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Сбросить порядок панели инструментов";
// Scale the interface
interface.scale = "Общий масштаб";
// Spacing between widgets
interface.cursorStep = "Вертикальный интервал";
// Width of the interface panels
interface.panelWidth = "Ширина панели";
// Size of fonts
interface.fontScale = "Масштабирование шрифта";
// Inset
interface.inset.title = "Смещения ребер";
interface.inset.title.help = "Вы можете изменить эти значения только в том случае, если у вас возникают проблемы при работе с кнопками на краях экрана.

Если слайдер отключен, Nomad будет использовать значения безопасных областей самого устройства.";
interface.inset.left = "Лево";
interface.inset.right = "Право";
interface.inset.bottom = "Низ";
interface.inset.top = "Верх";

// (see Glossary for Layer)
layer = "Слой";
// (see Glossary for Layer)
layers.lock = "Сохранить детали верхних слоев";
// (see Glossary for Layer)
layers.lock.yes = "Закрепить верхние слои?";
// (see Glossary for Layer)
layers.lock.warning = "Во время скульптурирования деформация верхних слоев будет игнорироваться.

Детали этих слоев все еще будут видны.

Эта функция работает только в том случае, если у верхних слоев детали небольшого размера.";
// (see Glossary for Layer)
layers.addLayer = "Добавить слой";
// (see Glossary for Layer)
layer.factors = "Факторы каналов";
// (see Glossary for Layer)
layer.factor = "Фактор";
// (see Glossary for Layer)
layer.offset = "Сдвиг";
// (see Glossary for Layer)
layers.title = "Слои";
// (see Glossary for Layer)
layers.title.help = "Слои могут записывать сдвиги позиций и окрашивание, что может помочь при нелинейном стиле работы.
Например, при экспериментировании с различными выражениями лица без опоры на стек истории и возврат изменений.

Данные окрашивания в слоях сортируются сверху вниз, т. е. слои вверху будут маскировать нижние.

Вы можете удалить часть слоя (и влияние слоя) с использованием инструмента «Удал. слой».";
layers.primitive = "Слои недоступны для примитив.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "Нет";

light = "Освещение";
// Intensity of light
light.intensity = "Интенсивность";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "Температура";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Привязка";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Закреплено";
// The light will move along the camera
light.attachment.camera = "Камера";
light.attachment.help = "-- Закреплено
Ориентация освещения не изменится

-- Камера
Ориентация освещения зависит от просмотра камеры.";
// Light type (directional, spot, point)
light.type = "Тип";
// Directional light (synonym: sun light)
light.type.directional = "По направлению";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Узконаправленное освещение";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Всесторонний свет";
// Cone angle for spot angles
light.spot.angle = "Конический угол";
// Softness of the spot light
light.spot.softness = "Мягкость";
// Position of the light
light.position = "Позиция";
// Enable or disable shadows for a light
light.shadow.cast = "Тень";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "Всесторонний свет поддерживает тени только на экранном пространстве.";
light.shadow.type = "Тип тени";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "Теневая карта";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "Экранное пространство";
light.shadow.type.screenspace.help = "Экспериментальная функция, может быть удалена в дальнейших релизах.

Эта функция используется вместе с функцией «Мягкость теней».";
// Adjustment to fix artefacts
light.shadow.bias = "Расхождение";
// How blurry the shadow is
light.shadow.softness = "Мягкость";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "Контактные";
light.contact.help = "Если выбран режим «Авто», то только у основного освещения будут контактные тени.";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "Допуск";
// Activated the light
light.visible = "Показать";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Отцентрировать";

// Object's material
material = "Материал";
// See glossary
material.pbrRoughnessMetalness.warning = "Для шероховатости и металличности необходим режим затенения PBR.";
// See glossary
material.pbrReflectance.warning = "Для отражательной способности необходим режим затенения PBR.";
// See glossary
material.pbrRefraction.warning = "Для отражения необходим режим затенения PBR.";
// See glossary
material.pbrSubsurface.warning = "Для подповерхности необходим режим затенения PBR.";
// Value that says how much light will change direction when hitting the surface
material.ior = "Показатель отражения";
// an object-level value that overrides the painting of the mesh
material.paintingOverride = "Регулировка окрашивания";
// The roughness in the inside is turbidity
material.paintingOverride.help = "Используются два типа шероховатости: поверхностная и внутренняя.

Окрашиваться может только одна шероховатость, поэтому у обоих типов шероховатости одно и то же значение.

Этот слайдер может использоваться для регулировки шероховатости поверхности и создания более глянцевой поверхности.";
// Glossiness is simply the opposite of roughness
material.refractionSurfaceGlossiness = "Глянцевость поверхности";
material.refractionSurfaceGlossiness.help = "- При 0 поверхность использует окрашенную шероховатость
- При 1 поверхность абсолютно гладкая";
// Synonym: turbidity
material.refractionInteriorRoughness = "Внутренняя шероховатость";
material.refractionInteriorRoughness.help = "- При 0 внутренняя часть использует окрашенную шероховатость
- При 1 внутренняя часть абсолютно шероховатая";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Глянцевое окрашивание";
material.paintGlossy.help = "Оно окрасит объект с величиной шероховатости и металличности 0, создав четкое отражение.

Этого также можно достичь, перейдя в меню окрашивания и используя функцию «Окрасить все», отключив цвет и металличность.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Поглощение";
material.absorptionEnable.help = "Симуляция поглощения света при прохождении через объем.

Тонкие участки будут казаться светлее, так как они пропускают большее количество света, а плотные участки будут казаться темнее.

Этот эффект сильно зависит от формы объекта: плотность объекта рассчитывается примерно.";
material.absorptionFactor = "Фактор";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "Глубина";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "Светопроницаемость";
material.translucency.help = "Вам нужен источник освещения, создающий тени, для того, чтоб увидеть светопроницаемость.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Непрозрачность";
// Fully opaque material
material.type.opaque = "Непрозрачный";
// See glossary
material.type.subsurface = "Подповерхность";
material.type.subsurface.help = "Для достижения наилучших результатов, переключитесь в режим затенения PBR и используйте как минимум один направленный источник цвета, предпочтительно в сумраке.";
// Transparency mode, alpha blending
material.type.blending = "Смешение";
material.type.blending.help = "Сделайте объект полупрозрачным, изменяя значение непрозрачности.

Примечание: из-за ограничений реального времени вы можете заметить крупные визуальные артефакты в случае, если у вашего объекта сложная форма.";
// Transparency mode
material.type.additive = "Аддитивный";
material.type.additive.help = "Сделайте объект полупрозрачным, изменяя значение непрозрачности.

Этот метод создает меньше артефактов, чем при смешении, но объект будет ярче.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Дизеринг";
material.type.dithering.help = "Сделайте объект полупрозрачным, удалив часть пикселей в случайном порядке.";
// Simulate glass-like material
material.type.refraction = "Отражение";
material.type.refraction.help = "Этот режим используется для симуляции стеклянных материалов.

В связи с ограничениями реального времени, самоотражение и многослойное отражение ограничены.";
material.castShadows = "Отбросить тени";
material.receiveShadows = "Покрыть тенями";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Всегда неосвещено";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Игнорирование инверсии";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Отражательная способность";
material.reflectance.help = "Регулируйте отражательную способность неметалличных материалов.

В большинстве случаев стоит использовать значение по умолчанию (0.5, что соответствует стандартным 4% отражаемого света при нормальном угле).";

// Menu name
menu.files = "Файлы";
// Menu name
menu.scene = "Кадр";
// Menu name
menu.multires = "Мультиразрешение";
// Menu name
menu.voxel = "Воксель";
// Menu name
menu.dynTopo = "Дин. топ.";
// Menu name
menu.topology = "Упрощ./UV...";
// Menu name
menu.primitive = "Примитивы";
// Menu name
menu.render = "Рендеринг";
// Menu name
menu.material = "Материал";
// Menu name
menu.postProcess = "Пост-обработка";
// Menu name
menu.camera = "Камера";
// Menu name
menu.background = "Фон";
// Menu name
menu.tool = "Инструмент";
// Menu name
menu.stroke = "Штрих";
// Menu name
menu.paint = "Рисовать";
// Menu name
menu.symmetry = "Симметрия";
// Menu name (pencil pressure)
menu.pressure = "Нажим";
// Menu name
menu.gesture = "Жест";
// Menu name
menu.layers = "Слои";
// Menu name
menu.settings = "Параметры";
// Menu name
menu.interface = "Интерфейс";
// Menu name
menu.bindings = "Привязки";
// Menu name
menu.history = "История";
// Menu name
menu.historySettings = "Параметры";
// Menu name
menu.about = "Информация";
// Menu name
menu.debug = "Отладка";

// Operation on the object (action)
mesh.action = "Операция";
// If the object has holes, the algorithm will close them
mesh.holeClose = "Закрыть дырки";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holeDetail = "Детали";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Отделить";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "Слои, окрашивание и мультиразрешение будут потеряны.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Разрешение";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Принудительно создать куб";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Конвертировать";
// Static object means "static topology"
mesh.typeStatic = "Меш";
// See glossary
mesh.typeMultiresolution = "Мультиразрешение";
// Dynamic topology
mesh.typeDynamic = "Дин. топ.";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Глобальный материал";
paint.useGlobal.help = "Если эта функция включена, выбранный материал будет таким же, как и у других инструментов.

Примечание: учитывается только шероховатость, металличность и настройки цвета.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Окрашивание штрихов";
// Factor/Opacity of paint tool
paint.intensity = "Интенсивность окрашивания";
// Apply the paint on the object
paint.paintAll = "Окрасить все";
paint.paintAll.help = "Применить текущий материал к объекту.

Область маски и отключенные каналы не будут окрашены.";
// Apply the paint on the object but ignore painting intensity (force full intensity)
paint.paintAllForce = "Принудительно окрасить все";
paint.strokePainting.title = "Краски";
// Brush stroke texture
paint.texture.title = "Текстура";
paint.texture.title.help = "Изображение, которое окрасит штрихи кисти.

Примечание: его настройки плитки и масштабирования будут такими же, как и у альфы.";
paint.texture.warningEnable = "Окрашивание штрихов необходимо включить для проекции текстур (галочка вверху)!";
paint.texture.warningIgnored = "Текущий инструмент не может использовать текстуры!";
// Whether the Brush Alpha will be used to module painting
paint.useAlpha = "Использовать альфа-штрихи";
paint.useAlpha.help = "Использование альфа-набора в меню штрихов для оптимизации окрашивания.";
// Whether the Brush Falloff will be used to module painting
paint.useFalloff = "Использовать спад штрихов";
paint.useFalloff.help = "Использование спад-набора в меню штрихов для оптимизации окрашивания.";

// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "Новое имя";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "Новое значение";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "Новый цвет (шестнадцатеричный формат)";

// Post process effect
postprocess = "Пост-обработка";
// Quality vs performance
postprocess.quality = "Качество";
postprocess.quality.help = "Включите эти функции для улучшения качества при ухудшении производительности.";
// More samples means better quality but slower performance
postprocess.maxSamples = "Макс. примеров";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Полное разрешение";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "Макс. сэмплирование кадров";
postprocess.accumulateCount.help = "Максимальное количество кадров, накапливаемое до остановки рендеринга.

При остановке рендеринга Nomad не будет совершать действий, экономя время работы аккумулятора.

Накапливание кадров положительно влияет на многие функции рендеринга:
- Мягкость теней
- Глобальное освещение
- Отражение (SSR)
- Ambient Occlusion
- Подповерхность
- Глубина резко изображаемого пространства

Высокое количество кадров преимущественно необходимо для функций «Мягкость теней» и «Глобальное освещение».
Nomad может прекратить рендеринг быстрее, если вышеупомянутые функции отключены.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Разрешение рендеринга";
postprocess.renderRatio.warning = "Принудительное выполнение эффектом «Пиксельная графика».";
postprocess.renderRatio.help = "Эта функция заметно влияет на производительность.
Рекомендуется выставлять значение ниже x1.25.

Эта опция не сохраняется в настройках.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "Временной анти-алиасинг (TAA)";
postprocess.taa.help = "Снижает мерцание при передвижении камеры.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "Отражение (SSR)";
postprocess.ssr.warning = "Для SSR необходим режим затенения PBR.";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "Глобальное освещение (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "Допуск";
postprocess.ssgi.experimental = "Экспериментальная функция!";
postprocess.ssgi.warning = "Для SSGI необходим режим затенения PBR.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "Ambient occlusion";
// How far the effect spreads
postprocess.ssao.radius = "Размер";
// How strong the effect is
postprocess.ssao.factor = "Сила";
// Adjustment to fix artefacts
postprocess.ssao.bias = "Расхождение модификатора кривой";
postprocess.ssao.bias.help = "Чувствительность эффекта в зависимости от кривизны поверхности.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "Глубина резко изображаемого пространства";
// The blur factor behind the focused point
postprocess.dof.blurFar = "Размытие на удалении";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "Размытие на близости";
postprocess.dof.focusTip = "Коснитесь объекта для изменения точки фокуса.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "Цветение";
// Intensity of the effect
postprocess.bloom.intensity = "Интенсивность";
// How far the effect spreads
postprocess.bloom.radius = "Радиус";
postprocess.bloom.radius.help = "Насколько распространено свечение.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "Порог";
postprocess.bloom.threshold.help = "Пороговое значение яркости, определяющее, будет ли светиться пиксель.
Если значение равно 0, все пиксели светятся.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "Тональное отображение";
postprocess.tone.exposure = "Экспозиция";
postprocess.tone.contrast = "Контраст";
postprocess.tone.saturation = "Насыщенность";
// No tonemapping operator is used
postprocess.tone.mapping.none = "Нет";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "Нейтральное";
// Color curves
postprocess.curve = "Цветокоррекция";
// Curve for pixel luminance
postprocess.curve.luminance = "Основная";
postprocess.curve.red = "Красный";
postprocess.curve.green = "Зеленый";
postprocess.curve.blue = "Синий";
postprocess.curve.reset = "Сбросить";
// Reset color grading curves
postprocess.curve.resetAll = "Сбросить все";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "Хроматическая аберрация";
postprocess.chromatic.factor = "Сила";
// Darking on the edges
postprocess.vignette = "Виньетка";
// How far the effect spreads
postprocess.vignette.size = "Размер";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "Твердость";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "Резкость";
postprocess.sharpness.factor = "Сила";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "Зерно";
postprocess.grain.factor = "Сила";
// Accentuate the edges of the model
postprocess.curvature = "Модификатор кривой";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "Полости";
// Color/Strength of convex curvature
postprocess.curvature.bump = "Выступы";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "Пиксельная графика";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "Позволить сэмплирование кадров";
// Simulate scanline rendering (horizonal line)
postprocess.scanline = "Сканирование строк";
postprocess.scanline.factor = "Фактор";
// Spacing between lines
postprocess.scanline.spacing = "Интервалы";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Примитивы";
primitive.box = "Коробка";
primitive.sphereCube = "Сфера";
primitive.sphereUV = "UV сфера";
primitive.icosahedron = "Икосаэдр";
primitive.cylinder = "Цилиндр";
primitive.cone = "Конус";
primitive.torus = "Тор";
primitive.lathe = "Тело вращения";
primitive.tube = "Трубка";
primitive.plane = "Плоскость";
primitive.triplanar = "Трипланарность";
primitive.faceXYZ = "Грань XYZ";
primitive.faceXYZ.help = "Базовый меш без развертки UV предоставлен https://texturing.xyz/";
primitive.needValidate = "Примитивы должны быть утверждены для скульптурирования.";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Правка";
primitive.edit.help = "Позволить 3D-редактирование во вьюпорте.

Вы можете отключить эту функцию, если вы хотите работать с гизмо или инструментом «Трансформация», не изменяя примитивы.";

// Primitive configuration
primitive.mainConfig = "Параметр";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Топология";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Геометрия";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Утвердить";
// Maximum number of faces of the primitives
primitive.maxFaces = "Макс. граней";
primitive.maxFaces.help = "Максимальное количество гране примитивы.

Это пороговое значение активно только тогда, когда примитива не утверждена, затем пороговое значение не играет роли.";
// Synonym: Flat subdivision
primitive.linear = "Линейное подразделение";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Последующее подразделение";

// Radius (of a sphere, torus, etc)
primitive.radius = "Радиус";
// Size (of cube x dimension)
primitive.size = "Размер";
primitive.sizeX = "Размер X";
primitive.sizeY = "Размер Y";
primitive.sizeZ = "Размер Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "Разрешение";
primitive.divisionX = "Разрешение X";
primitive.divisionY = "Разрешение Y";
primitive.divisionZ = "Разрешение Z";
// Angle of torus, etc
primitive.angleX = "Угол X";
primitive.angleY = "Угол Y";
primitive.angleZ = "Угол Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Постоянная плотность";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Проект на сфере";
primitive.projectOnSphere.help = "Привязывает точки в идеальную сферу.";

// triplanar
primitive.triplanar.title = "Трипланарность";
primitive.triplanar.title.help = "Трипланарность использует информацию масок трех плоскостей для заполнения воксельной сетки, которая затем полигонизируется.

При работе с подразделениями или слайдерами размера информация об окрашивании будет сброшена (сглаживание сохранится).

Стоит отключить симметрию, так как эта функция может сработать не так, как ожидается.

Вы можете использовать функцию топологической связи в панели масок для окрашивания плоскости, влияющей на остальные плоскости.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanarSameSize = "Одинаковый размер (куб)";
primitive.triplanarPolish = "Сглаженность";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanarResetMask = "Сбросить маску";
// One side of a cube (the back plane)
primitive.isolate.back = "Назад";
// One side of a cube (the right plane)
primitive.isolate.right = "Право";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Низ";
// Plane
primitive.planeSameSize = "Одинаковый размер (квадрат)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "Диск";
// Box
primitive.boxRegular = "Одинаковый размер (куб)";
// Distance to the snapping point
primitive.tubeSnapOffset = "Сдвиг привязки";
primitive.tubeSnapOffset.help = "Значение 1.0равно радиусу трубы.";
// Radius of the tube (starting end-point of the tube)
primitive.tubeThicknessStart = "Начало радиуса";
// Radius of the tube (ending end-point of the tube)
primitive.tubeThicknessEnd = "Конец радиуса";
primitive.tubeTwist = "Скручивание";
primitive.tubeTwistRotate = "Поворот";
primitive.tubeTwistRadius = "Величина";
primitive.tubeTwistOffset = "Сдвиг";
primitive.tubeSnap = "Привязка";
primitive.torusRadiusOuter = "Внешний радиус";
primitive.torusRadiusInner = "Внутренний радиус";
primitive.torusAngle = "Угол";
primitive.torusAngleOffset = "Сдвиг угла";
primitive.cylinderHeight = "Высота";
primitive.coneRadius = "Радиус";
primitive.coneHeight = "Высота";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Дырки";
// Make a hole in the primtive to make it hollow
primitive.hasHole = "Есть дырка";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radiusSync = "Тот же радиус";
primitive.radiusStart = "Начало радиуса";
primitive.radiusEnd = "Конец радиуса";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Импорт...";

scene.title = "Кадр";
scene.title.help = "При использовании кнопок видимости/выбора, удерживайте и перетаскивайте палец для простого выбора объектов.

Вы также можете длительно нажать на кнопки видимости/выбора для того, чтобы это касалось и дочерних узлов.";
// The view will focus on the item when we click on it
scene.focus = "Фокус на предмете";
// Icon size in pixel (min/max)
scene.iconSize = "";
// Min size of icon
scene.iconSize.min = "Мин.";
// Max size of icon
scene.iconSize.max = "Макс.";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "";
scene.showHierarchy.help = "";
scene.showHierarchyNomadPivot = "";
scene.showHierarchyNomadPivot.help = "";
// The view will focus on the item when we click on it
scene.syncVisible = "";
scene.syncVisible.help = "";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "Совместить";
// Group the selected object with a new created Empty Node as a parent
scene.group = "Группа";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "Отзеркаливание";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "Кривые";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "Массив";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "Радиально";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "";
scene.repeaters.help = "";
// singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "";
// Validate button
scene.validateGroup = "Утвердить";
// Keep instances in the scene
scene.validateGroup.keepInstances = "";
// If we should join children
scene.validateGroup.joinChildren = "Совмещение дочерних узлов";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Слияние вокселей";
scene.voxelResolution = "Разрешение";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Вычитание: скрыть объект (пиктограмма глаз)";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Пересечение: все объекты скрыты";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "Нет выбранного объекта, выберите как минимум один объект.";
// Need to select one object only
scene.noneButNeedOne = "Нет выбранного объекта, выберите один объект.";
// Need to select one object only
scene.onlyOneObject = "Несколько объектов выбрано, выберите один объект.";

// General scene display settings
settings.display.title = "Настройки отображения";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Каркас";
// Display UV
settings.debugUV = "Отладка UV";
settings.debugUV.help = "Эта функция играет значение только в том случае, если у объекта есть UV.

Она будет отображать каркас UV на фоне.

Она также покажет текстуру на модели, окрашенную в шахматном порядке.";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Две стороны";
settings.twoSided.help = "Грани будут видны с двух сторон.";
// If we colorize the inverted side of faces
settings.backface.color = "Цвет обратной стороны";
// Color of the inverted side of faces
settings.backface.colored = "Окрашенная обратная сторона";
// Outline (contour highlight around the selected object)
settings.outline = "Контур";
// Outline (contour highlight around the selected object)
settings.outline.help = "Выбранные объекты будут обведены контуром.";
settings.outline.thickness = "Толщина";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Привязка куба";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "Низ";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "Налево";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Статистика";
settings.stats.right = "Направо";
settings.stats.all = "Показать полный кадр";
// Grid
settings.grid = "Сетка";
// Cursor
settings.cursor.whileSculpting = "Показать круг при скульптурировании";
// A small indicator dot
settings.cursor.showDot = "Показать небольшую точку";
settings.cursor.showDot.help = "Точка может появиться в качестве опорной точки камеры или при скульптурировании.";
settings.cursor.showRope = "Показать канат-стабилизатор";
// Highlight (the object glows when we select it)
settings.highlight.selection = "Выделить выбранное";
// Highlight settings
settings.highlight = "Выделить";
settings.highlight.duration = "Длительность";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Затемнить не выбранные объекты";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Плавное затенение";
// Experimental feature
settings.partialDraw = "Частичное рисование";
settings.partialDraw.help = "Экспериментальная функция!

Используйте ее при скульптурировании малой части меша с высоким количеством полигонов.

Это поможет сделать скульптурирование более плавным, но при этом не включайте каркас!

Также это может добавить визуальных артефактов при штрихах кисти";
settings.partialDraw.warning = "Не забудьте отключить эту функцию, если артефакты будут сильно мешать!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Показать окрашивание";
// Display the light icons in the viewport
settings.lightIcon = "Значки освещения";
// Display the camera icons in the viewport
settings.cameraIcon = "Значки камеры";
// Show icon on the canvas
settings.icon = "Значок";
// Show icons on the canvas
settings.icons = "Значки";
// Tooltip
settings.icons.help = "Отображает пиктограмму на каркасе, что позволяет выбрать и внести коррективы напрямую.";
// Hole filling settings
settings.hole = "Заполнение дырок";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Заполнить non-manifold";
settings.hole.nonManifold.help = "Попытается заполнить дырку типа non-manifold.
Эта опция не сохраняется в настройках.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Максимальное количество вершин";
settings.multires.maxVertices.help = "Nomad не проводит проверку памяти перед проведением подразделения, высокое количество полигонов может привести к аварийному завершению работы.";
settings.multires.lowResVertices = "Порог низкого разрешения";
settings.multires.lowResVertices.help = "Более низкое разрешение меша может отображаться при движении камеры.

Вы можете увеличить это значение, если вы хотите отобразить более высокое разрешение меша.";

// The main rendering mode
shading = "Затенение";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "Освещено (PBR)";
shading.pbr.help = "В этом режиме вы можете добавить освещение (с тенями), а также HDR-окружение.

Вы также можете окрашивать металличность и шероховатость, что позволяет лучше редактировать внешний вид материала.";
// Fast rendering mode for sculpting purpose (do not translate)
shading.matcap = "Маткап";
shading.matcap.help = "Маткап управляет освещением и информацией о материалах в одном изображении.

Это режим быстрого рендеринга, преимущественно подходящий для скульптурирования с нуля.";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "Не освещено";
shading.unlit.help = "Режим затенения цветами без освещения.";
// Helper rendering mode that display a (do not translate)
shading.id = "ID";
shading.id.help = "Режим неосвещенного рендеринга, при котором каждому объекту предписан случайный цвет.

Эта функция полезна, когда в кадре много объектов.";
// Randomize colors
shading.id.randomize = "Случайный id";
shading.textures = "Использовать текстуры";
shading.textures.help = "В данный момент вы не можете создавать и редактировать текстуры в Nomad.

Если вы импортируете файл с текстурами, эта функция должна стать доступна.

-- Поддерживаемые текстуры --
Непрозрачность: Освещено, маткап, не освещено
Нормали: Освещено, маткап
Цвет: Освещено, не освещено
Излучение: Освещено
Шероховатость: Освещено
Металличность: Освещено";
// Lights
shading.lights = "Освещение";
shading.lights.addLight = "Добавить источник освещения";
shading.lights.warning = "Для освещения необходим режим затенения PBR.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Окружение";
shading.environment.import = "Импортировать изображение в высоком динамическом диапазоне";
shading.environment.exposure = "Экспозиция";
shading.environment.backgroundBlur = "Размытие (фон)";
shading.environment.rotation = "Поворот";
shading.environment.rotation.help = "Вы можете вращать окружение, перемещая 3 пальца горизонтально по вьюпорту.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "Закреплено к камере";
shading.environment.attachedToCamera.help = "Прикрепляет окружение к камере.

Таким образом освещение будет однородным, что может помочь при сульптурировании.";
shading.matcap.rotation = "Поворот";
shading.matcap.rotation.help = "Вы можете вращать Маткап, перемещая 3 пальца горизонтально по вьюпорту.";
shading.matcap.global = "Использовать глобальный Маткап";
shading.matcap.global.help = "Отключите эту функцию, если вы хотите использовать другой Маткап для этого меша.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible.short = "Маска";
shortcut.maskVisible.long = "Маска";
// bottom shortcut buttons (should be SHORT)
shortcut.solo.short = "Соло";
shortcut.solo.long = "Соло";
// bottom shortcut buttons (should be SHORT)
shortcut.voxelRemesh.short = "Воксель";
shortcut.voxelRemesh.long = "Воксельная перестройка меша";
// bottom shortcut buttons (should be SHORT)
shortcut.wireframe.short = "Каркас";
shortcut.wireframe.long = "Каркас";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraReset.short = "Сбросить";
shortcut.cameraReset.long = "Сброс камеры";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraSnap.short = "Привязка";
shortcut.cameraSnap.long = "Привязка камеры";
// bottom shortcut buttons (should be SHORT)
shortcut.lockSelection.short = "Блокировать";
shortcut.lockSelection.long = "Блокировка выделения";
shortcut.lockSelection.long.help = "При включении вы не сможете изменить выбор при нажатии на меш.";
// bottom shortcut buttons (should be SHORT)
shortcut.perspective.short = "Персп.";
shortcut.perspective.long = "Перспектива";
// bottom shortcut buttons (should be SHORT)
shortcut.grid.short = "Сетка";
shortcut.grid.long = "Сетка";
// bottom shortcut buttons (should be SHORT)
shortcut.uv.short = "uv";
shortcut.uv.long = "uv";

// Memory taken by the scene
stat.ramScene = "Кадр";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Видео-ОЗУ кадр";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "Видео-ОЗУ рендеринг";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "Видео-ОЗУ текстуры";
// Memory taken by the undo/redo history
stat.ramHistory = "История";
// Memory taken by other stuffs
stat.ramOther = "Другое";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "Использовано памяти";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "Свободная память";
// RAM, not storage!
stat.ram = "ОЗУ";
stat.used = "Использовано: $0 Мб";
stat.free = "Свободно: $0 Мб";
stat.faces = "Грани";
stat.triangles = "Треугольники";
stat.vertices = "Вершины";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Четырехугольники";
stat.sceneFaces = "Грани кадров";
stat.sceneVertices = "Вершины кадров";

// Brush stroke
stroke = "Штрих";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "Радиус на весь мир";
// The settings is shared among every tools
stroke.useWorldRadius.help = "Эта настройка общая для всех инструментов.";
// Share the radius value among every tools.
stroke.useShareRadius = "Общий радиус";
stroke.useShareRadius.help = "Общий размер радиуса для всех инструментов.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.minSpacing = "Расстояние между штрихами";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.minSpacing.adjustIntensity = "Настроить интенсивность в зависимости от расстояния";
stroke.minSpacingAdjustIntensity.help = "Настройка интенсивности кисти для создания последовательной деформации в зависимости от расстояния между штрихами.";
stroke.minSpacing.help = "Расстояние между штрихами, связано с радиусом инструментов.

Более низкое значение позволяет создавать более плавные штрихи, но производительность упадет.";
// Brush stroke smoothing
stroke.lazySmooth = "Сглаживание штрихов";
stroke.lazySmooth.help = "Выставите среднее значение с помощью многострелочного индикатора для более плавных штрихов.

При более высоком значении штрих будет отставать от индикатора, но рано или поздно нагонит его.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Канат-стабилизатор";
stroke.lazyRadius.help = "Штрихи будут отставать на определенную дистанцию от индикатора.

Таким образом можно рисовать более плавные линии.";
// It is not a per-tool settings
stroke.globalSettings = "Это глобальная настройка";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Радиус привязки";
stroke.snapRadius.help = "Привязка штрихов, если индикатор находится рядом с последним нарисованным штрихом.

Эта функция полезна при рисовании длинных продолжительных линий с регулярными паузами.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Сдвиг штрихов";
stroke.sculptOffset.help = "Применить регулярный сдвиг штрихов.

Эта функция помогает при использовании маленького экрана и пальцев: пальцы не закрывают штрих.";
stroke.accumulate = "Накопление штрихов";
stroke.accumulate.help = "Если эта функция включена, вы можете добавлять/убирать штрихи без ограничения.";
// The tool can use DynTopo
stroke.useDynamicTopology = "Разрешить использование динамической топологии";
// Only sculpt the part that are linked topologically
stroke.connectedTopology = "Топология закрепленного";
stroke.connectedTopology.help = "Эта функция будет скульптурировать только те вершины, которые закреплены на выбранной поверхности.

Она чаще всего используется с инструментом \"Перемещение\", например, если вы хотите переместить только ту часть, которая пересекается с другой частью.";
// Only sculpt the vertex that points toward the camera
stroke.onlyFrontFace = "Только вершины на лицевой поверхности";
stroke.onlyFrontFace.help = "Эта функция будет игнорировать вершины на обратной стороне.

Она особо пригодится в том случае, если вы хотите окрасить часть тонкой геометрии, не затрагивая другую часть.

Эта функция также применяется для скульптурирования, но могут возникнуть помехи.";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.onlySameSide = "Только вершины на одной стороне";
stroke.onlySameSide.help = "Игнорировать вершины, указывающие в обратную сторону от деформации.";
// Module the intensity of the sculpting operation by using a falloff curve
stroke.curveFalloff = "Спад";
stroke.onlyLasso = "Настройки активны только для инструмента \"Лассо\".";
// Alpha
stroke.alpha = "Альфа";
// Invert the pixel (black <-> white)
stroke.alphaInvert = "Инверсия пикселей";
// Repeat the alpha image (pattern)
stroke.alphaWrap = "Плитка";
// No repeat pattern
stroke.alphaWrap.none = "Нет";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alphaWrap.repeat = "Повторение";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alphaWrap.mirror = "Отзеркаливание";
stroke.alphaProject = "Метод";
// Project the alpha perpendicularly onto the surface
stroke.alphaProject.surfaceContinuous = "Поверхность";
// Project the alpha onto the surface in the direction of the camera view
stroke.alphaProject.screenFixed = "Проектирование на экран";
stroke.alphaRotation = "Поворот";
stroke.alphaRotation.lock.help = "";
// Repeat the image
stroke.alphaTiling = "Плитка";
// Scale the image (make it bigger or smaller)
stroke.alphaScale = "Масштабирование";
stroke.alphaScale.help = "При минимальном значении альфа-квадрат находится внутри радиуса инструмента.";
// Middle-point value at which no deformation occurs
stroke.alphaMidValue = "Среднее значение";
stroke.alphaMidValue.help = "Среднее значение, при котором не произойдет деформации.

(Среднее значение = 0)
- Черный: нет смещения
- Белый: позитивное смещение

(Среднее значение = 0.5)
- Черный: негативное смещение
- Белый: позитивное смещение

(Среднее значение = 1)
- Черный: негативное смещение
- Белый: нет смещения";
// Stroke type
stroke.strokeType = "Тип штриха";
// Sculpt and paint along the brush stroke at regular spacing
stroke.strokeTypeDot = "Точка";
// Sculpt continuously
stroke.strokeTypeDrag = "Перетаскивание";
// Lock a region and move it around
stroke.strokeTypeGrab = "Движение";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.strokeTypeGrabRadius = "Движение - динамический радиус";
// Lock a region and sculpt it by changing the tool intensity
stroke.strokeTypeGrabIntensity = "Движение - динамическая интенсивность";

// Symmetry
symmetry = "Симметрия";
symmetry.enable = "Вкл.";
// Display a warning (the feature is only available for mesh object)
symmetry.primitiveWarning = "Симметрия кисти доступна только для утвержденных примитив, за исключением трипланарности.";
symmetry.plane.title = "Плоскости";
symmetry.toolIgnore = "Текущий инструмент игнорирует симметрию.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Радиально";
symmetry.radialX = "Радиальная линия X";
symmetry.radialY = "Радиальная линия Y";
symmetry.radialZ = "Радиальная линия Z";
// Synonym: Offset
symmetry.offset.title = "Сдвиг";
symmetry.offsetX = "Сдвиг X";
symmetry.offsetY = "Сдвиг Y";
symmetry.offsetZ = "Сдвиг Z";
// Number of clones
symmetry.count.title = "Количество";
symmetry.countX = "Число X";
symmetry.countY = "Число Y";
symmetry.countZ = "Число Z";
// method
symmetry.method = "Метод:";
symmetry.method.help = "-- Локально
Плоскость симметрии будет двигаться вдоль меша при использовании одного из инструментов трансформации (Гизмо или Трансформирование).

-- Мир
Плоскость симметрии закреплена и не будет двигаться.";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.methodWorld = "Мир";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.methodLocal = "Локально";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Перевернуть объект";
// Mirror the mesh
symmetry.mirror = "Отзеркаливание";
symmetry.mirror.help = "Попытайтесь заново применить симметрию без влияния на топологию.

Радиальная симметрия будет проигнорирована.

Если топологию невозможно сохранить, потому что она не считается симметричной, вы можете принудительно произвести отзеркаливание.";
symmetry.mirrorLeftToRight = "Слева направо";
symmetry.mirrorRightToLeft = "Справа налево";
symmetry.mirrorFail = "Не удалось применить симметрию.

Хотите принудительно создать симметрию, отзеркалив меш?";
symmetry.mirrorUseMasking = "Защита области маски";
symmetry.mirrorUseMasking.help = "Сохраняет область маски нетронутой.

Эта опция игнорируется при несимметричной топологии (или на отдельной поверхности, например, глазах).";
// Reset the symmetry plane position
symmetry.reset = "Сбросить";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Центр объекта";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "Центр мира";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Ориентация";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Показать линию";
// Display the symmetry plane in 3d
symmetry.showPlane = "Показать плоскость";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Редактирование гизмо";
symmetry.edit.warning = "Редактирование симметрии — это экспериментальная функция.";
symmetry.edit.help = "Вы можете свободно настраивать плоскость симметрии.

Эта функция несколько экспериментальна и вам не стоит ее использовать.";

// Ideally <10 chars
tool.dynTopo = "Дин. топ.";
// Ideally <10 chars (Symmetry)
tool.symmetry = "Симметрия";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "Отзерк.";
// Ideally <10 chars
tool.clay = "Глина";
// Ideally <10 chars (Subtract)
tool.clay.sub = "Вычитание";
// Ideally <10 chars
tool.brush = "Кисть";
// Ideally <10 chars
tool.move = "Переместить";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "Обычное";
// Ideally <10 chars
tool.drag = "Перетаск.";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "Сглаживание";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Смягчение";
// Ideally <10 chars (Paint mask)
tool.mask = "Маска";
// Ideally <10 chars
tool.mask.unmask = "Снять маску";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "Выб. маску";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "Растушевка";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "Свести слои";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Заполнить";
// Ideally <10 chars (Layer brush)
tool.layer = "Слой";
// Ideally <10 chars
tool.crease = "Складка";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "Обрезка";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Разделить";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "Проект";
// Ideally <10 chars
tool.inflate = "Надуть";
// Ideally <10 chars
tool.pinch = "Сжать";
// Ideally <10 chars
tool.nudge = "Подтолкнуть";
// Ideally <10 chars
tool.stamp = "Штамп";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "Удал. слой";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.select = "Выбрать";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "Гизмо";
// Ideally <10 chars
tool.gizmo.editPivot = "Ось";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "Привязка";
// Ideally <10 chars (Snap translation)
tool.gizmo.moveSnap = "Привязка";
// Ideally <10 chars (Local/Relative space)
tool.gizmo.local = "Локально";
// Ideally <10 chars (World/Absolute space)
tool.gizmo.world = "Мир";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "Трансформация";
// Ideally <10 chars (Translate the object)
tool.transform.move = "Переместить";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "Поворот";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "Масштаб";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "Привязка";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "Измерение";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "Просмотр";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "Тело вращения";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "Трубка";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "Вставить";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "Переворот";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "Просмотр";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "Лассо";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Кривые";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Полигон";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Путь";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "Прямоугол.";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "Эллипс";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "Линия";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Закрыт";

// Popup when editing the vertical sliders on the left
tool.slider.radius = "Радиус $0";
// Popup when editing the vertical sliders on the left
tool.slider.intensity = "Интенсивность $0 %";

tool.settings = "Параметры";
tool.settings.none = "У этого инструмента нет особых настроек.";

// Flatten distance offset
tool.clay.flattenOffset = "Смещение уплощения";
tool.crease.pinchFactor = "Сила щипка";

tool.layer.removeInfluence = "Использовать данные слоев";
tool.layer.removeInfluence.help = "Эта функция активна только при выбранном слое.

Она использует только данные слоев для уменьшения смещения штрихов.";
tool.layer.noLayerSelected = "Эта функция доступна только в том случае, если выбран слой";

tool.flatten.warning = "Эти функции экспериментальны и могут быть удалены в будущем!";
tool.flatten.planeLockOrigin = "Закрепить опорную точку плоскости";
tool.flatten.planeLockNormal = "Закрепить направление плоскости";
tool.flatten.planeAverageOrigin = "Средняя опорная точка плоскости";
tool.flatten.planeAverageNormal = "Среднее направление плоскости";
tool.flatten.planeOffset = "Смещение плоскости";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "";
tool.syncInstance.message = "";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Прикрепленные вершины по краям";

tool.paint = "Рисовать";
// Erase the painting
tool.paint.erase = "Стереть";
// Only paint the part of the mesh above a certain height
tool.paint.depthFilter = "Фильтрование глубины";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Фильтрование слоев";
tool.paint.layerFilter.help = "Используйте эту функцию, если вы хотите заново окрасить уже окрашенную часть слоя.";

// Clear the painted mask
tool.mask.clear = "Очистить";
// Invert the painted mask
tool.mask.invert = "Инвертировать";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Переворот закрепленного";
// Blur the painted mask
tool.mask.blur = "Размытие";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Резкость";
// The thickness of the extracted mesh (from the painted mask)
tool.mask.thickness = "Толщина шелл";
// Smooth the border of the extracted mesh (from the painted mask)
tool.mask.polish = "Сглаживание краев";
// Extract a new mesh from the painteed mask and carve/emboss the base mesh
tool.mask.engraveEmboss = "Гравировка / тиснение";
// Extract a new mesh from the painted mask
tool.mask.extract = "Извлечение";
// Extract two new mesh from the painted mask and from the unmasked area
tool.mask.split = "Разделить";
// How should we close the topology of the extracted object
tool.mask.closeMask = "Действие закрытия (маска):";
// How should we close the topology of the extracted object
tool.mask.closeUnmask = "Действие закрытия (без маски):";
// How should we close the topology of the extracted object
tool.mask.closeAction = "Действие закрытия:";
// Do not close the mesh (leave it open)
tool.mask.closeActionNone = "Нет";
// Close the mesh with a hole-filling algorithm
tool.mask.closeActionFill = "Заполнить";
// Close the mesh by adding a thickness on the surface
tool.mask.closeActionShell = "Шелл";
// Close the mesh by using the layer data as a difference thickness
tool.mask.closeActionLayer = "Слой";
tool.mask.closeAction.help = "-- Нет
Просто извлекает часть и оставляет извлеченную часть открытой.

-- Заполнить
Дырка заполнена и сглажена.
Не используйте эту опцию для плоской поверхности.

-- Шелл
Закрыть извлеченную часть используя значение толщины.

-- Слой
Извлечь разницу слоев (только подменю слоев).";

// Transform/Matrix
tool.matrix = "Матрица";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.apply = "Цель";
// Automatic
tool.matrix.apply.auto = "Авто";
// Transform the object alone (the children stands still)
tool.matrix.apply.object = "Объект";
// Auto apply the transform on the vertices
tool.matrix.apply.vertex = "Вершина";
// Transform the object and its children
tool.matrix.apply.group = "Группа";
tool.matrix.apply.help = "-- Авто
При стандартных настройках будет работать подобно групповому варианту.
Если у меша есть маски или же включена симметрия гизмо, эта функция будет работать как вершины.

-- Вершина
Применяется для трансформации вершин и не будет работать на неутвержденных примитивах.
Экземпляры также будут затронуты.

-- Объект
Перемещает только объект, игнорирует симметрию и маски.
Только редактированный узел сдвигается, дочерние узлы остаются на месте.

-- Группа
Перемещает узел, игнорируя симметрию и маски. Остальная иерархия также переносится.";
// Operation on the mesh
tool.matrix.action = "Операция";
tool.matrix.action.help = "-- Перенос к опорной точке
Перенос меша к опорной точке мира.

-- Сброс
Сброс трансформации меша.

-- Запекание
Применение матрицы к вершинам и сброс меша. Визуально ничего не изменится.";
tool.matrix.translation = "Перевод";
tool.matrix.rotation = "Поворот";
tool.matrix.scale = "Масштаб";
// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "Сдвиг";
tool.matrix.uniformScale = "Однородное масштабирование";
tool.matrix.uniformScale.help = "Nomad не поддерживает неоднородное масштабирование при трансформации объекта, поэтому будет произведена трансформация вершины.";
tool.matrix.moveToOrigin = "Перенос к опорной точке";
tool.matrix.resetTransform = "Сбросить";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "Запекание";

tool.transform.tip = "";

// Size of the gizmo
tool.gizmo.size = "Размер виджета";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "Цифровой ввод";
tool.gizmo.allowInput.help = "Позволить цифровой ввод при нажатии на один из гизмо-виджетов";
// Angle threshold
tool.gizmo.linearRollThreshold = "Порог поворота тангенса";
tool.gizmo.linearRollThreshold.help = "Настройте на определенную сторону от порога для выбора между линейным и циклическим поворотом.

Значения выше этого порога используют циклический поворот.

Если вы предпочитаете линейный поворот (в сторону тангенса), установите значение на 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Скрывать при взаимодействии";
tool.gizmo.tap = "Перемещение уникальной оси одним касанием";
tool.gizmo.tap.help = "Эта функция эффективна только в режиме уникальной оси (отключена по умолчанию).

-- Нет
При нажатии на меш ничего не произойдет

-- Первое касание
Перенос гизмо при первом пересечении.

-- Средняя величина
Перенос гизмо в середину между первыми двумя пересечениями.";
tool.gizmo.tapNone = "Нет";
tool.gizmo.tapFirstHit = "Первое касание";
tool.gizmo.tapMiddleStab = "Средняя величина";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "Закреплено";

// Fill the object's hole
tool.hole = "Заполнение дырок";
tool.hole.fillHoles = "Заполнить дырки";
// synonym: Alternative method
tool.hole.bridges = "Boolean по размеру экрана";
tool.hole.bridges.help = "Включение этой функции позволяет создавать дырки в объеме.
Откос выемки будет ближе к форме вырезания.";
tool.hole.threshold = "Порог эпсилон";
tool.hole.threshold.help = "Настройка этого значения может помочь работе алгоритма по заполнению дырок.";
tool.hole.smoothing = "Сглаживание дырок";

tool.smudge.quality = "Качество";
tool.smudge.quality.help = "Изменяет разрешение проектируемых пикселей: чем ниже значение, тем чаще мазки.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Форма";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Квадрат";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Центрование";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Круг";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Центрование";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Пошаговый поворот";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Показать золотое сечение";

// Topology
topology = "Топология";
// Synynom: detail value, density
topology.dynamic.detail = "Детали";
// See glossary
topology.multires = "Мультиразрешение";
topology.multires.help = "Сохранить мультиразрешение меша.

При внесении изменений в низком разрешении, детали в высоком разрешении будут снова проецированы при переключении.

Слои доступны для всех разрешений.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "Возврат";
topology.multires.reverse.confirm = "Не удалось создать базовое подразделение.

Текущая топология, вероятно, не является результатом подразделения.";
topology.multires.subdivide = "Подразделение";
topology.multires.subdivide.confirm = "В меше будет $0M вершин(ы), вы уверены?";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "Достигнут лимит подразделений, см. $0";
topology.multires.deleteLower = "Удалить ниже";
topology.multires.deleteHigher = "Удалить выше";
topology.multires.keepTriangles = "Оставить треугольники";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "";
// Synonym: Flat subdivision
topology.multires.linear = "Линейное подразделение";
topology.multires.linear.help = "Простое подразделение меша без применения сглаживания";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Воксельная перестройка сетки";
topology.voxel.help = "Перестройка меша путем взятия образца меша с сетки.

Если объект не закрыт, вначале будет произведен алгоритм заполнения дырок.

Слои будут заново спроектированы после перестройки меша, но качество ухудшится.";
topology.voxel.resolution = "Разрешение";
topology.voxel.remesh = "Перестройка меша";
topology.voxel.sharp = "Сохранение острых ребер";
topology.voxel.sharp.help = "Эта функция наиболее полезна для простых примитивных операций Boolean.

Она добавит искажение в некоторых областях, поскольку точки будут привязаны по ребрам.";
topology.voxel.subLevel = "Создать мультиразрешение";
topology.voxel.subLevel.help = "Вы можете восстановить иерархию мультиразрешения по результату воксельной перестройки меша.

Этот процесс пройдет быстрее и с использованием меньшего количества памяти, в особенности если выставлено высокое значение детализации вокселей.
Если установлено низкое значение детализации вокселей, а необходимо произвести много уровней мультиразрешения, детали будут утеряны.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Перестройка меша";
topology.surface.detail = "Детали";
topology.surface.detail.help = "В отличие от воксельной перестройки меша, поверхностная перестройка меша не требует закрытого меша.

Она также поддерживает маски, т. е. вы можете защитить часть меша от изменений топологии.

Слои обновляются корректно.";
topology.surface.method = "Метод";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Униформизация";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Подразделение";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Упрощение";
topology.surface.method.help = "Поведение динамической топологии:
- Униформизация: добавление и удаление деталей
- Подразделение: добавление деталей
- Упрощение: удаление деталей";
topology.surface.useMasking = "Защита области маски";
topology.surface.useMasking.help = "Области маски защитят топологию от изменения.";
topology.surface.extrapolate = "Экстраполяция вершин";
// DynTopo
topology.dynamic = "Динамическая топология";
topology.dynamic.activate = "Вкл.";
topology.dynamic.activate.help = "Динамическая топология позволяет инструментам скульптурирования подразделять или упрощать меш локально в режиме реального времени.";
topology.dynamic.method = "Дали базируются на...";
topology.dynamic.method.zoom = "Увеличение";
topology.dynamic.method.radius = "Радиус";
topology.dynamic.method.constant = "Постоянная";
topology.dynamic.method.help = "-- Масштабирование
Детализация зависит от близости к поверхности.

-- Радиус
Инструмент \"Радиус\" определяет количество деталей.

-- Постоянная
Деталь закреплена, а значение детализации связано со слайдером вокселей.";
topology.dynamic.quality = "Предпочтение...";
topology.dynamic.quality.help = "Если вы выбираете опцию \"Качество\", два основных различия:
- улучшение применяется до скульптурирования, результатом является меньшее количество интерполирующих артефактов при окрашивании или скульптурировании очень мелких деталей
- улучшение не применяется пошагово, при скульптурировании очень мелких деталей или быстрых штрихах топология будет корректно улучшаться

Для улучшения работы и при использовании этой функции рекомендуется включить функцию \"Частичное рисование\" в панели настроек.";
topology.dynamic.quality.speed = "Скорость";
topology.dynamic.quality.quality = "Качество";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Использовать нажим на радиусе";
topology.dynamic.usePressure.help = "Используйте эту функцию, если вы хотите, чтобы уровень нажима на перо отображался уровнем детализации на радиусе инструмента.";
// Decimate
topology.decimate.title = "Упрощение";
topology.decimate.title.help = "Уменьшите количество полигонов путем сохранения максимального количества деталей.

Эта функция полезна для экспорта на 3D-принтер.
Однако, ее не стоит использовать, если вы планируете продолжить работать над скульптурированием, поскольку она может произвести неравные треугольники.

Примечание: зоны маски не будут упрощены.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Упростить";
topology.decimateTargetFaces = "Целевые треугольники";
topology.decimatePaintWeight = "Сохранить окрашивание";
topology.decimatePaintWeight.help = "При высоком значении программа попытается сохранить окрашивание.

Если окрашивание для вас не важно, установите это значение на 0.";
topology.decimateUniform = "Однородные грани";
topology.decimateUniform.help = "Более высокие значения будут выдавать треугольники подобного размера.";
topology.decimatePreserveBorders = "";
topology.decimatePreserveBorders.help = "";

// Unwrapping means compute UV (texture coordinates), it allows the object to receive on texture (wrap the texturing on the object)
topology.uv.title = "Автоматическая развертка";
// UV Unwrapping
topology.uvAtlas = "Развертка";
// The operation can be very slow
topology.uvAtlas.warning = "Может занять большое количество времени, у цели <100т вершин!";
// UV Unwrapping (BFF best left untranslated, stands for Boundary First Flattening)
topology.uvBFF = "Развертка BFF";
// Handles are topological holes (synonym: genus, hole)
topology.uvBFF.warning = "Если в меше есть отверстия, может возникнуть перекрытие!";
// Synonym: Point count? Singularity count ?
topology.uvBFFCones = "Количество конусов";
topology.uvBFFCones.help = "Более высокое значение уменьшит искажение сложных объектов.

Более высокое значение повысит время обработки.";
topology.uvDelete = "Удалить UV";

// Transfer the vertex painting in the texture, bake means "create texture (from mesh data)"
topology.bake.title = "Запекание раскрашивания вершин";
// Bake here means "create texture (from mesh data)"
topology.bake.title.help = "";
// Bake here means "create texture (from mesh data)"
topology.bakeSelf = "";
// Bake here means "create texture (from mesh data)"
topology.bakeHires = "";
topology.bakeResolution = "Разрешение";

// Reset key-bindings/shortcuts
binding.reset = "Сбросить привязки";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.materialPicker = "Выбор материала";
// Edit the tool brush size/radius
binding.editRadius = "Радиус инструмента";
// Edit the tool brush size/radius
binding.editIntensity = "Интенсивность инструмента";
// Snap the camera
binding.viewFront = "Просмотр спереди";
// Snap the camera
binding.viewLeft = "Просмотр слева";
// Snap the camera
binding.viewTop = "Просмотр сверху";
// Move/Translate the view
binding.panLeft = "Панорама влево (просмотр)";
// Move/Translate the view
binding.panRight = "Панорама вправо (просмотр)";
// Move/Translate the view
binding.panForward = "Панорама вперед (просмотр)";
// Move/Translate the view
binding.panBackward = "Панорама назад (просмотр)";
// Move/Translate the view
binding.panUp = "Панорама вверх (просмотр)";
// Move/Translate the view
binding.panDown = "Панорама вниз (просмотр)";
// Snap the view (while rotating)
binding.snapViewOnRotate = "Просмотр привязки (при прокручивании)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "Открыть (проект)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "Добавить (проект)";
// Import an external scene file (replace current scene)
binding.import.open = "Открыть (импорт)";
// Import an external scene file (add it to the current scene)
binding.import.add = "Добавить (импорт)";
// Select all the objects in the scene
binding.selectAll = "Выбрать все";
// Rotate environment and the lighting
binding.rotateLighting = "Поворот освещения";

// Privacy policy
privacyPolicy.title = "Политика конфиденциальности";
privacyPolicy.reject = "Отклонить";
// Hexanomad is the company name
privacyPolicy = "Hexanomad не собирает данные из Nomad Sculpt.";

// version trial
version.buyWeb = "Веб-версия — это только демо-версия";
version.buyFull = "Перейти на полную версию";
version.restorePurchase = "Восстановить покупку";

version.trialHistory = "Пробная версия: доступны только 4 отмены/возврата";
version.trialLayer = "Пробная версия: 1 слой на меш";
version.trialOneProject = "Пробная версия: только 1 активный проект";
version.trialNoImport = "Пробная версия: импорт невозможен";
version.trialNoExport = "Пробная версия: экспорт невозможен";

version.fullFeatures = "- Однократная покупка
- Бесконечное количество отмен/возвратов
- Бесконечное количество слоев
- Сохранение и загрузка
- Экспорт и импорт";
