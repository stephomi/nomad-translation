// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "Подтвердить?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Да";
// Answer to a question (Are you sure you want to do that? [yes, no, cancel])
confirm.no = "Нет";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "ОК";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Отмена";
// Restart nomad
confirm.restart = "После изменения этого значения необходимо перезапустить Nomad.";

// Experimental feature
experimental = "Экспериментальная функция!";

status.exit = "Несохранённые изменения! Сохранить перед закрытием?";
status.exit.yes = "Сохранить";
status.exit.no = "Не сохранять";

// On single tap (should be short)
ontap = "Касанием";

all = "Все";
error = "Ошибка";

reset = "Сбросить";
resetOrder = "Сбросить порядок";

clipboard = "Буфер обмена";
clipboard.copy = "Копировать";
clipboard.paste = "Вставить";

// memory size
bytes = "байт";
kB = "КБ";
MB = "мб";
GB = "Гб";
TB = "ТБ";

// Noun
instance = "Создать";
object = "Объект";

// Same value (usually for axis, e.g: x == y == z)
uniform = "Равномерный";

sync = "Синхронизация";

// position
position.top = "Верх";
position.bottom = "Низ";
position.left = "Лево";
position.right = "Право";
position.center = "Центрование";
// direction
direction.up = "Верх";
direction.down = "Низ";
direction.left = "Лево";
direction.right = "Право";
// 3D cube
cube.top = "Сверху";
cube.bottom = "Снизу";
cube.left = "Слева";
cube.right = "Справа";
cube.front = "Спереди";
cube.back = "Сзади";

// Name of an item (object, tool, etc)
item.name = "Имя";
// Add a new item (object, tool, etc)
item.new = "Создать";
// Rename an item (object, tool, etc)
item.rename = "Переименовать";
// Add a new item (object, tool, project, etc)
item.add = "Добавить";
// Update an item image with a new image (synonym: Update)
item.replace = "Заменить";
// Save an item (object, tool, etc)
item.save = "Сохранить";
item.save.confirm = "Подтвердить сохранение?";
// Update an item (update camera view point, etc)
item.update = "Обновлять";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Последнее сохранение";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "Загрузить последнее сохранение?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Сбросить";
item.reset.confirm = "Подтвердить сброс?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "Создать";
// Uninstance the object, make the object real
item.uninstance = "Снять";
// Clone an item (object, tool, etc)
item.clone = "Копировать";
// Delete an item (object, tool, etc)
item.delete = "Удалить";
item.delete.confirm = "Подтвердить удаление?";
item.delete.confirm.yes = "Да, удалить";
// When we delete the item but the image is used somewhere
item.delete.used = "Изображение использовано";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "В узел";
// Item visibility (object, layer, etc)
item.visible = "Видимо";
// Show an item (object, layer, etc)
item.show = "Показать";
// Hide an item (object, layer, etc)
item.hide = "Скрыть";
// Select an item (object, layer, etc)
item.select = "Выбрать";
// Unselect an item (object, layer, etc)
item.unselect = "Отменить выделение";
// Merge an item with another one below (layer)
item.mergeDown = "Объединить с нижним";
// The order of an item in a list
item.order = "Порядок";
// Focus on previous item
item.previous = "Предыдущий";
// Focus on next item
item.next = "Далее";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "Блокировать";
// No item selected
item.none = "Нет";
// Draggable, moveable
item.draggable = "Перемещаемый";

// Search something (text entry to filter item)
search = "Поиск";

// Three-state toggle button (Auto, Off, On)
toggle.on = "Вкл.";
// Three-state toggle button (Auto, Off, On)
toggle.off = "Выкл.";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "Авто";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Обнаружены недостающие эскизы, повторная обработка файлов...";
loading.reprocess.cancel = "Пропустить создание миниатюр?";

access.title = "Доступность";
access.window = "Вспомогательное окно";
access.pinch = "Сжать";
access.drag = "Перетаскивание";
access.rotate = "Поворот";
access.roll = "Прокрутка";

// Color of an object
material.color = "Цвет";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "Шероховатость";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "Глянцевость";
// Whether the material is a metal or not
material.metalness = "Металличность";
// How much light a surface will reflect
material.specular = "Зеркальность";
// Light that the surface can emit (glow)
material.emissive = "Излучение";
// Normal map (synonym: detail, bump)
material.normal = "Обычное";
// flip y coordinate
material.normal.flipY = "Отразить по Y";
// Ambient Occlusion (AO)
material.occlusion = "Объемный свет";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "Текстуры";
// Textures/Image
material.texture = "Текстура";
// A warning indicating that the mesh has no UVs
material.warningNoUVs = "Нет UV координат!";
// Texture filtering https://en.wikipedia.org/wiki/Texture_filtering
material.texture.filter = "Фильтрация";
// Nearest Filtering (closest sample)
material.texture.nearest = "Ближайший";
// Bilinear Filter
material.texture.linear = "Линейный";
// Mipmap filtering
material.texture.mipmap = "Мипмап";
// Triplanar mapping
material.projection = "Проекция";
material.projection.triplanar = "Трипланарность";

// Prefer low power
about.lowPower = "Энергоэффективный графический процессор";
// Wintab wacom API
about.wintab = "Использовать WinTab";
about.wintab.help = "Если WinTab включён, вам, вероятно, следует отключить Windows Ink в настройках Wacom.

Аналогично, если WinTab отключён, то Windows Ink должен быть включён в настройках Wacom.";
// Wacom Multi Touch API
about.touch = "Используйте мультисенсорное управление Wacom";
about.touch.help = "Включите эту опцию для поддержки нескольких пальцев на планшетах Wacom.";
// Prefer low power
about.fullScreen = "Полноэкранный режим";
// Minify
about.minify = "Уменьшение интерфейса";
about.minify.help = "Вы также можете нажать на экран четырьмя пальцами, если ваше устройство поддерживает эту функцию.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Турнтейбл";
// Rotation center of the turntable
about.turntable.pivot = "Центр вращения";
// Keep current pivot
about.turntable.pivot.keep = "Сохранить текущий";
// Turntable pivot will be at the center of the scene
about.turntable.pivot.scene = "Кадр";
// Make the entire scene turn around (speed of the animation)
about.turntable.speed = "Скорость";
// Stuffs that I used to make the app
about.credits = "Титры";
// Link to open source projects that I used for the app
about.credits.openSource = "Открытый исходный код";
// Only translate the &
about.credits.arts = "Маткапы и HDRI";
// Change languages of the app
about.languages = "Языки";
about.languages.help = "Файлы перевода доступны по ссылке $0";
// Link to the App Website
about.website = "Сайт";
// Link to the App Forum
about.forum = "Форум";
// Link to the App Manual
about.manual = "Руководство";
// Link to the App Email
about.mail = "Поддержка";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";
// Link to the App Threads account
about.threads = "Threads";

// The user canceled an operation that was running
alert.aborted = "Операция прервана!";
// Empty mesh
alert.mirror.empty = "Пустой вывод!";
// Mesh already mirrored
alert.mirror.same = "Такой же вывод!";
// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "У объекта нет отверстий!";
// No operation occured because the mesh is already manifold
alert.manifold.already = "Сетка уже замкнута!";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "Текущий объект не виден!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Нечего обрезать.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Отмена обрезки: объект полностью обрезан.";
// In order to extract something, the mesh needs to have painted mask
alert.extract.none = "Нечего извлечь!";
// In order to split something, the mesh needs to have painted mask
alert.extract.split.none = "Нечего разделить!";
// List of disabled features when View Mode is selected
alert.view.disabled = "Функции, отключенные в режиме просмотра:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Примитивные виджеты";
// The object needs to have two parts disconnected
alert.separate.fail = "Невозможно разделить: объект состоит только из одной части!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "Перестройка меша завершена!";
alert.voxelRemesh.empty = "Отменить перестройку меша: у нового меша нет граней.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "Неверный объект!";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "Объект будет дублирован";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "Для объекта будет создана метка экземпляра";
// A pivot refers the gizmo 3D position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Редактировать режим опорной точки.";
alert.mask.full = "Маска = 100%!";
// A pivot refers the gizmo 3D position
alert.gizmo.editObject = "Редактировать режим объекта.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Динамическая топология активна";
// See Glossary (DynTopo)
alert.dynamic.disable = "Динамическая топология отключена";
alert.colorPicker = "Проведите пальцем по объекту для выбора цвета.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Простое нажатие позволяет выйти из режима трансформации.";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "Простое нажатие для выхода из режима симметрии редактирования.";
// Show the painted mask on the mesh
alert.mask.show = "Показать маску";
// Hide the painted mask on the mesh
alert.mask.hide = "Скрыть маску";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Блокировка выделения";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Разблокировка выделения";
// Hide the objects that are not selected
alert.selection.isolate = "Изолирование выделения";
// Show the objects that are hidden
alert.selection.showAll = "Показать все";
// Project quick saving
alert.quickSave = "Сохранение...";
// Painting on the object was hidden but the user did paint the object
alert.forcePainting.fill = "Функция `Показать окрашивание` активирована, функция [Окрасить все] использована.";
// Painting on the object was hidden but the user started to paint on the object
alert.forcePainting.tool = "Функция `Показать окрашивание` активирована, объект был окрашен.";
// See Glossary (Multiresolution)
alert.multiresLost = "Мультиразрешение не будет сохранено!";
// Boolean cut mode will ignore some features
alert.booleanIgnored = "Режим Boolean не будет учитывать маскированные или скрытые участки!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "Детализация находится на высоком уровне и может потребовать большое количество памяти!";
// Autosave popup
alert.autoSave.auto = "Автосохранение через... $0с";
// The selected object doesn't have any layers
alert.needLayer = "Для текущего инструмента необходим активный слой.";
// The user decided to hide the painting on the objects
alert.paintingHidden = "Рисование скрыто!";
// The user decided to hide the masking on the objects
alert.maskingHidden = "Маска скрыта!";
// The user decided to display hidden faces
alert.hideIgnored = "Скрытие игнорируется!";
// The selected object doesn't have any layers
alert.noPartialWireframe = "Частичное рисование отключено, когда каркас отображается.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Подумайте об использовании ортогональной камеры, если вы хотите избежать искажения усеченного угла при использовании проектора.";
// Trial version has a limited number of undo
alert.state.trial = "Пробная версия: отмена отключена";

background = "Фон";
// A flat color will be displayed in the background of the scene
background.color = "Цвет";
// 2 color with rotation
background.gradient = "градиент";
// The environment (HDRI) will be displayed in the background
background.environment = "Окружение";
background.blur = "Размытие";
background.exposure = "Экспозиция";

// Image that the artist uses as a reference
background.imageEnable = "Эталонное изображение";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Наложение";
// Opposite of transparency (Alpha)
background.imageAlpha = "Непрозрачность";
background.imageReset = "Сбросить параметры";
background.imageTransform = "Трансформация";
// X screen coordinate of the image reference
background.imageX = "Позиция X";
// Y screen coordinate of the image reference
background.imageY = "Позиция Y";
// Rotation of the reference image
background.imageRotation = "Поворот";
// Scale of the reference image
background.imageScale = "Масштаб";
// Auto adjust the reference when moving the camera
background.lock.image = "Синхронизация с блокировкой камеры";
background.lock.image.help = "При блокировке с помощью Snap Cube изображение ориентира следует за движением камеры.";
// When exiting camera lock
background.lock.exit = "Сбросить при разблокировке:";
background.lock.exit.none = "Настроить Fov";
background.lock.exit.none.help = "Оставить изображение и камеру без изменений. 
Если в перспективе, настройте только поле зрения.";
background.lock.exit.all = "Сбросить все";
background.lock.exit.all.help = "Сбросить и изображение, и положение камеры.";
background.lock.exit.perspective = "Если Перспектива";
background.lock.exit.perspective.help = "Если в перспективе, сбросьте изображение и положение камеры.";

// Blend: normal
blend.normal = "Обычное";
// Blend: darker
blend.darker = "Темнее";
blend.darker.darken = "Затемнить";
blend.darker.multiply = "Умножить";
blend.darker.linearBurn = "Линейное сгорание";
blend.darker.colorBurn = "Цветное сгорание";
// Blend: lighter
blend.lighter = "Светлее";
blend.lighter.lighten = "Осветить";
blend.lighter.screen = "Экран";
blend.lighter.linearDodge = "Линейный огонь";
blend.lighter.colorDodge = "Цветное уклонение";
// Blend: contrast
blend.contrast = "Контраст";
blend.contrast.hardLight = "Жесткий свет";
blend.contrast.softLight = "Мягкий свет";
blend.contrast.overlay = "Наложение";
blend.contrast.hardMix = "Твёрдое смешивание";
blend.contrast.linearLight = "Линейный свет";
blend.contrast.vividLight = "Яркий свет";
blend.contrast.average = "Среднее";
// Blend: inversion
blend.inversion = "Инверсия";
blend.inversion.exclusion = "Исключение";
blend.inversion.difference = "Разница";
// Blend: cancelation
blend.cancelation = "Отмена";
blend.cancelation.divide = "Разделить";
blend.cancelation.subtract = "Вычесть";
// Blend: component
blend.component = "Компонент";
blend.component.luminosity = "Светимость";

// Camera (point of view in 3D)
camera = "Камера";
cameras = "камеры";
camera.view = "Просмотр";
// Copy the views
camera.updateView = "Обновить точку просмотра?";
// Add a new camera
camera.addView = "Добавить просмотр";
// Focus on the camera
camera.focus = "Фокусировка";
// Add on the camera camera
camera.focusOn = "Фокусировка на $0";
// Camera projection, Orthographic or Perspective
camera.projection = "Проекция";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Ортогональная";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Перспектива";
// camera Vertical Field of View
camera.fov = "Вертикальное поле обзора";
// Camera Field of View hint
camera.focal = "фок. $0mm (сенсор 35мм)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Поворот";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "турнтейбл";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Трекбол";
camera.rotation.trackball.help = "Шаровой манипулятор предоставляет больше возможностей: вы можете вращать камеру двумя пальцами.";
// Camera interaction mode, 1st person view
camera.firstPerson = "Первое лицо";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Скорость";
// Camera rotation sensitivity
camera.speed.rotation = "Поворот";
// Camera translation sensitivity
camera.speed.panning = "Панорамирование";
// Camera zooming sensitivity
camera.speed.zooming = "Масштабирование";
// Reset camera position
camera.resetView = "Сбросить просмотр";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Привязать просмотр";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "Камера привязана (ортогональная)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "Ортогональная привязка";
camera.snapOrthographic.help = "Эта функция также работает при использовании куба привязки в углу.";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Ось";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Двойное касание по объекту";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Двойное касание по фону";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "Переключатель";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "Выделение";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "Кадр";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "Обновление по двойному касанию";
camera.doubleTapPivot.help = "Обновление оси вращения при двойном касании по поверхности объекта.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "Воздушная ось";
camera.airPivot.help = "Позволить создание новой оси при масштабировании вне поверхности объекта.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "Старт жестами при запуске камеры";
camera.autoPivot.help = "Обновить ось при начале работы с камерой.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Фокусировка";
camera.doubleTapFocus.help = "При двойном нажатии по объекту камера произведет панорамирование и сфокусируется на выбранной точке.";
// Disable XY panning when unzomming
camera.centerZoomOut = "Центрирование вида при уменьшении масштаба";
camera.panZoomOut.help = "Если эта опция отключена, положение поворотного центра останется неизменным.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "Выбор нескольких объектов";
// There is 0 nodes/items selected
context.noSelection = "Нет выделения";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "Пресет";
// Quick curve x side shift
curve.shift = "Shift";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Катмалла-Рома";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "Сплайн";
curve.bspline = "B-сплайн";
curve.precision = "Точность";
// merge or collapse 1 point into another
curve.merge = "Объединить";
// snap
curve.snap = "Привязка";
curve.snap.offset = "Сдвиг";
curve.snap.offset.help = "Значение 100%равно радиусу трубы.";
curve.snap.surface = "Поверхность";
curve.snap.vertex = "Вершина";
curve.snap.grid = "Сетка (если привязана)";
// Regular spaced sampling
curve.uniform = "Равномерный";
curve.uniform.help = "Кривая будет отобрана с равномерным интервалом, чтобы обеспечить однородную плотность.

Вы можете отключить эту опцию, чтобы немного контролировать петли краев, добавляя новые контрольные точки на кривой.";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "Отображать затухание симметрично.

Эта опция только визуальная подсказка, она не влияет на само затухание";
curve.radius = "Радиус";
curve.twist = "Скручивание";
curve.spiral = "Спираль";
curve.spiral.twist = "Угол закрутки";
curve.spiral.scale = "Масштаб";
curve.spiral.offset = "Сдвиг";
curve.spiral.angle = "Сдвиг угла";
curve.pivot = "Ось";
curve.pivot.self = "Кривые";
curve.pivot.children = "Дочерних узлов";

// Set the desired FPS (frame per second, refresh rate)
debug.targetFps = "Целевой FPS";
debug.targetFps.help = "Когда отключено, значение по умолчанию означает, что оно будет синхронизировано с частотой обновления дисплея.";

// Warning about UVs (using extra memory)
debug.uvPrimitive.warning = "Отключите эту функцию, если вы не работаете с UV (экономия памяти).";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "Нормализация UV";
debug.uvNormalize.help = "Nomad нормализует UV в плитке [0-1].";

// Debug option, display an window with some debugging logs
debug.logs = "Журнал";
// Model shortcut window
debug.shortcut = "Окно ярлыков";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Карта высот";
// Debug options, graphical stuffs
debug.graphics = "Графика";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Создать пиктограммы для магазина";

// Open file explorer
file.explore = "Исследовать";
// Open file explorer
file.scope = "Область применения";
file.scope.internal = "Внутренний";
file.scope.internal.help = "Поведение по умолчанию, такое же, как и на мобильном. 
Проекты сохраняются только внутри основной папки Nomad.";
file.scope.external = "На месте";
file.scope.external.help = "При импорте проекта из внешнего источника сохранение перезапишет оригинальный файл.
Автосохранение не поддерживается для внешних проектов.";
// Empty list: there is no projects
file.project.load = "Загрузить проект при запуске";
// Empty list: there is no projects
file.project.empty = "Еще нет сохраненных проектов!";
// The current opened project has some unsaved changes
file.project.unsaved = "Несохраненные изменения!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "Вы потеряете несохраненные изменения!";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Предпросмотр последнего сохранения вручную";

file.project = "Проект";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Сохранить";
// E.g: Save "my_project"?
file.project.save.confirm = "Сохранить $0?";
// Make a copy
file.project.saveAs = "Сохранить как";
// Overwrite another project
file.project.overwrite = "Перезаписать";
// E.g: Overwrite "my_other_project"?
file.project.overwrite.confirm = "Перезаписать $0?";
// Open a project
file.project.open = "Открыть";
// E.g: Open "my_project"?
file.project.open.confirm = "Открыть $0?";
// E.g: Clone "my_project"?
file.project.clone.confirm = "Копировать $0?";
// Load another project and add/append all its data to the current scene
file.project.add = "Добавить в кадр";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "Добавить $0 в кадр?";
// Reset the scene and create a new project
file.project.new = "Создать";
file.project.new.confirm = "Создать новый кадр?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "Удалить $0?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "Удалить $0?

Это текущий активный проект!";

// Auto save section
file.autoSave = "Автосохранение";
file.autoSave.confirm = "Отключить автосохранение?";
file.autoSave.help = "Регулярно сохраняйте проект в отдельном файле.

Файл автосохранения находится здесь:";
// Interval in minutes in which the auto save popup will appear
file.autoSave.popup = "Интервал всплывающего окна";
// In minutes
file.autoSave.minutes = "Таймер всплывающего окна";
// Delete the current autoSave data
file.autoSave.delete = "Сбросить автосохранение";
// Open the outdated auto save
file.autoSave.open.manual = "Открыть устаревшую ручную версию";
file.autoSave.open.auto = "Открыть устаревшую автосохранённую версию";

// color space (linear or srgb), do not translate linear/srgb if there is a doubt
file.colorSpace = "Цветовое пространство";
file.colorSpace.help = "Попробуйте переключить эту опцию, если цвета кажутся некорректными.";
file.colorSpace.linear = "Линейный";
file.colorSpace.srgb = "sRGB";

// Configure imports option
file.importSettings = "Настройки импорта";

// Load interface preference settings when opening a scene file
file.import.guiSettings = "Сохранить настройки интерфейса";
file.import.guiSettings.help = "При открытии или импорте файла проекта будут загружены все настройки интерфейса, установленные в проекте.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.import.obj.splitByGroup = "Разбить OBJ по группам";
file.import.obj.splitByGroup.help = "При включении этой функции Nomad будет разбивать группы OBJ на отдельные объекты.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.import.mergeLayers = "Объединить слои";
// Ignore the textures present in the file to load
file.import.skipTextures = "Игнорировать текстуры";
// Do not fiddle with the object topology when loading the file
file.import.keepTopology = "Сохранить топологию";
file.import.keepTopology.help = "Используйте эту функцию, если вы не хотите, чтоб Nomad вносил изменения в топологию импортированного меша.

Это отключит перестройку вершин/граней, удаление дубликатов вершин/граней и удаление неиспользованных вершин.";

// Import file section
file.import.title = "Импорт";
file.import.title.help = "Поддерживаемые форматы:";
// The user imports a scene file that will replace the current scene
file.import.open = "Открыть";
file.import.open.confirm = "Импортировать новый файл?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Добавить в кадр";
file.import.add.confirm = "Импортировать новый файл?";

// Export scene file
file.export = "Экспорт";

// Filter nodes that we want to export
file.select.include = "Включать";
file.select.all = "Все";
file.select.visible = "Видимо";
file.select.selected = "Выбранный";
file.select.unselected = "Не выбрано";

// Export each node in a separate file
file.export.separate = "Отдельный файл на объект";

// Export the current selected objects instead of the entire scene
file.onlySelection = "Включать только выбранные объекты";
file.onlySelection.help = "Включать только выбранное, а не весь кадр.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Восстановление четырехугольника";
file.convertToQuad.help = "Восстановление четырехугольников из треугольников путем сопряжения треугольников (если они прилегают друг к другу в файлах).";
// ----------------------------------------------
// Whether we include the textures in the exported file
file.export.texture = "Текстур";
// Baking means transfering/converting
file.export.texture.help = "Эта функция не позволяет запекать цвета вершин в текстуры.";
// ----------------------------------------------
file.export.color0 = "Цветов вершин";
file.export.color1 = "Окрашивания PBR";
file.export.color1.help = "Экспорт шероховатости, металличности и окрашивания масок. Будет игнорироваться другими программами.";
// ----------------------------------------------
// Whether we include normals vector in the exported file
file.export.normal = "Нормалей";
file.export.normal.help = "Выберите эту опцию, если вы хотите открыт файл в других программах.

Nomad всегда игнорирует нормали, т. к. они будут вычислены заново.";
// ----------------------------------------------
file.export.tangent = "Касательные";
file.export.tangent.help = "Выберите эту опцию, если вы хотите открыть файл в других программах.

Касательные используются только если модель имеет карту нормалей.

Nomad всегда игнорирует касательные, так как пересчитывает их.";
// ----------------------------------------------
file.export.nomad.help = "Формат внутреннего файла Nomad Sculpt.

Этот формат не будет загружаться в других программах, он в основном используется для повторного импорта.";
// ----------------------------------------------
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Ировать слои";
file.export.gltf.layer.help = "Экспорт слоев в качестве морфов. Официально поддерживается glTF и должно работать и в других программах.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Ировать окрашивание слоев";
file.export.gltf.layerPaint.help = "Экспорт окрашивания слоев. Обычно игнорируется другими программами.";
// ----------------------------------------------
file.export.obj.warning = "Слои и другое окрашивание (шероховатость, металличность и маски) не будут сохранены.";
// Whether we include the vertex color in the exported file
file.export.obj.color = "Цветов вершин";
file.export.obj.color.help = "Некоторые 3D-программы смогут прочесть эту информацию, но не все.";
file.export.obj.color.help.append = "Прикрепление цветовой информации к вершинам.";
file.export.obj.color.help.hexa = "Альтернативный способ кодирования цвета. Также поддерживает данные маски.";
file.export.obj.faceGroup = "Группа Граней";
file.export.obj.object = "Запись объектов";
file.export.obj.object.help = "Сохранять объекты отдельно.

Отключение этой опции приведет к экспорту всего как единой сущности.
Вы должны отключить эту опцию, если хотите использовать функцию 'Mesh ID / Polygroup' в Substance Painter.";
file.export.obj.archive = "Тип";
file.export.obj.archive.folder = "Папка";
file.export.obj.archive.zip = "Zip";
file.export.obj.archive.help = "Некоторые приложения (Google Drive, One Drive и т. д.) не поддерживают импорт папок, поэтому вместо этого можно использовать Zip.";
// ----------------------------------------------
file.export.ply.warning = "Слои и другое окрашивание (шероховатость, металличность и маски) не будут сохранены.";
// ----------------------------------------------
file.export.stl.warning = "Слои и другое окрашивание (шероховатость, металличность и маски) не будут сохранены.";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Цветов вершин";
file.export.stl.color.help = "Некоторые 3D-программы смогут прочесть эту информацию, но не все.";
// ----------------------------------------------
file.export.usd.skew = "Разрешить наклон";
file.export.usd.skew.help = "Разрешить наклон в преобразованиях матрицы.

При отключении, Nomad разделит матрицы наклона на два отдельных масштабирования и поворота.";
// ----------------------------------------------
// Advanced settings
settings.advanced = "Дополнительно";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "Эти опции не сохраняются в настройках.";
settings.reset.title = "Параметры";
settings.reset.title.help = "Это сбросит настройки предпочтений приложения.

Часть ресурсов сохраняется отдельно и не будет сброшена, а именно:
• Проекты
• Функциональные клавиши
• Наборы инструментов
• HDR-окружение
• MatCap
• Альфы
• Текстуры (кисти)
• Эталонные изображения

Примечание: все, связанное с проектами, будет сохранено, например, освещение, пост-обработка, просмотр камеры, и т.д.";

// Reset preference settings button
settings.reset = "Сбросить к стандартным";
settings.reset.confirm = "Сбросить настройки предпочтений?";

// Render a screenshot of the scene
file.render = "Рендеринг";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Показать интерфейс";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Разрешение рендеринга";
file.render.renderRatio.help = "Значение 1.0 значит, что Nomad будет производить рендеринг в том же разрешении, как и изображение ниже.

Используйте эту функцию, если вы не можете произвести рендеринг в определенном разрешении (аварийное завершение работы в связи с недостатком памяти).";
// Desired size of the exported screenshot
file.render.size = "Финальный размер";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Собственный";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "Экран";
// width of exported screenshot
file.render.width = "Ширина";
// height of exported screenshot
file.render.height = "Высота";
// export screenshot of the scene
file.render.warn = "Высокое разрешение экспорта ($0x$1)!

Обязательно сохраните проект в случае, если вашему устройству не хватит видео-ОЗУ и произойдет аварийное завершение работы.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Прозрачный фон";
file.render.transparent.help = "Эта функция может пригодиться для вставки меша в программу для создания 2D.

Частичная прозрачность объектов пока не поддерживается.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Использовать глобальные настройки";
pressure.useGlobal.help = "По умолчанию инструменты используют одинаковые настройки нажима.

Снимите галочку с этой функции, если вы хотите установить особые настройки нажима для этого инструмента.";

// Pencil pressure
pressure.title = "Нажим";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "Этот инструмент не поддерживает нажим стилуса.";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "Тип штриха «Движение» будет игнорировать настройки нажима.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Радиус";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Интенсивность";
// Average pencil pressure event to get smoother result
pressure.average = "Сглаживание давления";
pressure.average.help = "Усредните события давления карандаша для более плавного результата.";
// Limit pressure to 100%
pressure.limit = "Ограничение давления до 100%";
pressure.limit.help = "Это глобальная настройка.

Используйте эту опцию, чтобы давление стилуса не превышало 100%.";

// list of inputs allowing camera interaction
gesture.camera = "Камера";
// list of inputs allowing sculpting interaction
gesture.sculpt = "Скульптурирование";
// Select object
gesture.select = "Выбрать объект";
// Finger/Touch input
gesture.finger = "Палец";
// Stylus/Pencil
gesture.stylus = "Стилус";
// Mouse/Trackpad
gesture.mouse = "Мышь";

gesture.wheel = "Колесо мыши";
gesture.wheel.speed3d = "Скорость (3D увеличение)";
gesture.wheel.speed2d = "Скорость (2D интерфейс)";

// long press to pick the color/material under the cursor
gesture.dropper = "Выбор материала";
gesture.dropper.help = "Выбор материала/цвета можно вызвать долгим нажатием на холст.

Примечание: это работает только в том случае, если для текущей кисти включено окрашивание.";

camera.airStroke = "Разрешить воздушный удар";
camera.airStroke.help = "Позволяет начать лепку ударом, даже если начальный курсор не попадает на поверхность. 

Эта опция активна только для входных данных с включенной лепкой и отключенной камерой.";

// Three fingers on screen
gesture.three.title = "Три пальца";
gesture.three.light = "Поворот освещения";
gesture.three.light.help = "Поверните окружение, освещение и MatCap.";
gesture.three.radius = "Радиус инструмента";
gesture.three.intensity = "Интенсивность инструмента";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.finger.smooth = "Палец производит сглаживание";
gesture.finger.smooth.help = "Эта опция активна только если активирован инструмент для лепки.";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Разрешить неопознанное давление";
gesture.unknownPressure.help = "Выберите эту функцию, если нажим не поддерживается для вашего стилуса или вам нужна регулировка нажима стилусом.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Кнопка стилуса";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Двойное касание стилусом";
gesture.pencilAction.ios.help = "Активно только для стилуса Apple Pencil второго поколения.";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "Нет";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Добавить/убрать";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "Быстрая клавиша для одного касания";
gesture.mask.oneTap.help = "Позволяет быстрой клавише произвести действие «Маска», однократно нажав на экран, не зажимая быструю клавишу маски.

Это включит следующие жесты:
• нажатие на фон произведет инверсию маски
• нажатие на зону маски произведет размытие маски
• нажатие на зону без маски усилит резкость маски";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.holdStroke = "Штрих";
gesture.mask.holdStroke.help = "Долгое нажатие будет переключать между Mask и SelMask и начинать новый штрих.

По окончании штриха предыдущий инструмент выбирается обратно.";
gesture.mask.holdIdle = "Инструмент";
gesture.mask.holdIdle.help = "Долгое нажатие и отпускание без движения для переключения между Mask и SelMask.";

// Shortcut customization, choose the action that the shortcut will performan (select tool, etc)
gesture.shortcut = "быстрой клавише";

// Shortcuts to undo/redo
gesture.history = "Быстрая клавиша истории";
gesture.history.help = "• Отмена: нажатие двумя пальцами
• Возврат: нажатие тремя пальцами";
gesture.history.hold = "Долгое нажатие";
gesture.history.hold.help = "Продолжительно зажать 2/3 пальца.";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Отторжение ладони";
gesture.palmRejection.confirm = "Отключите эту функцию, если у вас возникают сложности при работе с холстом!";
gesture.palmRejection.help = "Отклоняет ввод, если контактная поверхность больше этого значения.

Может работать не на всех устройствах.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Порог макс. размера";

// Smoothing strategy
extract.polish.all = "Все";
extract.polish.sharp = "Острый край";
extract.polish.border = "Только границы";
// Smooth the border in a way that it matches completely with its dual
extract.polish.syncBorder = "Синхронизация границ";
// topology of extracted mesh
extract.edgeLoop = "Петля кромки (бок)";
extract.edgeLoop.auto = "Автоматическая петля кромки";
extract.edgeLoop.division = "Разрешение";
// The thickness of the extracted mesh (from the painted mask)
extract.thickness = "Толщина";
// Carve the mask into the surface
extract.carve = "Гравировка";
// Extract a new mesh from the painted mask
extract = "Извлечение";
// Preview extract
extract.preview = "Предпросмотр";
// Extract two new mesh from the painted mask and from the unmasked area
extract.split = "Разделить";
// How should we close the topology of the extracted object
extract.action = "Действие закрытия:";
extract.action.help = "• Нет
Просто извлекает часть и оставляет извлеченную часть открытой.

• Заполнить
Дырка заполнена и сглажена.
Не используйте эту опцию для плоской поверхности.

• Шелл
Закрыть извлеченную часть используя значение толщины.

• Слой
Извлечь разницу слоев (только подменю слоев).";
// Do not close the mesh (leave it open)
extract.action.none = "Нет";
// Close the mesh with a hole-filling algorithm
extract.action.fill = "Заполнить";
// Close the mesh by adding a thickness on the surface
extract.action.shell = "Шелл";
// Close the mesh by using the layer data as a difference thickness
extract.action.layer = "Слой";

// uv part of revolution surface
genus.main = "Основная";
genus.hole = "Дырки";
genus.bottom = "Низ";
genus.top = "Верх";

// History, list of undo/redo
history = "История";
// First "undo" state
history.root = "Первое действие";
history.undoConfirm = "Вы точно хотите отменить все эти действия?";
history.undoWarning = "Если вы отредактируете что-то, вы можете потерять большое количество изменений.";
// Settings concerning the history stack of undo/redo
history.stack = "Стек";
// Actions to include in the undo/redo stack
history.include = "Включать действия";
// include lighting editing in the undo/redo
history.includeLights = "Освещение";
history.includeLights.help = "Если эта функция включена, перемещение освещения с помощью гизмо все еще будет включено, т. к. оно может повлиять на другие объекты в иерархии кадра.";
// include postProcess editing in the undo/redo
history.includePostProcess = "Пост-обработка";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "Маткапы и HDRI";
// Can limit the stack of undo/redo size
history.limitSize = "Лимит истории";
history.limitSize.help = "Максимальный размер истории.

История будет обновлена при следующем записанном действии.";
// Limit the number of undo in the history stack
history.limitStack = "Лимит стека";
history.limitStack.help = "Максимальное количество регистрируемых действий.

История будет обновлена при следующем записанном действии.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Максимум возвратов";
history.rangeProtect.help = "Если вы вернетесь в истории, автоматически возникнет диалог подтверждения до удаления многих изменений.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Восстановление камеры";
history.restoreCamera.help = "Включите эту функцию для восстановления сохраненной позиции камеры при отмене/возврате.";
// Undo
history.undo = "Отмена действия";
// Redo
history.redo = "Повторить";
// Shown during undo
history.state.undo = "Отмена: $0";
// Shown during redo
history.state.redo = "Возврат: $0";
// Shown during undo/redo
history.state.voxelRemesh = "Воксельная перестройка меша";
// Shown during undo/redo
history.state.surfaceRemesh = "Поверхностная перестройка меша";
// Shown during undo/redo
history.state.multiresLevel = "Изменение разрешения";

// Debugging/Inspect object material (view channel separately color, roughness, normal, uv, etc)
inspect = "Инспектор";
// Inspector but SHORT
inspect.short = "Проверить";
// Display the material channel on the background
inspect.onBackground = "На фоне";
// Display the material channel on the mesh
inspect.onMesh = "На объекте";
// Show UV seams
inspect.seams = "Швы";

// Interface customization
interface = "Интерфейс";

// Resize window (should be short)
interface.resize = "Изменить размер";

// UI customization: one item row will stands on one line (synonym: Inlined)
interface.compact = "UI: Компактный";

// UI customization: each row of the list will be bigger
interface.expandList = "Интерфейс: расширить список";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Опция интерфейса для упрощения работы со списками.";

// Add shortcuts buttons to the bottom of the screen
interface.shortcut.bottom = "Добавить быстрые клавиши (низ)...";
// Floating window
interface.shortcut.float = "Добавить быстрые клавиши (окно)...";

// Interface option (main base color)
interface.colorBase = "Базовый цвет";
// Interface option (accent widget color)
interface.colorSelect = "Цвет виджета";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Прозрачные панели";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Интенсивность размытия";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Цвета панелей";

// Interface color style
interface.preset.title = "Пресеты";

// Reset interface settings
interface.resetAll = "Сбросить стиль";
interface.resetAll.confirm = "Сбросить настройки интерфейса?";
// help popup when hovering
interface.hoverHelp = "Всплывающая подсказка при наведении";
// Interface option (main base color)
interface.iconSupport = "Кнопка с высокой контрастностью";
interface.iconSupport.help = "Альтернативный стиль для кнопок, который делает их более заметными, когда они включены.

Если установлено на Авто, Nomad будет использовать этот режим, когда контрастность цветов интерфейса между включенным/выключенным низкая.";
// Interface customization
interface.flipTop = "Отражение верхней панели";
// Interface customization
interface.flipBottom = "Отражение нижней панели";
// Interface customization
interface.flipMiddle = "Отражение боковой панели";
// list of tools
interface.toolbox = "панель инструментов";
// hide toolbox by default
interface.toolbox.hide = "Скрытый";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.columns = "количество столбцов";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.rows = "Строки";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Сбросить порядок";
// Colored text and icon
interface.toolbox.color = "Цветной";
// Top bar
interface.top.title = "Верхняя панель";
interface.top.responsive = "Адаптивный";
interface.top.responsive.help = "Эта опция в основном актуальна для небольших экранов.";
interface.top.responsive.multiline = "Многострочный";
interface.top.responsive.scroll = "Прокрутка";
interface.top.responsive.collapse = "Свернуть";
interface.top.alt = "Альтернативный порядок";
interface.top.alt.help = "Альтернативная иконка порядка для верхнего меню.

Меню, связанные с редактированием сетки, в основном находятся на противоположной стороне от меню сцены, что может помочь в редактировании сцены.";
// Scale the interface
interface.scale = "Общий масштаб";
// Spacing between widgets
interface.cursorStep = "Вертикальный интервал";
// Width of the interface panels
interface.panelWidth = "Ширина панели";
// Size of fonts
interface.fontScale = "Масштабирование шрифта";
// Inset
interface.inset.title = "Смещения ребер";
interface.inset.title.help = "Вы можете изменить эти значения только в том случае, если у вас возникают проблемы при работе с кнопками на краях экрана.

Если слайдер отключен, Nomad будет использовать значения безопасных областей самого устройства.";

// (see Glossary for Layer)
layer = "Слой";
layers.syncTransform = "Синхронизировать трансформацию";
layers.syncTransform.help = "If enabled, all the unselected layers will be adjusted depending on the transform rotation, scale and skew.

Disable this option if the other layers are meant to be used without the new transform that you are applying.

When set on auto, only the visible layers will be adjusted.";
// (see Glossary for Layer)
layers.lock = "Сохранить детали верхних слоев";
// (see Glossary for Layer)
layers.lock.yes = "Закрепить верхние слои?";
// (see Glossary for Layer)
layers.lock.warning = "Во время скульптурирования деформация верхних слоев будет игнорироваться.

Детали этих слоев все еще будут видны.

Эта функция работает только в том случае, если у верхних слоев детали небольшого размера.";
// (see Glossary for Layer)
layers.addLayer = "Добавить слой";
// (see Glossary for Layer)
layer.factors = "Факторы каналов";
// (see Glossary for Layer)
layer.factor = "Фактор";
// (see Glossary for Layer)
layer.offset = "Сдвиг";
// Layer blend mode
layer.blendMode = "Смешение";
// (see Glossary for Layer)
layer.base = "База";
layer.base.nothing = "Нечего извлечь!";
layer.base.background = "Фоновый материал";
layer.base.background.help = "Если активно, будут извлечены только значения материалов, отличающиеся от фонового материала.";
// (see Glossary for Layer)
layers = "Слои";
layers.title = "Слои";
// (see Glossary for Layer)
layers.title.help = "Слои могут записывать сдвиги позиций и окрашивание, что может помочь при нелинейном стиле работы.
Например, при экспериментировании с различными выражениями лица без опоры на стек истории и возврат изменений.

Данные окрашивания в слоях сортируются сверху вниз, т. е. слои вверху будут маскировать нижние.

Вы можете удалить часть слоя (и влияние слоя) с использованием инструмента «Удал. слой».";
layers.primitive = "Слои недоступны для примитив.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "Нет";

light = "Освещение";
lights = "Освещение";
// Intensity of light
light.intensity = "Интенсивность";
// Color of light
light.color = "Цвет";
// Kelvin (the temperature unit)
light.kelvin = "Кельвин";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "Температура";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Привязка";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Закреплено";
// The light will move along the camera
light.attachment.camera = "Камера";
light.attachment.help = "• Закреплено
Ориентация освещения не изменится

• Камера
Ориентация освещения зависит от просмотра камеры.";
// Light type (directional, spot, point)
light.type = "Тип";
// Directional light (synonym: sun light)
light.type.directional = "Направленный";
light.type.sun = "Солнце";
// Directional light (synonym: sun light)
light.type.environment = "Окружение";
light.type.hdri = "HDRI";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Прожектор";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Точечный";
// For directional light (angle jitter)
light.angle = "Угол";
// For point/spot light (offset jitter)
light.size = "Размер";
// Cone angle for spot angles
light.spot.angle = "Конический угол";
// Softness of the spot light
light.spot.softness = "Мягкость";
// Position of the light
light.position = "Позиция";
// Enable or disable shadows for a light
light.shadow.cast = "Тень";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "Всесторонний свет поддерживает тени только на экранном пространстве.";
light.shadow.type = "Тип тени";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "Теневая карта";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "Экранное пространство";
light.shadow.type.screenspace.help = "Экспериментальная функция, может быть удалена в дальнейших релизах.

Эта функция используется вместе с функцией «Мягкость теней».";
// Adjustment to fix artefacts
light.shadow.bias = "Расхождение";
// How blurry the shadow is
light.shadow.softness = "Мягкость";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "Контактные";
light.contact.help = "Если выбран режим «Авто», то только у основного освещения будут контактные тени.";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "Допуск";
// Activated the light
light.visible = "Показать";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Отцентрировать";

// Object's material
material = "Материал";
// See glossary
material.pbrRoughnessMetalness.warning = "Для шероховатости и металличности необходим режим затенения PBR.";
// See glossary
material.pbrReflectance.warning = "Для отражательной способности необходим режим затенения PBR.";
// See glossary
material.pbrRefraction.warning = "Для отражения необходим режим затенения PBR.";
// See glossary
material.pbrSubsurface.warning = "Для подповерхности необходим режим затенения PBR.";
// Value that says how much light will change direction when hitting the surface
material.ior = "Показатель отражения";
// an object-level value that overrides the roughness interior/surface of the mesh
material.paintingOverride = "Регулировка окрашивания";
// The roughness in the inside is turbidity
material.paintingOverride.help = "Используются два типа шероховатости: поверхностная и внутренняя.

Окрашиваться может только одна шероховатость, поэтому у обоих типов шероховатости одно и то же значение.";
// Glossiness is simply the opposite of roughness
material.refraction.surface = "Поверхности";
// Synonym: turbidity
material.refraction.interior = "Внутренняя";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Глянцевое окрашивание";
material.paintGlossy.help = "Оно окрасит объект с величиной шероховатости и металличности 0, создав четкое отражение.

Этого также можно достичь, перейдя в меню окрашивания и используя функцию «Окрасить все», отключив цвет.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Поглощение";
material.absorptionEnable.help = "Симуляция поглощения света при прохождении через объем.

Тонкие участки будут казаться светлее, так как они пропускают большее количество света, а плотные участки будут казаться темнее.

Этот эффект сильно зависит от формы объекта: плотность объекта рассчитывается примерно.";
material.absorptionFactor = "Фактор";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "Глубина";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "Светопроницаемость";
material.translucency.help = "Вам нужен источник освещения, создающий тени, для того, чтоб увидеть светопроницаемость.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Непрозрачность";
// Fully opaque material
material.type.opaque = "Непрозрачный";
material.type.opaque.help = "Это стандартный тип материала.

Альфа канала раскрашенной вершины, текстура непрозрачности или альфа канал цветового канала учтены через дизеринг.

Будет игнорироваться только основной ползунок непрозрачности.";
// Fully opaque material
material.type.shadowCatcher = "Ловушка теней";
material.type.shadowCatcher.help = "Делает объект полностью прозрачным, за исключением теней от свечей.

Этот режим обычно используется на плоской геометрии.";
material.type.shadowCatcher.warning = "В вашей сцене нет источников света с тенями, поэтому проекционщик теней будет неактивен.

В противном случае, если ловец теней полностью металлический, он может отражать сцену, если включен Пост Процесс SSR (Reflection).";
// See glossary
material.type.subsurface = "Подповерхность";
material.type.subsurface.help = "Для достижения наилучших результатов, переключитесь в режим затенения PBR и используйте как минимум один направленный источник цвета, предпочтительно в сумраке.";
// Transparency mode, alpha blendingd
material.type.blending = "Смешение";
material.type.blending.help = "Сделайте объект полупрозрачным, изменяя значение непрозрачности.

Примечание: из-за ограничений реального времени вы можете заметить крупные визуальные артефакты в случае, если у вашего объекта сложная форма.";
// Transparency mode
material.type.additive = "Аддитивный";
material.type.additive.help = "Сделайте объект полупрозрачным, изменяя значение непрозрачности.

Этот метод создает меньше артефактов, чем при смешении, но объект будет ярче.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Дизеринг";
material.type.dithering.help = "Сделайте объект полупрозрачным, удалив часть пикселей в случайном порядке.";
// Simulate glass-like material
material.type.refraction = "Отражение";
material.type.refraction.help = "Этот режим используется для симуляции стеклянных материалов.

В связи с ограничениями реального времени, самоотражение и многослойное отражение ограничены.";
material.castShadows = "Отбросить тени";
material.receiveShadows = "Покрыть тенями";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Всегда неосвещено";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Игнорирование инверсии";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Отражательная способность";
material.reflectance.help = "Регулируйте отражательную способность неметалличных материалов.

В большинстве случаев стоит использовать значение по умолчанию (что соответствует стандартным 4% отражаемого света при нормальном угле).";
// Material preview in the viewport
material.preview = "Предпросмотр цвета материала";
material.preview.help = "When you modify a material, a preview will be displayed in the viewport on the selected object.

The preview is shown while you interact with the color, roughness, metalness, opacity and intensity sliders.";
// Menu name
menu.files = "Файлы";
// Menu name
menu.scene = "Кадр";
// Menu name
menu.multires = "Мультиразрешение";
// Menu name
menu.voxel = "Воксель";
// Menu name
menu.dynamic = "Дин. топ.";
// Menu name (Synonym: Misc, Other)
menu.topology = "Разное";
// Menu name
menu.primitive = "Примитивы";
// Menu name
menu.render = "Рендеринг";
// Menu name
menu.material = "Материал";
// Menu name
menu.postprocess = "Пост-обработка";
// Menu name
menu.camera = "Камера";
// Menu name
menu.background = "Фон";
// Menu name
menu.tool = "Инструмент";
// Menu name
menu.stroke = "Штрих";
// Menu name
menu.alpha = "Альфа";
// Menu name
menu.filter = "Фильтр";
// Menu name
menu.falloff = "Спад";
// Menu name
menu.paint = "Рисовать";
// Menu name
menu.symmetry = "Симметрия";
// Menu name
menu.operation = "Операция";
// Menu name (pencil pressure)
menu.pressure = "Нажим";
// Menu name
menu.gesture = "Жест";
// Menu name
menu.layers = "Слои";
// Menu name
menu.settings = "Параметры";
// Menu name
menu.interface = "Интерфейс";
// Menu name
menu.bindings = "Привязки";
// Menu name
menu.history = "История";
// Menu name
menu.historySettings = "Параметры";
// Menu name
menu.about = "Информация";
// Menu name
menu.debug = "Отладка";

// Operation on the object (action)
mesh.holes = "Дырки";
// If the object has holes, the algorithm will close them
mesh.holes.close = "Закрыть дырки";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holes.detail = "Детали";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Отделить";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "Слои, окрашивание и мультиразрешение будут потеряны.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Разрешение";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Принудительно создать куб";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Конвертировать";
// Static object means "static topology"
mesh.static = "Меш";
// See glossary
mesh.multires = "Мультиразрешение";
// Dynamic topology
mesh.dynamic = "Дин. топ.";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Глобальный материал";
paint.useGlobal.help = "Если эта функция включена, выбранный материал будет таким же, как и у других инструментов.

Примечание: учитывается только шероховатость, металличность и настройки цвета.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Окрашивание штрихов";
// If true save the textures data into
paint.preset.embed = "Встроить текстуры";
paint.preset.embed.help = "The textures can be found in the Nomad textures/ folder.
The material presets can be found in the Nomad materials/ folder.

When this option is off, the material preset only reference the texture inside the textures/ folder.

You can enable this option to make a copy of the textures inside the material preset.
It can be useful if you want to share a textured preset without providing the associated textures.";
paint.preset.embed.apply = "Apply to all materials";
// Factor/Opacity of paint tool
paint.intensity = "Интенсивность окрашивания";
// Apply the paint on the object
paint.paintAll = "Окрасить все";
paint.paintAll.help = "Применить текущий материал к объекту.";
paint.paintAll.help.mask = "Замаскированная область не будет затронута.";
paint.paintAll.help.hide = "Скрытая область не будет затронута.";
paint.paintAll.help.opacity = "Используйте выше указанный фактор рисования инструментом.";
paint.paintAll.help.layer = "Некрашеная область. не будет затронута.";
paint.strokePainting.title = "Краски";
// Brush stroke texture
paint.texture.warningEnable = "Окрашивание штрихов необходимо включить для проекции текстур (галочка вверху)!";
paint.texture.warningIgnored = "Текущий инструмент не может использовать текстуры!";
// use stencil mode
paint.stencil = "Трафарет";
// Inherit stroke falloff option for the painting
paint.tool.help = "Используйте инструмент Alpha, ослабление и рандомайзер для модуляции интенсивности мазка кисти.

Эти опции игнорируются для функции покраски всей модели, но Alpha учитывается для трипланарного варианта.";
// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "Новое имя";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "Новое значение";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "Новый цвет (шестнадцатеричный формат)";

// Post process effect
postprocess = "Пост-обработка";
// Denoise
postprocess.denoise = "Шумоподавитель";
postprocess.denoise.help = "Примените шумоподавление после накопления всех кадров.";
postprocess.denoise.warning = "Это дорогостоящая операция, включайте этот эффект только если изображение шумное.";
// Quality vs performance
postprocess.quality = "Качество";
postprocess.quality.help = "Включите эти функции для улучшения качества при ухудшении производительности.";
// More samples means better quality but slower performance
postprocess.maxSamples = "Макс. примеров";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Полное разрешение";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "Макс. сэмплирование кадров";
postprocess.accumulateCount.help = "Максимальное количество кадров, накапливаемое до остановки рендеринга.

При остановке рендеринга Nomad не будет совершать действий, экономя время работы аккумулятора.

Накапливание кадров положительно влияет на многие функции рендеринга:
• Мягкость теней
• Глобальное освещение
• Отражение (SSR)
• Ambient Occlusion
• Подповерхность
• Глубина резко изображаемого пространства

Высокое количество кадров преимущественно необходимо для функций «Мягкость теней» и «Глобальное освещение».
Nomad может прекратить рендеринг быстрее, если вышеупомянутые функции отключены.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Разрешение рендеринга";
postprocess.renderRatio.warning = "Принудительное выполнение эффектом «Пиксельная графика».";
postprocess.renderRatio.help = "Эта функция заметно влияет на производительность.
Рекомендуется выставлять значение ниже x1.25.

Эта опция не сохраняется в настройках.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "Временной анти-алиасинг (TAA)";
postprocess.taa.help = "Снижает мерцание при передвижении камеры.";
// Ditherhing pixel
postprocess.dithering = "Дизеринг";
postprocess.dithering.help = "Использовать дизеринг пикселей для уменьшения артефактов полос.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "Отражение (SSR)";
postprocess.ssr.warning = "Для SSR необходим режим затенения PBR.";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "Глобальное освещение (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "Допуск";
postprocess.ssgi.warning = "Для SSGI необходим режим затенения PBR.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "Ambient occlusion";
// How far the effect spreads
postprocess.ssao.radius = "Размер";
// How strong the effect is
postprocess.ssao.factor = "Сила";
// Adjustment to fix artefacts
postprocess.ssao.bias = "Расхождение модификатора кривой";
postprocess.ssao.bias.help = "Чувствительность эффекта в зависимости от кривизны поверхности.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "Глубина резко изображаемого пространства";
// The blur factor behind the focused point
postprocess.dof.blurFar = "Размытие на удалении";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "Размытие на близости";
postprocess.dof.focusTip = "Коснитесь объекта для изменения точки фокуса.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "Цветение";
// Intensity of the effect
postprocess.bloom.intensity = "Интенсивность";
// How far the effect spreads
postprocess.bloom.radius = "Радиус";
postprocess.bloom.radius.help = "Насколько распространено свечение.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "Порог";
postprocess.bloom.threshold.help = "Пороговое значение яркости, определяющее, будет ли светиться пиксель.
Если значение равно 0, все пиксели светятся.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "Тональное отображение";
postprocess.tone.exposure = "Экспозиция";
postprocess.tone.contrast = "Контраст";
postprocess.tone.saturation = "Насыщенность";
postprocess.tone.hue = "Оттенок";
// No tonemapping operator is used
postprocess.tone.mapping.none = "Нет";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "Нейтральное";
// Color curves
postprocess.curve = "Цветокоррекция";
// Curve for pixel luminance
postprocess.curve.luminance = "Основная";
postprocess.curve.red = "Красный";
postprocess.curve.green = "Зеленый";
postprocess.curve.blue = "Синий";
// Reset color grading curves
postprocess.curve.resetAll = "Сбросить все";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "Хроматическая аберрация";
postprocess.chromatic.factor = "Сила";
// Darking on the edges
postprocess.vignette = "Виньетка";
// How far the effect spreads
postprocess.vignette.size = "Размер";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "Твердость";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "Резкость";
postprocess.sharpness.factor = "Сила";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "Зерно";
postprocess.grain.factor = "Сила";
// Accentuate the edges of the model
postprocess.curvature = "Модификатор кривой";
// main strength of curvatre
postprocess.curvature.factor = "Фактор";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "Полости";
// Color/Strength of convex curvature
postprocess.curvature.bump = "Выступы";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "Пиксельная графика";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "Позволить сэмплирование кадров";
// Simulate scanline rendering (horizontal line)
postprocess.scanline = "Сканирование строк";
postprocess.scanline.factor = "Фактор";
// Spacing between lines
postprocess.scanline.spacing = "Интервалы";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Примитивы";
primitive.box = "Коробка";
primitive.sphereCube = "Квадратная сфера";
primitive.sphereUV = "UV сфера";
primitive.icosahedron = "Икосаэдр";
primitive.cylinder = "Цилиндр";
primitive.cone = "Конус";
primitive.torus = "Тор";
primitive.lathe = "Тело вращения";
primitive.tube = "Трубка";
primitive.plane = "Плоскость";
primitive.triplanar = "Трипланарность";
primitive.needValidate = "Примитивы должны быть утверждены!";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Правка";
primitive.edit.help = "Позволить 3D-редактирование во вьюпорте.

Вы можете отключить эту функцию, если вы хотите работать с гизмо или инструментом «Трансформация», не изменяя примитивы.";

// Primitive configuration
primitive.mainConfig = "Параметр";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Топология";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Геометрия";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Утвердить";
// Maximum number of faces of the primitives
primitive.maxFaces = "Макс. граней";
primitive.maxFaces.help = "Максимальное количество гране примитивы.

Это пороговое значение активно только тогда, когда примитива не утверждена, затем пороговое значение не играет роли.";
// Synonym: Flat subdivision
primitive.linear = "Линейное подразделение";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Последующее подразделение";

// Radius (of a sphere, torus, etc)
primitive.radius = "Радиус";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radius.sync = "Тот же радиус";
primitive.radius.start = "Начало радиуса";
primitive.radius.end = "Конец радиуса";
// Size (of cube x dimension)
primitive.size = "Размер";
primitive.sizeX = "Размер X";
primitive.sizeY = "Размер Y";
primitive.sizeZ = "Размер Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "Разрешение";
primitive.divisionX = "Разрешение X";
primitive.divisionY = "Разрешение Y";
primitive.divisionZ = "Разрешение Z";
// Angle of torus, etc
primitive.angleX = "Угол X";
primitive.angleY = "Угол Y";
primitive.angleZ = "Угол Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Постоянная плотность";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Проект на сфере";
primitive.projectOnSphere.help = "Привязывает точки в идеальную сферу.";

// triplanar
primitive.triplanar.title = "Трипланарность";
primitive.triplanar.title.help = "Трипланарность использует информацию масок трех плоскостей для заполнения воксельной сетки, которая затем полигонизируется.

При работе с подразделениями или слайдерами размера информация об окрашивании будет сброшена (сглаживание сохранится).

Стоит отключить симметрию, так как эта функция может сработать не так, как ожидается.

Вы можете использовать функцию топологической связи в панели масок для окрашивания плоскости, влияющей на остальные плоскости.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanar.sameSize = "Одинаковый размер (куб)";
primitive.triplanar.polish = "Сглаженность";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanar.resetMask = "Сбросить маску";
// One side of a cube (the back plane)
primitive.isolate.back = "Назад";
// One side of a cube (the right plane)
primitive.isolate.right = "Право";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Низ";
// Plane
primitive.planeSameSize = "Одинаковый размер (квадрат)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "Диск";
// Box
primitive.boxRegular = "Одинаковый размер (куб)";
// Torus
primitive.torus.radiusOuter = "Внешний радиус";
primitive.torus.radiusInner = "Внутренний радиус";
primitive.torus.angle = "Угол";
primitive.torus.angleOffset = "Сдвиг угла";
// Cylinder
primitive.cylinder.height = "Высота";
// Cone
primitive.cone.radius = "Радиус";
primitive.cone.height = "Высота";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Дырки";
// Make a hole in the primitive to make it hollow
primitive.hasHole = "Есть дырка";
// Curve profile (synonym: profile, curve)
primitive.profile = "Профиль";
primitive.profile.viewport = "Отображать во вьюпорте";
// If the revolution surface has caps (E.g: cylinder)
primitive.cap = "Крышка";

// Singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "Репитер";
// All the new items will be inserted inside the bound rather than outside
repeater.array.fitInside = "Вписать внутрь";
// The object will follow the curve
repeater.curve.align = "Выровнять";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Импорт...";
// iOS Photos gallery
resource.import.ios.photos = "Фотографии";
// iOS Files App
resource.import.ios.files = "Файлы";

scene.title = "Кадр";
scene.title.help = "При использовании кнопок видимости/выбора, удерживайте и перетаскивайте палец для простого выбора объектов.

Вы также можете длительно нажать на кнопки видимости/выбора для того, чтобы это касалось и дочерних узлов.";
// The view will focus on the item when we click on it
scene.focus = "Интерфейс: Сфокусироваться на элементе при двойном нажатии";
// Add new object on gizmo position
scene.addOnGizmo = "На гизмо";
scene.addOnGizmo.help = "Переместить узел на позицию гизмо (если выбран инструмент гизмо)";
// Select the gizmo tool after adding a new object
scene.addSelectGizmo = "Выбрать гизмо";
scene.addSelectGizmo.help = "Выбрать инструмент гизмо при добавлении нового узла";
// Icon size in pixel (min/max)
scene.iconSize = "Размер иконки";
// Min size of icon
scene.iconSize.min = "Мин.";
// Max size of icon
scene.iconSize.max = "Макс.";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "Линии иерархии";
scene.showHierarchy.help = "Отображать линию между родителем и его детьми во вьюпорте.";
scene.showHierarchyNomadPivot = "Использовать pivot Nomad";
scene.showHierarchyNomadPivot.help = "Pivot Nomad • это точка опоры, используемая инструментами Transform и Gizmo.

Если эта опция отключена, будет использоваться естественный базовый pivot.
В некоторых случаях этот базовый pivot может находиться далеко от центра самого объекта!";
// The view will focus on the item when we click on it
scene.syncVisible = "Синхронизировать видимость";
scene.syncVisible.help = "Когда включено, использование иконки видимости (глаз) будет влиять на все выбранные элементы.";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "Совместить";
// Group the selected object with a new created Empty Node as a parent
scene.group = "Группа";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "Открепить";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "Отзеркаливание";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "Кривые";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "Массив";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "Радиально";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "Репитеры";
scene.repeaters.help = "Узлы репитеры, создающие экземпляры любых геометрий ниже по иерархии сцены.";
// Validate button
scene.validateGroup = "Утвердить";
// Keep instances in the scene
scene.validateGroup.keepInstances = "Сохранить экземпляры";
// If we should join children
scene.validateGroup.joinChildren = "Совмещение дочерних узлов";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Слияние вокселей";
scene.voxelResolution = "Разрешение";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Вычитание: скрыть объект";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Пересечение: все объекты скрыты";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "Нет выбранного объекта, выберите как минимум один объект.";
// Need to select one object only
scene.noneButNeedOne = "Нет выбранного объекта, выберите один объект.";
// Need to select one object only
scene.onlyOneObject = "Несколько объектов выбрано, выберите один объект.";
// Boolean operation
scene.boolean = "Boolean";
scene.boolean.help = "Merge, subtract or intersect objects by performing a boolean operation.

The operation can fail if some objects are not manifold or not watertight.

If the boolean fails, you can always use the voxel remesher on the problematic object to ensure it's a watertight manifold.";
// Weld intersection
scene.boolean.mergeIntersection = "Сплавить пересечения";

// General scene display settings
settings.display.title = "Настройки отображения";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Каркас";
// Display the material texture
settings.debugChannel = "Показать текстуру";
// Display the material texture in the background
settings.debugChannel.onBackground = "На фоне";
// Display the material texture on the mesh
settings.debugChannel.onMesh = "На меше";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Две стороны";
settings.twoSided.help = "Грани будут видны с двух сторон.";
// If we colorize the inverted side of faces
settings.backface.color = "Цвет обратной стороны";
// Color of the inverted side of faces
settings.backface.colored = "Окрашенная обратная сторона";
// Outline (contour highlight around the selected object)
settings.outline = "Контур";
// Outline (contour highlight around the selected object)
settings.outline.help = "Выбранные объекты будут обведены контуром.";
settings.outline.thickness = "Толщина";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Привязка куба";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "Низ";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "Налево";
// Flip the camera (rotate 180° to see the other side)
settings.snapCube.flip = "Перевернуть на 180°";
settings.snapCube.flip.help = "Переверните вид, если вид уже зацеплен.";
// Alignment (can be auto/on/off)
settings.snapCube.align = "Ограничить выравнивание";
settings.snapCube.align.help = "Выравнивание видов по осям мира. Если включено, возможно только 6 направлений привязки.

В автоматическом режиме ограничение будет применяться только если камера находится в режиме Орбиты.";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Статистика";
settings.stats.right = "Направо";
settings.stats.all = "Показать полный кадр";
// Grid
settings.grid = "Сетка";
settings.grid.divideThreshold = "Порог деления";
// Cursor
settings.cursor.title = "Курсор";
settings.cursor.whileSculpting = "Показать круг при скульптурировании";
// A small indicator dot
settings.cursor.showDot = "Показать небольшую точку";
settings.cursor.showDot.help = "Точка может появиться в качестве опорной точки камеры или при скульптурировании.";
settings.cursor.showRope = "Показать канат-стабилизатор";
// indicator
settings.indicator.title = "Индикатор";
settings.indicator.title.help = "Отображение визуального индикатора (учебные пособия, захват экрана и т.д.).";
settings.indicator.size = "Размер";
// Highlight (the object glows when we select it)
settings.highlight.selection = "Выделить выбранное";
// Highlight settings
settings.highlight = "Выделить";
settings.highlight.duration = "Длительность";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Затемнить не выбранные объекты";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Плавное затенение";
// Experimental feature
settings.partialDraw = "Частичное рисование";
settings.partialDraw.help = "Экспериментальная функция!

Используйте ее при скульптурировании малой части меша с высоким количеством полигонов.

Это поможет сделать скульптурирование более плавным, но при этом не включайте каркас!

Также это может добавить визуальных артефактов при штрихах кисти";
settings.partialDraw.warning = "Не забудьте отключить эту функцию, если артефакты будут сильно мешать!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Показать окрашивание";
// Show and use the masking on the mesh
settings.showMasking = "Показать маску";
// Disable this option to force show the hidden faces
settings.showDiscard = "Использовать скрытие";
// Show icon on the canvas
settings.icon = "Значок";
// Show icons on the canvas
settings.icons = "Значки";
// Tooltip
settings.icons.help = "Отображает пиктограмму на каркасе, что позволяет выбрать и внести коррективы напрямую.";
// Hole filling settings
settings.hole = "Заполнение дырок";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Заполнить non-manifold";
settings.hole.nonManifold.help = "Попытается заполнить дырку типа non-manifold.
Эта опция не сохраняется в настройках.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Максимальное количество вершин";
settings.multires.maxVertices.help = "Nomad не проводит проверку памяти перед проведением подразделения, высокое количество полигонов может привести к аварийному завершению работы.";
settings.multires.lowResVertices = "Порог низкого разрешения";
settings.multires.lowResVertices.help = "Более низкое разрешение меша может отображаться при движении камеры.

Вы можете увеличить это значение, если вы хотите отобразить более высокое разрешение меша.";

// The main rendering mode
shading = "Затенение";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "Освещено (PBR)";
shading.pbr.help = "В этом режиме вы можете добавить освещение (с тенями), а также HDR-окружение.

Вы также можете окрашивать металличность и шероховатость, что позволяет лучше редактировать внешний вид материала.";
// Fast rendering mode for sculpting purpose
shading.matcap = "Маткап";
shading.matcap.help = "Маткап управляет освещением и информацией о материалах в одном изображении.

Это режим быстрого рендеринга, преимущественно подходящий для скульптурирования с нуля.";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "Не освещено";
shading.unlit.help = "Режим затенения цветами без освещения.";
// Helper rendering mode that display solid colors
shading.object = "Объект ID";
shading.object.help = "Режим неосвещенного рендеринга, при котором каждому объекту предписан случайный цвет.

Эта функция полезна, когда в кадре много объектов.";
// Helper rendering mode that display solid colors
shading.instance = "Создать ID";
shading.instance.help = "Так же, как ID объекта, но экземпляры будут иметь одинаковый цвет.";
// Helper rendering mode that display solid colors
shading.material = "ID материала";
shading.material.help = "Показать сплошной цвет для каждого экземпляра материала.";
// Randomize colors
shading.id.randomize = "Случайный id";
shading.textures = "Использовать текстуры";
shading.textures.help = "В данный момент вы не можете создавать и редактировать текстуры в Nomad.

Если вы импортируете файл с текстурами, эта функция должна стать доступна.

• Поддерживаемые текстуры
Непрозрачность: Освещено, маткап, не освещено
Нормали: Освещено, маткап
Цвет: Освещено, не освещено
Излучение: Освещено
Шероховатость: Освещено
Металличность: Освещено";
// Lights
shading.lights = "Освещение";
shading.lights.addLight = "Добавить источник освещения";
shading.lights.warning = "Для освещения необходим режим затенения PBR.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Окружение";
shading.environment.import = "Импортировать изображение в высоком динамическом диапазоне";
shading.environment.exposure = "Экспозиция";
shading.environment.backgroundBlur = "Размытие (фон)";
shading.environment.rotation = "Поворот";
shading.environment.rotation.help = "Вы можете вращать окружение, перемещая 3 пальца горизонтально по вьюпорту.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "Закреплено к камере";
shading.environment.attachedToCamera.help = "Прикрепляет окружение к камере.

Таким образом освещение будет однородным, что может помочь при сульптурировании.";
shading.matcap.rotation = "Поворот";
shading.matcap.rotation.help = "Вы можете вращать Маткап, перемещая 3 пальца горизонтально по вьюпорту.";
shading.matcap.global = "Использовать глобальный Маткап";
shading.matcap.global.help = "Отключите эту функцию, если вы хотите использовать другой Маткап для этого меша.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible = "Маска";
shortcut.solo = "Соло";
shortcut.xray = "Рентген";
shortcut.voxelRemesh = "Воксель";
shortcut.wireframe = "Каркас";
shortcut.cameraReset = "Сбросить";
shortcut.cameraSnap = "Привязка";
shortcut.lockSelection = "Блокировать";
shortcut.lockSelection.help = "При включении вы не сможете изменить выбор при нажатии на меш.";
shortcut.grid = "Сетка";

// Memory taken by the scene
stat.ramScene = "Кадр";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Видео-ОЗУ кадр";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "Видео-ОЗУ рендеринг";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "Видео-ОЗУ текстуры";
// Memory taken by the undo/redo history
stat.ramHistory = "История";
// Memory taken by other stuffs
stat.ramOther = "Другое";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "Использовано памяти";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "Свободная память";
// RAM, not storage!
stat.ram = "ОЗУ";
stat.used = "Использовано: $0";
stat.free = "Свободно: $0";
stat.faces = "Грани";
stat.triangles = "Треугольники";
stat.vertices = "Вершины";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Четырехугольники";
stat.vertex = "Вершина";
stat.scene.face = "Грани кадров";
stat.scene.vertex = "Вершины кадров";

// Brush stroke
stroke = "Штрих";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "Радиус на весь мир";
// The settings is shared among every tools
stroke.useWorldRadius.help = "Эта настройка общая для всех инструментов.";
// Share the radius value among every tools.
stroke.useShareRadius = "Общий радиус";
stroke.useShareRadius.help = "Общий размер радиуса для всех инструментов.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.spacing = "Расстояние между штрихами";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.spacing.adjust = "Настроить интенсивность в зависимости от расстояния";
stroke.minSpacingAdjustIntensity.help = "Настройка интенсивности кисти для создания последовательной деформации в зависимости от расстояния между штрихами.";
stroke.minSpacing.help = "Расстояние между штрихами, связано с радиусом инструментов.

Более низкое значение позволяет создавать более плавные штрихи, но производительность упадет.";
// Brush stroke smoothing
stroke.lazySmooth = "Сглаживание штрихов";
stroke.lazySmooth.help = "Выставите среднее значение с помощью многострелочного индикатора для более плавных штрихов.

При более высоком значении штрих будет отставать от индикатора, но рано или поздно нагонит его.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Канат-стабилизатор";
stroke.lazyRadius.help = "Штрихи будут отставать на определенную дистанцию от индикатора.

Таким образом можно рисовать более плавные линии.";
// It is not a per-tool settings
stroke.globalSettings = "Это глобальная настройка";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Радиус привязки";
stroke.snapRadius.help = "Привязка штрихов, если индикатор находится рядом с последним нарисованным штрихом.

Эта функция полезна при рисовании длинных продолжительных линий с регулярными паузами.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Сдвиг штрихов";
stroke.sculptOffset.help = "Применить регулярный сдвиг штрихов.

Эта функция помогает при использовании маленького экрана и пальцев: пальцы не закрывают штрих.";
stroke.accumulate = "Накопление штрихов";
stroke.accumulate.help = "Если эта функция включена, вы можете добавлять/убирать штрихи без ограничения.";
// The tool can use DynTopo
stroke.useDynamic = "Разрешить использование динамической топологии";
// Only sculpt the part that are linked topologically
stroke.connect = "Топология закрепленного";
stroke.connect.help = "Эта функция будет скульптурировать только те вершины, которые закреплены на выбранной поверхности.

Она чаще всего используется с инструментом `Перемещение`, например, если вы хотите переместить только ту часть, которая пересекается с другой частью.";
stroke.connect.short = "Закрепленного";
// sculpt on hide or mask
stroke.protect = "Защита области";
stroke.protect.hide.help = "Если установлено на 'авто', скрытые поверхности будут редактироваться, если каркас на скрытых поверхностях виден (см. меню каркаса).";
// Only sculpt the vertex that points toward the camera
stroke.culling = "Только вершины на лицевой поверхности";
stroke.culling.help = "Эта функция будет игнорировать вершины на обратной стороне.

Она особо пригодится в том случае, если вы хотите окрасить часть тонкой геометрии, не затрагивая другую часть.

Эта функция также применяется для скульптурирования, но могут возникнуть помехи.";
// Infinite depth, move everything under the circle, disregarding depth
stroke.silhouette = "Силуэт";
stroke.silhouette.view = "Просмотр";
stroke.silhouette.snapped = "Если привязано";
stroke.silhouette.closest = "Ближайший";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.sameSide = "Только вершины на одной стороне";
stroke.sameSide.help = "Игнорировать вершины, указывающие в обратную сторону от деформации.";
// determine normal direction
stroke.normal.direction = "Направление";
stroke.normal.direction.help = "Актуально только если включена деформация нормали.

Управляет тем, как Nomad определяет знак деформации (толкать или тянуть).";
stroke.normal.direction.normal = "Обычная 3D";
stroke.normal.direction.normal.help = "Сравнивает позицию XY указателя с проекцией нормальной поверхности.";
stroke.normal.direction.screen = "XY";
stroke.normal.direction.screen.help = "Использует XY позицию экрана указателя, чтобы определить толкать или тянуть.";
stroke.normal.direction.auto = "Авто";
stroke.normal.direction.auto.help = "Выбирает метод автоматически на основе угла нормальной проекции.";
stroke.normal.direction.auto.threshold = "Порог";
stroke.normal.direction.auto.threshold.help = "Предельный угол в сравнении с нормалью поверхности для выбора метода.";
// small tip/warning
stroke.onlyLasso = "Настройки активны только для инструмента `Лассо`.";

// Here sampling refers to the app gathering information under the mouse
stroke.area = "Выборка области";
stroke.area.help = "Некоторым кистям или параметрам штриха требуется плоскость, перпендикулярная поверхности, для работы.
Можно управлять вычислением этой средней плоскости, устанавливая область выборки в процентах от радиуса инструмента.

При 100% учитываются все точки внутри круга выбора.
При 0% учитывается только ближайшая вершина или треугольник.";
// Sampling radius size (percent)
stroke.area.normal.radius = "Радиус нормали";
// Sampling radius size (percent)
stroke.area.point.radius = "Радиус позиции";
// Sampling averaging
stroke.area.normal.average = "Усреднение нормалей";
// Sampling averaging
stroke.area.point.average = "Усреднение позиций";
// Keep sharp edges
stroke.normalFilter = "Фильтр нормали";
stroke.normalFilter.help = "
Фильтрование глубины";

// Only paint the part of the mesh above a certain height
stroke.depth.enable = "Маскировка по глубине";
stroke.depth.enable.help = "Исключить точки, которые находятся выше или ниже определенного расстояния от вычисленной плоскости (Выборка области).

Как пример, это может использоваться для рисования выпуклостей или впадин.";
stroke.depth.offset = "Смещение по высоте";
stroke.depth.falloff = "Падение глубины";
stroke.depth.max = "Верхняя область";
stroke.depth.min = "Нижняя область";

// Invert the pixel (black <-> white)
stroke.alpha.invert = "Инверсия пикселей";
// Repeat the alpha image (pattern)
stroke.alpha.wrap = "Плитка";
// No repeat pattern
stroke.alpha.wrap.none = "Нет";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alpha.wrap.repeat = "Повторение";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alpha.wrap.mirror = "Отзеркаливание";
// Tight fit when using tiling
stroke.alpha.fit = "Вписать внутрь";
stroke.alpha.fit.help = "This option is only relevant if the alpha and brushes textures are non square.

When enabled, each images will tile independently with no spacing.
You can disable this option if you want to keep the alpha and other images synchronized, in case their ratio are not the same.";
// Alpha rotation
stroke.alpha.rotation = "Поворот";
stroke.alpha.rotation.lock.help = "Заблокировать ориентацию альфа.

Если вращение разблокировано, ориентация будет следовать за направлением штриха в реальном времени.";
// Repeat the image
stroke.alpha.tiling = "Плитка";
// Scale the image (make it bigger or smaller)
stroke.alpha.scale = "Масштабирование";
stroke.alpha.scale.help = "При минимальном значении альфа-квадрат находится внутри радиуса инструмента.";
// Middle-point value at which no deformation occurs
stroke.alpha.midValue = "Среднее значение";
stroke.alpha.midValue.help = "Среднее значение, при котором не произойдет деформации.

(Среднее значение = 0)
• Черный: нет смещения
• Белый: позитивное смещение

(Среднее значение = 0.5)
• Черный: негативное смещение
• Белый: позитивное смещение

(Среднее значение = 1)
• Черный: негативное смещение
• Белый: нет смещения";
// Synonymous: Scatter/Jitter/Randomize
stroke.jitter = "Рандомизировать";
// Sculpt and paint along the brush stroke at regular spacing
stroke.type.dot = "Точка";
// Sculpt and paint along with alpha spaced by brush radius
stroke.type.roll = "Катить";
// Sculpt and paint with alpha projected on screen stencil
stroke.type.tile = "Плитка";
// Sculpt and paint with alpha projected on 3 axis
stroke.type.triplanar = "Трипланарность";
// Sculpt continuously
stroke.type.drag = "Перетаскивание";
// Lock a region and move it around
stroke.type.grab = "Движение";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.type.grabRadius = "Движение • динамический радиус";
// Lock a region and sculpt it by changing the tool intensity
stroke.type.grabIntensity = "Движение • динамическая интенсивность";

stroke.falloffProject = "Влияние";
stroke.falloffProject.help = "• Сфера (3D)
Влияние вычисляется, исходя из расстояния от вершины до центра кисти.

• Круг (2D)
Сначала вершина проецируется на плоскость области, а затем вычисляется её расстояние до центра кисти.
Это похоже на способ выборки альфа.";
stroke.falloffProject.sphere = "Сфера";
stroke.falloffProject.circle = "Круг";
stroke.falloffProject.cylinder = "Цилиндр";

// Symmetry
symmetry = "Симметрия";
symmetry.enable = "Вкл.";
symmetry.primitiveWarning = "Симметрия кисти доступна только для утвержденных примитив, за исключением трипланарности.";
symmetry.plane.title = "Плоскости";
symmetry.toolIgnore = "Текущий инструмент игнорирует симметрию.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Радиально";
symmetry.radialX = "Радиальная линия X";
symmetry.radialY = "Радиальная линия Y";
symmetry.radialZ = "Радиальная линия Z";
// A warning indicating that we limit the number of repetitions ($0 is a number)
symmetry.limited = "Количество повторений ограничено до $0!";
// Synonym: Offset
symmetry.offset.title = "Сдвиг";
symmetry.offsetX = "Сдвиг X";
symmetry.offsetY = "Сдвиг Y";
symmetry.offsetZ = "Сдвиг Z";
// Number of clones
symmetry.count.title = "Количество";
symmetry.countX = "Число X";
symmetry.countY = "Число Y";
symmetry.countZ = "Число Z";
// method
symmetry.method = "Метод:";
symmetry.method.help = "• Локально
Плоскость симметрии будет двигаться вдоль меша при использовании одного из инструментов трансформации (Гизмо или Трансформирование).

• Мир
Плоскость симметрии закреплена и не будет двигаться.";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.method.world = "Мир";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.method.local = "Локально";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Перевернуть объект";
// Cut half of the mesh
symmetry.cut = "Обрезать";
// after mirroring, separate into multiple output (synonym: split, separate)
symmetry.split = "Разделить";
// Reapply the mesh mirror, does not impact the topology
symmetry.mirror = "Зеркало";
symmetry.mirror.help = "Попытайтесь заново применить симметрию без влияния на топологию.

Радиальная симметрия будет проигнорирована.

Если топологию невозможно сохранить, потому что она не считается симметричной, вы можете принудительно произвести отзеркаливание.";
// indicate that applying the mirror will keep the mesh topology
symmetry.mirror.keepTopology = "с сохранением топологии";
symmetry.mirrorFail = "Не удалось применить симметрию.

Хотите принудительно создать симметрию, отзеркалив меш?";
symmetry.mirrorUseMasking = "Защита области маски";
symmetry.mirrorUseMasking.help = "Сохраняет область маски нетронутой.

Эта опция игнорируется при несимметричной топологии (или на отдельной поверхности, например, глазах).";
// Reset the symmetry plane position
symmetry.reset = "Сбросить";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Центр объекта";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "Центр мира";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Ориентация";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Показать линию";
// Display the symmetry plane in 3D
symmetry.showPlane = "Показать плоскость";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Редактирование гизмо";
symmetry.edit.warning = "Редактирование симметрии — это экспериментальная функция.";
symmetry.edit.help = "Вы можете свободно настраивать плоскость симметрии.

Эта функция несколько экспериментальна и вам не стоит ее использовать.";

// Ideally short strings
tool.dynamic = "Дин. топ.";
// Ideally short strings (Symmetry)
tool.symmetry = "Симметрия";
// Ideally short strings (Mirror primitive)
tool.mirror = "Отзерк.";
// Ideally short strings
tool.clay = "Глина";
// Ideally short strings (Subtract)
tool.clay.sub = "Вычитание";
// Ideally short strings
tool.brush = "Кисть";
// Ideally short strings
tool.move = "Переместить";
// Ideally short strings (Normal vector, perpendicular to surface)
tool.move.normal = "Обычное";
// Ideally short strings
tool.drag = "Перетаск.";
// Ideally short strings (Smooth the surface by erasing the details)
tool.smooth = "Сглаживание";
// Ideally short strings (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Смягчение";
// Ideally short strings (Paint mask)
tool.mask = "Маска";
// Ideally short strings
tool.mask.unmask = "Снять маску";
// Ideally short strings (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "Выб. маску";
// Ideally short strings (Smudge the paint of the object)
tool.smudge = "Растушевка";
// Ideally short strings (Flatten the surface)
tool.flatten = "Свести слои";
// Ideally short strings (Flatten the surface, more strongly than Flatten)
tool.planar = "Планар";
// Ideally short strings (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Заполнить";
// Ideally short strings (Layer brush)
tool.layer = "Слой";
// Ideally short strings
tool.crease = "Складка";
// Ideally short strings (Cut part of the mesh cleanly)
tool.trim = "Обрезка";
// Ideally short strings (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Разделить";
// Ideally short strings (Project part of the object onto a curve)
tool.project = "Проект";
// Ideally short strings
tool.inflate = "Надуть";
// Ideally short strings
tool.pinch = "Сжать";
// Ideally short strings
tool.nudge = "Подтолкнуть";
// Ideally short strings
tool.stamp = "Штамп";
// Ideally short strings (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "Удал. слой";
// Ideally short strings (Select multiple objects with a lasso tool)
tool.select = "Выбрать";
// Ideally short strings (Rotate, Translate and Scale the object)
tool.gizmo = "Гизмо";
// Ideally short strings
tool.gizmo.editPivot = "Ось";
// Ideally short strings (Snap angle)
tool.gizmo.rotateSnap = "Привязка";
// Ideally short strings (Snap translation)
tool.gizmo.moveSnap = "Привязка";
// Ideally short strings (Local/Relative space)
tool.gizmo.local = "Локально";
// Ideally short strings (Align/Snap the gizmo to world axis)
tool.gizmo.align = "Выровнять";
// Ideally short strings (Pin the gizmo, so that it stays in place when switching between objects)
tool.gizmo.pin = "Закрепить";
// Ideally short strings (Rotate, Translate and Scale the object)
tool.transform = "Трансформация";
// Ideally short strings (Translate the object)
tool.transform.move = "Переместить";
// Ideally short strings (Rotate the object)
tool.transform.rotate = "Поворот";
// Ideally short strings (Scale the object)
tool.transform.scale = "Масштаб";
// Ideally short strings (Snap the object on another object surface)
tool.transform.snap = "Привязка";
// Ideally short strings (Measure distance between 2 points)
tool.measure = "Измерение";
// Ideally short strings (Lattice, deformer)
tool.lattice = "Решетка";
// If an option is shared among the tools
tool.all = "Все";
// Ideally short strings (Quad Remesher)
tool.remesh = "Квад Ремешер";
tool.remesh.guides = "Направляющие";
tool.remesh.density = "Плотность";
tool.remesh.same = "Same";
tool.remesh.half = "Half";
// Ideally short strings (FaceGroup)
tool.faceGroup = "Группа Граней";
tool.faceGroup.autoPick = "Автовыбор";
tool.faceGroup.flush = "Удалить неиспользуемые";
tool.faceGroup.skip = "Исключить малые группы на основе:";
tool.faceGroup.skipFace = "Количество граней";
tool.faceGroup.skipFace.help = "Не создавать новую группу, если количество граней меньше или равно этому порогу.";
tool.faceGroup.skipArea = "Площадь поверхности";
tool.faceGroup.skipArea.help = "Не создавать новую группу, если площадь поверхности новой группы меньше этого порога.

Порог указан как процент от общей площади объекта.";
// Ideally short strings (Hide)
tool.hide = "Скрыть";
// Ideally short strings (View tool, do nothing in particular)
tool.view = "Просмотр";
// Ideally short strings (Revolving surface along a line)
tool.lathe = "Тело вращения";
// Ideally short strings (Revolving surface along a curve)
tool.tube = "Трубка";
// Ideally short strings (Insert object into the scene)
tool.insert = "Вставить";
// Ideally short strings (Flip/Invert/Negate the shape)
tool.shape.flip = "Переворот";
// Ideally short strings (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "Просмотр";
// Ideally short strings (Lasso selection)
tool.shape.lasso = "Лассо";
// Ideally short strings (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Кривые";
// Ideally short strings (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Полигон";
// Ideally short strings (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Путь";
// Ideally short strings (Rectangular selection)
tool.shape.rectangle = "Прямоугол.";
// Ideally short strings (Ellipse selection)
tool.shape.ellipse = "Эллипс";
// Ideally short strings (Line selection, split the screen in half)
tool.shape.line = "Линия";
// Ideally short strings (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Закрыт";

// Radius of the tool (size)
tool.radius = "Радиус";
// Intensity of the tool (force)
tool.intensity = "Интенсивность";

tool.settings = "Параметры";
tool.settings.none = "У этого инструмента нет особых настроек.";

tool.crease.pinchFactor = "Сила щипка";
tool.crease.offsetFactor = "Коэффициент смещения";

tool.layer.removeInfluence = "Использовать данные слоев";
tool.layer.removeInfluence.help = "Эта функция активна только при выбранном слое.

Она использует только данные слоев для уменьшения смещения штрихов.";
tool.layer.noLayerSelected = "Эта функция доступна только в том случае, если выбран слой";

tool.flatten.planeLockOrigin = "Закрепить опорную точку плоскости";
tool.flatten.planeLockNormal = "Закрепить направление плоскости";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "Синхронизация";
tool.syncInstance.message = "Новый объект будет добавлен во все другие инстансы!";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Прикрепленные вершины по краям";
tool.smooth.screen = "Сглаживание на экране";
tool.smooth.screen.help = "Используйте эту опцию для получения сглаживания, не зависящего от топологии, даже при большом количестве полигонов.";
tool.smooth.screen.samples = "Образцы экрана";
tool.smooth.stable = "Стабильное сглаживание";
tool.smooth.stable.help = "Пытается сделать сглаживание независимым от топологии.

Этот режим лучше всего работает с различной плотностью топологии и с высоким значением интенсивности сглаживания.";

tool.paint = "Рисовать";
// Erase the painting
tool.paint.erase = "Стереть";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Фильтрование слоев";
tool.paint.layerFilter.help = "Используйте эту функцию, если вы хотите заново окрасить уже окрашенную часть слоя.";

// Clear the painted mask
tool.mask.clear = "Очистить";
tool.mask.clearAll = "Очистить все";
// Invert the painted mask
tool.mask.invert = "Инвертировать";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Переворот закрепленного";
// Blur the painted mask
tool.mask.blur = "Размытие";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Резкость";
// Transform/Matrix
tool.matrix = "Матрица";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.target = "Цель";
// Automatic
tool.matrix.target.auto = "Авто";
tool.matrix.target.auto.help = "При стандартных настройках будет работать подобно групповому варианту.
Если у меша есть маски или же включена симметрия, эта функция будет работать как вершины.";
// Auto apply the transform on the vertices
tool.matrix.target.vertex = "Вершина";
tool.matrix.target.vertex.help = "Применяется для трансформации вершин и не будет работать на неутвержденных примитивах.
Экземпляры также будут затронуты.";
// Transform the object alone (the children stands still)
tool.matrix.target.object = "Объект";
tool.matrix.target.object.help = "Перемещает только объект, игнорирует симметрию и маски.
Только редактированный узел сдвигается, дочерние узлы остаются на месте.";
// Transform the object and its children
tool.matrix.target.group = "Группа";
tool.matrix.target.group.help = "Перемещает узел, игнорируя симметрию и маски.
Остальная иерархия также переносится.";
// Operation on the mesh
tool.matrix.action = "Операция";
tool.matrix.action.origin = "Перенос к опорной точке";
tool.matrix.action.origin.help = "Перенос меша к опорной точке мира.";
tool.matrix.action.bake = "Запекание";
tool.matrix.action.bake.help = "Применение матрицы к вершинам и сброс меша. Визуально ничего не изменится.";
tool.matrix.action.reset = "Сбросить";
tool.matrix.action.reset.help = "Сброс трансформации меша.";

// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "Сдвиг";
tool.matrix.translation = "Перевод";
tool.matrix.rotation = "Поворот";
tool.matrix.scale = "Масштаб";
tool.matrix.uniformScale = "Однородное масштабирование";

tool.transform.tip = "Одинарное касание вторым пальцем для смены режима";

// Size of the gizmo
tool.gizmo.size = "Размер виджета";
// If true, there is less spacing between gizmo handlers (rotate, scale, etc)
tool.gizmo.compact = "Компактный";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "Цифровой ввод";
tool.gizmo.allowInput.help = "Позволить цифровой ввод при нажатии на один из гизмо-виджетов";
// Angle threshold
tool.gizmo.linearRollThreshold = "Порог поворота тангенса";
tool.gizmo.linearRollThreshold.help = "Настройте на определенную сторону от порога для выбора между линейным и циклическим поворотом.

Значения выше этого порога используют циклический поворот.

Если вы предпочитаете линейный поворот (в сторону тангенса), установите значение на 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Скрывать при взаимодействии";
tool.gizmo.tap = "одним касанием";
tool.gizmo.tap.help = "Эта функция эффективна только в режиме уникальной оси (отключена по умолчанию).";
tool.gizmo.tap.none = "Нет";
tool.gizmo.tap.none.help = "При нажатии на меш ничего не произойдет";
tool.gizmo.tap.normal = "Обычное";
tool.gizmo.tap.normal.help = "Move the gizmo on the first intersection and align it according to the surface normal.";
tool.gizmo.tap.first = "Первое касание";
tool.gizmo.tap.first.help = "Перенос гизмо при первом пересечении.";
tool.gizmo.tap.medial = "Средняя величина";
tool.gizmo.tap.medial.help = "Перенос гизмо в середину между первыми двумя пересечениями.";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "Закреплено";
tool.lathe.axisOnly = "Только ось";
tool.lathe.stable = "Стабильный";
tool.lathe.axis = "Ось";

// Fill the object's hole
tool.hole = "Заполнение дырок";
tool.hole.fillHoles = "Заполнить дырки";
// synonym: Alternative method
tool.hole.method.fill = "Заполнить";
tool.hole.method.legacy = "Устаревший";
tool.hole.method.boolean = "Boolean";
tool.hole.bridges = "Boolean по размеру экрана";
tool.hole.bridges.help = "Включение этой функции позволяет создавать дырки в объеме.
Откос выемки будет ближе к форме вырезания.";
tool.hole.threshold = "Порог эпсилон";
tool.hole.threshold.help = "Настройка этого значения может помочь работе алгоритма по заполнению дырок.";
tool.hole.smoothing = "Сглаживание дырок";

tool.smudge.quality = "Качество";
tool.smudge.quality.help = "Изменяет разрешение проектируемых пикселей: чем ниже значение, тем чаще мазки.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Форма";
// Auto-validate the drawn shape
tool.shape.autoValidate = "Автоматическая валидация";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Квадрат";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Центрование";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Круг";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Центрование";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Пошаговый поворот";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Золотое сечение";
// volume of a mesh
tool.measure.volume = "Объем";
// Surface of a mesh
tool.measure.surface = "Поверхность";

// Always display the camera shortcut buttons on the viewport
tool.view.stickyCamera = "Ярлык камеры (всегда)";

// Topology
topology = "Топология";
// Synynom: detail value, density
topology.dynamic.detail = "Детали";
// See glossary
topology.multires = "Мультиразрешение";
topology.multires.help = "Сохранить мультиразрешение меша.

При внесении изменений в низком разрешении, детали в высоком разрешении будут снова проецированы при переключении.

Слои доступны для всех разрешений.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "Возврат";
topology.multires.reverse.confirm = "Не удалось создать базовое подразделение.

Текущая топология, вероятно, не является результатом подразделения.";
topology.multires.subdivide = "Подразделение";
topology.multires.subdivide.confirm = "В меше будет $0M вершин(ы), вы уверены?";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "Достигнут лимит подразделений, см. $0";
topology.multires.deleteLower = "Удалить ниже";
topology.multires.deleteHigher = "Удалить выше";
topology.multires.keepTriangles = "Оставить треугольники";
topology.multires.lock = "Блокировать (LV0)";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "Уровень Мультреза →";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "Уровень Мультреза ←";
// Synonym: Flat subdivision
topology.multires.linear = "Линейное подразделение";
topology.multires.linear.help = "Простое подразделение меша без применения сглаживания";
// Only show the lowest resolution wireframe
topology.multires.minWireframe = "Только уровень 0";
// Create a new object by recomputing a new topology
topology.remesh = "Перестройка меша";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Воксельная перестройка сетки";
topology.voxel.help = "Перестройка меша путем взятия образца меша с сетки.

Если объект не закрыт, вначале будет произведен алгоритм заполнения дырок.

Слои будут заново спроектированы после перестройки меша, но качество ухудшится.";
topology.voxel.resolution = "Разрешение";
topology.voxel.sharp = "Сохранение острых ребер";
topology.voxel.sharp.help = "Эта функция наиболее полезна для простых примитивных операций Boolean.

Она добавит искажение в некоторых областях, поскольку точки будут привязаны по ребрам.";
topology.voxel.subLevel = "Создать мультиразрешение";
topology.voxel.subLevel.help = "Вы можете восстановить иерархию мультиразрешения по результату воксельной перестройки меша.

Этот процесс пройдет быстрее и с использованием меньшего количества памяти, в особенности если выставлено высокое значение детализации вокселей.
Если установлено низкое значение детализации вокселей, а необходимо произвести много уровней мультиразрешения, детали будут утеряны.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Перестройка меша";
topology.surface.detail = "Детали";
topology.surface.detail.help = "В отличие от воксельной перестройки меша, поверхностная перестройка меша не требует закрытого меша.

Она также поддерживает маски, т. е. вы можете защитить часть меша от изменений топологии.

Слои обновляются корректно.";
topology.surface.method = "Метод";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Униформизация";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Подразделение";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Упрощение";
topology.surface.method.help = "Поведение динамической топологии:
• Униформизация: добавление и удаление деталей
• Подразделение: добавление деталей
• Упрощение: удаление деталей";
topology.surface.useMasking = "Защита области маски";
topology.surface.useMasking.help = "Области маски защитят топологию от изменения.";
topology.surface.extrapolate = "Экстраполяция вершин";
// DynTopo
topology.dynamic = "Динамическая топология";
topology.dynamic.global = "Глобально включить/выключить";
topology.dynamic.activate = "Вкл.";
topology.dynamic.activate.help = "Динамическая топология позволяет инструментам скульптурирования подразделять или упрощать меш локально в режиме реального времени.";
topology.dynamic.method = "Дали базируются на...";
topology.dynamic.method.screen = "Экран";
topology.dynamic.method.radius = "Радиус";
topology.dynamic.method.constant = "Постоянная";
topology.dynamic.method.help = "• Масштабирование
Детализация зависит от близости к поверхности.

• Радиус
Инструмент `Радиус` определяет количество деталей.

• Постоянная
Деталь закреплена, а значение детализации связано со слайдером вокселей.";
topology.dynamic.quality = "Предпочтение...";
topology.dynamic.quality.help = "Если вы выбираете опцию `Качество`, два основных различия:
• улучшение применяется до скульптурирования, результатом является меньшее количество интерполирующих артефактов при окрашивании или скульптурировании очень мелких деталей
• улучшение не применяется пошагово, при скульптурировании очень мелких деталей или быстрых штрихах топология будет корректно улучшаться";
topology.dynamic.quality.speed = "Скорость";
topology.dynamic.quality.quality = "Качество";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Использовать нажим на радиусе";
topology.dynamic.usePressure.help = "Используйте эту функцию, если вы хотите, чтобы уровень нажима на перо отображался уровнем детализации на радиусе инструмента.";
topology.dynamic.useFalloff = "Использовать спад штрихов";
// Decimate
topology.decimate.title = "Упрощение";
topology.decimate.title.help = "Уменьшите количество полигонов путем сохранения максимального количества деталей.

Эта функция полезна для экспорта на 3D-принтер.
Однако, ее не стоит использовать, если вы планируете продолжить работать над скульптурированием, поскольку она может произвести неравные треугольники.

Примечание: зоны маски не будут упрощены.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Упростить";
topology.decimatePaintWeight = "Сохранить окрашивание";
topology.decimatePaintWeight.help = "При высоком значении программа попытается сохранить окрашивание.

Если окрашивание для вас не важно, установите это значение на 0.";
topology.decimateUniform = "Однородные грани";
topology.decimateUniform.help = "Более высокие значения будут выдавать треугольники подобного размера.";
topology.decimatePreserveBorders = "Сохранить границы";
topology.decimatePreserveBorders.help = "Не уменьшать количество полигонов на границе сетки.";
// Target a certain number of triangles, faces and vertices
topology.target.triangles = "Целевые треугольники";
topology.target.faces = "Целевые грани";
topology.target.quads = "Целевые квады";
topology.target.points = "Целевые точки";
// Quad remesher
topology.qremesh = "Квад Ремеш";
topology.qremesh.angle = "Угол фаски";
topology.qremesh.border = "Сохранить границы";
topology.qremesh.onlyQuad = "Только квады";
topology.qremesh.hole = "Максимальное заполнение отверстия";
topology.qremesh.hole.help = "
UV-развертка";

// Unwrapping means compute UV (texture coordinates), with uvs you can appliy (wrap) a texture onto the model
topology.uv.title = "Раскрытие UV";
// UV Unwrap but as a Verb
topology.uv.unwrap = "Развернуть";
// The operation can be very slow
topology.uv.atlas.warning = "Может занять большое количество времени, у цели <100т вершин!";
// Handles are topological holes (synonym: genus, hole)
topology.uv.bff.warning = "Если в меше есть отверстия, может возникнуть перекрытие!";
// Solo patch
topology.uv.bff.seamless = "Бесшовные патчи";
topology.uv.bff.seamless.help = "Эта опция может вызвать значительные искажения.

Как правило, её можно использовать, когда группы лиц тщательно настроены.";
// Synonym: Point count? Singularity count ?
topology.uv.bff.cones = "Количество конусов";
topology.uv.bff.help = "Более высокое значение уменьшит искажение сложных объектов.

Более высокое значение повысит время обработки.";
topology.uv.delete = "Удалить UV";

// Transfer the vertex painting in the texture, bake means "create texture (from mesh data)"
topology.bake.title = "Запекание";
// Bake here means "create texture (from mesh data)"
topology.bake.title.help = "Создание текстур выполняется путем проецирования других видимых объектов в сцене.

Вот типичный рабочий процесс для создания текстур:
• У вас есть сетка с тонкими деталями и рисунком
• Склонируйте ее
• Упростите (установите `Сохранить рисунок` на 0!)
• Раскройте UV
• Выпеките!

Теперь у вас должна быть сетка с низким разрешением, которая сохраняет большую часть рисунка и деталей вашего предыдущего объекта.

После операции цвета вершин будут перемещены в новый отключенный слой, чтобы они игнорировались вместо того, чтобы умножаться на цветную текстуру.

Чтобы выбрать, какие объекты будут использованы для запекания, применяется следующая логика:
- все выбранные объекты и главный выделенный объект будут запеканы (самое яркое выделение в меню сцены)
- если выбран только один объект, то Nomad учтет все видимые объекты.
- если все объекты скрыты (например, через Solo), то учитывается вся сцена";
// Bake here means "create texture (from mesh data)"
topology.bake.self = "Из самого себя";
// Bake here means "create texture (from another mesh data)"
topology.bake.other = "Из высоко-детализированного";
topology.bake.resolution = "Разрешение";
// Cage is a specific term, synonyom: "Bake offset"
topology.bake.offset = "Смещение луча";
topology.bake.radius = "Радиус каркаса";
// Bake opacity (from mask data)
topology.bake.opacityFromMask = "Маска -> Непрозрачность";
topology.bake.backup = "Резервное копирование";

// project a high resolution mesh details onto another
topology.reproject.title = "Репроекция";
topology.reproject.title.help = "Проецируйте детали скульптуры, рисунок и слои с ближайших видимых объектов.

Это в основном предназначено для использования также на сетке с высоким разрешением, обычно с чистой топологией.";
// tweaking value
topology.reproject.rayBias = "Смещение луча";
topology.reproject.rayBias.help = "Для репроекции используются два метода:
• ближайший: ближайшая точка на поверхности
• луч: точка пересечения через нормальное направление

Большие значения смещения будут способствовать пересечению луча вместо ближайшей поверхности.";
topology.reproject.normalOffset = "Смещение нормали";
topology.reproject.shpereCast = "Альтернативное использование сферического отбрасывания";
topology.reproject.shpereCast.help = "Если репроекция по нормальному лучу не удастся, Nomad перейдет к ближайшему пересечению поверхности.";
// number of iteration the algorithm will take
topology.reproject.iterations = "Итерации";
topology.reproject.relax = "Смягчение";
topology.reproject.relax.help = "Релаксацию следует предпочесть, когда сетка низкополигональная.";
topology.reproject.layers.help = "Перенос других слоев на выбранную сетку.";

topology.manifold = "Многообразие";
topology.nonManifold = "Non-manifold";
topology.manifold.clean = "Очистить";
topology.manifold.collapse = "Удалить маленькие грани";
topology.manifold.title = "Принудительное многообразие";
topology.manifold.title.help = "Попытается очистить non-manifold ребра.

Это может быть полезно для внешних программ, которые не поддерживают ребра, у которых более двух общих граней.";

// Reset key-bindings/shortcuts
binding.reset = "Сбросить привязки";
// Add node in a sync mode (synchronize instance)
binding.addSync = "Синхронизация";
binding.addSync.help = "По умолчанию, будет использоваться синхронизационное значение, установленное в меню сцены.";
// Binding option
binding.context.toggle = "Переключить контекст";
// quick sidebar tool shortcuts
binding.quicks = "Быстрые клавиши";
// quick regular tool shortcuts
binding.tools = "Клавиши инструментов";
// When the key is tapped once, the value will be toggled
binding.toggle = "Переключатель предыдущего инструмента";
binding.toggle.help = "Используйте ту же клавишу, чтобы вернуться к последнему инструменту.";
// sticky keys
binding.sticky = "Залипающие клавиши";
binding.sticky.off = "Удерживать";
binding.sticky.off.help = "Удерживайте клавишу для использования инструмента, отпустите, чтобы вернуться к предыдущему инструменту.";
binding.sticky.on = "Переключить";
binding.sticky.on.help = "Нажмите один раз, чтобы переключить инструменты.";
binding.sticky.quick = "Быстрое нажатие";
binding.sticky.quick.help = "Удерживать для временного использования, быстро нажать для переключения.";
// The binding force camera movement
binding.forceCamera = "Принудительная камера";
binding.forceCamera.help = "Принудительное взаимодействие с камерой в случае конфликта с другой связкой.

Это обычно происходит, если та же связка назначена для ярлыка инструмента или операции добавления/вычитания.";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickMaterial = "Выбор материала";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickFaceGroup = "Выбор группы граней";
// Edit the tool brush size/radius
binding.editRadius = "Радиус инструмента";
// Inverse direction zooming
binding.invertZoomY = "Инвертировать масштабирование по оси Y";
// Edit the tool brush size/radius
binding.editIntensity = "Интенсивность инструмента";
// Controller dead zone
binding.joystick = "Джойстик";
binding.controller.deadZone = "Мертвая зона джойстика";
binding.controller.deadZone.help = "Увеличьте это значение, если камера продолжает двигаться, даже если джойстик контроллера не трогают.";
// Snap the camera
binding.view.front = "Вид спереди";
binding.view.left = "Вид слева";
binding.view.top = "Вид сверху";
// Move/Translate the view
binding.pan.left = "Панорамирование влево";
binding.pan.right = "Панорама вправо";
binding.pan.forward = "Панорама вперед";
binding.pan.backward = "Панорама назад";
binding.pan.up = "Панорама вверх";
binding.pan.down = "Панорама вниз";
// Snap the view (while rotating)
binding.snapViewOnRotate = "Просмотр привязки (при прокручивании)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "Открыть (проект)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "Добавить (проект)";
// Select all the objects in the scene
binding.selectAll = "Выбрать все";
// Rotate environment and the lighting
binding.rotateLighting = "Поворот освещения";
// The Camera pivot is the point around which the camera rotates
binding.updatePivot = "Ось";

quadremesh.adaptQuadCount = "Адаптивное количество квадов";
quadremesh.curvatureAdaptivness = "Адаптивный размер";
quadremesh.curvatureAdaptivness.help = "При 100%, размер квадов будет варьироваться в зависимости от кривизны объекта, позволяя меньшие квады на высокой кривизне.
При 0%, размер квадов будет равномерным.";
quadremesh.useVertexColors = "Сохранить окрашивание";
quadremesh.autoDetectHardEdges = "Авто-обнаружение острых кромок";
quadremesh.autoDetectHardEdges.short = "Жесткие края";
quadremesh.reprojectVertex = "Перепроецирование вершины";
quadremesh.reprojectVertex.short = "Перепроецирование вершины";
quadremesh.reprojectVertex.label = "Когда включено, Nomad перепроецирует положение на предыдущую сетку.

Обратите внимание, что если у сетки есть слои, перепроецирование всегда будет использоваться.";

// Privacy policy
privacyPolicy.title = "Политика конфиденциальности";
privacyPolicy.reject = "Отклонить";
// Hexanomad is the company name
privacyPolicy = "Hexanomad не собирает данные из Nomad Sculpt.";

sonar.disconnect = "Отключить SonarPen";
sonar.connect = "Подключить SonarPen";
sonar.connect.confirm = "Подключить SonarPen?";
sonar.connect.confirm.warning = "Sonar Pen будет использовать микрофон (обратная связь по аудио) для определения давления стилуса.";

// Color disc mode
widget.color.disc = "Диск";
widget.color.ring = "Кольцо";
widget.color.square = "Квадрат";

nomad.mainFolder = "Главная папка Nomad";
nomad.mainFolder.warning = "Файлы оставлены без изменений.
Они не копируются, не удаляются и не перемещаются.";
nomad.mainFolder.error = "После выбора 'Да', Nomad закроется, и вы сможете просто перезапустить его.";

license.title = "Лицензия";
license.retry = "Повторить";
license.key = "Ключ лицензии";
license.activate = "Активировать лицензию";
// ----------------------------------------------
license.newest = "Доступна новая версия!";
license.encrypt.error = "Не удалось зашифровать!";
// ----------------------------------------------
license.grace = "Офлайн - Остаток льготного периода:";
license.grace.hours = "часов";
license.grace.days = "дней";
// ----------------------------------------------
license.portal.title = "Существующие пользователи";
license.portal.label = "Портал лицензий";
// ----------------------------------------------
license.checkout.title = "Новые пользователи";
license.checkout.label = "Купить Nomad";
// ----------------------------------------------
license.device.error = "Невозможно получить ID устройства.";
license.device.mismatch = "Несоответствие ID устройства!";
// ----------------------------------------------
license.error429 = "Слишком много запросов (ожидание).";
// ----------------------------------------------
license.validate.error404 = "Лицензионный ключ не найден.";
license.validate.error422 = "Непроцессируемый объект.";
// ----------------------------------------------
license.activate.error403 = "Максимальное количество устройств достигнуто!
Вы можете деактивировать другое устройство в своем лицензионном портале.";
license.activate.error404 = "Лицензионный ключ не найден.";
license.activate.error422 = "Непроцессируемый объект.";
// ----------------------------------------------
// version
version.update = "Обновление доступно!";
version.restore = "Восстановить покупку";
version.buyWeb = "Веб-версия — это только демо-версия";
version.buyFull = "Перейти на полную версию";
// ----------------------------------------------
// QuadRemesh
version.qr.unlock = "Разблокировать (покупка, восстановление, пробная версия)";
version.qr.desktop = "На рабочем столе QuadRemesher распространяется компанией Hexanomad, но Hexanomad не занимается продажей или лицензированием. 
Управление всеми лицензиями осуществляет Exoside.";
version.qr.buy = "Покупка";
version.qr.promo = "
Quad Remesher — это алгоритм, который создает сетку, преимущественно состоящую из четырехугольников.
Распределение четырехугольников будет пытаться следовать естественной кривизне объекта.

Алгоритм также может адаптировать размер четырехугольников в зависимости от локальной кривизны.

Вы также можете управлять результирующей топологией с помощью:

• Группы граней $0 (убедитесь, что их границы сглажены для лучшего результата!)

• Плоскостной симметрии X/Y/Z $1

• Направляющих кривых $2

• Рисования плотности $3

Quad Remesher разработан https://exoside.com/.";
// ----------------------------------------------
version.trialLayer = "Пробная версия: 1 слой на меш";
version.trialNoExport = "Пробная версия: экспорт невозможен";
// ----------------------------------------------
version.fullFeatures = "• Однократная покупка
• Бесконечное количество отмен/возвратов
• Бесконечное количество слоев
• Экспорт и импорт";
// ----------------------------------------------
version.demo.purpose = "Это демоверсия приложения.";
version.demo.disable = "Функция недоступна в демоверсии.";
// ----------------------------------------------
version.demo = "Демо Тест";
version.demo.sculpt = "Скульптурирование";
version.demo.sculpt.help = "Все кисти доступны, но вы не можете сохранять или экспортировать.

Этот режим в основном предназначен для экспериментов с кистями или проверки поддержки силы нажатия.

Другие функции также могут быть ограничены (история, слои).";
version.demo.file = "Импорт и Экспорт";
version.demo.file.help = "Вы можете импортировать и экспортировать модель, но скульптурные кисти отключены.

Этот режим в основном полезен для мобильных пользователей, которые не могут открыть большие проекты .nom из-за ограничения памяти мобильного устройства.";
// ----------------------------------------------
// app store main page
store.name = "Nomad Sculpt";
store.headline = "Лепка и рисование в 3D";
store.tag = "sculpt, 3d, nomad, paint, modeling, лепка, рисование, моделирование";
// ----------------------------------------------
store.description.sculpt = "• Инструменты лепки
Глина, выравнивание, сглаживание, маска и множество других кистей позволят вам формировать ваше творение.
Вы также можете использовать инструмент для резки булевыми операциями с лассо, прямоугольником и другими формами для целей хардсерфейса.";
// ----------------------------------------------
store.description.stroke = "• Настройка штриха
Затухание, альфы, размещение, давление карандаша и другие параметры штриха могут быть настроены.
Вы также можете сохранять и загружать предустановки ваших инструментов.";
// ----------------------------------------------
store.description.paint = "• Инструменты рисования
Вершинное рисование с цветом, шероховатостью и металлическостью.
Все предустановки ваших материалов также легко управляются.";
// ----------------------------------------------
store.description.layer = "• Слои
Записывайте свои действия по лепке и рисованию в отдельные слои для упрощения итерации в процессе создания.
Записываются изменения как в лепке, так и в рисовании.";
// ----------------------------------------------
store.description.multires = "• Мультирезолюционное скульптурирование
Переходите туда и обратно между множеством разрешений вашей сетки для гибкого рабочего процесса.";
// ----------------------------------------------
store.description.voxel = "• Voxel ретопология
Быстро ретопологируйте вашу сетку, чтобы получить равномерный уровень детализации.
Может использоваться для быстрого наброска приблизительной формы в начале процесса создания.";
// ----------------------------------------------
store.description.dynamic = "• Динамическая топология
Локально детализируйте вашу сетку под вашей кистью, чтобы автоматически получить уровень детализации.
Вы даже можете сохранять ваши слои, поскольку они будут автоматически обновляться!";
// ----------------------------------------------
store.description.topology = "• Уменьшение
Уменьшайте количество полигонов, сохраняя как можно больше деталей.";
// ----------------------------------------------
store.description.group = "• Группа лиц
Сегментируйте вашу сетку на подгруппы с помощью инструмента для группы лиц.";
// ----------------------------------------------
store.description.unwrap = "• Автоматическое развёртывание UV
Автоматический развёртыватель UV может использовать группы лиц для контроля процесса развёртки.";
// ----------------------------------------------
store.description.baking = "• Baking
Вы можете перенести вершинные данные, такие как цвет, шероховатость, металлическость и детали малого масштаба в текстуры.
Также можно делать обратное, перенося данные текстур в вершинные данные или слои.";
// ----------------------------------------------
store.description.primitive = "• Примитивная форма
Цилиндр, тор, труба, токарные и другие примитивы могут быть использованы для быстрого начала новых форм с нуля.";
// ----------------------------------------------
store.description.rendering = "• PBR рендеринг
По умолчанию прекрасный PBR рендеринг с освещением и тенями.
Вы всегда можете переключиться на MatCap для более стандартного затенения для целей лепки.";
// ----------------------------------------------
store.description.postprocess = "• Постобработка
Отражение в экранном пространстве, глубина резкости, окклюзия окружающей среды, тоновое отображение и т.д.";
// ----------------------------------------------
store.description.files = "• Экспорт и импорт
Поддерживаются форматы glTF, OBJ, STL или PLY файлов.";
// ----------------------------------------------
store.description.interface = "• Интерфейс
Легкий в использовании интерфейс, разработанный для мобильного опыта.
Доступна также настройка!";
// ----------------------------------------------
store.description.remesher = "• Quad Remesher (доступно только с отдельной покупкой в приложении)
Автоматически ретопологируйте ваш объект с преобладанием четырехугольной сетки, которая следует за кривизной сетки.
Поддерживаются руководства, группы лиц и рисование плотности.";
// ----------------------------------------------