// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "Confirmar?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Sim";
// Answer to a question (Are you sure you want to do that? [yes, no, cancel])
confirm.no = "Não";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "OK";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Cancelar";
// Restart nomad
confirm.restart = "Após alterar este valor, você precisa reiniciar o Nomad.";

// Experimental feature
experimental = "Experimental!";

status.exit = "Alterações não salvas! Guardar antes de fechar?";
status.exit.yes = "Salvar";
status.exit.no = "Não salvar";

// On single tap (should be short)
ontap = "Toque";

all = "Todos";
error = "Erro";

reset = "Redefinir";
resetOrder = "Redefinir ordem";

clipboard = "Área de transferência";
clipboard.copy = "Copiar";
clipboard.paste = "Colar";

// memory size
bytes = "bytes";
kB = "kB";
MB = "MB";
GB = "GB";
TB = "TB";

// Noun
instance = "Instanciar";
object = "Objeto";

// Same value (usually for axis, e.g: x == y == z)
uniform = "Uniforme";

sync = "Sincronizar";

// position
position.top = "Superior";
position.bottom = "Inferior";
position.left = "Esquerda";
position.right = "Direita";
position.center = "Centralizado";
// direction
direction.up = "Superior";
direction.down = "Inferior";
direction.left = "Esquerda";
direction.right = "Direita";
// 3D cube
cube.top = "Superior";
cube.bottom = "Inferior";
cube.left = "Esquerda";
cube.right = "Direita";
cube.front = "Frontal";
cube.back = "Posterior";

// Name of an item (object, tool, etc)
item.name = "Nome";
// Add a new item (object, tool, etc)
item.new = "Novo";
// Rename an item (object, tool, etc)
item.rename = "Renomear";
// Add a new item (object, tool, project, etc)
item.add = "Adicionar";
// Update an item image with a new image (synonym: Update)
item.replace = "Substituir";
// Save an item (object, tool, etc)
item.save = "Salvar";
item.save.confirm = "Confirmar salvamento?";
// Update an item (update camera view point, etc)
item.update = "Atualizar?";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Último salvamento";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "Carregar último salvamento?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Redefinir";
item.reset.confirm = "Confirmar redefinição?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "Instanciar";
// Uninstance the object, make the object real
item.uninstance = "Desinstanciar";
// Clone an item (object, tool, etc)
item.clone = "Clonar";
// Delete an item (object, tool, etc)
item.delete = "Apagar";
item.delete.confirm = "Confirmar apagamento?";
item.delete.confirm.yes = "Sim, apagar";
// When we delete the item but the image is used somewhere
item.delete.used = "Imagem usada";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "Em Nó";
// Item visibility (object, layer, etc)
item.visible = "Visível";
// Show an item (object, layer, etc)
item.show = "Mostrar";
// Hide an item (object, layer, etc)
item.hide = "Ocultar";
// Select an item (object, layer, etc)
item.select = "Selecionar";
// Unselect an item (object, layer, etc)
item.unselect = "Desmarcar";
// Merge an item with another one below (layer)
item.mergeDown = "Combinar abaixo";
// The order of an item in a list
item.order = "Ordem";
// Focus on previous item
item.previous = "Anterior";
// Focus on next item
item.next = "Seguinte";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "Bloquear";
// No item selected
item.none = "Nenhum";
// Draggable, moveable
item.draggable = "Movível";

// Search something (text entry to filter item)
search = "Buscar";

// Three-state toggle button (Auto, Off, On)
toggle.on = "Ativar";
// Three-state toggle button (Auto, Off, On)
toggle.off = "Desativar";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "Auto";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Miniaturas faltando. Reprocessando arquivos…";
loading.reprocess.cancel = "Pular geração de miniaturas?";

access.title = "Acessibilidade";
access.window = "Janela auxiliar";
access.pinch = "Apertar";
access.drag = "Arrasto";
access.rotate = "Girar";
access.roll = "Rolar";

// Color of an object
material.color = "Cor";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "Aspereza";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "Brilhosidade";
// Whether the material is a metal or not
material.metalness = "Metalidade";
// How much light a surface will reflect
material.specular = "Especular";
// Light that the surface can emit (glow)
material.emissive = "Emissiva";
// Normal map (synonym: detail, bump)
material.normal = "Normal";
// flip y coordinate
material.normal.flipY = "Inverter Y";
// Ambient Occlusion (AO)
material.occlusion = "Oclusão";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "Texturas";
// Textures/Image
material.texture = "Textura";
// A warning indicating that the mesh has no UVs
material.warningNoUVs = "Sem UVs!";
// Texture filtering https://en.wikipedia.org/wiki/Texture_filtering
material.texture.filter = "Filtragem";
// Nearest Filtering (closest sample)
material.texture.nearest = "Mais próximo";
// Bilinear Filter
material.texture.linear = "Linear";
// Mipmap filtering
material.texture.mipmap = "Mipmap";
// Triplanar mapping
material.projection = "Projeção";
material.projection.triplanar = "Triplano";

// Prefer low power
about.lowPower = "GPU de baixo consumo";
// Wintab wacom API
about.wintab = "Usar WinTab";
about.wintab.help = "Se o WinTab estiver ativado, você provavelmente deve desabilitar o Windows Ink nas configurações do seu Wacom.

Da mesma forma, se o WinTab estiver desativado, então o Windows Ink deve ser ativado nas configurações do Wacom";
// Wacom Multi Touch API
about.touch = "Utilizar Wacom Multi-Touch";
about.touch.help = "Ative esta opção para suportar múltiplos dedos em tablets Wacom.";
// Prefer low power
about.fullScreen = "Tela cheia";
// Minify
about.minify = "Mini IU";
about.minify.help = "Você também pode tocar na tela com 4 dedos, se isso for compatível com o dispositivo.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Mesa Giratória";
// Rotation center of the turntable
about.turntable.pivot = "Centro de rotação";
// Keep current pivot
about.turntable.pivot.keep = "Manter atual";
// Turntable pivot will be at the center of the scene
about.turntable.pivot.scene = "Cena";
// Make the entire scene turn around (speed of the animation)
about.turntable.speed = "Velocidade";
// Stuffs that I used to make the app
about.credits = "Créditos";
// Link to open source projects that I used for the app
about.credits.openSource = "Código Aberto";
// Only translate the &
about.credits.arts = "MatCaps e HDRIs";
// Change languages of the app
about.languages = "Idiomas";
about.languages.help = "Arquivos de tradução disponíveis em $0";
// Link to the App Website
about.website = "Site";
// Link to the App Forum
about.forum = "Fórum";
// Link to the App Manual
about.manual = "Manual";
// Link to the App Email
about.mail = "Suporte";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";
// Link to the App Threads account
about.threads = "Threads";

// The user canceled an operation that was running
alert.aborted = "Operação abortada!";
// Empty mesh
alert.mirror.empty = "Saída vazia!";
// Mesh already mirrored
alert.mirror.same = "Mesma saída!";
// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "O objeto não tem furos!";
// No operation occured because the mesh is already manifold
alert.manifold.already = "A malha já é manifold!";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "O objeto atual está invisível!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Nada para recortar.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Abortar recorte: o objeto está totalmente recortado.";
// In order to extract something, the mesh needs to have painted mask
alert.extract.none = "Nada para extrair!";
// In order to split something, the mesh needs to have painted mask
alert.extract.split.none = "Nada para dividir!";
// List of disabled features when View Mode is selected
alert.view.disabled = "Recursos desativados no Modo Visualização:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Widgets primitivos";
// The object needs to have two parts disconnected
alert.separate.fail = "Não foi possível separar: o objeto só tem uma parte!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "Malha recriada!";
alert.voxelRemesh.empty = "Abortar recriação da malha: a malha resultante não tem faces.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "Entrada inválida!";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "O objeto será duplicado";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "O objeto será instanciado";
// A pivot refers the gizmo 3D position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Edite o modo do pivô.";
alert.mask.full = "Máscara = 100%!";
// A pivot refers the gizmo 3D position
alert.gizmo.editObject = "Edite o modo do objeto.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Topologia dinâmica ativa";
// See Glossary (DynTopo)
alert.dynamic.disable = "Desativar topologia dinâmica";
alert.colorPicker = "Arraste o dedo sobre o objeto para selecionar uma cor.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Dê um único toque para sair do modo transformar.";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "Toque simples para sair do modo de simetria de edição.";
// Show the painted mask on the mesh
alert.mask.show = "Mostrar máscara";
// Hide the painted mask on the mesh
alert.mask.hide = "Ocultar máscara";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Bloquear seleção";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Desbloquear seleção";
// Hide the objects that are not selected
alert.selection.isolate = "Isolar seleção";
// Show the objects that are hidden
alert.selection.showAll = "Mostrar tudo";
// Project quick saving
alert.quickSave = "Salvando...";
// Painting on the object was hidden but the user did paint the object
alert.forcePainting.fill = "Mostrar pintura ativado, [Pintar tudo] foi usado.";
// Painting on the object was hidden but the user started to paint on the object
alert.forcePainting.tool = "Mostrar pintura ativado, o objeto foi pintado.";
// See Glossary (Multiresolution)
alert.multiresLost = "A multirresolução será perdida!";
// Boolean cut mode will ignore some features
alert.booleanIgnored = "Boolean ignorará áreas mascaradas ou ocultas!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "O valor do detalhe está alto e pode exigir muita memória!";
// Autosave popup
alert.autoSave.auto = "Salvamento automático em... $0s";
// The selected object doesn't have any layers
alert.needLayer = "A ferramenta atual requer uma camada ativa.";
// The user decided to hide the painting on the objects
alert.paintingHidden = "Pintura oculta!";
// The user decided to hide the masking on the objects
alert.maskingHidden = "Máscara está oculta!";
// The user decided to display hidden faces
alert.hideIgnored = "Hide é ignorado!";
// The selected object doesn't have any layers
alert.noPartialWireframe = "O desenho parcial está desativado enquanto a armação é exibida.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Considere o uso de uma câmera ortográfica para evitar a distorção de perspectiva do campo de visão ao usar um projetor.";
// Trial version has a limited number of undo
alert.state.trial = "Versão de avaliação: desfazer cancelado";

background = "Fundo";
// A flat color will be displayed in the background of the scene
background.color = "Cor";
// 2 color with rotation
background.gradient = "Gradiente";
// The environment (HDRI) will be displayed in the background
background.environment = "Ambiente";
background.blur = "Desfoque";
background.exposure = "Exposição";

// Image that the artist uses as a reference
background.imageEnable = "Imagem de referência";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Sobrepor";
// Opposite of transparency (Alpha)
background.imageAlpha = "Opacidade";
background.imageReset = "Redefinir ajustes";
background.imageTransform = "Transformar";
// X screen coordinate of the image reference
background.imageX = "Posição X";
// Y screen coordinate of the image reference
background.imageY = "Posição Y";
// Rotation of the reference image
background.imageRotation = "Rotação";
// Scale of the reference image
background.imageScale = "Escala";
// Auto adjust the reference when moving the camera
background.lock.image = "Sincronizar com bloqueio da câmera";
background.lock.image.help = "Quando a câmera é bloqueada com o Snap Cube, a imagem de referência segue o movimento da câmera.";
// When exiting camera lock
background.lock.exit = "Redefinir ao desbloquear:";
background.lock.exit.none = "Ajustar Fov";
background.lock.exit.none.help = "Manter a imagem e a câmera como estão.  
Se estiver em perspectiva, apenas ajuste o campo de visão.";
background.lock.exit.all = "Redefinir Tudo";
background.lock.exit.all.help = "Redefinir tanto a posição da imagem quanto da câmera.";
background.lock.exit.perspective = "Se em Perspectiva";
background.lock.exit.perspective.help = "Se estiver em perspectiva, redefina a posição da imagem e da câmera.";

// Blend: normal
blend.normal = "Normal";
// Blend: darker
blend.darker = "Mais escuro";
blend.darker.darken = "Escurecer";
blend.darker.multiply = "Multiplicar";
blend.darker.linearBurn = "Queima Linear";
blend.darker.colorBurn = "Queima de Cor";
// Blend: lighter
blend.lighter = "Mais claro";
blend.lighter.lighten = "Clarear";
blend.lighter.screen = "Tela";
blend.lighter.linearDodge = "Soma Linear";
blend.lighter.colorDodge = "Soma de Cor";
// Blend: contrast
blend.contrast = "Contraste";
blend.contrast.hardLight = "Luz Forte";
blend.contrast.softLight = "Luz Suave";
blend.contrast.overlay = "Sobrepor";
blend.contrast.hardMix = "Mistura Dura";
blend.contrast.linearLight = "Luz Linear";
blend.contrast.vividLight = "Luz Vívida";
blend.contrast.average = "Média";
// Blend: inversion
blend.inversion = "Inversão";
blend.inversion.exclusion = "Exclusão";
blend.inversion.difference = "Diferença";
// Blend: cancelation
blend.cancelation = "Cancelamento";
blend.cancelation.divide = "Divisão";
blend.cancelation.subtract = "Subtração";
// Blend: component
blend.component = "Componente";
blend.component.luminosity = "Luminosidade";

// Camera (point of view in 3D)
camera = "Câmera";
cameras = "Câmeras";
camera.view = "Visualizar";
// Copy the views
camera.updateView = "Atualizar ponto de visualização?";
// Add a new camera
camera.addView = "Adicionar Visualização";
// Focus on the camera
camera.focus = "Foco";
// Add on the camera camera
camera.focusOn = "Foco em $0";
// Camera projection, Orthographic or Perspective
camera.projection = "Projeção";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Ortográfica";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Perspectiva";
// camera Vertical Field of View
camera.fov = "CDV Vertical";
// Camera Field of View hint
camera.focal = "focal $0 mm (sensor de 35 mm)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Rotação";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "Mesa Giratória";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Trackball";
camera.rotation.trackball.help = "Trackball oferece uma liberdade maior: você também pode rolar a câmera com 2 dedos.";
// Camera interaction mode, 1st person view
camera.firstPerson = "Primeira Pessoa";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Velocidade";
// Camera rotation sensitivity
camera.speed.rotation = "Rotação";
// Camera translation sensitivity
camera.speed.panning = "Deslocamento";
// Camera zooming sensitivity
camera.speed.zooming = "Zoom";
// Reset camera position
camera.resetView = "Redefinir visualização";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Ajustar visualização";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "A câmera está ajustada (ortográfica)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "Ajuste ortográfico";
camera.snapOrthographic.help = "Esta opção também funciona ao usar o Cubo de Ajuste no canto.";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Pivô";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Toque duas vezes no objeto";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Toque duas vezes no fundo";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "Alternar";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "Seleção";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "Cena";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "Atualizar ao tocar duas vezes";
camera.doubleTapPivot.help = "Atualize o pivô de rotação ao tocar duas vezes na superfície do objeto.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "Pivô aéreo";
camera.airPivot.help = "Permita um novo pivô mesmo com o zoom fora da superfície do objeto.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "Ao iniciar gesto da câmera";
camera.autoPivot.help = "Atualize o pivô quando começar a interagir com a câmera.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Foco";
camera.doubleTapFocus.help = "Ao tocar duas vezes no objeto, a câmera será deslocada e focada no ponto escolhido.";
// Disable XY panning when unzomming
camera.centerZoomOut = "Centralizar a visão ao afastar o zoom";
camera.panZoomOut.help = "Quando esta opção estiver desativada, a posição do pivô será mantida intacta.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "Seleção múltipla";
// There is 0 nodes/items selected
context.noSelection = "Nenhuma seleção";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "Pré‑ajuste";
// Quick curve x side shift
curve.shift = "Shift";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "Spline";
curve.bspline = "B-spline";
curve.precision = "Precisão";
// merge or collapse 1 point into another
curve.merge = "Mesclar";
// snap
curve.snap = "Ajuste";
curve.snap.offset = "Deslocamento";
curve.snap.offset.help = "Um valor de 100% é igual ao raio do tubo.";
curve.snap.surface = "Superfície";
curve.snap.vertex = "Vértice";
curve.snap.grid = "Grade (se ajustado)";
// Regular spaced sampling
curve.uniform = "Uniforme";
curve.uniform.help = "A curva será amostrada com espaçamento regular, para garantir densidade uniforme.

Você pode desativar esta opção para controlar um pouco os laços de borda adicionando novos pontos de controle na curva.";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "Exibir a atenuação de forma simétrica.

Esta opção é apenas um indicativo visual, ela não impacta a atenuação em si";
curve.radius = "Raio";
curve.twist = "Torção";
curve.spiral = "Espiral";
curve.spiral.twist = "Ângulo de torção";
curve.spiral.scale = "Escala";
curve.spiral.offset = "Deslocamento";
curve.spiral.angle = "Deslocamento do ângulo";
curve.pivot = "Pivô";
curve.pivot.self = "Curva";
curve.pivot.children = "Secundários";

// Set the desired FPS (frame per second, refresh rate)
debug.targetFps = "FPS Alvo";
debug.targetFps.help = "Quando desativado, o valor padrão significa que irá sincronizar com a taxa de atualização do display.";

// Warning about UVs (using extra memory)
debug.uvPrimitive.warning = "Desative esta opção caso não precise de UVs (memória extra).";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "Normalizar UVs";
debug.uvNormalize.help = "O Nomad normalizará os UVs dentro do mosaico [0-1].";

// Debug option, display an window with some debugging logs
debug.logs = "Registros";
// Model shortcut window
debug.shortcut = "Janela de atalho";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Mapa de altura";
// Debug options, graphical stuffs
debug.graphics = "Gráficos";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Criar miniaturas da loja";

// Open file explorer
file.explore = "Explorar";
// Open file explorer
file.scope = "Âmbito";
file.scope.internal = "Interna";
file.scope.internal.help = "Comportamento padrão, igual ao móvel.  
Os projetos são salvos apenas na pasta principal do Nomad.";
file.scope.external = "No Local";
file.scope.external.help = "Ao importar um projeto de fora, salvar irá sobrescrever o arquivo original.
Auto salvar não é suportado para projetos externos.";
// Empty list: there is no projects
file.project.load = "Recarregar projeto ao iniciar";
// Empty list: there is no projects
file.project.empty = "Você ainda não salvou nenhum projeto!";
// The current opened project has some unsaved changes
file.project.unsaved = "Alterações não salvas!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "Você perderá as alterações não salvas!";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Pré‑visualização do último salvamento manual";

file.project = "Projeto";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Salvar";
// E.g: Save "my_project"?
file.project.save.confirm = "Salvar $0?";
// Make a copy
file.project.saveAs = "Salvar Como";
// Overwrite another project
file.project.overwrite = "Substituir";
// E.g: Overwrite "my_other_project"?
file.project.overwrite.confirm = "Substituir $0?";
// Open a project
file.project.open = "Abrir";
// E.g: Open "my_project"?
file.project.open.confirm = "Abrir $0?";
// E.g: Clone "my_project"?
file.project.clone.confirm = "Clonar $0?";
// Load another project and add/append all its data to the current scene
file.project.add = "Adicionar à cena";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "Adicionar $0 à cena?";
// Reset the scene and create a new project
file.project.new = "Novo";
file.project.new.confirm = "Criar nova cena?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "Apagar $0?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "Apagar $0?

Esse é o projeto em atividade!";

// Auto save section
file.autoSave = "Salvamento Automático";
file.autoSave.confirm = "Desativar Salvamento Automático?";
file.autoSave.help = "Salve o projeto em um arquivo separado em intervalos regulares.

O arquivo de salvamento automático pode ser encontrado em:";
// Interval in minutes in which the auto save popup will appear
file.autoSave.popup = "Tempo limite do pop-up";
// In minutes
file.autoSave.minutes = "Pop-up do timer";
// Delete the current autoSave data
file.autoSave.delete = "Descartar Salvamento Automático";
// Open the outdated auto save
file.autoSave.open.manual = "Abrir salvamento manual desatualizado";
file.autoSave.open.auto = "Abrir salvamento automático desatualizado";

// color space (linear or srgb), do not translate linear/srgb if there is a doubt
file.colorSpace = "Espaço de Cor";
file.colorSpace.help = "Tente alternar esta opção se as cores parecerem incorretas.";
file.colorSpace.linear = "Linear";
file.colorSpace.srgb = "sRGB";

// Configure imports option
file.importSettings = "Opções de importação";

// Load interface preference settings when opening a scene file
file.import.guiSettings = "Manter ajustes da IU";
file.import.guiSettings.help = "Ao abrir ou importar um arquivo de projeto, todos os ajustes relacionados à IU integrados ao projeto serão carregados.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.import.obj.splitByGroup = "Dividir OBJ em grupos";
file.import.obj.splitByGroup.help = "Quando ativado, o Nomad dividirá os grupos OBJ em objetos separados.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.import.mergeLayers = "Combinar Camadas";
// Ignore the textures present in the file to load
file.import.skipTextures = "Ignorar texturas";
// Do not fiddle with the object topology when loading the file
file.import.keepTopology = "Manter topologia";
file.import.keepTopology.help = "Use esta opção para que o Nomad não altere a topologia da malha importada.

Ela desativará a reordenação de vértice/face, remoção de duplicatas de vértice/face e remoção de vértices não usados.";

// Import file section
file.import.title = "Importar";
file.import.title.help = "Formatos compatíveis:";
// The user imports a scene file that will replace the current scene
file.import.open = "Abrir";
file.import.open.confirm = "Importar novo arquivo?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Adicionar à cena";
file.import.add.confirm = "Importar novo arquivo?";

// Export scene file
file.export = "Exportar";

// Filter nodes that we want to export
file.select.include = "Incluir";
file.select.all = "Todos";
file.select.visible = "Visível";
file.select.selected = "Selecionados";
file.select.unselected = "Não selecionado";

// Export each node in a separate file
file.export.separate = "Um arquivo por objeto";

// Export the current selected objects instead of the entire scene
file.onlySelection = "Incluir apenas objetos selecionados";
file.onlySelection.help = "Inclui apenas a seleção, em vez da cena inteira.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Reconstruir quadrado";
file.convertToQuad.help = "Associe triângulos (se adjacentes nos arquivos) para reconstruir quadrados.";
// ----------------------------------------------
// Whether we include the textures in the exported file
file.export.texture = "Texturas";
// Baking means transfering/converting
file.export.texture.help = "Esta opção não sela as cores dos vértices nas texturas.";
// ----------------------------------------------
file.export.color0 = "Cores dos vértices";
file.export.color1 = "Pintura PBR";
file.export.color1.help = "Exporte a pintura da aspereza, metalidade e máscara. Isso será ignorado por outros softwares.";
// ----------------------------------------------
// Whether we include normals vector in the exported file
file.export.normal = "Normais";
file.export.normal.help = "Selecione esta opção para abrir o arquivo em outros softwares.

Como o Nomad recalcula os normais, ele sempre os ignora.";
// ----------------------------------------------
file.export.tangent = "Tangentes";
file.export.tangent.help = "Selecione esta opção se quiser abrir o arquivo em outros softwares.

Tangentes são utilizadas apenas se o modelo possui um mapa normal.

O Nomad sempre ignora as tangentes, pois ele as recalcula.";
// ----------------------------------------------
file.export.nomad.help = "Formato de arquivo interno do Nomad Sculpt.

Este formato não será carregado em outros softwares, é mais para fins de reimportação.";
// ----------------------------------------------
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Camadas";
file.export.gltf.layer.help = "Exporte as camadas como morphs. Por ser oficialmente compatível com gITF, isso também deve funcionar em outros softwares.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Pintura da camada";
file.export.gltf.layerPaint.help = "Exporte a pintura da camada. Normalmente, isso é ignorado por outros softwares.";
// ----------------------------------------------
file.export.obj.warning = "Camadas e pinturas extras (aspereza, metalidade e máscara) serão perdidas.";
// Whether we include the vertex color in the exported file
file.export.obj.color = "Cores dos vértices";
file.export.obj.color.help = "Alguns softwares de 3D (mas não todos) poderão ler essas informações.";
file.export.obj.color.help.append = "Afixe informações de cores aos vértices.";
file.export.obj.color.help.hexa = "Uma maneira alternativa de codificar cor. Também suporta dados de máscara.";
file.export.obj.faceGroup = "Grupo de Faces";
file.export.obj.object = "Escrever Objetos";
file.export.obj.object.help = "Mantenha objetos separados.

Desabilitar esta opção exportará tudo como uma única entidade.
Você precisa desabilitar esta opção se deseja usar o recurso 'Mesh ID / Polygroup' da Substance Painter.";
file.export.obj.archive = "Tipo";
file.export.obj.archive.folder = "Pasta";
file.export.obj.archive.zip = "Zip";
file.export.obj.archive.help = "Alguns aplicativos (Google Drive, One Drive, etc) não suportam a importação de pastas, então você pode usar Zip em vez disso.";
// ----------------------------------------------
file.export.ply.warning = "Camadas e pinturas extras (aspereza, metalidade e máscara) serão perdidas.";
// ----------------------------------------------
file.export.stl.warning = "Camadas e pinturas extras (aspereza, metalidade e máscara) serão perdidas.";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Cores dos vértices";
file.export.stl.color.help = "Alguns softwares de 3D (mas não todos) poderão ler essas informações.";
// ----------------------------------------------
file.export.usd.skew = "Permitir inclinação";
file.export.usd.skew.help = "Permitir inclinação nas transformações da matriz.

Quando desativado, o Nomad dividirá matrizes de inclinação em duas transformações separadas de escala e rotação.";
// ----------------------------------------------
// Advanced settings
settings.advanced = "Avançado";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "Estas opções não são salvas nos ajustes.";
settings.reset.title = "Ajustes";
settings.reset.title.help = "Isto redefinirá os ajustes de preferências do app.

Alguns recursos são salvos separadamente e NÃO serão redefinidos, incluindo:

• Projetos
• Atalhos
• Pré‑ajustes das ferramentas
• Ambientes HDR
• MatCaps
• Alfas
• Texturas (pincel)
• Imagens de referência

Note que tudo aquilo ligado ao projeto será mantido intacto, como iluminação, Pós-processamento, visualizações da câmera, etc.";

// Reset preference settings button
settings.reset = "Redefinir padrão";
settings.reset.confirm = "Redefinir ajustes das preferências?";

// Render a screenshot of the scene
file.render = "Renderizar";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Mostrar interface";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Proporção da renderização";
file.render.renderRatio.help = "Com um valor de 1.0, o Nomad renderizará na mesma resolução do tamanho de imagem solicitado abaixo.

Use esta opção caso não consiga renderizar em uma certa resolução (falhas por causa da falta de memória).";
// Desired size of the exported screenshot
file.render.size = "Tamanho final";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Personalizado";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "Tela";
// width of exported screenshot
file.render.width = "Largura";
// height of exported screenshot
file.render.height = "Altura";
// export screenshot of the scene
file.render.warn = "A resolução da exportação é alta ($0x$1)!

Certifique-se de que o projeto esteja salvo para o caso do dispositivo ficar sem VRAM e falhar.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Fundo transparente";
file.render.transparent.help = "Esta opção pode ser útil para inserir a malha em um software de criação 2D.

A transparência parcial de objetos não é compatível no momento.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Usar ajustes globais";
pressure.useGlobal.help = "Por padrão, as ferramentas compartilham os mesmos ajustes de pressão.

Desmarque esta opção para usar ajustes específicos de pressão para esta ferramenta.";

// Pencil pressure
pressure.title = "Pressão";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "Esta ferramenta não usa a pressão do lápis.";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "O tipo de traçado ao pegar o lápis ignorará os ajustes de pressão.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Raio";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Intensidade";
// Average pencil pressure event to get smoother result
pressure.average = "Suavização de pressão";
pressure.average.help = "Média dos eventos de pressão do lápis para resultados mais suaves.";
// Limit pressure to 100%
pressure.limit = "Limitar pressão a 100%";
pressure.limit.help = "Esta é uma configuração global.

Use esta opção para garantir que a pressão da caneta nunca exceda 100%.";

// list of inputs allowing camera interaction
gesture.camera = "Câmera";
// list of inputs allowing sculpting interaction
gesture.sculpt = "Esculpir";
// Select object
gesture.select = "Selecionar objeto";
// Finger/Touch input
gesture.finger = "Dedo";
// Stylus/Pencil
gesture.stylus = "Stylus";
// Mouse/Trackpad
gesture.mouse = "Mouse";

gesture.wheel = "Roda do mouse";
gesture.wheel.speed3d = "Velocidade (zoom 3d)";
gesture.wheel.speed2d = "Velocidade (interface 2d)";

// long press to pick the color/material under the cursor
gesture.dropper = "Seleção de material";
gesture.dropper.help = "Você pode manter a tela pressionada para acionar o seletor de cor/material.

Note que isso só funciona se a pintura estiver ativada no pincel atual.";

camera.airStroke = "Permitindo o traço de ar";
camera.airStroke.help = "Permitir que o traço de escultura comece mesmo que o cursor inicial não acerte a malha.

Esta opção está ativa apenas para entradas com escultura habilitada e câmera desabilitada.";

// Three fingers on screen
gesture.three.title = "Três dedos";
gesture.three.light = "Girar iluminação";
gesture.three.light.help = "Girar o ambiente, luzes e MatCap.";
gesture.three.radius = "Raio da Ferramenta";
gesture.three.intensity = "Intensidade da Ferramenta";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.finger.smooth = "Dedo sempre suaviza";
gesture.finger.smooth.help = "Esta opção só está ativa se uma ferramenta de escultura estiver ativa.";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Permitir pressão não reconhecida";
gesture.unknownPressure.help = "Selecione esta opção se a pressão não funcionar com o lápis ou você precisar de pressão do dedo.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Botão do lápis";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Dois toques no lápis";
gesture.pencilAction.ios.help = "Ativado apenas para o Apple Pencil (2ª geração).";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "Nenhuma";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Adicionar/Subtrair";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "Atalhos de um toque";
gesture.mask.oneTap.help = "Toque na tela uma vez para permitir o atalho de Máscara, sem precisar manter pressionado o atalho do botão de máscara.

Isso permitirá os seguintes gestos:
• Toque no fundo para inverter a máscara
• Toque em uma área com máscara para desfocar a máscara
• Toque em uma área sem máscara para dar nitidez à máscara";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.holdStroke = "Traçado";
gesture.mask.holdStroke.help = "Pressionar e segurar alternará entre Máscara e SelMáscara e iniciará um novo traço.

No final do traço, a ferramenta anterior é selecionada novamente.";
gesture.mask.holdIdle = "Ferramenta";
gesture.mask.holdIdle.help = "Pressione e segure sem mover para alternar entre Máscara e SelMáscara.";

// Shortcut customization, choose the action that the shortcut will performan (select tool, etc)
gesture.shortcut = "Atalho";

// Shortcuts to undo/redo
gesture.history = "Atalhos do histórico";
gesture.history.help = "• Desfazer: toque com 2 dedos
• Refazer: toque com 3 dedos";
gesture.history.hold = "Manter pressionado";
gesture.history.hold.help = "Mantenha 2/3 dedos na tela (contínuo).";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Rejeição de palma";
gesture.palmRejection.confirm = "Desative esta opção caso tenha problemas para interagir com a tela!";
gesture.palmRejection.help = "Rejeite a entrada se o tamanho da área de contato for maior que este valor.

Pode não funcionar em todos os dispositivos.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Limite de tamanho máximo";

// Smoothing strategy
extract.polish.all = "Todos";
extract.polish.sharp = "Borda afiada";
extract.polish.border = "Apenas bordas";
// Smooth the border in a way that it matches completely with its dual
extract.polish.syncBorder = "Sincronizar borda";
// topology of extracted mesh
extract.edgeLoop = "Laço de borda (lateral)";
extract.edgeLoop.auto = "Laço de borda automático";
extract.edgeLoop.division = "Divisão";
// The thickness of the extracted mesh (from the painted mask)
extract.thickness = "Espessura";
// Carve the mask into the surface
extract.carve = "Baixo relevo";
// Extract a new mesh from the painted mask
extract = "Extrair";
// Preview extract
extract.preview = "Pré‑visualização";
// Extract two new mesh from the painted mask and from the unmasked area
extract.split = "Dividir";
// How should we close the topology of the extracted object
extract.action = "Ação de fechamento:";
extract.action.help = "• Nenhuma
Apenas extrai a parte e deixa as partes extraídas abertas.

• Preencher
Não use esta opção em superfícies planas.

• Casca
Use o valor de espessura para fechar a forma extraída.

• Camada
Extraia a diferença da camada (somente submenu de camada).";
// Do not close the mesh (leave it open)
extract.action.none = "Nenhuma";
// Close the mesh with a hole-filling algorithm
extract.action.fill = "Preencher";
// Close the mesh by adding a thickness on the surface
extract.action.shell = "Casca";
// Close the mesh by using the layer data as a difference thickness
extract.action.layer = "Camada";

// uv part of revolution surface
genus.main = "Principal";
genus.hole = "Furo";
genus.bottom = "Inferior";
genus.top = "Superior";

// History, list of undo/redo
history = "Histórico";
// First "undo" state
history.root = "Início";
history.undoConfirm = "Você confirma que deseja desfazer todas essas operações?";
history.undoWarning = "Se você fizer uma edição posteriormente, poderá perder várias alterações.";
// Settings concerning the history stack of undo/redo
history.stack = "Pilha";
// Actions to include in the undo/redo stack
history.include = "Incluir ações";
// include lighting editing in the undo/redo
history.includeLights = "Luzes";
history.includeLights.help = "Com esta opção desativada, a movimentação de luzes com o Gizmo ainda será incluída, já que ela pode afetar outros objetos na hierarquia da cena.";
// include postProcess editing in the undo/redo
history.includePostProcess = "Pós-processamento";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCaps e HDRIs";
// Can limit the stack of undo/redo size
history.limitSize = "Limite do histórico";
history.limitSize.help = "Tamanho máximo do histórico.

O histórico será atualizado na próxima operação gravada.";
// Limit the number of undo in the history stack
history.limitStack = "Limite da pilha";
history.limitStack.help = "O número máximo de operações que o aplicativo pode manter.

O histórico será atualizado na próxima operação gravada.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Desfazer máximo ";
history.rangeProtect.help = "Se você voltar muito no histórico, verá um diálogo de confirmação antes de desfazer muitas operações.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Restaurar câmera";
history.restoreCamera.help = "Ative esta opção para restaurar o ponto de visualização salvo da câmera ao desfazer/refazer uma ação.";
// Undo
history.undo = "Desfazer";
// Redo
history.redo = "Refazer";
// Shown during undo
history.state.undo = "Desfazer: $0";
// Shown during redo
history.state.redo = "Refazer: $0";
// Shown during undo/redo
history.state.voxelRemesh = "Remalhar voxels";
// Shown during undo/redo
history.state.surfaceRemesh = "Remalhar superfície";
// Shown during undo/redo
history.state.multiresLevel = "Alteração de resolução";

// Debugging/Inspect object material (view channel separately color, roughness, normal, uv, etc)
inspect = "Inspetor";
// Inspector but SHORT
inspect.short = "Inspecionar";
// Display the material channel on the background
inspect.onBackground = "Em Fundo";
// Display the material channel on the mesh
inspect.onMesh = "Na Malha";
// Show UV seams
inspect.seams = "Costuras";

// Interface customization
interface = "Interface";

// Resize window (should be short)
interface.resize = "Redimensionar";

// UI customization: one item row will stands on one line (synonym: Inlined)
interface.compact = "UI: Compacto";

// UI customization: each row of the list will be bigger
interface.expandList = "IU: expandir lista";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Uma opção da IU para gerenciar a lista mais facilmente.";

// Add shortcuts buttons to the bottom of the screen
interface.shortcut.bottom = "Adicionar atalhos (inferior)...";
// Floating window
interface.shortcut.float = "Adicionar atalhos (janela flutuante)...";

// Interface option (main base color)
interface.colorBase = "Cor da base";
// Interface option (accent widget color)
interface.colorSelect = "Cor do widget";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Painel transparente";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Intensidade do desfoque";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Cor do painel";

// Interface color style
interface.preset.title = "Pré‑ajustes";

// Reset interface settings
interface.resetAll = "Redefinir estilo";
interface.resetAll.confirm = "Redefinir ajustes da interface?";
// help popup when hovering
interface.hoverHelp = "Ajuda pop-up ao passar o mouse";
// Interface option (main base color)
interface.iconSupport = "Botão de alto contraste";
interface.iconSupport.help = "Um estilo alternativo para botões que os torna mais visíveis quando estão ativados.

Se definido como Automático, o Nomad usará este modo quando o contraste de cor da UI entre ativado/desativado for baixo.";
// Interface customization
interface.flipTop = "Espelhar barra superior";
// Interface customization
interface.flipBottom = "Espelhar barra inferior";
// Interface customization
interface.flipMiddle = "Espelhar barras laterais";
// list of tools
interface.toolbox = "Caixa de ferramentas";
// hide toolbox by default
interface.toolbox.hide = "Ocultar";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.columns = "Colunas";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.rows = "Linhas";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Redefinir ordem";
// Colored text and icon
interface.toolbox.color = "Colorido";
// Top bar
interface.top.title = "Área superior";
interface.top.responsive = "Adaptável";
interface.top.responsive.help = "Esta opção é mais relevante para telas pequenas.";
interface.top.responsive.multiline = "Multilinha";
interface.top.responsive.scroll = "Rolar";
interface.top.responsive.collapse = "Colapso";
interface.top.alt = "Ordem alternativa";
interface.top.alt.help = "Ícone de ordem alternativa para o menu superior.

Menus relativos à edição de mesh estão principalmente no lado oposto do menu de cena, o que pode ajudar na edição de cena.";
// Scale the interface
interface.scale = "Tamanho global";
// Spacing between widgets
interface.cursorStep = "Espaçamento vertical";
// Width of the interface panels
interface.panelWidth = "Largura do painel";
// Size of fonts
interface.fontScale = "Tamanho da fonte";
// Inset
interface.inset.title = "Deslocamento da borda";
interface.inset.title.help = "Você pode alterar esses valores apenas se tiver problemas para interagir com os botões na borda da tela.

Se o controle estiver desativado, o Nomad usará os valores de área segura sugeridos pelo próprio dispositivo.";

// (see Glossary for Layer)
layer = "Camada";
layers.syncTransform = "Sincronizar transformação";
layers.syncTransform.help = "If enabled, all the unselected layers will be adjusted depending on the transform rotation, scale and skew.

Disable this option if the other layers are meant to be used without the new transform that you are applying.

When set on auto, only the visible layers will be adjusted.";
// (see Glossary for Layer)
layers.lock = "Manter detalhes das camadas superiores";
// (see Glossary for Layer)
layers.lock.yes = "Bloquear camadas superiores?";
// (see Glossary for Layer)
layers.lock.warning = "Ao esculpir, a deformação vinda das camadas superiores será ignorada.

Mas os detalhes dessas camadas ainda estarão visíveis.

Esta opção funciona apenas se as camadas superiores tiverem detalhes relativamente pequenos.";
// (see Glossary for Layer)
layers.addLayer = "Adicionar camada";
// (see Glossary for Layer)
layer.factors = "Fatores do canal";
// (see Glossary for Layer)
layer.factor = "Fator";
// (see Glossary for Layer)
layer.offset = "Deslocamento";
// Layer blend mode
layer.blendMode = "Mistura";
// (see Glossary for Layer)
layer.base = "Base";
layer.base.nothing = "Nada para extrair!";
layer.base.background = "Material de fundo";
layer.base.background.help = "Se ativo, apenas os valores do material que diferem do material de fundo serão extraídos.";
// (see Glossary for Layer)
layers = "Camadas";
layers.title = "Camadas";
// (see Glossary for Layer)
layers.title.help = "As camadas podem gravar deslocamentos de posição e pintura, o que é útil em um fluxo de trabalho não linear. Por exemplo, para experimentar expressões faciais diferentes sem depender da pilha do histórico para desfazer as alterações.

Nos dados de pintura, as camadas são ordenadas de cima para baixo, de modo que as camadas superiores mascaram as inferiores.

Você pode usar a ferramenta ApagCamada para apagar parte da camada.";
layers.primitive = "Camadas não estão disponíveis para primitivas.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "Nenhuma";

light = "Luz";
lights = "Luzes";
// Intensity of light
light.intensity = "Intensidade";
// Color of light
light.color = "Cor";
// Kelvin (the temperature unit)
light.kelvin = "Kelvin";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "Temperatura";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Conexão";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Fixa";
// The light will move along the camera
light.attachment.camera = "Câmera";
light.attachment.help = "• Fixa
A orientação da luz não mudará.

• Câmera
A orientação da luz dependerá da visualização da câmera.";
// Light type (directional, spot, point)
light.type = "Tipo";
// Directional light (synonym: sun light)
light.type.directional = "Direcional";
light.type.sun = "Sol";
// Directional light (synonym: sun light)
light.type.environment = "Ambiente";
light.type.hdri = "HDRI";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Spot";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Ponto";
// For directional light (angle jitter)
light.angle = "Ângulo";
// For point/spot light (offset jitter)
light.size = "Tamanho";
// Cone angle for spot angles
light.spot.angle = "Ângulo do cone";
// Softness of the spot light
light.spot.softness = "Suavidade";
// Position of the light
light.position = "Posição";
// Enable or disable shadows for a light
light.shadow.cast = "Sombra";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "A luz de ponto é compatível apenas com sombras no espaço da tela.";
light.shadow.type = "Tipo de sombra";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "Mapeamento de sombra";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "Espaço da tela";
light.shadow.type.screenspace.help = "Recurso experimental. Pode ser removido em um lançamento futuro.

Esta opção se destina ao uso com o recurso de suavidade da sombra.";
// Adjustment to fix artefacts
light.shadow.bias = "Propensão";
// How blurry the shadow is
light.shadow.softness = "Suavidade";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "Contato";
light.contact.help = "Se Automático for selecionado, apenas a luz mais dominante terá uma sombra de contato.";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "Tolerância";
// Activated the light
light.visible = "Mostrar";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Recentralizar";

// Object's material
material = "Material";
// See glossary
material.pbrRoughnessMetalness.warning = "Aspereza e Metalidade requerem o modo de sombreamento PBR.";
// See glossary
material.pbrReflectance.warning = "Reflexividade requer o modo de sombreamento PBR.";
// See glossary
material.pbrRefraction.warning = "Refração requer o modo de sombreamento PBR.";
// See glossary
material.pbrSubsurface.warning = "Subsuperfície requer o modo de sombreamento PBR.";
// Value that says how much light will change direction when hitting the surface
material.ior = "Índice de Refração";
// an object-level value that overrides the roughness interior/surface of the mesh
material.paintingOverride = "Substituir pintura";
// The roughness in the inside is turbidity
material.paintingOverride.help = "Há duas asperezas atuando juntas: uma que fica na superfície e outra no interior.

Mas como só há uma aspereza que pode ser pintada, as duas asperezas têm os mesmos valores.";
// Glossiness is simply the opposite of roughness
material.refraction.surface = "Superfície";
// Synonym: turbidity
material.refraction.interior = "Interior";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Brilhosidade da pintura";
material.paintGlossy.help = "Isto pintará o objeto com aspereza e metalidade de 0, o que permite uma refração nítida.

Essa ação é igual à acessar o menu de pintura e usar o recurso de pintar tudo com cor desativadas.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Absorção";
material.absorptionEnable.help = "Simule a luz sendo absorvida quando ela viaja através do volume.

As partes finas brilharão, já que deixam mais luz passar, enquanto as partes espessas serão mais escuras.

O efeito depende diretamente da forma do objeto; apenas uma aproximação da espessura do objeto é usada.";
material.absorptionFactor = "Fator";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "Profundidade";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "Translucidez";
material.translucency.help = "Você precisa de uma luz que projete sombras para ver translucidez.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Opacidade";
// Fully opaque material
material.type.opaque = "Opaco";
material.type.opaque.help = "Este é o tipo de material padrão.

O alpha do vértice pintado, a textura de opacidade ou o canal alpha do canal de cor ainda serão considerados através de dithering.

Apenas o controle deslizante principal de opacidade será ignorado.";
// Fully opaque material
material.type.shadowCatcher = "Sombras";
material.type.shadowCatcher.help = "Torne o objeto completamente transparente, exceto pelas sombras projetadas pelas luzes.

Este modo é geralmente usado na geometria plana.";
material.type.shadowCatcher.warning = "Não há luzes com sombras na sua cena, o Shadow Caster estará inativo.

Caso contrário, se o Shadow Catcher for totalmente metálico, ele pode refletir a cena se o Post Process de SSR (Reflexão) estiver ativado.";
// See glossary
material.type.subsurface = "Subsuperfície";
material.type.subsurface.help = "Para ter resultados melhores, alterne para o modo de sombreamento PBR e use ao menos uma luz direcional, idealmente com um ambiente escurecido.";
// Transparency mode, alpha blendingd
material.type.blending = "Mistura";
material.type.blending.help = "Ajuste o valor de opacidade para tornar o objeto semitransparente.

Devido às restrições de tempo real, artefatos podem ser notados se o objeto tiver uma forma complexa.";
// Transparency mode
material.type.additive = "Aditiva";
material.type.additive.help = "Ajuste o valor de opacidade para tornar o objeto semitransparente.

Este método tende a ter menos artefatos que o método Mistura, mas o objeto será mais claro.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Pontilhamento";
material.type.dithering.help = "Descarte alguns pixels aleatoriamente para tornar o objeto semitransparente.";
// Simulate glass-like material
material.type.refraction = "Refração";
material.type.refraction.help = "Este modo pode ser usado para simular material de vidro.

Devido às restrições de tempo real, a autorrefração e a refração multicamada são limitadas.";
material.castShadows = "Projetar sombras";
material.receiveShadows = "Receber sombras";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Sempre não iluminado";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Inverter culling";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Reflexividade";
material.reflectance.help = "Controle a quantidade de reflexo que o material (não metálico) receberá.

Na maioria das vezes, o valor padrão deve ser usado (que corresponde aos 4% padrão de luz refletida em ângulo normal).";
// Material preview in the viewport
material.preview = "Pré‑visualização da cor do material";
material.preview.help = "When you modify a material, a preview will be displayed in the viewport on the selected object.

The preview is shown while you interact with the color, roughness, metalness, opacity and intensity sliders.";
// Menu name
menu.files = "Arquivo";
// Menu name
menu.scene = "Cena";
// Menu name
menu.multires = "Multirres";
// Menu name
menu.voxel = "Voxel";
// Menu name
menu.dynamic = "TopoDin";
// Menu name (Synonym: Misc, Other)
menu.topology = "Diversos";
// Menu name
menu.primitive = "Primitiva";
// Menu name
menu.render = "Renderizar";
// Menu name
menu.material = "Material";
// Menu name
menu.postprocess = "Pós-processamento";
// Menu name
menu.camera = "Câmera";
// Menu name
menu.background = "Fundo";
// Menu name
menu.tool = "Ferramenta";
// Menu name
menu.stroke = "Traçado";
// Menu name
menu.alpha = "Alfa";
// Menu name
menu.filter = "Filtro";
// Menu name
menu.falloff = "Decaimento";
// Menu name
menu.paint = "Pintura";
// Menu name
menu.symmetry = "Simetria";
// Menu name
menu.operation = "Operação";
// Menu name (pencil pressure)
menu.pressure = "Pressão";
// Menu name
menu.gesture = "Gesto";
// Menu name
menu.layers = "Camadas";
// Menu name
menu.settings = "Ajustes";
// Menu name
menu.interface = "Interface";
// Menu name
menu.bindings = "Atalhos";
// Menu name
menu.history = "Histórico";
// Menu name
menu.historySettings = "Ajustes";
// Menu name
menu.about = "Sobre";
// Menu name
menu.debug = "Depurar";

// Operation on the object (action)
mesh.holes = "Furos";
// If the object has holes, the algorithm will close them
mesh.holes.close = "Fechar furos";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holes.detail = "Detalhe";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Separar";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "Camadas, pintura e multirresolução serão perdidas.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Resolução";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Forçar cúbico";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Converter";
// Static object means "static topology"
mesh.static = "Malha";
// See glossary
mesh.multires = "Multirresolução";
// Dynamic topology
mesh.dynamic = "TopoDin";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Material global";
paint.useGlobal.help = "Se esta opção for ativada, o material selecionado será o mesmo das outras ferramentas.

Note que isso só considera os ajustes de aspereza, metalidade e cor.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Pintura com traçado";
// If true save the textures data into
paint.preset.embed = "Incorporar texturas";
paint.preset.embed.help = "The textures can be found in the Nomad textures/ folder.
The material presets can be found in the Nomad materials/ folder.

When this option is off, the material preset only reference the texture inside the textures/ folder.

You can enable this option to make a copy of the textures inside the material preset.
It can be useful if you want to share a textured preset without providing the associated textures.";
paint.preset.embed.apply = "Apply to all materials";
// Factor/Opacity of paint tool
paint.intensity = "Intensidade da pintura";
// Apply the paint on the object
paint.paintAll = "Pintar tudo";
paint.paintAll.help = "Aplique o material atual ao objeto.";
paint.paintAll.help.mask = "Área mascarada não será afetada.";
paint.paintAll.help.hide = "Área oculta não será afetada.";
paint.paintAll.help.opacity = "Use o fator de pintura da ferramenta acima.";
paint.paintAll.help.layer = "Área não pintada de uma camada não será afetada.";
paint.strokePainting.title = "Pintura";
// Brush stroke texture
paint.texture.warningEnable = "A pintura com traçado precisa ser ativada para permitir a projeção de textura (opção na parte superior).";
paint.texture.warningIgnored = "A ferramenta atual não pode usar texturas!";
// use stencil mode
paint.stencil = "Estêncil";
// Inherit stroke falloff option for the painting
paint.tool.help = "Use a ferramenta alpha, falloff e randomizador para modular a intensidade do traço de pintura.

Essas opções são ignoradas para a funcionalidade de pintar tudo, mas o alpha é levado em consideração para a variante triplanar.";
// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "Novo nome";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "Novo valor";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "Nova cor (formato hex)";

// Post process effect
postprocess = "Pós-processamento";
// Denoise
postprocess.denoise = "Removedor de Ruído";
postprocess.denoise.help = "Aplicar uma passagem de remoção de ruído após acumular todos os quadros.";
postprocess.denoise.warning = "Esta é uma operação onerosa. Ative este efeito apenas se a imagem estiver com ruído.";
// Quality vs performance
postprocess.quality = "Qualidade";
postprocess.quality.help = "Ative estas opções para melhorar a qualidade em detrimento do desempenho.";
// More samples means better quality but slower performance
postprocess.maxSamples = "Máximo de amostras";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Resolução completa";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "Amostragem máxima de quadros";
postprocess.accumulateCount.help = "O número máximo de quadros acumulados antes de parar a renderização.

Quando a renderização parar, o Nomad não fará nada, o que economiza a bateria.

O acúmulo de quadros beneficia muitos recursos de renderização, dentre eles:
• Sombras Suaves
• Iluminação Global
• Reflexão (SSR)
• Oclusão Ambiente
• Subsuperfície
• Profundidade de Campo

Uma grande contagem de quadros é necessária na maioria das vezes para Sombras Suaves e Iluminação Global.
O Nomad pode parar a renderização antes se os recursos mencionados acima estiverem desativados.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Resolução da renderização";
postprocess.renderRatio.warning = "Substituído pelo efeito de Pixel Art.";
postprocess.renderRatio.help = "Esta opção afeta bastante o desempenho.
É recomendável manter um valor menor que x1.25.

Esta opção não é salva nos ajustes.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "Antisserrilhado (TAA)";
postprocess.taa.help = "Reduz a tremulação ao mover a câmera.";
// Ditherhing pixel
postprocess.dithering = "Pontilhamento";
postprocess.dithering.help = "Dissipar pixels para reduzir artefatos de banding.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "Reflexão (SSR)";
postprocess.ssr.warning = "SSR requer o modo de sombreamento PBR.";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "Iluminação Global (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "Tolerância";
postprocess.ssgi.warning = "SSGI requer o modo de sombreamento PBR.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "Oclusão Ambiente";
// How far the effect spreads
postprocess.ssao.radius = "Tamanho";
// How strong the effect is
postprocess.ssao.factor = "Intensidade";
// Adjustment to fix artefacts
postprocess.ssao.bias = "Propensão de curvatura";
postprocess.ssao.bias.help = "O quão sensível o efeito é, dependendo da curvatura da superfície.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "Profundidade de Campo";
// The blur factor behind the focused point
postprocess.dof.blurFar = "Desfoque longe";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "Desfoque perto";
postprocess.dof.focusTip = "Toque em um objeto para alterar o ponto de foco.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "Incandescência";
// Intensity of the effect
postprocess.bloom.intensity = "Intensidade";
// How far the effect spreads
postprocess.bloom.radius = "Raio";
postprocess.bloom.radius.help = "O quanto a incandescência se espalha.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "Limite";
postprocess.bloom.threshold.help = "O limite de luminosidade para decidir se um pixel emitirá ou não incandescência.
Se o valor for 0, tudo terá incandescência.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "Mapeamento de Tons";
postprocess.tone.exposure = "Exposição";
postprocess.tone.contrast = "Contraste";
postprocess.tone.saturation = "Saturação";
postprocess.tone.hue = "Matiz";
// No tonemapping operator is used
postprocess.tone.mapping.none = "Nenhum";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "Neutro";
// Color curves
postprocess.curve = "Gradação de Cores";
// Curve for pixel luminance
postprocess.curve.luminance = "Principal";
postprocess.curve.red = "Vermelho";
postprocess.curve.green = "Verde";
postprocess.curve.blue = "Azul";
// Reset color grading curves
postprocess.curve.resetAll = "Redefinir Tudo";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "Aberração Cromática";
postprocess.chromatic.factor = "Intensidade";
// Darking on the edges
postprocess.vignette = "Vinheta";
// How far the effect spreads
postprocess.vignette.size = "Tamanho";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "Dureza";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "Nitidez";
postprocess.sharpness.factor = "Intensidade";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "Granulação";
postprocess.grain.factor = "Intensidade";
// Accentuate the edges of the model
postprocess.curvature = "Curvatura";
// main strength of curvatre
postprocess.curvature.factor = "Fator";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "Cavidade";
// Color/Strength of convex curvature
postprocess.curvature.bump = "Protuberância";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "Pixel Art";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "Permitir amostragem de quadros";
// Simulate scanline rendering (horizontal line)
postprocess.scanline = "Linha de escaneamento";
postprocess.scanline.factor = "Fator";
// Spacing between lines
postprocess.scanline.spacing = "Espaçamento";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Primitiva";
primitive.box = "Caixa";
primitive.sphereCube = "Esfera Cubo";
primitive.sphereUV = "Esfera UV";
primitive.icosahedron = "Icosaedro";
primitive.cylinder = "Cilindro";
primitive.cone = "Cone";
primitive.torus = "Toro";
primitive.lathe = "Torno";
primitive.tube = "Tubo";
primitive.plane = "Plano";
primitive.triplanar = "Triplano";
primitive.needValidate = "As primitivas devem ser validadas!";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Editar";
primitive.edit.help = "Permite a edição 3D na janela de visualização.

Você pode desativar este recurso caso deseje interagir com o Gizmo ou a ferramenta Transformar sem modificar a primitiva.";

// Primitive configuration
primitive.mainConfig = "Parâmetro";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Topologia";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Geometria";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Validar";
// Maximum number of faces of the primitives
primitive.maxFaces = "Máximo de faces";
primitive.maxFaces.help = "O número máximo de faces que uma primitiva pode ter.

Este limite só fica ativado enquanto a primitiva não é validada. Depois disso, esta proteção é removida.";
// Synonym: Flat subdivision
primitive.linear = "Subdivisão linear";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Subdivisão posterior";

// Radius (of a sphere, torus, etc)
primitive.radius = "Raio";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radius.sync = "Mesmo raio";
primitive.radius.start = "Início do raio";
primitive.radius.end = "Fim do raio";
// Size (of cube x dimension)
primitive.size = "Tamanho";
primitive.sizeX = "Tamanho X";
primitive.sizeY = "Tamanho Y";
primitive.sizeZ = "Tamanho Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "Divisão";
primitive.divisionX = "Divisão X";
primitive.divisionY = "Divisão Y";
primitive.divisionZ = "Divisão Z";
// Angle of torus, etc
primitive.angleX = "Ângulo X";
primitive.angleY = "Ângulo Y";
primitive.angleZ = "Ângulo Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Densidade constante";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Projetar na esfera";
primitive.projectOnSphere.help = "Ajusta os pontos em uma esfera perfeita.";

// triplanar
primitive.triplanar.title = "Triplano";
primitive.triplanar.title.help = "O Triplano usa as informações de máscara de 3 planos para preencher uma grade de voxels que é então poligonizada.

Se você interagir com os controles de divisão ou tamanho, as informações de pintura serão redefinidas (a suavidade não).

É recomendável desativar a simetria, já que ela pode não funcionar conforme o esperado.

Você pode usar a opção “Topologia conectada” no painel de máscara para pintar um plano que afete os outros planos.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanar.sameSize = "Mesmo tamanho (cubo)";
primitive.triplanar.polish = "Suavidade";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanar.resetMask = "Redefinir máscara";
// One side of a cube (the back plane)
primitive.isolate.back = "Verso";
// One side of a cube (the right plane)
primitive.isolate.right = "Direita";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Inferior";
// Plane
primitive.planeSameSize = "Mesmo tamanho (quadrado)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "Disco";
// Box
primitive.boxRegular = "Mesmo tamanho (cubo)";
// Torus
primitive.torus.radiusOuter = "Raio externo";
primitive.torus.radiusInner = "Raio interno";
primitive.torus.angle = "Ângulo";
primitive.torus.angleOffset = "Deslocamento do ângulo";
// Cylinder
primitive.cylinder.height = "Altura";
// Cone
primitive.cone.radius = "Raio";
primitive.cone.height = "Altura";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Furo";
// Make a hole in the primitive to make it hollow
primitive.hasHole = "Tem furo";
// Curve profile (synonym: profile, curve)
primitive.profile = "Perfil";
primitive.profile.viewport = "Mostrar no viewport";
// If the revolution surface has caps (E.g: cylinder)
primitive.cap = "Tampa";

// Singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "Repetidor";
// All the new items will be inserted inside the bound rather than outside
repeater.array.fitInside = "Encaixar dentro";
// The object will follow the curve
repeater.curve.align = "Alinhar";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Importar...";
// iOS Photos gallery
resource.import.ios.photos = "Fotos";
// iOS Files App
resource.import.ios.files = "Arquivo";

scene.title = "Cena";
scene.title.help = "Ao usar os botões de visibilidade e seleção, toque e arraste o dedo para selecionar facilmente outros objetos.

Você também pode manter pressionados os botões de visibilidade e seleção para que os itens secundários também sejam afetados.";
// The view will focus on the item when we click on it
scene.focus = "UI: Focar no item ao tocar duas vezes";
// Add new object on gizmo position
scene.addOnGizmo = "No gizmo";
scene.addOnGizmo.help = "Mover o nó para a posição do gizmo (se a ferramenta gizmo estiver selecionada)";
// Select the gizmo tool after adding a new object
scene.addSelectGizmo = "Selecionar gizmo";
scene.addSelectGizmo.help = "Selecionar a ferramenta gizmo ao adicionar um novo nó";
// Icon size in pixel (min/max)
scene.iconSize = "Tamanho do ícone";
// Min size of icon
scene.iconSize.min = "Mín.";
// Max size of icon
scene.iconSize.max = "Máx.";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "Linhas de hierarquia";
scene.showHierarchy.help = "Exibir uma linha entre o pai e seus filhos no viewport.";
scene.showHierarchyNomadPivot = "Usar pivô do Nomad";
scene.showHierarchyNomadPivot.help = "O pivô do Nomad é o pivô usado pelas ferramentas de Transformação e Gizmo.

Se esta opção estiver desativada, ele usará o pivô de base natural.
Em alguns casos, esse pivô de base pode estar longe do centro do objeto!";
// The view will focus on the item when we click on it
scene.syncVisible = "Sincronizar visibilidade";
scene.syncVisible.help = "Quando ativado, usar o ícone visível (olho) afetará todos os itens selecionados.";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "Unir";
// Group the selected object with a new created Empty Node as a parent
scene.group = "Agrupar";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "Desvincular";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "Espelhar";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "Curva";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "Matriz";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "Radial";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "Repetidores";
scene.repeaters.help = "Nós repetidores que fazem instâncias de quaisquer geometrias abaixo deles na hierarquia da cena.";
// Validate button
scene.validateGroup = "Validar";
// Keep instances in the scene
scene.validateGroup.keepInstances = "Manter instâncias";
// If we should join children
scene.validateGroup.joinChildren = "Unir secundários";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Combinar voxels";
scene.voxelResolution = "Resolução";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Subtração: ocultar objeto";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Interseção: ocultar todos os objetos";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "Nenhum objeto selecionado. Selecione ao menos um objeto.";
// Need to select one object only
scene.noneButNeedOne = "Nenhum objeto selecionado. Selecione um objeto.";
// Need to select one object only
scene.onlyOneObject = "Vários objetos selecionados. Selecione apenas um objeto.";
// Boolean operation
scene.boolean = "Booleano";
scene.boolean.help = "Merge, subtract or intersect objects by performing a boolean operation.

The operation can fail if some objects are not manifold or not watertight.

If the boolean fails, you can always use the voxel remesher on the problematic object to ensure it's a watertight manifold.";
// Weld intersection
scene.boolean.mergeIntersection = "Soldar interseção";

// General scene display settings
settings.display.title = "Ajustes de exibição";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Armação";
// Display the material texture
settings.debugChannel = "Mostrar Textura";
// Display the material texture in the background
settings.debugChannel.onBackground = "Em Fundo";
// Display the material texture on the mesh
settings.debugChannel.onMesh = "Na Malha";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Dois lados";
settings.twoSided.help = "As faces poderão ser vistas de ambos os lados.";
// If we colorize the inverted side of faces
settings.backface.color = "Cor do verso";
// Color of the inverted side of faces
settings.backface.colored = "Verso colorido";
// Outline (contour highlight around the selected object)
settings.outline = "Contorno";
// Outline (contour highlight around the selected object)
settings.outline.help = "Os objetos selecionados serão contornados.";
settings.outline.thickness = "Espessura";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Cubo de ajuste";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "Inferior";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "Esquerda";
// Flip the camera (rotate 180° to see the other side)
settings.snapCube.flip = "Virar 180°";
settings.snapCube.flip.help = "Virar a vista se a vista já estiver alinhada.";
// Alignment (can be auto/on/off)
settings.snapCube.align = "Restringir alinhamento";
settings.snapCube.align.help = "Alinhar as vistas aos eixos do mundo. Se ativado, apenas 6 vistas de encaixe são possíveis.

Em Automático, a restrição ocorrerá apenas se a câmera estiver no modo Órbita.";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Estatísticas";
settings.stats.right = "Direita";
settings.stats.all = "Mostrar cena completa";
// Grid
settings.grid = "Grade";
settings.grid.divideThreshold = "Limite de divisão";
// Cursor
settings.cursor.title = "Cursor";
settings.cursor.whileSculpting = "Mostrar círculo ao esculpir";
// A small indicator dot
settings.cursor.showDot = "Mostrar ponto pequeno";
settings.cursor.showDot.help = "O ponto pode aparecer como ponto pivô da câmera ou enquanto você esculpe.";
settings.cursor.showRope = "Mostrar estabilizador de corda";
// indicator
settings.indicator.title = "Indicador";
settings.indicator.title.help = "Exibir um indicador visual (tutoriais, captura de tela, etc).";
settings.indicator.size = "Tamanho";
// Highlight (the object glows when we select it)
settings.highlight.selection = "Destacar seleção";
// Highlight settings
settings.highlight = "Destaque";
settings.highlight.duration = "Duração";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Escurecer objetos não selecionados";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Sombreamento suave";
// Experimental feature
settings.partialDraw = "Desenho parcial";
settings.partialDraw.help = "Recurso experimental!

Use se você estiver esculpindo uma parte relativamente pequena de uma malha com muitos polígonos.

Isto deve suavizar a escultura, mas você não deve ativar a armação!

Isto também pode adicionar artefatos ao traçar com o pincel.";
settings.partialDraw.warning = "Não se esqueça de desativar esta opção se os artefatos incomodarem muito!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Mostrar pintura";
// Show and use the masking on the mesh
settings.showMasking = "Mostrar máscara";
// Disable this option to force show the hidden faces
settings.showDiscard = "Usar Ocultar";
// Show icon on the canvas
settings.icon = "Ícone";
// Show icons on the canvas
settings.icons = "Ícones";
// Tooltip
settings.icons.help = "Mostre um ícone na tela para que você possa selecionar e editar diretamente.";
// Hole filling settings
settings.hole = "Preenchimento de furo";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Preenchimento não diverso";
settings.hole.nonManifold.help = "Tente preencher um furo de maneira não diversa.
Esta opção não é salva nos ajustes.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Contagem máxima de vértices";
settings.multires.maxVertices.help = "Como Nomad não verifica a memória antes de subdividir, uma alta contagem de polígonos pode levar facilmente a falhas.";
settings.multires.lowResVertices = "Limite de baixa resolução";
settings.multires.lowResVertices.help = "A malha pode exibir uma resolução mais baixa ao mover a câmera.

Você pode aumentar este valor caso deseje ter uma malha de resolução maior.";

// The main rendering mode
shading = "Sombreamento";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "Iluminar (PBR)";
shading.pbr.help = "Neste modo, você pode adicionar luzes (com sombras), junto com um ambiente HDR.

Você também pode pintar metalidade e aspereza, o que permite um controle mais preciso da aparência do material.";
// Fast rendering mode for sculpting purpose
shading.matcap = "MatCap";
shading.matcap.help = "A MatCap (captura material) lida com as informações de iluminação e do material em uma única imagem.

Este é um modo de renderização rápido, adequado na maioria das vezes à escultura bruta.";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "Não iluminar";
shading.unlit.help = "Modo de sombreamento de cor sólida, sem iluminação.";
// Helper rendering mode that display solid colors
shading.object = "Objeto ID";
shading.object.help = "Modo de renderização não iluminada onde cada objeto tem uma cor aleatória atribuída.

Útil na maioria das vezes quando há muitos objetos na cena.";
// Helper rendering mode that display solid colors
shading.instance = "Instanciar ID";
shading.instance.help = "Igual ao ID do Objeto, mas instâncias terão a mesma cor.";
// Helper rendering mode that display solid colors
shading.material = "ID de material";
shading.material.help = "Mostrar uma cor sólida para cada instância de material.";
// Randomize colors
shading.id.randomize = "Aleatorizar id";
shading.textures = "Usar texturas";
shading.textures.help = "No momento, não é possível criar ou editar texturas no Nomad.

Mas a importação de um arquivo com texturas deve funcionar.

— Texturas compatíveis
Opacidade: Iluminar, MatCap, Não iluminar
Normal: Iluminar, MatCap
Cor: Iluminar, Não Iluminar
Emissiva: Iluminar
Aspereza: Iluminar
Metalidade: Iluminar";
// Lights
shading.lights = "Luzes";
shading.lights.addLight = "Adicionar luz";
shading.lights.warning = "Luzes requerem o modo de sombreamento PBR.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Ambiente";
shading.environment.import = "Importar HDR";
shading.environment.exposure = "Exposição";
shading.environment.backgroundBlur = "Desfoque (fundo)";
shading.environment.rotation = "Rotação";
shading.environment.rotation.help = "Arraste 3 dedos horizontalmente na janela de visualização para girar o ambiente.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "Conectado à câmera";
shading.environment.attachedToCamera.help = "Conecte o ambiente à câmera.

Isto fará com que a iluminação seja consistente, o que pode ser útil para esculpir.";
shading.matcap.rotation = "Rotação";
shading.matcap.rotation.help = "Arraste 3 dedos horizontalmente na janela de visualização para girar a MatCap.";
shading.matcap.global = "Usar MatCap global";
shading.matcap.global.help = "Desmarque esta opção para usar uma MatCap diferente para esta malha em particular.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible = "Máscara";
shortcut.solo = "Solo";
shortcut.xray = "Raio-X";
shortcut.voxelRemesh = "Voxel";
shortcut.wireframe = "Armação";
shortcut.cameraReset = "Redefinir";
shortcut.cameraSnap = "Ajustar";
shortcut.lockSelection = "Bloquear";
shortcut.lockSelection.help = "Quando ativado, você não pode tocar em uma malha para alterar a seleção.";
shortcut.grid = "Grade";

// Memory taken by the scene
stat.ramScene = "Cena";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "VRAM da Cena";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "VRAM do Renderizador";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "VRAM das Texturas";
// Memory taken by the undo/redo history
stat.ramHistory = "Histórico";
// Memory taken by other stuffs
stat.ramOther = "Outros";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "Memória Usada";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "Memória Livre";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "Usada: $0";
stat.free = "Livre: $0";
stat.faces = "Faces";
stat.triangles = "Triângulos";
stat.vertices = "Vértices";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Quadrados";
stat.vertex = "Vértice";
stat.scene.face = "Faces da cena";
stat.scene.vertex = "Vértices da cena";

// Brush stroke
stroke = "Traçado";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "Raio da cena";
// The settings is shared among every tools
stroke.useWorldRadius.help = "Isto é compartilhado por todas as ferramentas.";
// Share the radius value among every tools.
stroke.useShareRadius = "Raio compartilhado";
stroke.useShareRadius.help = "Compartilhe o valor do raio entre todas as ferramentas.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.spacing = "Espaçamento do traçado";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.spacing.adjust = "Ajustar intensidade do espaçamento";
stroke.minSpacingAdjustIntensity.help = "Ajuste a intensidade do pincel para garantir uma deformação constante dependendo do espaçamento do traçado.";
stroke.minSpacing.help = "O espaçamento entre cada traçado, relativo ao raio da ferramenta.

Um valor mais baixo permitirá um traçado mais suave, mas o desempenho sofrerá degradação.";
// Brush stroke smoothing
stroke.lazySmooth = "Suavização do traçado";
stroke.lazySmooth.help = "Calcula uma média de várias posições do cursor para gerar um traçado mais suave.

Com valores altos, o traçado ficará para trás do cursor e o alcançará eventualmente.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Estabilizador de corda preguiçoso";
stroke.lazyRadius.help = "Os traçados ficarão para trás da posição do cursor de acordo com uma certa distância.

Isto pode ser usado para desenhar linhas suaves.";
// It is not a per-tool settings
stroke.globalSettings = "Este é um ajuste global";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Raio de ajuste";
stroke.snapRadius.help = "Ajuste o traçado se o cursor estiver perto do último traçado reconhecido.

Isto pode ser útil ao desenhar linhas longas e contínuas, intercaladas com pausas frequentes.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Deslocamento do traçado";
stroke.sculptOffset.help = "Aplique um deslocamento constante no traçado.

Esta opção serve para ajudar a usar o dedo em telas pequenas, para que ele não cubra o traçado.";
stroke.accumulate = "Acumular traçado";
stroke.accumulate.help = "Se esta opção for ativada, não existirá um limite na quantidade de matéria que você pode adicionar/remover por traçado.";
// The tool can use DynTopo
stroke.useDynamic = "Permitir topologia dinâmica";
// Only sculpt the part that are linked topologically
stroke.connect = "Topologia conectada";
stroke.connect.help = "Esta opção esculpirá apenas os vértices associados à superfície escolhida.

Normalmente, isto é usado para a ferramenta Mover, caso você queira mover exclusivamente uma parte que cruze com outra parte, por exemplo.";
stroke.connect.short = "Conectada";
// sculpt on hide or mask
stroke.protect = "Proteger área";
stroke.protect.hide.help = "Quando definido como automático, as faces ocultas serão editadas se a wireframe das faces ocultas estiver visível (veja o menu de wireframe).";
// Only sculpt the vertex that points toward the camera
stroke.culling = "Apenas vértice da face frontal";
stroke.culling.help = "Esta opção ignorará os vértices da face de trás.

Isto pode ser útil para pintar parte de uma geometria fina sem afetar o outro lado.

Isto também funciona para esculpir, mas alguns artefatos podem aparecer.";
// Infinite depth, move everything under the circle, disregarding depth
stroke.silhouette = "Silhueta";
stroke.silhouette.view = "Visualizar";
stroke.silhouette.snapped = "Se alinhado";
stroke.silhouette.closest = "Mais próximo";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.sameSide = "Apenas vértice do mesmo lado";
stroke.sameSide.help = "Ignore os vértices que apontam na direção oposta da deformação.";
// determine normal direction
stroke.normal.direction = "Direção";
stroke.normal.direction.help = "Relevante apenas se a deformação normal estiver habilitada.

Controla como o Nomad decide o sinal de deformação (empurrar vs puxar).";
stroke.normal.direction.normal = "Normal 3D";
stroke.normal.direction.normal.help = "Compara a posição XY do ponteiro com a normal projetada da superfície.";
stroke.normal.direction.screen = "XY";
stroke.normal.direction.screen.help = "Usa a posição XY da tela do ponteiro para decidir empurrar ou puxar.";
stroke.normal.direction.auto = "Auto";
stroke.normal.direction.auto.help = "Escolhe o método automaticamente com base no ângulo normal projetado.";
stroke.normal.direction.auto.threshold = "Limite";
stroke.normal.direction.auto.threshold.help = "Limite de ângulo comparado com a normal da superfície para decidir qual método é usado.";
// small tip/warning
stroke.onlyLasso = "Ajustes ativos somente para a ferramenta de laço.";

// Here sampling refers to the app gathering information under the mouse
stroke.area = "Amostragem de área";
stroke.area.help = "Algumas pinceladas ou opções de traço requerem um plano normal à superfície para funcionar.
Você pode controlar como calcular esse plano médio definindo a área de amostragem como uma proporção do raio da ferramenta.

A 100%, todos os pontos dentro do círculo de seleção são levados em conta.
A 0%, apenas o vértice ou triângulo mais próximo é levado em conta.";
// Sampling radius size (percent)
stroke.area.normal.radius = "Raio normal";
// Sampling radius size (percent)
stroke.area.point.radius = "Raio de posição";
// Sampling averaging
stroke.area.normal.average = "Média normal";
// Sampling averaging
stroke.area.point.average = "Média de posição";
// Keep sharp edges
stroke.normalFilter = "Filtro normal";
stroke.normalFilter.help = "
Filtro de profundidade";

// Only paint the part of the mesh above a certain height
stroke.depth.enable = "Máscara de profundidade";
stroke.depth.enable.help = "Excluir pontos que estão acima ou abaixo de uma certa distância do plano calculado (Amostragem de área).

Como exemplo, pode ser usado para pintar saliências ou cavidades.";
stroke.depth.offset = "Deslocamento de altura";
stroke.depth.falloff = "Decaimento de profundidade";
stroke.depth.max = "Área superior";
stroke.depth.min = "Área inferior";

// Invert the pixel (black <-> white)
stroke.alpha.invert = "Inverter pixels";
// Repeat the alpha image (pattern)
stroke.alpha.wrap = "Matrização";
// No repeat pattern
stroke.alpha.wrap.none = "Nenhum";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alpha.wrap.repeat = "Repetir";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alpha.wrap.mirror = "Espelhar";
// Tight fit when using tiling
stroke.alpha.fit = "Encaixar dentro";
stroke.alpha.fit.help = "This option is only relevant if the alpha and brushes textures are non square.

When enabled, each images will tile independently with no spacing.
You can disable this option if you want to keep the alpha and other images synchronized, in case their ratio are not the same.";
// Alpha rotation
stroke.alpha.rotation = "Rotação";
stroke.alpha.rotation.lock.help = "Bloqueie a orientação alfa.

Se a rotação estiver desbloqueada, a orientação seguirá a direção do traço em tempo real.";
// Repeat the image
stroke.alpha.tiling = "Matrização";
// Scale the image (make it bigger or smaller)
stroke.alpha.scale = "Dimensionamento";
stroke.alpha.scale.help = "No valor mínimo, o quadro alfa fica dentro do raio da ferramenta de círculo.";
// Middle-point value at which no deformation occurs
stroke.alpha.midValue = "Valor médio";
stroke.alpha.midValue.help = "Valor de ponto médio no qual nenhuma deformação ocorre.

(Valor médio = 0)
• Preto: sem deslocamento
• Branco: deslocamento positivo

(Valor médio = 0.5)
• Preto: deslocamento negativo
• Branco: deslocamento positivo

(Valor médio = 1)
• Preto: deslocamento negativo
• Branco: sem deslocamento";
// Synonymous: Scatter/Jitter/Randomize
stroke.jitter = "Randomizar";
// Sculpt and paint along the brush stroke at regular spacing
stroke.type.dot = "Ponto";
// Sculpt and paint along with alpha spaced by brush radius
stroke.type.roll = "Rolar";
// Sculpt and paint with alpha projected on screen stencil
stroke.type.tile = "Ladrilho";
// Sculpt and paint with alpha projected on 3 axis
stroke.type.triplanar = "Triplano";
// Sculpt continuously
stroke.type.drag = "Arrasto";
// Lock a region and move it around
stroke.type.grab = "Seguro";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.type.grabRadius = "Seguro • raio dinâmico";
// Lock a region and sculpt it by changing the tool intensity
stroke.type.grabIntensity = "Seguro • intensidade dinâmica";

stroke.falloffProject = "Influência";
stroke.falloffProject.help = "• Esfera (3d)
A influência é calculada tomando a distância do vértice até o centro do pincel.

• Círculo (2d)
O vértice é primeiro projetado no plano da área, antes de tomar sua distância até o centro do pincel.
Isso é semelhante a como os alfas são amostrados.";
stroke.falloffProject.sphere = "Esfera";
stroke.falloffProject.circle = "Círculo";
stroke.falloffProject.cylinder = "Cilindro";

// Symmetry
symmetry = "Simetria";
symmetry.enable = "Ativada";
symmetry.primitiveWarning = "A simetria de pincel está disponível apenas para primitivas validadas, com exceção do Triplano.";
symmetry.plane.title = "Planos";
symmetry.toolIgnore = "A ferramenta atual ignora a simetria.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Radial";
symmetry.radialX = "Radial X";
symmetry.radialY = "Radial Y";
symmetry.radialZ = "Radial Z";
// A warning indicating that we limit the number of repetitions ($0 is a number)
symmetry.limited = "Número de repetições limitado a $0!";
// Synonym: Offset
symmetry.offset.title = "Deslocamento";
symmetry.offsetX = "Deslocamento X";
symmetry.offsetY = "Deslocamento Y";
symmetry.offsetZ = "Deslocamento Z";
// Number of clones
symmetry.count.title = "Contagem";
symmetry.countX = "Contagem X";
symmetry.countY = "Contagem Y";
symmetry.countZ = "Contagem Z";
// method
symmetry.method = "Método:";
symmetry.method.help = "• Local
O plano de simetria será movido com a malha ao usar uma das ferramentas de transformação (Gizmo ou Transformar).

• Cena
O plano de simetria é fixo e não se move.";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.method.world = "Cena";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.method.local = "Local";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Virar objeto";
// Cut half of the mesh
symmetry.cut = "Cortar";
// after mirroring, separate into multiple output (synonym: split, separate)
symmetry.split = "Dividir";
// Reapply the mesh mirror, does not impact the topology
symmetry.mirror = "Espelho";
symmetry.mirror.help = "Tente reaplicar a simetria sem afetar a topologia.

A simetria radial será ignorada.

Se a topologia não puder ser mantida por não ser considerada simétrica, você terá a opção de aplicar o espelhamento.";
// indicate that applying the mirror will keep the mesh topology
symmetry.mirror.keepTopology = "mantém a topologia";
symmetry.mirrorFail = "Falha ao aplicar simetria.

Deseja espelhar a malha para aplicar simetria?";
symmetry.mirrorUseMasking = "Proteger área com máscara";
symmetry.mirrorUseMasking.help = "Mantenha intacta a área com máscara.

Esta opção será ignorada em topologias não simétricas (ou em superfícies desconectadas, como olhos).";
// Reset the symmetry plane position
symmetry.reset = "Redefinir";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Centro do objeto";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "Centro da cena";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Orientação";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Mostrar linha";
// Display the symmetry plane in 3D
symmetry.showPlane = "Mostrar plano";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Editar Gizmo";
symmetry.edit.warning = "A edição de simetria é experimental.";
symmetry.edit.help = "Você pode definir livremente o plano de simetria.

Este recurso é um pouco experimental e seu uso é desaconselhado.";

// Ideally short strings
tool.dynamic = "TopoDin";
// Ideally short strings (Symmetry)
tool.symmetry = "Simetria";
// Ideally short strings (Mirror primitive)
tool.mirror = "Espelhar";
// Ideally short strings
tool.clay = "Argila";
// Ideally short strings (Subtract)
tool.clay.sub = "Sub";
// Ideally short strings
tool.brush = "Pincel";
// Ideally short strings
tool.move = "Mover";
// Ideally short strings (Normal vector, perpendicular to surface)
tool.move.normal = "Normal";
// Ideally short strings
tool.drag = "Arrastar";
// Ideally short strings (Smooth the surface by erasing the details)
tool.smooth = "Suavizar";
// Ideally short strings (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Relaxar";
// Ideally short strings (Paint mask)
tool.mask = "Máscara";
// Ideally short strings
tool.mask.unmask = "Desmascara";
// Ideally short strings (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "MáscSel";
// Ideally short strings (Smudge the paint of the object)
tool.smudge = "Borrar";
// Ideally short strings (Flatten the surface)
tool.flatten = "Achatar";
// Ideally short strings (Flatten the surface, more strongly than Flatten)
tool.planar = "Planar";
// Ideally short strings (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Preencher";
// Ideally short strings (Layer brush)
tool.layer = "Camada";
// Ideally short strings
tool.crease = "Vincar";
// Ideally short strings (Cut part of the mesh cleanly)
tool.trim = "Aparar";
// Ideally short strings (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Dividir";
// Ideally short strings (Project part of the object onto a curve)
tool.project = "Projetar";
// Ideally short strings
tool.inflate = "Inflar";
// Ideally short strings
tool.pinch = "Apertar";
// Ideally short strings
tool.nudge = "Empurrar";
// Ideally short strings
tool.stamp = "Carimbo";
// Ideally short strings (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "ApagCamada";
// Ideally short strings (Select multiple objects with a lasso tool)
tool.select = "Selecionar";
// Ideally short strings (Rotate, Translate and Scale the object)
tool.gizmo = "Gizmo";
// Ideally short strings
tool.gizmo.editPivot = "Pivô";
// Ideally short strings (Snap angle)
tool.gizmo.rotateSnap = "Ajustar";
// Ideally short strings (Snap translation)
tool.gizmo.moveSnap = "Ajustar";
// Ideally short strings (Local/Relative space)
tool.gizmo.local = "Local";
// Ideally short strings (Align/Snap the gizmo to world axis)
tool.gizmo.align = "Alinhar";
// Ideally short strings (Pin the gizmo, so that it stays in place when switching between objects)
tool.gizmo.pin = "Fixar";
// Ideally short strings (Rotate, Translate and Scale the object)
tool.transform = "Transformar";
// Ideally short strings (Translate the object)
tool.transform.move = "Mover";
// Ideally short strings (Rotate the object)
tool.transform.rotate = "Girar";
// Ideally short strings (Scale the object)
tool.transform.scale = "Escala";
// Ideally short strings (Snap the object on another object surface)
tool.transform.snap = "Ajustar";
// Ideally short strings (Measure distance between 2 points)
tool.measure = "Medir";
// Ideally short strings (Lattice, deformer)
tool.lattice = "Grade";
// If an option is shared among the tools
tool.all = "Todos";
// Ideally short strings (Quad Remesher)
tool.remesh = "Remodelador Quad";
tool.remesh.guides = "Guias";
tool.remesh.density = "Densidade";
tool.remesh.same = "Same";
tool.remesh.half = "Half";
// Ideally short strings (FaceGroup)
tool.faceGroup = "Grupo de Faces";
tool.faceGroup.autoPick = "Escolha automática";
tool.faceGroup.flush = "Remover não utilizados";
tool.faceGroup.skip = "Ignorar pequenos grupos baseado em:";
tool.faceGroup.skipFace = "Contagem de faces";
tool.faceGroup.skipFace.help = "Não criar um novo grupo se o número de faces for inferior ou igual a esse limite.";
tool.faceGroup.skipArea = "Área de superfície";
tool.faceGroup.skipArea.help = "Não criar um novo grupo se a área de superfície do novo grupo for inferior a esse limite.

O limite é dado como percentagem da área total do objeto.";
// Ideally short strings (Hide)
tool.hide = "Ocultar";
// Ideally short strings (View tool, do nothing in particular)
tool.view = "Visualizar";
// Ideally short strings (Revolving surface along a line)
tool.lathe = "Torno";
// Ideally short strings (Revolving surface along a curve)
tool.tube = "Tubo";
// Ideally short strings (Insert object into the scene)
tool.insert = "Inserir";
// Ideally short strings (Flip/Invert/Negate the shape)
tool.shape.flip = "Virar";
// Ideally short strings (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "Visualizar";
// Ideally short strings (Lasso selection)
tool.shape.lasso = "Laço";
// Ideally short strings (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Curva";
// Ideally short strings (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Polígono";
// Ideally short strings (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Caminho";
// Ideally short strings (Rectangular selection)
tool.shape.rectangle = "Retângulo";
// Ideally short strings (Ellipse selection)
tool.shape.ellipse = "Elipse";
// Ideally short strings (Line selection, split the screen in half)
tool.shape.line = "Linha";
// Ideally short strings (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Fechado";

// Radius of the tool (size)
tool.radius = "Raio";
// Intensity of the tool (force)
tool.intensity = "Intensidade";

tool.settings = "Ajustes";
tool.settings.none = "Esta ferramenta não tem ajustes específicos.";

tool.crease.pinchFactor = "Força do apertar";
tool.crease.offsetFactor = "Fator de deslocamento";

tool.layer.removeInfluence = "Usar dados da camada";
tool.layer.removeInfluence.help = "Esta opção só é ativada quando há uma camada selecionada.

Ela usará os dados da camada para limitar o deslocamento sobre os traçados.";
tool.layer.noLayerSelected = "Esta opção só está disponível quando há uma camada selecionada";

tool.flatten.planeLockOrigin = "Bloquear origem do plano";
tool.flatten.planeLockNormal = "Bloquear direção do plano";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "Sincronizar";
tool.syncInstance.message = "O novo objeto será adicionado em todas as outras instâncias!";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Vértice persistente na borda";
tool.smooth.screen = "Suavização da tela";
tool.smooth.screen.help = "Use esta opção para obter uma suavização independente de topologia, mesmo em alta poligonalidade.";
tool.smooth.screen.samples = "Amostras da tela";
tool.smooth.stable = "Suavização estável";
tool.smooth.stable.help = "Tenta tornar a suavização independente da topologia.

Este modo funciona melhor com densidade de topologia variável e com alto valor de intensidade de suavização.";

tool.paint = "Pintura";
// Erase the painting
tool.paint.erase = "Apagar";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Filtro de camada";
tool.paint.layerFilter.help = "Use esta opção caso deseje apenas repintar uma área já pintada de uma camada.";

// Clear the painted mask
tool.mask.clear = "Limpar";
tool.mask.clearAll = "Limpar tudo";
// Invert the painted mask
tool.mask.invert = "Inverter";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Inverter conectada";
// Blur the painted mask
tool.mask.blur = "Desfocar";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Nitidez";
// Transform/Matrix
tool.matrix = "Matriz";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.target = "Destino";
// Automatic
tool.matrix.target.auto = "Auto";
tool.matrix.target.auto.help = "Por padrão, funciona de maneira similar à opção Grupo.
Se a malha tiver máscara ou a simetria estiver ativada, o funcionamento será igual a Vértice.";
// Auto apply the transform on the vertices
tool.matrix.target.vertex = "Vértice";
tool.matrix.target.vertex.help = "Tente aplicar a transformação nos vértices (não funciona em primitivas não validadas).
As instâncias também serão afetadas.";
// Transform the object alone (the children stands still)
tool.matrix.target.object = "Objeto";
tool.matrix.target.object.help = "Mova apenas o objeto, ignorando a simetria e a máscara.
Apenas o nó editado será movido, os secundários permanecerão parados.";
// Transform the object and its children
tool.matrix.target.group = "Grupo";
tool.matrix.target.group.help = "Mova o nó, ignorando a simetria e a máscara.
O restante da hierarquia também será transformado.";
// Operation on the mesh
tool.matrix.action = "Operação";
tool.matrix.action.origin = "Mover origem";
tool.matrix.action.origin.help = "Mova a malha para a origem da cena.";
tool.matrix.action.bake = "Selar";
tool.matrix.action.bake.help = "Aplique a matriz ao vértice e redefina a matriz. Visualmente, nada deve mudar.";
tool.matrix.action.reset = "Redefinir";
tool.matrix.action.reset.help = "Redefina a transformação da malha à identidade.";

// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "Cisalhamento";
tool.matrix.translation = "Translação";
tool.matrix.rotation = "Rotação";
tool.matrix.scale = "Escala";
tool.matrix.uniformScale = "Escala uniforme";

tool.transform.tip = "Toque simples com o segundo dedo para alternar modo";

// Size of the gizmo
tool.gizmo.size = "Tamanho do widget";
// If true, there is less spacing between gizmo handlers (rotate, scale, etc)
tool.gizmo.compact = "Compacto";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "Entrada numérica";
tool.gizmo.allowInput.help = "Permite a entrada numérica ao tocar em um widget do Gizmo.";
// Angle threshold
tool.gizmo.linearRollThreshold = "Limite de rolagem da tangente";
tool.gizmo.linearRollThreshold.help = "O limite do ângulo para escolher entre um método de rolagem linear ou circular.

Um valor acima deste limite usará a rolagem circular.

Caso prefira a rolagem linear (direção da tangente), defina este valor em 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Ocultar ao interagir";
tool.gizmo.tap = "Toque";
tool.gizmo.tap.help = "Esta opção só tem efeito no modo de pivô personalizado (Auto desativado).";
tool.gizmo.tap.none = "Nenhum";
tool.gizmo.tap.none.help = "Nada acontece ao tocar na malha.";
tool.gizmo.tap.normal = "Normal";
tool.gizmo.tap.normal.help = "Move the gizmo on the first intersection and align it according to the surface normal.";
tool.gizmo.tap.first = "Primeira ocorrência";
tool.gizmo.tap.first.help = "Mova o Gizmo na primeira interseção.";
tool.gizmo.tap.medial = "Meio corte";
tool.gizmo.tap.medial.help = "Mova o Gizmo na média das duas primeiras interseções.";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "Fixo";
tool.lathe.axisOnly = "Apenas eixo";
tool.lathe.stable = "Estável";
tool.lathe.axis = "Eixo";

// Fill the object's hole
tool.hole = "Preenchimento de furo";
tool.hole.fillHoles = "Preencher furos";
// synonym: Alternative method
tool.hole.method.fill = "Preencher";
tool.hole.method.legacy = "Legado";
tool.hole.method.boolean = "Booleano";
tool.hole.bridges = "Booleano de espaço da tela";
tool.hole.bridges.help = "Com esta opção ativada, você pode perfurar o volume.
A inclinação do corte também seguirá a forma do corte mais fielmente.";
tool.hole.threshold = "Épsilon limite";
tool.hole.threshold.help = "O ajuste deste valor pode ajudar no algoritmo de preenchimento de furo.";
tool.hole.smoothing = "Suavização do furo";

tool.smudge.quality = "Qualidade";
tool.smudge.quality.help = "Altere a resolução dos pixels projetados. Valores mais baixos geram traçados mais rápidos.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Forma";
// Auto-validate the drawn shape
tool.shape.autoValidate = "Auto-validar";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Quadrado";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Centralizado";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Círculo";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Centralizado";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Girar por grau";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Proporção áurea";
// volume of a mesh
tool.measure.volume = "Volume do mesh";
// Surface of a mesh
tool.measure.surface = "Superfície";

// Always display the camera shortcut buttons on the viewport
tool.view.stickyCamera = "Atalho da câmera (sempre)";

// Topology
topology = "Topologia";
// Synynom: detail value, density
topology.dynamic.detail = "Detalhe";
// See glossary
topology.multires = "Multirresolução";
topology.multires.help = "Mantenha várias resoluções de uma malha.

Se você fizer alterações em resoluções mais baixas, os detalhes das resoluções mais altas serão reprojetados ao alternar.

Camadas estão disponíveis em todas as resoluções.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "Inverter";
topology.multires.reverse.confirm = "Não foi possível criar a subdivisão base.

A topologia atual provavelmente não resulta de uma subdivisão.";
topology.multires.subdivide = "Subdividir";
topology.multires.subdivide.confirm = "A malha terá $0M de vértices, tem certeza?";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "Limite de subdivisão excedido, veja $0";
topology.multires.deleteLower = "Apagar mais baixa";
topology.multires.deleteHigher = "Apagar mais alta";
topology.multires.keepTriangles = "Manter triângulos";
topology.multires.lock = "Bloquear (LV0)";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "Nível Multires →";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "Nível Multires ←";
// Synonym: Flat subdivision
topology.multires.linear = "Subdivisão linear";
topology.multires.linear.help = "Simplesmente subdivida a malha, sem aplicar nenhuma suavização.";
// Only show the lowest resolution wireframe
topology.multires.minWireframe = "Apenas nível 0";
// Create a new object by recomputing a new topology
topology.remesh = "Remalhar";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Recriação da malha de voxels";
topology.voxel.help = "Tire uma amostra da malha em uma grade para recriar a malha.

Se o objeto não estiver fechado (à prova d’água), um algoritmo de preenchimento de furo será aplicado primeiro.

As camadas são reprojetadas depois de recriar a malha, mas a qualidade sofre degradação.";
topology.voxel.resolution = "Resolução";
topology.voxel.sharp = "Manter bordas pontiagudas";
topology.voxel.sharp.help = "Esta opção é útil na maioria das vezes para operações booleanas primitivas simples.

Ela introduzirá distorção em certas áreas devido ao ajuste dos pontos nas bordas.";
topology.voxel.subLevel = "Construir multirresolução";
topology.voxel.subLevel.help = "Você pode recriar uma hierarquia multirresolução a partir da saída da recriação da malha de voxels.

Isto também ajuda a executar mais rápido e usar menos memória, especialmente quando o valor de detalhes dos voxels é alto.

Mas se o valor de detalhes dos voxels for baixo e você estiver em busca de muitos níveis multirresolução, os detalhes serão perdidos.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Remalhar";
topology.surface.detail = "Detalhe";
topology.surface.detail.help = "Ao contrário da recriação da malha de voxels, a recriação da malha da superfície não requer que a malha esteja fechada.

Ela também é compatível com máscaras, de forma que você pode proteger certas partes da malha contra alterações de topologia.

As camadas são atualizadas corretamente.";
topology.surface.method = "Método";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Uniformização";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Subdivisão";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Dizimação";
topology.surface.method.help = "Comportamento da topologia dinâmica:
• Uniformização: adicione e remova detalhes
• Subdivisão: adicione detalhes
• Dizimação: remova detalhes";
topology.surface.useMasking = "Proteger área com máscara";
topology.surface.useMasking.help = "As áreas com máscaras protegerão a topologia contra alterações.";
topology.surface.extrapolate = "Extrapolação de vértice";
// DynTopo
topology.dynamic = "Topologia dinâmica";
topology.dynamic.global = "Ativar/desativar globalmente";
topology.dynamic.activate = "Ativada";
topology.dynamic.activate.help = "Com a topologia dinâmica, as ferramentas de escultura podem subdividir ou simplificar a malha localmente em tempo real.

Este recurso pode afetar perceptivelmente o desempenho.

As camadas são atualizadas corretamente.";
topology.dynamic.method = "Detalhe baseado em...";
topology.dynamic.method.screen = "Tela";
topology.dynamic.method.radius = "Raio";
topology.dynamic.method.constant = "Constante";
topology.dynamic.method.help = "/• Zoom
O nível de detalhe é baseado na distância que você está superfície.

• Raio
A ferramenta de raio define a quantidade de detalhes.

• Constante
O detalhe é fixo e o valor de detalhe também é compartilhado com o controle de voxel.";
topology.dynamic.quality = "Preferir...";
topology.dynamic.quality.help = "Caso escolha Qualidade, as 2 principais diferenças são:
• O refinamento é aplicado antes do operador de escultura; você terá menos artefatos ao pintar ou esculpir com detalhes minúsculos
• O refinamento não é aplicado incrementalmente; se você esculpir detalhes minúsculos ou fizer traçados rápidos, a topologia sempre será refinada corretamente";
topology.dynamic.quality.speed = "Velocidade";
topology.dynamic.quality.quality = "Qualidade";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Usar pressão no raio";
topology.dynamic.usePressure.help = "Use esta opção caso deseje que a pressão da caneta na ferramenta de raio afete o nível de detalhe.";
topology.dynamic.useFalloff = "Usar decaimento do traçado";
// Decimate
topology.decimate.title = "Dizimação";
topology.decimate.title.help = "Tente manter o máximo possível de detalhes ao reduzir o número de polígonos.

Este recurso pode ser útil caso deseje exportar para impressão 3D.

Mas não o use caso deseje continuar esculpindo, já que isso pode produzir triângulos desnivelados.

Note que a área com máscara não será dizimada.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Dizimar";
topology.decimatePaintWeight = "Preservar pintura";
topology.decimatePaintWeight.help = "Valores mais altos tentarão preservar a pintura.

Defina este valor em 0 caso a pintura seja irrelevante.";
topology.decimateUniform = "Faces uniformes";
topology.decimateUniform.help = "Valores mais altos gerarão triângulos de tamanhos similares.";
topology.decimatePreserveBorders = "Preservar bordas";
topology.decimatePreserveBorders.help = "Não decimar a borda da malha.";
// Target a certain number of triangles, faces and vertices
topology.target.triangles = "Triângulos são destino";
topology.target.faces = "Faces alvo";
topology.target.quads = "Quadrados alvo";
topology.target.points = "Pontos alvo";
// Quad remesher
topology.qremesh = "Remalhar em Quads";
topology.qremesh.angle = "Ângulo de vinco";
topology.qremesh.border = "Preservar bordas";
topology.qremesh.onlyQuad = "Apenas quads";
topology.qremesh.hole = "Máximo preenchimento de buraco";
topology.qremesh.hole.help = "
Cálculo de UV";

// Unwrapping means compute UV (texture coordinates), with uvs you can appliy (wrap) a texture onto the model
topology.uv.title = "Cálcular UV";
// UV Unwrap but as a Verb
topology.uv.unwrap = "Cálcular";
// The operation can be very slow
topology.uv.atlas.warning = "Pode ser muito lento. Use menos de 100k vértices como destino.";
// Handles are topological holes (synonym: genus, hole)
topology.uv.bff.warning = "Pode ter sobreposições se a malha tiver alças.";
// Solo patch
topology.uv.bff.seamless = "Remendos Sem Costura";
topology.uv.bff.seamless.help = "Esta opção pode introduzir uma distorção importante.

Tipicamente, pode ser usada quando grupos de faces são configurados cuidadosamente.";
// Synonym: Point count? Singularity count ?
topology.uv.bff.cones = "Contagem de cones";
topology.uv.bff.help = "Valores mais altos reduzirão a distorção de objetos complexos.

Valores mais altos levarão mais tempo para calcular.";
topology.uv.delete = "Apagar UVs";

// Transfer the vertex painting in the texture, bake means "create texture (from mesh data)"
topology.bake.title = "Selar";
// Bake here means "create texture (from mesh data)"
topology.bake.title.help = "A criação de texturas por baking irá criar texturas projetando outros objetos visíveis na cena.

Aqui está o fluxo de trabalho típico para baking:
• Você tem uma malha com detalhes finos e pintura
• Clone-a
• Decime-a (defina `Preservar pintura` para 0!)
• Desembrulhe-a (UV unwrap)
• Faça o baking!

Você agora deve ter uma malha de baixa resolução que retém a maioria da pintura e detalhes do seu objeto anterior.

Após a operação, as cores dos vértices serão movidas para uma nova camada desativada, para que sejam ignoradas em vez de serem multiplicadas contra a textura colorida.

Para escolher quais objetos são usados para baking, a seguinte lógica será aplicada:
- todos os objetos selecionados usados e o objeto principal selecionado serão baked (maior destaque no menu da cena)
- se houver apenas um objeto selecionado, o Nomad considerará todos os objetos visíveis em vez disso 
- caso contrário, se todos os objetos estiverem ocultos (por exemplo, ao usar Solo), então toda a cena será levada em consideração";
// Bake here means "create texture (from mesh data)"
topology.bake.self = "De si mesmo";
// Bake here means "create texture (from another mesh data)"
topology.bake.other = "De alta resolução";
topology.bake.resolution = "Resolução";
// Cage is a specific term, synonyom: "Bake offset"
topology.bake.offset = "Offset de raio";
topology.bake.radius = "Raio da gaiola";
// Bake opacity (from mask data)
topology.bake.opacityFromMask = "Máscara -> Opacidade";
topology.bake.backup = "Backup";

// project a high resolution mesh details onto another
topology.reproject.title = "Reprojetar";
topology.reproject.title.help = "Projetar detalhes esculpidos, pintura e camadas dos objetos visíveis mais próximos.

Isso é geralmente usado também em uma malha de alta resolução, tipicamente com uma topologia limpa.";
// tweaking value
topology.reproject.rayBias = "Viés do raio";
topology.reproject.rayBias.help = "Dois métodos são usados para a reprojeção:
• mais próximo: o ponto mais próximo na superfície
• raio: ponto de interseção através da direção normal

Valores de viés mais altos favorecerão a interseção de raio em vez da superfície mais próxima.";
topology.reproject.normalOffset = "Deslocamento normal";
topology.reproject.shpereCast = "Fallback de lançamento esférico";
topology.reproject.shpereCast.help = "Se a reprojeção de raio normal falhar, o Nomad recorrerá à intersecção da superfície mais próxima.";
// number of iteration the algorithm will take
topology.reproject.iterations = "Iterações";
topology.reproject.relax = "Relaxar";
topology.reproject.relax.help = "Relaxar deve ser preferido quando a malha é de baixo poli.";
topology.reproject.layers.help = "Transferir outras camadas para a malha selecionada.";

topology.manifold = "Manifold";
topology.nonManifold = "Não-manifold";
topology.manifold.clean = "Limpar";
topology.manifold.collapse = "Excluir pequenas faces";
topology.manifold.title = "Forçar Manifold";
topology.manifold.title.help = "Tenta limpar aresta não manifold.

Pode ser útil para softwares externos que não suportam arestas que têm mais de 2 faces em comum.";

// Reset key-bindings/shortcuts
binding.reset = "Redefinir vínculos";
// Add node in a sync mode (synchronize instance)
binding.addSync = "Sincronizar";
binding.addSync.help = "Por padrão, será usado o valor de sincronização definido no menu de cena.";
// Binding option
binding.context.toggle = "Alternar contexto";
// quick sidebar tool shortcuts
binding.quicks = "Atalhos rápidos";
// quick regular tool shortcuts
binding.tools = "Atalhos de ferramentas";
// When the key is tapped once, the value will be toggled
binding.toggle = "Alternar ferramenta anterior";
binding.toggle.help = "Use a mesma combinação para voltar à última ferramenta.";
// sticky keys
binding.sticky = "Teclas fixas";
binding.sticky.off = "Segurar";
binding.sticky.off.help = "Segure a tecla para usar a ferramenta, solte para retornar à ferramenta anterior.";
binding.sticky.on = "Alternar";
binding.sticky.on.help = "Pressione uma vez para alternar ferramentas.";
binding.sticky.quick = "Pressão rápida";
binding.sticky.quick.help = "Segure para usar temporariamente, pressione rapidamente para alternar.";
// The binding force camera movement
binding.forceCamera = "Forçar câmera";
binding.forceCamera.help = "Forçar a interação da câmera em caso de conflito com outra ligação.

Isso pode acontecer tipicamente se a mesma ligação for atribuída a um atalho de ferramenta ou Adicionar/Subtrair.";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickMaterial = "Seletor de Material";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickFaceGroup = "Escolher Grupo de Faces";
// Edit the tool brush size/radius
binding.editRadius = "Raio da Ferramenta";
// Inverse direction zooming
binding.invertZoomY = "Inverter o zoom Y";
// Edit the tool brush size/radius
binding.editIntensity = "Intensidade da Ferramenta";
// Controller dead zone
binding.joystick = "Joystick";
binding.controller.deadZone = "Zona morta do controle";
binding.controller.deadZone.help = "Aumente este valor se a câmera estiver se movendo mesmo que o stick do controle não seja tocado.";
// Snap the camera
binding.view.front = "Vista Frontal";
binding.view.left = "Vista Lateral";
binding.view.top = "Vista Superior";
// Move/Translate the view
binding.pan.left = "Deslocar para Esquerda";
binding.pan.right = "Deslocar para a Direita";
binding.pan.forward = "Deslocar para a Frente (Visualização";
binding.pan.backward = "Deslocar para Trás (Visualização";
binding.pan.up = "Deslocar para Cima (Visualização";
binding.pan.down = "Deslocar para Baixo (Visualização";
// Snap the view (while rotating)
binding.snapViewOnRotate = "Ajustar visualização (ao girar)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "Abrir (projeto)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "Adicionar (projeto)";
// Select all the objects in the scene
binding.selectAll = "Selecionar Tudo";
// Rotate environment and the lighting
binding.rotateLighting = "Girar iluminação";
// The Camera pivot is the point around which the camera rotates
binding.updatePivot = "Pivô";

quadremesh.adaptQuadCount = "Contagem Adaptativa de Quads";
quadremesh.curvatureAdaptivness = "Tamanho Adaptativo";
quadremesh.curvatureAdaptivness.help = "A 100%, o tamanho dos quads variará dependendo da curvatura do objeto, permitindo quads menores em alta curvatura.
A 0%, o tamanho dos quads será uniforme.";
quadremesh.useVertexColors = "Preservar pintura";
quadremesh.autoDetectHardEdges = "Detectar Automaticamente Bordas Duras";
quadremesh.autoDetectHardEdges.short = "Luz Forte";
quadremesh.reprojectVertex = "Reprojetar Vértice";
quadremesh.reprojectVertex.short = "Reprojetar Vértice";
quadremesh.reprojectVertex.label = "Quando ativado, Nomad reprojetará a posição no mesh anterior.

Note que se o mesh tiver layers, a reprojeção será sempre usada.";

// Privacy policy
privacyPolicy.title = "Política de Privacidade";
privacyPolicy.reject = "Rejeitar";
// Hexanomad is the company name
privacyPolicy = "O Hexanomad não coleta nenhum dado do Nomad Sculpt.";

sonar.disconnect = "Desconectar SonarPen";
sonar.connect = "Conectar SonarPen";
sonar.connect.confirm = "Conectar SonarPen?";
sonar.connect.confirm.warning = "Sonar Pen usará o microfone (retorno de áudio) para detectar a pressão da caneta.";

// Color disc mode
widget.color.disc = "Disco";
widget.color.ring = "Anel";
widget.color.square = "Quadrado";

nomad.mainFolder = "Pasta principal do Nomad";
nomad.mainFolder.warning = "Os arquivos são deixados intactos.
Eles não são copiados, excluídos ou movidos.";
nomad.mainFolder.error = "Depois de selecionar sim, o Nomad será fechado e você poderá simplesmente reiniciá-lo.";

license.title = "Licença";
license.retry = "Tentar novamente";
license.key = "Chave de licença";
license.activate = "Ativar licença";
// ----------------------------------------------
license.newest = "Nova versão disponível!";
license.encrypt.error = "Não foi possível criptografar!";
// ----------------------------------------------
license.grace = "Offline - Período de carência restante:";
license.grace.hours = "horas";
license.grace.days = "dias";
// ----------------------------------------------
license.portal.title = "Usuários existentes";
license.portal.label = "Portal de licença";
// ----------------------------------------------
license.checkout.title = "Novos usuários";
license.checkout.label = "Comprar Nomad";
// ----------------------------------------------
license.device.error = "Não foi possível obter o identificador do dispositivo.";
license.device.mismatch = "Identificador de dispositivo incompatível!";
// ----------------------------------------------
license.error429 = "Muitas solicitações (aguarde).";
// ----------------------------------------------
license.validate.error404 = "A chave de licença não foi encontrada.";
license.validate.error422 = "Entidade não processável.";
// ----------------------------------------------
license.activate.error403 = "Número máximo de dispositivos atingido!
Você pode desativar outro dispositivo no seu portal de licença.";
license.activate.error404 = "A chave de licença não foi encontrada.";
license.activate.error422 = "Entidade não processável.";
// ----------------------------------------------
// version
version.update = "Atualização disponível!";
version.restore = "Restaurar compra";
version.buyWeb = "A versão da web é apenas uma demonstração";
version.buyFull = "Mudar para versão completa";
// ----------------------------------------------
// QuadRemesh
version.qr.unlock = "Desbloquear (compra, restaurar, teste)";
version.qr.desktop = "No desktop, o QuadRemesher é distribuído pela Hexanomad, mas a Hexanomad não lida com vendas ou licenciamento.
Todo gerenciamento de licença é realizado pela Exoside.";
version.qr.buy = "Compra";
version.qr.promo = "
O Quad Remesher é um algoritmo que gera uma malha predominantemente de quads.
A distribuição dos quads tentará acompanhar a curvatura natural do objeto.

O algoritmo também pode adaptar o tamanho dos quads dependendo da curvatura local.

Você também pode guiar a topologia resultante com:

• Grupo de Faces $0 (certifique-se de suavizar suas bordas para um melhor resultado!)

• Simetria Plana X/Y/Z $1

• Guias de Curvas $2

• Pintura de Densidade $3

O Quad Remesher é desenvolvido por https://exoside.com/.";
// ----------------------------------------------
version.trialLayer = "Versão de avaliação: 1 camada por malha";
version.trialNoExport = "Versão de avaliação: proibido exportar";
// ----------------------------------------------
version.fullFeatures = "• Compra única
• Desfazer/refazer ilimitado
• Camadas ilimitadas
• Exporte e importe";
// ----------------------------------------------
version.demo.purpose = "Esta versão foi criada somente para fins de demonstração.";
version.demo.disable = "Recurso não habilitado para esta demonstração.";
// ----------------------------------------------
version.demo = "Teste de Demonstração";
version.demo.sculpt = "Esculpir";
version.demo.sculpt.help = "Todos os pincéis estão disponíveis, mas você não pode salvar ou exportar.

Este modo é principalmente para experimentar com os pincéis ou testar suporte à pressão.

Outras funcionalidades também podem ser limitadas (histórico, camadas).";
version.demo.file = "Importação & Exportação";
version.demo.file.help = "Você pode importar e exportar modelos, mas os pincéis de escultura estão desativados.

Este modo é mais útil para usuários de dispositivos móveis que não conseguem abrir grandes projetos .nom devido à limitação de memória móvel.";
// ----------------------------------------------
// app store main page
store.name = "Nomad Sculpt";
store.headline = "Esculpir, pintar e criar em 3D";
store.tag = "sculpt, 3d, nomad, paint, modeling, esculpir, pintar, modelagem";
// ----------------------------------------------
store.description.sculpt = "• Ferramentas de escultura
Argila, achatamento, suavização, máscara e muitas outras pinceladas permitirão que você modele sua criação.
Você também pode usar a ferramenta de corte booleana com laço, retângulo e outras formas, para fins de superfície dura.";
// ----------------------------------------------
store.description.stroke = "• Personalização de traço
A queda de intensidade, alfas, padronagens, pressão do lápis e outros parâmetros de traço podem ser personalizados.
Você pode salvar e carregar o seu preset de ferramentas também.";
// ----------------------------------------------
store.description.paint = "• Ferramentas de pintura
Pintura de vértices com cor, rugosidade e metalicidade.
Você pode gerenciar facilmente todos os seus predefinições de material também.";
// ----------------------------------------------
store.description.layer = "• Camadas
Registre suas operações de escultura e pintura em camadas separadas para uma iteração mais fácil durante o processo de criação.
Tanto as alterações de escultura quanto de pintura são registradas.";
// ----------------------------------------------
store.description.multires = "• Escultura Multirresolução
Vá e volte entre várias resoluções da sua malha para um fluxo de trabalho flexível.";
// ----------------------------------------------
store.description.voxel = "• Remalhamento de Voxel
Remalhe rapidamente sua malha para obter um nível uniforme de detalhes.
Pode ser usado para esboçar rapidamente uma forma aproximada no início do processo de criação.";
// ----------------------------------------------
store.description.dynamic = "• Topologia dinâmica
Refine localmente sua malha sob o pincel para obter um nível automático de detalhe.
Você pode até manter suas camadas, pois elas serão atualizadas automaticamente!";
// ----------------------------------------------
store.description.topology = "• Dizimar
Reduzir o número de polígonos mantendo o máximo de detalhes possível.";
// ----------------------------------------------
store.description.group = "• Grupo de Faces
Segmente sua malha em subgrupos com a ferramenta de grupo de faces.";
// ----------------------------------------------
store.description.unwrap = "• Desembrulho UV automático
O desembrulhador UV automático pode usar grupos de faces para controlar o processo de desembrulho.";
// ----------------------------------------------
store.description.baking = "• Cozimento
Você pode transferir dados de vértices como cor, aspereza, metalicidade e detalhes em pequena escala para texturas.
Você também pode fazer o oposto, transferindo dados de texturas para dados de vértices ou camadas.";
// ----------------------------------------------
store.description.primitive = "• Forma primitiva
Cilindro, toro, tubo, torno e outras primitivas podem ser usadas para começar rapidamente novas formas do zero.";
// ----------------------------------------------
store.description.rendering = "• Renderização PBR
Renderização PBR linda por padrão, com iluminação e sombras.
Você sempre pode alternar para matcap para um sombreamento mais padrão para fins de escultura.";
// ----------------------------------------------
store.description.postprocess = "• Pós-processamento
Reflexão de Espaço de Tela, Profundidade de Campo, Oclusão Ambiental, Mapeamento de Tons, etc";
// ----------------------------------------------
store.description.files = "• Exportação e Importação
Formatos suportados incluem arquivos glTF, OBJ, STL ou PLY.";
// ----------------------------------------------
store.description.interface = "• Interface
Interface de fácil utilização, projetada para a experiência móvel.
A personalização também é possível!";
// ----------------------------------------------
store.description.remesher = "• Quad Remesher (compra dentro do aplicativo separadamente)
Refaz a malha do seu objeto automaticamente com uma malha dominante de quads que segue as curvaturas da malha.
Suporta guias, grupos de faces e pintura de densidade.";
// ----------------------------------------------