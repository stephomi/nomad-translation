// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "Confirmar?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Sim";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "OK";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Cancelar";

// Name of an item (object, tool, etc)
item.name = "Nome";
// Add a new item (object, tool, etc)
item.new = "Novo";
// Rename an item (object, tool, etc)
item.rename = "Renomear";
// Add a new item (object, tool, project, etc)
item.add = "Adicionar";
// Save an item (object, tool, etc)
item.save = "Salvar";
item.save.confirm = "Confirmar salvamento?";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Último salvamento";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "Carregar último salvamento?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Redefinir";
item.reset.confirm = "Confirmar redefinição?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "Instanciar";
// Uninstance the object, make the object real
item.uninstance = "Desinstanciar";
// Clone an item (object, tool, etc)
item.clone = "Clonar";
// Delete an item (object, tool, etc)
item.delete = "Apagar";
item.delete.confirm = "Confirmar apagamento?";
item.delete.confirm.yes = "Sim, apagar";
// When we delete the item but the image is used somewhere
item.delete.imageUsed = "Usado pelas seguintes ferramentas:";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "Em Nó";
// Item visibility (object, layer, etc)
item.visible = "Visível";
// Show an item (object, layer, etc)
item.show = "Mostrar";
// Hide an item (object, layer, etc)
item.hide = "Ocultar";
// Select an item (object, layer, etc)
item.select = "Selecionar";
// Unselect an item (object, layer, etc)
item.unselect = "Desmarcar";
// Merge an item with another one below (layer)
item.mergeDown = "Combinar abaixo";
// The order of an item in a list
item.order = "Ordem";
// Focus on previous item
item.previous = "Anterior";
// Focus on next item
item.next = "Seguinte";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "Bloquear";

// Three-state toggle button (Auto, Off, On)
toggle.on = "Ativar";
// Three-state toggle button (Auto, Off, On)
toggle.off = "Desativar";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "Auto";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Miniaturas faltando. Reprocessando arquivos… ($0/$1)

$2";
loading.reprocess.cancel = "Skip thumbnails generation?";

// Color of an object
material.color = "Cor";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "Aspereza";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "Brilhosidade";
// Whether the material is a metal or not
material.metalness = "Metalidade";
// How much light a surface will reflect
material.specular = "Especular";
// Light that the surface can emit (glow)
material.emissive = "Emissiva";
// Normal map (synonym: detail, bump)
material.normal = "Normal";
// Ambient Occlusion (AO)
material.occlusion = "Oclusão";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "Texturas";

// Minify
about.minify = "Mini IU";
about.minify.help = "Você também pode tocar na tela com 4 dedos, se isso for compatível com o dispositivo.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Mesa Giratória";
// Make the entire scene turn around (speed of the animation)
about.turntableSpeed = "Velocidade da Mesa Giratória";
// Stuffs that I used to make the app
about.credits = "Créditos";
// Link to open source projects that I used for the app
about.credits.openSource = "Código Aberto";
// Only translate the &
about.credits.arts = "MatCaps e HDRIs";
// Change languages of the app
about.languages = "Idiomas";
about.languages.help = "Arquivos de tradução disponíveis em $0";
// Link to the App Website
about.website = "Site";
// Link to the App Forum
about.forum = "Fórum";
// Link to the App Manual
about.manual = "Manual";
// Link to the App Email
about.mail = "Suporte";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";

// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "O objeto não tem furos!";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "O objeto atual está invisível!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Nada para recortar.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Abortar recorte: o objeto está totalmente recortado.";
// In order to extract something, the mesh needs to have painted mask
alert.mask.noExtract = "Nada para extrair!";
// In order to split something, the mesh needs to have painted mask
alert.mask.noSplit = "Nada para dividir!";
// List of disabled features when View Mode is selected
alert.view.disabled = "Recursos desativados no Modo Visualização:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Widgets primitivos";
// The object needs to have two parts disconnected
alert.separate.fail = "Não foi possível separar: o objeto só tem uma parte!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "Malha recriada!";
alert.voxelRemesh.empty = "Abortar recriação da malha: a malha resultante não tem faces.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "Entrada inválida!";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "O objeto será duplicado";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "O objeto será instanciado";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Edite o modo do pivô.";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "Edite o modo do objeto.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Dynamic topology ON";
// See Glossary (DynTopo)
alert.dynamic.disable = "Dynamic topology OFF";
alert.colorPicker = "Arraste o dedo sobre o objeto para selecionar uma cor.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Dê um único toque para sair do modo transformar.";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "Simple tap to exit edit symmetry mode.";
alert.view.reset = "Redefinir visualização";
// Snap the view to the nearest aligned 90° angle
alert.view.snap = "Ajustar visualização";
// Show the painted mask on the mesh
alert.mask.show = "Mostrar máscara";
// Hide the painted mask on the mesh
alert.mask.hide = "Ocultar máscara";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Bloquear seleção";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Desbloquear seleção";
// Hide the objects that are not selected
alert.selection.isolate = "Isolar seleção";
// Show the objects that are hidden
alert.selection.showAll = "Mostrar tudo";
// Project quick saving
alert.quickSave = "Salvando...";
// Painting on the object was hidden but the user did paint the object
alert.forceShowPainting.fill = "Mostrar pintura ativado, [Pintar tudo] foi usado.";
// Painting on the object was hidden but the user started to paint on the object
alert.forceShowPainting.tool = "Mostrar pintura ativado, o objeto foi pintado.";
// See Glossary (Multiresolution)
alert.multiresLost = "A multirresolução será perdida!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "O valor do detalhe está alto e pode exigir muita memória!";
// Autosave popup
alert.autoSave.auto = "Salvamento automático em... $0s";
// The selected object doesn't have any layers
alert.needLayer = "A ferramenta atual requer uma camada ativa.";
// The user decides to hide the painting on the objects
alert.paintingHidden = "Pintura oculta: mostre-a novamente no painel de Ajustes.";
// The selected object doesn't have any layers
alert.noPartialWireframe = "O desenho parcial está desativado enquanto a armação é exibida.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Considere o uso de uma câmera ortográfica para evitar a distorção de perspectiva do campo de visão ao usar um projetor.";
// Trial version has a limited number of undo
alert.state.trial = "Versão de avaliação: desfazer cancelado";

background = "Fundo";
// A flat color will be displayed in the background of the scene
background.color = "Cor";
// The environment (HDRI) will be displayed in the background
background.environment = "Ambiente";
background.blur = "Desfoque";
background.exposure = "Exposição";

// Image that the artist uses as a reference
background.imageEnable = "Imagem de referência";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Sobrepor";
// Opposite of transparency (Alpha)
background.imageAlpha = "Opacidade";
background.imageReset = "Redefinir ajustes";
background.imageTransform = "Transformar";
// X screen coordinate of the image reference
background.imageX = "Posição X";
// Y screen coordinate of the image reference
background.imageY = "Posição Y";
// Rotation of the reference image
background.imageRotation = "Rotação";
// Scale of the reference image
background.imageScale = "Escala";

// Camera (point of view in 3d)
camera = "Câmera";
// Copy the views
camera.updateView = "Atualizar ponto de visualização?";
// Add a new camera
camera.addView = "Adicionar Visualização";
// Focus on the camera
camera.focus = "Foco";
// Add on the camera camera
camera.focusOn = "Foco em $0";
// Camera projection, Orthographic or Perspective
camera.projection = "Projeção";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Ortográfica";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Perspectiva";
// camera Vertical Field of View
camera.fov = "CDV Vertical";
// Camera Field of View hint
camera.focal = "focal $0 mm (sensor de 35 mm)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Rotação";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "Mesa Giratória";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Trackball";
camera.rotation.trackball.help = "Trackball oferece uma liberdade maior: você também pode rolar a câmera com 2 dedos.";
// Camera interaction mode, 1st person view
camera.firstPerson = "Primeira Pessoa";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Velocidade";
// Camera rotation sensitivity
camera.speed.rotation = "Rotação";
// Camera panning sensitivity
camera.speed.panning = "Deslocamento";
// Camera zooming sensitivity
camera.speed.zooming = "Zoom";
// Reset camera position
camera.resetView = "Redefinir visualização";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Ajustar visualização";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "A câmera está ajustada (ortográfica)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "Ajuste ortográfico";
camera.snapOrthographic.help = "Esta opção também funciona ao usar o Cubo de Ajuste no canto.";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Update pivot...";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Toque duas vezes no objeto";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Toque duas vezes no fundo";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "Alternar";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "Seleção";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "Cena";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "When double tapping";
camera.doubleTapPivot.help = "Atualize o pivô de rotação ao tocar duas vezes na superfície do objeto.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "Allow air pivot";
camera.airPivot.help = "Permita um novo pivô mesmo com o zoom fora da superfície do objeto.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "When camera starts moving";
camera.autoPivot.help = "Atualize o pivô quando começar a interagir com a câmera.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Foco";
camera.doubleTapFocus.help = "Ao tocar duas vezes no objeto, a câmera será deslocada e focada no ponto escolhido.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "Seleção múltipla";
// There is 0 nodes/items selected
context.noSelection = "Nenhuma seleção";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "Pré‑ajuste";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "Spline";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "Display the falloff in a symmetric way.

This option is only a visual cue, it doesn't impact the falloff itself";

// set the desired FPS (frame per second, refresh rate)
debug.targetFPS = "Target FPS";
debug.targetFPS.help = "When disabled, the default value means it will sync with the display's refresh rate.";

// Debug option, the newly created primitives will contains texture coordinates (UVs)
debug.uvPrimitive = "Manter UVs primitivas";
debug.uvPrimitive.warning = "Desative esta opção caso não precise de UVs (memória extra).";
debug.uvPrimitive.help = "Por enquanto, apenas Caixa e Esfera são compatíveis.

Outros tipos serão compatíveis no futuro.";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "Normalizar UVs";
debug.uvNormalize.help = "O Nomad normalizará os UVs dentro do mosaico [0-1].";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "Adicionar UVs BFF";
debug.uvBFF.help = "Adicione um método alternativo de cálculo (Boundary First Flattening).

Note que o BFF produzirá sobreposições se a topologia da malha não for um disco ou esfera.";
// Debug option, display an window with some debugging logs
debug.logs = "Registros";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Mapa de altura";
// Debug options, graphical stuffs
debug.graphics = "Gráficos";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Criar miniaturas da loja";

// Empty list: there is no projects
file.project.empty = "Você ainda não salvou nenhum projeto!";
// The current opened project has some unsaved changes
file.project.unsaved = "Alterações não salvas!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "Você perderá as alterações não salvas!";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Pré‑visualização do último salvamento manual";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "Versão de avaliação: você não poderá reabrir o projeto atual!";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "Versão de avaliação: você só pode abrir o projeto atual!";

file.project = "Projeto";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Salvar";
// E.g: Save "my_project"?
file.project.save.confirm = "Salvar $0?";
// Save to another project (either new one or overriding existing one)
file.project.saveAs = "Salvar Como";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "Substituir $0?";
// Open a project
file.project.open = "Abrir";
// E.g: Open "my_project"?
file.project.open.confirm = "Abrir $0?";
// Load another project and add/append all its data to the current scene
file.project.add = "Adicionar à cena";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "Adicionar $0 à cena?";
// Reset the scene and create a new project
file.project.new = "Novo";
file.project.new.confirm = "Criar nova cena?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "Apagar $0?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "Apagar $0?

Esse é o projeto em atividade!";

// Auto save section
file.project.autoSave = "Salvamento Automático";
file.project.autoSave.confirm = "Desativar Salvamento Automático?";
file.project.autoSave.help = "Salve o projeto em um arquivo separado em intervalos regulares.
O arquivo de salvamento automático pode ser encontrado em:

$0";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "Tempo limite do pop-up";
// In minutes
file.project.autoSave.minutes = "Pop-up do timer";
// Delete the current autoSave data
file.project.autoSave.delete = "Descartar Salvamento Automático";

// Load interface preference settings when opening a scene file
file.load.guiSettings = "Manter ajustes da IU";
file.load.guiSettings.help = "Ao abrir ou importar um arquivo de projeto, todos os ajustes relacionados à IU integrados ao projeto serão carregados.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.load.objSplitByGroup = "Dividir OBJ em grupos";
file.load.objSplitByGroup.help = "Quando ativado, o Nomad dividirá os grupos OBJ em objetos separados.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.load.mergeLayers = "Combinar Camadas";
// Ignore the textures present in the file to load
file.load.skipTextures = "Ignorar texturas";
// Do not fiddle with the object topology when loading the file
file.load.keepTopology = "Manter topologia";
file.load.keepTopology.help = "Use esta opção para que o Nomad não altere a topologia da malha importada.

Ela desativará a reordenação de vértice/face, remoção de duplicatas de vértice/face e remoção de vértices não usados.";
// If the object has more vertices than this value, then we won't attemp to reverse (multiresolution) the object
file.load.reverseVertices = "Inverter limite";
file.load.reverseVertices.help = "Para usar menos memória, o Nomad não salva a resolução mais baixa de uma malha.

No entanto, ele reconstruirá a resolução mais baixa se o número de vértices for menor que este limite.";


// Configure imports option
file.importSettings = "Opções de importação";

// Import file section
file.import.title = "Importar";
file.import.title.help = "Formatos compatíveis:
- Wavefront (.obj)
- glTF 2.0 (.glb .gltf)
- STL (.stl)";
// The user imports a scene file that will replace the current scene
file.import.open = "Abrir";
file.import.open.confirm = "Importar novo arquivo?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Adicionar à cena";
file.import.add.confirm = "Importar novo arquivo?";

// Export scene file
file.export.title = "Exportar";
file.export.title.help = "Se possível, dê preferência à exportação em gITF, por oferecer mais recursos do que outros formatos.";

// Export the current selected objects instead of the entire scene
file.onlySelection = "Incluir apenas objetos selecionados";
file.onlySelection.help = "Inclui apenas a seleção, em vez da cena inteira.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Reconstruir quadrado";
file.convertToQuad.help = "Associe triângulos (se adjacentes nos arquivos) para reconstruir quadrados.";

// Whether we include the textures in the exported file
file.export.texture = "Exportar texturas";
// Baking means transfering/converting
file.export.texture.help = "Esta opção não sela as cores dos vértices nas texturas.";
// Whether we include normals vector in the exported file
file.export.normal = "Exportar normais";
file.export.normal.help = "Selecione esta opção para abrir o arquivo em outros softwares.

Como o Nomad recalcula os normais, ele sempre os ignora.";

file.export.gltf = "Exportar glTF 2.0";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Exportar camadas";
file.export.gltf.layer.help = "Exporte as camadas como morphs. Por ser oficialmente compatível com gITF, isso também deve funcionar em outros softwares.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Exportar pintura da camada";
file.export.gltf.layerPaint.help = "Exporte a pintura da camada. Normalmente, isso é ignorado por outros softwares.";
// Whether the exported layer will use the non-standard Nomad encoding (smaller size)
file.export.gltf.layerNomad = "Codificação de camada do Nomad";
file.export.gltf.layerNomad.help = "Pode reduzir o tamanho do arquivo ao gravar camadas de pintura em 8 bits, em vez de 16 bits.

A codificação funciona apenas no Nomad, que usa pintura absoluta.
Outros softwares gerarão resultados incorretos, já que gITF exige codificação relativa.";
// Whether we include the vertex color in the exported file
file.export.gltf.color0 = "Exportar cores dos vértices";
file.export.gltf.color0.help = "Exporte as cores dos vértices. Por ser oficialmente compatível com gITF, isso também deve funcionar em outros softwares.";
// Whether we include the vertex roughness and vertex metalness in the exported file
file.export.gltf.color1 = "Exportar pintura PBR";
file.export.gltf.color1.help = "Exporte a pintura da aspereza, metalidade e máscara. Isso será ignorado por outros softwares.";

file.export.obj = "Exportar OBJ";
file.export.obj.warning = "Camadas e pinturas extras (aspereza, metalidade e máscara) serão perdidas.";
// Whether we include the vertex color in the exported file
file.export.obj.colorAppend = "Exportar cores dos vértices";
file.export.obj.colorAppend.help = "Afixe informações de cores aos vértices.

Alguns softwares de 3D (mas não todos) poderão ler essas informações.";

file.export.stl = "Exportar STL";
file.export.stl.warning = "Camadas e pinturas extras (aspereza, metalidade e máscara) serão perdidas.";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Exportar cores dos vértices";
file.export.stl.color.help = "Alguns softwares de 3D (mas não todos) poderão ler essas informações.";
file.export.stl.ascii = "Por padrão, o formato é binário.

Você pode optar por exportar em formato de texto (ASCII), mas o arquivo ficará maior.";

// Advanced settings
settings.advanced = "Avançado";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "Estas opções não são salvas nos ajustes.";
settings.reset.title = "Ajustes";
settings.reset.title.help = "Isto redefinirá os ajustes de preferências do app.

Alguns recursos são salvos separadamente e NÃO serão redefinidos, incluindo:

- Projetos
- Atalhos
- Pré‑ajustes das ferramentas
- Ambientes HDR
- MatCaps
- Alfas
- Texturas (pincel)
- Imagens de referência

Note que tudo aquilo ligado ao projeto será mantido intacto, como iluminação, Pós-processamento, visualizações da câmera, etc.";

// Reset preference settings button
settings.reset = "Redefinir padrão";
settings.reset.confirm = "Redefinir ajustes das preferências?";

// Render a screenshot of the scene
file.render = "Renderizar";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Mostrar interface";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Proporção da renderização";
file.render.renderRatio.help = "Com um valor de 1.0, o Nomad renderizará na mesma resolução do tamanho de imagem solicitado abaixo.

Use esta opção caso não consiga renderizar em uma certa resolução (falhas por causa da falta de memória).";
// Desired size of the exported screenshot
file.render.size = "Tamanho final";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Personalizado";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "tela";
// width of exported screenshot
file.render.width = "Largura";
// height of exported screenshot
file.render.height = "Altura";
// export screenshot of the scene
file.render.export = "Exportar png";
file.render.warn = "A resolução da exportação é alta ($0x$1)!

Certifique-se de que o projeto esteja salvo para o caso do dispositivo ficar sem VRAM e falhar.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Fundo transparente";
file.render.transparent.help = "Esta opção pode ser útil para inserir a malha em um software de criação 2D.

A transparência parcial de objetos não é compatível no momento.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Usar ajustes globais";
pressure.useGlobal.help = "Por padrão, as ferramentas compartilham os mesmos ajustes de pressão.

Desmarque esta opção para usar ajustes específicos de pressão para esta ferramenta.";

// Pencil pressure
pressure.title = "Pressão";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "Esta ferramenta não usa a pressão do lápis.";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "O tipo de traçado ao pegar o lápis ignorará os ajustes de pressão.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Raio";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Intensidade";

// Customize whether finger and/or stylus can move the Camera
gesture.cameraInteraction = "Câmera:";
// Customize whether finger and/or stylus can sculpt on object
gesture.sculptInteraction = "Esculpir:";
// Both the finger and the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.fingerAndStylus = "Dedo e Stylus";
// Only the finger can perform a certain action (move camera, sculpt, etc)
gesture.interaction.finger = "Dedo";
// Only the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.stylus = "Stylus";
// Disable the action
gesture.interaction.none = "Nenhum";
// Allow the action for any inputs
gesture.interaction.any = "Qualquer";

// long press to pick the color/material under the cursor
gesture.materialPicking = "Seleção de material";
gesture.materialPicking.help = "Você pode manter a tela pressionada para acionar o seletor de cor/material.

Note que isso só funciona se a pintura estiver ativada no pincel atual.";

// Three fingers on screen
gesture.three.title = "Três dedos";
// Drag 3 fingers horizontally on the canvas to rotate the environment, lights and MatCap
gesture.fingerLighting = "Girar iluminação (3 dedos)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerLighting.help = "Arraste 3 dedos horizontalmente na tela para girar o ambiente, luzes e MatCap.";
// Drag 3 fingers vertically to edit the tool radius
gesture.fingerRadius = "Raio de edição da ferramenta (3 dedos)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerRadius.help = "Arraste 3 dedos verticalmente na tela para editar o raio da ferramenta.";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.fingerSmooth = "Dedo sempre suaviza";
gesture.fingerSmooth.help = "This option is only active if a sculpting tool is active.";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Permitir pressão não reconhecida";
gesture.unknownPressure.help = "Selecione esta opção se a pressão não funcionar com o lápis ou você precisar de pressão do dedo.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Botão do lápis";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Dois toques no lápis";
gesture.pencilAction.ios.help = "Ativado apenas para o Apple Pencil (2ª geração).";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "Nenhuma";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Adicionar/Subtrair";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "Atalhos de um toque";
gesture.mask.oneTap.help = "Toque na tela uma vez para permitir o atalho de Máscara, sem precisar manter pressionado o atalho do botão de máscara.

Isso permitirá os seguintes gestos:
- Toque no fundo para inverter a máscara
- Toque em uma área com máscara para desfocar a máscara
- Toque em uma área sem máscara para dar nitidez à máscara";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress = "Manter pressionado (Máscara ↔ MáscSel)";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress.help = "Quando Máscara ou MáscSel está ativada, mantenha pressionado para alternar entre elas.

Se você mantiver pressionado sem mover o dedo, a nova ferramenta será usada como atalho de máscara padrão.";
// Indicator that the tool has been set as the new shortcut
gesture.mask.infoShortcut = "$0 definido como atalho de máscara.";

// Shortcuts to undo/redo
gesture.history = "Atalhos do histórico";
gesture.history.help = "- Desfazer: toque com 2 dedos
- Refazer: toque com 3 dedos
- Desfazer/Refazer: mantenha 2/3 dedos na tela (contínuo)";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Rejeição de palma";
gesture.palmRejection.confirm = "Desative esta opção caso tenha problemas para interagir com a tela!";
gesture.palmRejection.help = "Rejeite a entrada se o tamanho da área de contato for maior que este valor.

Pode não funcionar em todos os dispositivos.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Limite de tamanho máximo";

// History, list of undo/redo
history = "Histórico";
// First "undo" state
history.root = "Início";
history.undoConfirm = "Você confirma que deseja desfazer todas essas operações?";
history.undoWarning = "Se você fizer uma edição posteriormente, poderá perder várias alterações.";
// Settings concerning the history stack of undo/redo
history.stack = "Pilha";
// Actions to include in the undo/redo stack
history.include = "Incluir ações";
// include lighting editing in the undo/redo
history.includeLights = "Luzes";
history.includeLights.help = "Com esta opção desativada, a movimentação de luzes com o Gizmo ainda será incluída, já que ela pode afetar outros objetos na hierarquia da cena.";
// include postProcess editing in the undo/redo
history.includePostProcess = "Pós-processamento";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCaps e HDRIs";
// Can limit the stack of undo/redo size
history.limitSize = "Limite do histórico (Mb)";
history.limitSize.help = "Tamanho máximo (em Mb) do histórico.

O histórico será atualizado na próxima operação gravada.";
// Limit the number of undo in the history stack
history.limitStack = "Limite da pilha";
history.limitStack.help = "O número máximo de operações que o aplicativo pode manter.

O histórico será atualizado na próxima operação gravada.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Desfazer máximo ";
history.rangeProtect.help = "Se você voltar muito no histórico, verá um diálogo de confirmação antes de desfazer muitas operações.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Restaurar câmera";
history.restoreCamera.help = "Ative esta opção para restaurar o ponto de visualização salvo da câmera ao desfazer/refazer uma ação.";
// Undo
history.undo = "Desfazer";
// Redo
history.redo = "Refazer";
// Shown during undo
history.state.undo = "Desfazer: $0";
// Shown during redo
history.state.redo = "Refazer: $0";
// Shown during undo/redo
history.state.symmetrySplit = "Divisão de Simetria";
// Shown during undo/redo
history.state.voxelRemesh = "Remalhar voxels";
// Shown during undo/redo
history.state.surfaceRemesh = "Remalhar superfície";
// Shown during undo/redo
history.state.multiresLevel = "Alteração de resolução";
// Shown during undo/redo
history.state.multiresToDynamic = "Multirresolução para Topologia Dinâmica";
// Shown during undo/redo (mesh type conversion)
history.state.meshDynamicToStatic = "Topologia Dinâmica para Estática";
// Shown during undo/redo (mesh type conversion)
history.state.meshStaticToDynamic = "Estática para Topologia Dinâmica";

// Interface customization
interface = "Interface";

// UI customization: each row of the list will be bigger
interface.expandList = "IU: expandir lista";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Uma opção da IU para gerenciar a lista mais facilmente.";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "Adicionar atalhos (inferior)...";

// Interface option (main base color)
interface.colorBase = "Cor da base";
// Interface option (accent widget color)
interface.colorSelect = "Cor do widget";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Painel transparente";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Intensidade do desfoque";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Cor do painel";

// Interface color style
interface.preset.title = "Pré‑ajustes de cores";
// Interface color style (original color of Nomad Sculpt)
interface.preset.classic = "Clássica";
// Interface color style
interface.preset.orange = "Laranja";
// Interface color style (~red)
interface.preset.cardinal = "Cardeal";
// Interface Color style (~pink)
interface.preset.mulberry = "Morado";
// Interface color style
interface.preset.brown = "Marrom";
// Interface color style (~green)
interface.preset.emerald = "Esmeralda";
// Interface color style (~blue)
interface.preset.neon = "Neon";
// Interface color style
interface.preset.violet = "Violeta";
// Interface color style
interface.preset.grey = "Cinza";
// Interface color style
interface.preset.black = "Preto";
// Interface color style
interface.preset.white = "Branco";

// Reset interface settings
interface.resetAll = "Redefinir estilo";
interface.resetAll.confirm = "Redefinir ajustes da interface?";
// Interface option (main base color)
interface.iconSupport = "High-contrast button";
interface.iconSupport.help = "An alternative style for buttons that makes them more visible when they are enabled.

If set on Auto, Nomad will use this mode when the UI color contrast between enabled/disabled is low.";
// Interface customization
interface.flipTop = "Espelhar barra superior";
// Interface customization
interface.flipBottom = "Espelhar barra inferior";
// Interface customization
interface.flipMiddle = "Espelhar barras laterais";
// Interface customization (preview material in the viewport when editing material color)
interface.materialPreview = "Pré‑visualização da cor do material";
// Interface customization
interface.materialPreview.help = "Ao selecionar uma cor para um material, a pré‑visualização do material é exibida no objeto selecionado atualmente.";
interface.toolbox.hide = "Ocultar caixa de ferramentas";
interface.toolboxHide.help = "Ative esta opção caso deseje ocultar a caixa de ferramentas.";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.maxColumn = "Máximo de colunas na caixa de ferramentas";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Redefinir ordem na caixa de ferramentas";
// Scale the interface
interface.scale = "Tamanho global";
// Spacing between widgets
interface.cursorStep = "Espaçamento vertical";
// Width of the interface panels
interface.panelWidth = "Largura do painel";
// Size of fonts
interface.fontScale = "Tamanho da fonte";
// Inset
interface.inset.title = "Deslocamento da borda";
interface.inset.title.help = "You can change these values only if you have issues interacting with the buttons on the screen edges.

If the slider is disabled, Nomad will use the safe area values returned by the device itself.";
interface.inset.left = "Esquerda";
interface.inset.right = "Direita";
interface.inset.bottom = "Inferior";
interface.inset.top = "Superior";

// (see Glossary for Layer)
layer = "Camada";
// (see Glossary for Layer)
layers.lock = "Manter detalhes das camadas superiores";
// (see Glossary for Layer)
layers.lock.yes = "Bloquear camadas superiores?";
// (see Glossary for Layer)
layers.lock.warning = "Ao esculpir, a deformação vinda das camadas superiores será ignorada.

Mas os detalhes dessas camadas ainda estarão visíveis.

Esta opção funciona apenas se as camadas superiores tiverem detalhes relativamente pequenos.";
// (see Glossary for Layer)
layers.addLayer = "Adicionar camada";
// (see Glossary for Layer)
layer.factors = "Fatores do canal";
// (see Glossary for Layer)
layer.factor = "Fator";
// (see Glossary for Layer)
layer.offset = "Deslocamento";
// (see Glossary for Layer)
layers.title = "Camadas";
// (see Glossary for Layer)
layers.title.help = "Layers can record position offsets and painting, it can be useful for non-linear workflow.
For example by experimenting different facial expression without relying on the history stack to undo the changes.

For painting data, layers are sorted in a top-down fashion; so layers on top will mask the lower ones.

You can erase part of the layer by using the 'DelLayer' tool.";
layers.primitive = "Camadas não estão disponíveis para primitivas.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "Nenhuma";

light = "Luz";
// Intensity of light
light.intensity = "Intensidade";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "Temperatura";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Conexão";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Fixa";
// The light will move along the camera
light.attachment.camera = "Câmera";
light.attachment.help = "- Fixa
A orientação da luz não mudará.

- Câmera
A orientação da luz dependerá da visualização da câmera.";
// Light type (directional, spot, point)
light.type = "Tipo";
// Directional light (synonym: sun light)
light.type.directional = "Direcional";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Spot";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Ponto";
// Cone angle for spot angles
light.spot.angle = "Ângulo do cone";
// Softness of the spot light
light.spot.softness = "Suavidade";
// Position of the light
light.position = "Posição";
// Enable or disable shadows for a light
light.shadow.cast = "Sombra";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "A luz de ponto é compatível apenas com sombras no espaço da tela.";
light.shadow.type = "Tipo de sombra";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "Mapeamento de sombra";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "Espaço da tela";
light.shadow.type.screenspace.help = "Recurso experimental. Pode ser removido em um lançamento futuro.

Esta opção se destina ao uso com o recurso de suavidade da sombra.";
// Adjustment to fix artefacts
light.shadow.bias = "Propensão";
// How blurry the shadow is
light.shadow.softness = "Suavidade";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "Contato";
light.contact.help = "Se Automático for selecionado, apenas a luz mais dominante terá uma sombra de contato.";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "Tolerância";
// Activated the light
light.visible = "Mostrar";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Recentralizar";

// Object's material
material = "Material";
// See glossary
material.pbrRoughnessMetalness.warning = "Aspereza e Metalidade requerem o modo de sombreamento PBR.";
// See glossary
material.pbrReflectance.warning = "Reflexividade requer o modo de sombreamento PBR.";
// See glossary
material.pbrRefraction.warning = "Refração requer o modo de sombreamento PBR.";
// See glossary
material.pbrSubsurface.warning = "Subsuperfície requer o modo de sombreamento PBR.";
// Value that says how much light will change direction when hitting the surface
material.ior = "Índice de Refração";
// an object-level value that overrides the painting of the mesh
material.paintingOverride = "Substituir pintura";
// The roughness in the inside is turbidity
material.paintingOverride.help = "Há duas asperezas atuando juntas: uma que fica na superfície e outra no interior.

Mas como só há uma aspereza que pode ser pintada, as duas asperezas têm os mesmos valores.

Você pode usar este controle para substituir a aspereza da superfície e deixá‑la mais brilhante.";
// Glossiness is simply the opposite of roughness
material.refractionSurfaceGlossiness = "Brilhosidade da superfície";
material.refractionSurfaceGlossiness.help = "- Em 0, a superfície usa a aspereza da pintura
- Em 1, a superfície fica completamente lisa";
// Synonym: turbidity
material.refractionInteriorRoughness = "Aspereza interior";
material.refractionInteriorRoughness.help = "- Em 0, o interior usa a aspereza da pintura
- Em 1, o interior fica completamente áspero";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Brilhosidade da pintura";
material.paintGlossy.help = "Isto pintará o objeto com aspereza e metalidade de 0, o que permite uma refração nítida.

Essa ação é igual à acessar o menu de pintura e usar o recurso de pintar tudo com cor e metalidade desativadas.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Absorção";
material.absorptionEnable.help = "Simule a luz sendo absorvida quando ela viaja através do volume.

As partes finas brilharão, já que deixam mais luz passar, enquanto as partes espessas serão mais escuras.

O efeito depende diretamente da forma do objeto; apenas uma aproximação da espessura do objeto é usada.";
material.absorptionFactor = "Fator";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "Profundidade";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "Translucidez";
material.translucency.help = "Você precisa de uma luz que projete sombras para ver translucidez.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Opacidade";
// Fully opaque material
material.type.opaque = "Opaco";
// See glossary
material.type.subsurface = "Subsuperfície";
material.type.subsurface.help = "Para ter resultados melhores, alterne para o modo de sombreamento PBR e use ao menos uma luz direcional, idealmente com um ambiente escurecido.";
// Transparency mode, alpha blending
material.type.blending = "Mistura";
material.type.blending.help = "Ajuste o valor de opacidade para tornar o objeto semitransparente.

Devido às restrições de tempo real, artefatos podem ser notados se o objeto tiver uma forma complexa.";
// Transparency mode
material.type.additive = "Aditiva";
material.type.additive.help = "Ajuste o valor de opacidade para tornar o objeto semitransparente.

Este método tende a ter menos artefatos que o método Mistura, mas o objeto será mais claro.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Pontilhamento";
material.type.dithering.help = "Descarte alguns pixels aleatoriamente para tornar o objeto semitransparente.";
// Simulate glass-like material
material.type.refraction = "Refração";
material.type.refraction.help = "Este modo pode ser usado para simular material de vidro.

Devido às restrições de tempo real, a autorrefração e a refração multicamada são limitadas.";
material.castShadows = "Projetar sombras";
material.receiveShadows = "Receber sombras";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Sempre não iluminado";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Inverter culling";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Reflexividade";
material.reflectance.help = "Controle a quantidade de reflexo que o material (não metálico) receberá.

Na maioria das vezes, o valor padrão deve ser usado (0.5, que corresponde aos 4% padrão de luz refletida em ângulo normal).";

// Menu name
menu.files = "Arquivo";
// Menu name
menu.scene = "Cena";
// Menu name
menu.multires = "Multirres";
// Menu name
menu.voxel = "Voxel";
// Menu name
menu.dynTopo = "TopoDin";
// Menu name
menu.topology = "Dizi/UV...";
// Menu name
menu.primitive = "Primitiva";
// Menu name
menu.render = "Renderizar";
// Menu name
menu.material = "Material";
// Menu name
menu.postProcess = "Pós-processamento";
// Menu name
menu.camera = "Câmera";
// Menu name
menu.background = "Fundo";
// Menu name
menu.tool = "Ferramenta";
// Menu name
menu.stroke = "Traçado";
// Menu name
menu.paint = "Pintura";
// Menu name
menu.symmetry = "Simetria";
// Menu name (pencil pressure)
menu.pressure = "Pressão";
// Menu name
menu.gesture = "Gesto";
// Menu name
menu.layers = "Camadas";
// Menu name
menu.settings = "Ajustes";
// Menu name
menu.interface = "Interface";
// Menu name
menu.bindings = "Atalhos";
// Menu name
menu.history = "Histórico";
// Menu name
menu.historySettings = "Ajustes";
// Menu name
menu.about = "Sobre";
// Menu name
menu.debug = "Depurar";

// Operation on the object (action)
mesh.action = "Operação";
// If the object has holes, the algorithm will close them
mesh.holeClose = "Fechar furos";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holeDetail = "Detalhe";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Separar";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "Camadas, pintura e multirresolução serão perdidas.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Resolução";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Forçar cúbico";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Converter";
// Static object means "static topology"
mesh.typeStatic = "Malha";
// See glossary
mesh.typeMultiresolution = "Multirresolução";
// Dynamic topology
mesh.typeDynamic = "TopoDin";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Material global";
paint.useGlobal.help = "Se esta opção for ativada, o material selecionado será o mesmo das outras ferramentas.

Note que isso só considera os ajustes de aspereza, metalidade e cor.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Pintura com traçado";
// Factor/Opacity of paint tool
paint.intensity = "Intensidade da pintura";
// Apply the paint on the object
paint.paintAll = "Pintar tudo";
paint.paintAll.help = "Aplique o material atual ao objeto.

Áreas com máscaras e canais desativados não serão pintadas.";
// Apply the paint on the object but ignore painting intensity (force full intensity)
paint.paintAllForce = "Forçar pintar tudo";
paint.strokePainting.title = "Pintura";
// Brush stroke texture
paint.texture.title = "Textura";
paint.texture.title.help = "Uma imagem que colorirá o traçado do pincel.

Note que isso compartilhará os ajustes de tesselação e tamanho do alfa.";
paint.texture.warningEnable = "A pintura com traçado precisa ser ativada para permitir a projeção de textura (opção na parte superior).";
paint.texture.warningIgnored = "A ferramenta atual não pode usar texturas!";
// Whether the Brush Alpha will be used to module painting
paint.useAlpha = "Usar alfa do traçado";
paint.useAlpha.help = "Use o alfa definido no menu de traçado para modular a pintura.";
// Whether the Brush Falloff will be used to module painting
paint.useFalloff = "Usar decaimento do traçado";
paint.useFalloff.help = "Use o decaimento definido no menu de traçado para modular a pintura.";

// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "Novo nome";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "Novo valor";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "Nova cor (formato hex)";

// Post process effect
postprocess = "Pós-processamento";
// Quality vs performance
postprocess.quality = "Qualidade";
postprocess.quality.help = "Ative estas opções para melhorar a qualidade em detrimento do desempenho.";
// More samples means better quality but slower performance
postprocess.maxSamples = "Máximo de amostras";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Resolução completa";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "Amostragem máxima de quadros";
postprocess.accumulateCount.help = "Maximum number of frames to accumulate before the rendering stops.

When the rendering stops, Nomad won't do anything, thus saving battery life.

Many rendering features benefit from frame accumulation, notably:
- Soft Shadows
- Global Illumination
- Reflection (SSR)
- Ambient Occlusion
- Subsurface
- Depth Of Field

High frame counts are mostly necessary for Soft Shadows and Global Illumination.
Nomad can stop the rendering sooner if the features mentioned aboved are disabled.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Resolução da renderização";
postprocess.renderRatio.warning = "Substituído pelo efeito de Pixel Art.";
postprocess.renderRatio.help = "Esta opção afeta bastante o desempenho.
É recomendável manter um valor menor que x1.25.

Esta opção não é salva nos ajustes.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "Antisserrilhado (TAA)";
postprocess.taa.help = "Reduz a tremulação ao mover a câmera.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "Reflexão (SSR)";
postprocess.ssr.warning = "SSR requer o modo de sombreamento PBR.";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "Iluminação Global (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "Tolerância";
postprocess.ssgi.experimental = "Experimental!";
postprocess.ssgi.warning = "SSGI requer o modo de sombreamento PBR.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "Oclusão Ambiente";
// How far the effect spreads
postprocess.ssao.radius = "Tamanho";
// How strong the effect is
postprocess.ssao.factor = "Intensidade";
// Adjustment to fix artefacts
postprocess.ssao.bias = "Propensão de curvatura";
postprocess.ssao.bias.help = "O quão sensível o efeito é, dependendo da curvatura da superfície.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "Profundidade de Campo";
// The blur factor behind the focused point
postprocess.dof.blurFar = "Desfoque longe";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "Desfoque perto";
postprocess.dof.focusTip = "Toque em um objeto para alterar o ponto de foco.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "Incandescência";
// Intensity of the effect
postprocess.bloom.intensity = "Intensidade";
// How far the effect spreads
postprocess.bloom.radius = "Raio";
postprocess.bloom.radius.help = "O quanto a incandescência se espalha.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "Limite";
postprocess.bloom.threshold.help = "O limite de luminosidade para decidir se um pixel emitirá ou não incandescência.
Se o valor for 0, tudo terá incandescência.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "Mapeamento de Tons";
postprocess.tone.exposure = "Exposição";
postprocess.tone.contrast = "Contraste";
postprocess.tone.saturation = "Saturação";
// No tonemapping operator is used
postprocess.tone.mapping.none = "Nenhum";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "Neutro";
// Color curves
postprocess.curve = "Gradação de Cores";
// Curve for pixel luminance
postprocess.curve.luminance = "Principal";
postprocess.curve.red = "Vermelho";
postprocess.curve.green = "Verde";
postprocess.curve.blue = "Azul";
postprocess.curve.reset = "Redefinir";
// Reset color grading curves
postprocess.curve.resetAll = "Redefinir Tudo";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "Aberração Cromática";
postprocess.chromatic.factor = "Intensidade";
// Darking on the edges
postprocess.vignette = "Vinheta";
// How far the effect spreads
postprocess.vignette.size = "Tamanho";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "Dureza";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "Nitidez";
postprocess.sharpness.factor = "Intensidade";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "Granulação";
postprocess.grain.factor = "Intensidade";
// Accentuate the edges of the model
postprocess.curvature = "Curvatura";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "Cavidade";
// Color/Strength of convex curvature
postprocess.curvature.bump = "Protuberância";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "Pixel Art";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "Permitir amostragem de quadros";
// Simulate scanline rendering (horizonal line)
postprocess.scanline = "Linha de escaneamento";
postprocess.scanline.factor = "Fator";
// Spacing between lines
postprocess.scanline.spacing = "Espaçamento";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Primitiva";
primitive.box = "Caixa";
primitive.sphereCube = "Esfera";
primitive.sphereUV = "Esfera UV";
primitive.icosahedron = "Icosaedro";
primitive.cylinder = "Cilindro";
primitive.cone = "Cone";
primitive.torus = "Toro";
primitive.lathe = "Torno";
primitive.tube = "Tubo";
primitive.plane = "Plano";
primitive.triplanar = "Triplano";
primitive.faceXYZ = "Face XYZ";
primitive.faceXYZ.help = "Malha base calculada por UV fornecida por https://texturing.xyz/";
primitive.needValidate = "As primitivas devem ser validadas para que sejam esculpidas.";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Editar";
primitive.edit.help = "Permite a edição 3D na janela de visualização.

Você pode desativar este recurso caso deseje interagir com o Gizmo ou a ferramenta Transformar sem modificar a primitiva.";

// Primitive configuration
primitive.mainConfig = "Parâmetro";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Topologia";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Geometria";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Validar";
// Maximum number of faces of the primitives
primitive.maxFaces = "Máximo de faces";
primitive.maxFaces.help = "O número máximo de faces que uma primitiva pode ter.

Este limite só fica ativado enquanto a primitiva não é validada. Depois disso, esta proteção é removida.";
// Synonym: Flat subdivision
primitive.linear = "Subdivisão linear";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Subdivisão posterior";

// Radius (of a sphere, torus, etc)
primitive.radius = "Raio";
// Size (of cube x dimension)
primitive.size = "Tamanho";
primitive.sizeX = "Tamanho X";
primitive.sizeY = "Tamanho Y";
primitive.sizeZ = "Tamanho Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "Divisão";
primitive.divisionX = "Divisão X";
primitive.divisionY = "Divisão Y";
primitive.divisionZ = "Divisão Z";
// Angle of torus, etc
primitive.angleX = "Ângulo X";
primitive.angleY = "Ângulo Y";
primitive.angleZ = "Ângulo Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Densidade constante";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Projetar na esfera";
primitive.projectOnSphere.help = "Ajusta os pontos em uma esfera perfeita.";

// triplanar
primitive.triplanar.title = "Triplano";
primitive.triplanar.title.help = "O Triplano usa as informações de máscara de 3 planos para preencher uma grade de voxels que é então poligonizada.

Se você interagir com os controles de divisão ou tamanho, as informações de pintura serão redefinidas (a suavidade não).

É recomendável desativar a simetria, já que ela pode não funcionar conforme o esperado.

Você pode usar a opção “Topologia conectada” no painel de máscara para pintar um plano que afete os outros planos.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanarSameSize = "Mesmo tamanho (cubo)";
primitive.triplanarPolish = "Suavidade";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanarResetMask = "Redefinir máscara";
// One side of a cube (the back plane)
primitive.isolate.back = "Verso";
// One side of a cube (the right plane)
primitive.isolate.right = "Direita";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Inferior";
// Plane
primitive.planeSameSize = "Mesmo tamanho (quadrado)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "Disco";
// Box
primitive.boxRegular = "Mesmo tamanho (cubo)";
// Distance to the snapping point
primitive.tubeSnapOffset = "Deslocamento do ajuste";
primitive.tubeSnapOffset.help = "Um valor de 1.0 é igual ao raio do tubo.";
// Radius of the tube (starting end-point of the tube)
primitive.tubeThicknessStart = "Início do raio";
// Radius of the tube (ending end-point of the tube)
primitive.tubeThicknessEnd = "Fim do raio";
primitive.tubeTwist = "Torção";
primitive.tubeTwistRotate = "Rotação";
primitive.tubeTwistRadius = "Magnitude";
primitive.tubeTwistOffset = "Deslocamento";
primitive.tubeSnap = "Ajuste";
primitive.torusRadiusOuter = "Raio externo";
primitive.torusRadiusInner = "Raio interno";
primitive.torusAngle = "Ângulo";
primitive.torusAngleOffset = "Deslocamento do ângulo";
primitive.cylinderHeight = "Altura";
primitive.coneRadius = "Raio";
primitive.coneHeight = "Altura";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Furo";
// Make a hole in the primtive to make it hollow
primitive.hasHole = "Tem furo";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radiusSync = "Mesmo raio";
primitive.radiusStart = "Início do raio";
primitive.radiusEnd = "Fim do raio";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Importar...";

scene.title = "Cena";
scene.title.help = "Ao usar os botões de visibilidade e seleção, toque e arraste o dedo para selecionar facilmente outros objetos.

Você também pode manter pressionados os botões de visibilidade e seleção para que os itens secundários também sejam afetados.";
// The view will focus on the item when we click on it
scene.focus = "Focar no item";
// Icon size in pixel (min/max)
scene.iconSize = "Icon size";
// Min size of icon
scene.iconSize.min = "Mín.";
// Max size of icon
scene.iconSize.max = "Máx.";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "Hierarchy lines";
scene.showHierarchy.help = "Display a line between parent and its children in the viewport.";
scene.showHierarchyNomadPivot = "Use Nomad pivot";
scene.showHierarchyNomadPivot.help = "The Nomad pivot is the pivot used by the Transform and Gizmo tools.

If this option is disabled, it will use the natural base pivot.
In some case this base pivot can be far away from the object center itself!";
// The view will focus on the item when we click on it
scene.syncVisible = "Sync visibility";
scene.syncVisible.help = "When enabled, using the visible (eye) icon will impact all the selected items.";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "Unir";
// Group the selected object with a new created Empty Node as a parent
scene.group = "Agrupar";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "Espelhar";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "Curva";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "Matriz";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "Radial";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "Repeaters";
scene.repeaters.help = "Repeater nodes that make instances of any geometries below it in the scene hierarchy.";
// Validate button
scene.validateGroup = "Validar";
// If we should join children
scene.validateGroup.joinChildren = "Unir secundários";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Combinar voxels";
scene.voxelResolution = "Resolução";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Subtração: ocultar objeto (ícone de olho)";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Interseção: ocultar todos os objetos";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "Nenhum objeto selecionado. Selecione ao menos um objeto.";
// Need to select one object only
scene.noneButNeedOne = "Nenhum objeto selecionado. Selecione um objeto.";
// Need to select one object only
scene.onlyOneObject = "Vários objetos selecionados. Selecione apenas um objeto.";

// General scene display settings
settings.display.title = "Ajustes de exibição";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Armação";
// Display UV
settings.debugUV = "Depurar UV";
settings.debugUV.help = "Esta opção só é relevante quando o modelo tem UVs.

Ela mostrará a armação da UV no fundo.

Ela também mostrará uma textura de tabuleiro de damas colorido no modelo.";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Dois lados";
settings.twoSided.help = "As faces poderão ser vistas de ambos os lados.";
// If we colorize the inverted side of faces
settings.backface.color = "Cor do verso";
// Color of the inverted side of faces
settings.backface.colored = "Verso colorido";
// Outline (contour highlight around the selected object)
settings.outline = "Contorno";
// Outline (contour highlight around the selected object)
settings.outline.help = "Os objetos selecionados serão contornados.";
settings.outline.thickness = "Espessura";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Cubo de ajuste";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "Inferior";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "Esquerda";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Estatísticas";
settings.stats.right = "Direita";
settings.stats.all = "Mostrar cena completa";
// Grid
settings.grid = "Grade";
// Cursor
settings.cursor.whileSculpting = "Mostrar círculo ao esculpir";
// A small indicator dot
settings.cursor.showDot = "Mostrar ponto pequeno";
settings.cursor.showDot.help = "O ponto pode aparecer como ponto pivô da câmera ou enquanto você esculpe.";
settings.cursor.showRope = "Mostrar estabilizador de corda";
// Highlight (the object glows when we select it)
settings.highlight.selection = "Destacar seleção";
// Highlight settings
settings.highlight = "Destaque";
settings.highlight.duration = "Duração";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Escurecer objetos não selecionados";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Sombreamento suave";
// Experimental feature
settings.partialDraw = "Desenho parcial";
settings.partialDraw.help = "Recurso experimental!

Use se você estiver esculpindo uma parte relativamente pequena de uma malha com muitos polígonos.

Isto deve suavizar a escultura, mas você não deve ativar a armação!

Isto também pode adicionar artefatos ao traçar com o pincel.";
settings.partialDraw.warning = "Não se esqueça de desativar esta opção se os artefatos incomodarem muito!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Mostrar pintura";
// Display the light icons in the viewport
settings.lightIcon = "Ícones de luz";
// Display the camera icons in the viewport
settings.cameraIcon = "Ícones de câmera";
// Show icon on the canvas
settings.icon = "Ícone";
// Show icons on the canvas
settings.icons = "Ícones";
// Tooltip
settings.icons.help = "Mostre um ícone na tela para que você possa selecionar e editar diretamente.";
// Hole filling settings
settings.hole = "Preenchimento de furo";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Preenchimento não diverso";
settings.hole.nonManifold.help = "Tente preencher um furo de maneira não diversa.
Esta opção não é salva nos ajustes.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Contagem máxima de vértices";
settings.multires.maxVertices.help = "Como Nomad não verifica a memória antes de subdividir, uma alta contagem de polígonos pode levar facilmente a falhas.";
settings.multires.lowResVertices = "Limite de baixa resolução";
settings.multires.lowResVertices.help = "A malha pode exibir uma resolução mais baixa ao mover a câmera.

Você pode aumentar este valor caso deseje ter uma malha de resolução maior.";

// The main rendering mode
shading = "Sombreamento";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "Iluminar (PBR)";
shading.pbr.help = "Neste modo, você pode adicionar luzes (com sombras), junto com um ambiente HDR.

Você também pode pintar metalidade e aspereza, o que permite um controle mais preciso da aparência do material.";
// Fast rendering mode for sculpting purpose (do not translate)
shading.matcap = "MatCap";
shading.matcap.help = "A MatCap (captura material) lida com as informações de iluminação e do material em uma única imagem.

Este é um modo de renderização rápido, adequado na maioria das vezes à escultura bruta.";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "Não iluminar";
shading.unlit.help = "Modo de sombreamento de cor sólida, sem iluminação.";
// Helper rendering mode that display a (do not translate)
shading.id = "ID";
shading.id.help = "Modo de renderização não iluminada onde cada objeto tem uma cor aleatória atribuída.

Útil na maioria das vezes quando há muitos objetos na cena.";
// Randomize colors
shading.id.randomize = "Aleatorizar id";
shading.textures = "Usar texturas";
shading.textures.help = "No momento, não é possível criar ou editar texturas no Nomad.

Mas a importação de um arquivo com texturas deve funcionar.

— Texturas compatíveis —
Opacidade: Iluminar, MatCap, Não iluminar
Normal: Iluminar, MatCap
Cor: Iluminar, Não Iluminar
Emissiva: Iluminar
Aspereza: Iluminar
Metalidade: Iluminar";
// Lights
shading.lights = "Luzes";
shading.lights.addLight = "Adicionar luz";
shading.lights.warning = "Luzes requerem o modo de sombreamento PBR.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Ambiente";
shading.environment.import = "Importar HDR";
shading.environment.exposure = "Exposição";
shading.environment.backgroundBlur = "Desfoque (fundo)";
shading.environment.rotation = "Rotação";
shading.environment.rotation.help = "Arraste 3 dedos horizontalmente na janela de visualização para girar o ambiente.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "Conectado à câmera";
shading.environment.attachedToCamera.help = "Conecte o ambiente à câmera.

Isto fará com que a iluminação seja consistente, o que pode ser útil para esculpir.";
shading.matcap.rotation = "Rotação";
shading.matcap.rotation.help = "Arraste 3 dedos horizontalmente na janela de visualização para girar a MatCap.";
shading.matcap.global = "Usar MatCap global";
shading.matcap.global.help = "Desmarque esta opção para usar uma MatCap diferente para esta malha em particular.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible.short = "Máscara";
shortcut.maskVisible.long = "Máscara";
// bottom shortcut buttons (should be SHORT)
shortcut.solo.short = "Solo";
shortcut.solo.long = "Solo";
// bottom shortcut buttons (should be SHORT)
shortcut.voxelRemesh.short = "Voxel";
shortcut.voxelRemesh.long = "Remalhar voxels";
// bottom shortcut buttons (should be SHORT)
shortcut.wireframe.short = "Armação";
shortcut.wireframe.long = "Armação";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraReset.short = "Redefinir";
shortcut.cameraReset.long = "Redefinir câmera";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraSnap.short = "Ajustar";
shortcut.cameraSnap.long = "Ajuste da câmera";
// bottom shortcut buttons (should be SHORT)
shortcut.lockSelection.short = "Bloquear";
shortcut.lockSelection.long = "Bloquear seleção";
shortcut.lockSelection.long.help = "Quando ativado, você não pode tocar em uma malha para alterar a seleção.";
// bottom shortcut buttons (should be SHORT)
shortcut.perspective.short = "Persp";
shortcut.perspective.long = "Perspectiva";
// bottom shortcut buttons (should be SHORT)
shortcut.grid.short = "Grade";
shortcut.grid.long = "Grade";
// bottom shortcut buttons (should be SHORT)
shortcut.uv.short = "uv";
shortcut.uv.long = "uv";

// Memory taken by the scene
stat.ramScene = "Cena";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "VRAM da Cena";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "VRAM do Renderizador";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "VRAM das Texturas";
// Memory taken by the undo/redo history
stat.ramHistory = "Histórico";
// Memory taken by other stuffs
stat.ramOther = "Outros";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "Memória Usada";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "Memória Livre";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "Usada: $0 MB";
stat.free = "Livre: $0 MB";
stat.faces = "Faces";
stat.triangles = "Triângulos";
stat.vertices = "Vértices";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Quadrados";
stat.sceneFaces = "Faces da cena";
stat.sceneVertices = "Vértices da cena";

// Brush stroke
stroke = "Traçado";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "Raio da cena";
// The settings is shared among every tools
stroke.useWorldRadius.help = "Isto é compartilhado por todas as ferramentas.";
// Share the radius value among every tools.
stroke.useShareRadius = "Raio compartilhado";
stroke.useShareRadius.help = "Compartilhe o valor do raio entre todas as ferramentas.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.minSpacing = "Espaçamento do traçado";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.minSpacing.adjustIntensity = "Ajustar intensidade do espaçamento";
stroke.minSpacingAdjustIntensity.help = "Ajuste a intensidade do pincel para garantir uma deformação constante dependendo do espaçamento do traçado.";
stroke.minSpacing.help = "O espaçamento entre cada traçado, relativo ao raio da ferramenta.

Um valor mais baixo permitirá um traçado mais suave, mas o desempenho sofrerá degradação.";
// Brush stroke smoothing
stroke.lazySmooth = "Suavização do traçado";
stroke.lazySmooth.help = "Calcula uma média de várias posições do cursor para gerar um traçado mais suave.

Com valores altos, o traçado ficará para trás do cursor e o alcançará eventualmente.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Estabilizador de corda preguiçoso";
stroke.lazyRadius.help = "Os traçados ficarão para trás da posição do cursor de acordo com uma certa distância.

Isto pode ser usado para desenhar linhas suaves.";
// It is not a per-tool settings
stroke.globalSettings = "Este é um ajuste global";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Raio de ajuste";
stroke.snapRadius.help = "Ajuste o traçado se o cursor estiver perto do último traçado reconhecido.

Isto pode ser útil ao desenhar linhas longas e contínuas, intercaladas com pausas frequentes.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Deslocamento do traçado";
stroke.sculptOffset.help = "Aplique um deslocamento constante no traçado.

Esta opção serve para ajudar a usar o dedo em telas pequenas, para que ele não cubra o traçado.";
stroke.accumulate = "Acumular traçado";
stroke.accumulate.help = "Se esta opção for ativada, não existirá um limite na quantidade de matéria que você pode adicionar/remover por traçado.";
// The tool can use DynTopo
stroke.useDynamicTopology = "Permitir topologia dinâmica";
// Only sculpt the part that are linked topologically
stroke.connectedTopology = "Topologia conectada";
stroke.connectedTopology.help = "Esta opção esculpirá apenas os vértices associados à superfície escolhida.

Normalmente, isto é usado para a ferramenta Mover, caso você queira mover exclusivamente uma parte que cruze com outra parte, por exemplo.";
// Only sculpt the vertex that points toward the camera
stroke.onlyFrontFace = "Apenas vértice da face frontal";
stroke.onlyFrontFace.help = "Esta opção ignorará os vértices da face de trás.

Isto pode ser útil para pintar parte de uma geometria fina sem afetar o outro lado.

Isto também funciona para esculpir, mas alguns artefatos podem aparecer.";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.onlySameSide = "Apenas vértice do mesmo lado";
stroke.onlySameSide.help = "Ignore os vértices que apontam na direção oposta da deformação.";
// Module the intensity of the sculpting operation by using a falloff curve
stroke.curveFalloff = "Decaimento";
stroke.onlyLasso = "Ajustes ativos somente para a ferramenta de laço.";
// Alpha
stroke.alpha = "Alfa";
// Invert the pixel (black <-> white)
stroke.alphaInvert = "Inverter pixels";
// Repeat the alpha image (pattern)
stroke.alphaWrap = "Matrização";
// No repeat pattern
stroke.alphaWrap.none = "Nenhum";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alphaWrap.repeat = "Repetir";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alphaWrap.mirror = "Espelhar";
stroke.alphaProject = "Método";
// Project the alpha perpendicularly onto the surface
stroke.alphaProject.surfaceContinuous = "Superfície";
// Project the alpha onto the surface in the direction of the camera view
stroke.alphaProject.screenFixed = "Projetado na tela";
stroke.alphaRotation = "Rotação";
stroke.alphaRotation.lock.help = "Lock the alpha orientation.

If the rotation is unlocked, the orientation will follow the stroke direction in real-time.";
// Repeat the image
stroke.alphaTiling = "Matrização";
// Scale the image (make it bigger or smaller)
stroke.alphaScale = "Dimensionamento";
stroke.alphaScale.help = "No valor mínimo, o quadro alfa fica dentro do raio da ferramenta de círculo.";
// Middle-point value at which no deformation occurs
stroke.alphaMidValue = "Valor médio";
stroke.alphaMidValue.help = "Valor de ponto médio no qual nenhuma deformação ocorre.

(Valor médio = 0)
- Preto: sem deslocamento
- Branco: deslocamento positivo

(Valor médio = 0.5)
- Preto: deslocamento negativo
- Branco: deslocamento positivo

(Valor médio = 1)
- Preto: deslocamento negativo
- Branco: sem deslocamento";
// Stroke type
stroke.strokeType = "Tipo do traçado";
// Sculpt and paint along the brush stroke at regular spacing
stroke.strokeTypeDot = "Ponto";
// Sculpt continuously
stroke.strokeTypeDrag = "Arrasto";
// Lock a region and move it around
stroke.strokeTypeGrab = "Seguro";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.strokeTypeGrabRadius = "Seguro - raio dinâmico";
// Lock a region and sculpt it by changing the tool intensity
stroke.strokeTypeGrabIntensity = "Seguro - intensidade dinâmica";

// Symmetry
symmetry = "Simetria";
symmetry.enable = "Ativada";
// Display a warning (the feature is only available for mesh object)
symmetry.primitiveWarning = "A simetria de pincel está disponível apenas para primitivas validadas, com exceção do Triplano.";
symmetry.plane.title = "Planos";
symmetry.toolIgnore = "A ferramenta atual ignora a simetria.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Radial";
symmetry.radialX = "Radial X";
symmetry.radialY = "Radial Y";
symmetry.radialZ = "Radial Z";
// Synonym: Offset
symmetry.offset.title = "Deslocamento";
symmetry.offsetX = "Deslocamento X";
symmetry.offsetY = "Deslocamento Y";
symmetry.offsetZ = "Deslocamento Z";
// Number of clones
symmetry.count.title = "Contagem";
symmetry.countX = "Contagem X";
symmetry.countY = "Contagem Y";
symmetry.countZ = "Contagem Z";
// method
symmetry.method = "Método:";
symmetry.method.help = "- Local
O plano de simetria será movido com a malha ao usar uma das ferramentas de transformação (Gizmo ou Transformar).

- Cena
O plano de simetria é fixo e não se move.";
// Local means: in the coordinate of the scene
symmetry.methodWorld = "Cena";
// Local means: in the coordinate of the object (internal)
symmetry.methodLocal = "Local";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Virar objeto";
// Mirror the mesh
symmetry.mirror = "Espelhamento";
symmetry.mirror.help = "Tente reaplicar a simetria sem afetar a topologia.

A simetria radial será ignorada.

Se a topologia não puder ser mantida por não ser considerada simétrica, você terá a opção de aplicar o espelhamento.";
symmetry.mirrorLeftToRight = "Esquerda/Direita";
symmetry.mirrorRightToLeft = "Direita/Esquerda";
symmetry.mirrorFail = "Falha ao aplicar simetria.

Deseja espelhar a malha para aplicar simetria?";
symmetry.mirrorUseMasking = "Proteger área com máscara";
symmetry.mirrorUseMasking.help = "Mantenha intacta a área com máscara.

Esta opção será ignorada em topologias não simétricas (ou em superfícies desconectadas, como olhos).";
// Reset the symmetry plane position
symmetry.reset = "Redefinir";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Centro do objeto";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "Centro da cena";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Orientação";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Mostrar linha";
// Display the symmetry plane in 3d
symmetry.showPlane = "Mostrar plano";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Editar Gizmo";
symmetry.edit.warning = "A edição de simetria é experimental.";
symmetry.edit.help = "Você pode definir livremente o plano de simetria.

Este recurso é um pouco experimental e seu uso é desaconselhado.";

// Ideally <10 chars
tool.dynTopo = "TopoDin";
// Ideally <10 chars (Symmetry)
tool.symmetry = "Simetria";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "Espelhar";
// Ideally <10 chars
tool.clay = "Argila";
// Ideally <10 chars (Subtract)
tool.clay.sub = "Sub";
// Ideally <10 chars
tool.brush = "Pincel";
// Ideally <10 chars
tool.move = "Mover";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "Normal";
// Ideally <10 chars
tool.drag = "Arrastar";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "Suavizar";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Relaxar";
// Ideally <10 chars (Paint mask)
tool.mask = "Máscara";
// Ideally <10 chars
tool.mask.unmask = "Desmascara";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "MáscSel";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "Borrar";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "Achatar";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Preencher";
// Ideally <10 chars (Layer brush)
tool.layer = "Camada";
// Ideally <10 chars
tool.crease = "Vincar";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "Aparar";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Dividir";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "Projetar";
// Ideally <10 chars
tool.inflate = "Inflar";
// Ideally <10 chars
tool.pinch = "Apertar";
// Ideally <10 chars
tool.nudge = "Empurrar";
// Ideally <10 chars
tool.stamp = "Carimbo";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "ApagCamada";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.select = "Selecionar";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "Gizmo";
// Ideally <10 chars
tool.gizmo.editPivot = "Pivô";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "Ajustar";
// Ideally <10 chars (Snap translation)
tool.gizmo.moveSnap = "Ajustar";
// Ideally <10 chars (Local space)
tool.gizmo.local = "Local";
// Ideally <10 chars (Local space)
tool.gizmo.world = "Cena";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "Transformar";
// Ideally <10 chars (Translate the object)
tool.transform.move = "Mover";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "Girar";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "Escala";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "Ajustar";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "Medir";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "Visualizar";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "Torno";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "Tubo";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "Inserir";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "Virar";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "Visualizar";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "Laço";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Curva";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Polígono";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Caminho";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "Retângulo";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "Elipse";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "Linha";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Fechado";

// Popup when editing the vertical sliders on the left
tool.slider.radius = "Raio $0";
// Popup when editing the vertical sliders on the left
tool.slider.intensity = "Intensidade $0 %";

tool.settings = "Ajustes";
tool.settings.none = "Esta ferramenta não tem ajustes específicos.";

// Flatten distance offset
tool.clay.flattenOffset = "Deslocamento do plano";
tool.crease.pinchFactor = "Força do apertar";

tool.layer.removeInfluence = "Usar dados da camada";
tool.layer.removeInfluence.help = "Esta opção só é ativada quando há uma camada selecionada.

Ela usará os dados da camada para limitar o deslocamento sobre os traçados.";
tool.layer.noLayerSelected = "Esta opção só está disponível quando há uma camada selecionada";

tool.flatten.warning = "Estas opções são experimentais e podem ser removidas no futuro!";
tool.flatten.planeLockOrigin = "Bloquear origem do plano";
tool.flatten.planeLockNormal = "Bloquear direção do plano";
tool.flatten.planeAverageOrigin = "Média da origem do plano";
tool.flatten.planeAverageNormal = "Média da direção do plano";
tool.flatten.planeOffset = "Deslocamento do plano";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "Sync";
tool.syncInstance.message = "The new object will be added on all other instances!";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Vértice persistente na borda";

tool.paint = "Pintura";
// Erase the painting
tool.paint.erase = "Apagar";
// Only paint the part of the mesh above a certain height
tool.paint.depthFilter = "Filtro de profundidade";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Filtro de camada";
tool.paint.layerFilter.help = "Use esta opção caso deseje apenas repintar uma área já pintada de uma camada.";

// Clear the painted mask
tool.mask.clear = "Limpar";
// Invert the painted mask
tool.mask.invert = "Inverter";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Invert mask (connected)";
// Blur the painted mask
tool.mask.blur = "Desfocar";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Nitidez";
// The thickness of the extracted mesh (from the painted mask)
tool.mask.thickness = "Espessura da casca";
// Smooth the border of the extracted mesh (from the painted mask)
tool.mask.polish = "Suavidade da borda";
// Extract a new mesh from the painteed mask and carve/emboss the base mesh
tool.mask.engraveEmboss = "Baixo / Alto relevo";
// Extract a new mesh from the painted mask
tool.mask.extract = "Extrair";
// Extract two new mesh from the painted mask and from the unmasked area
tool.mask.split = "Dividir";
// How should we close the topology of the extracted object
tool.mask.closeMask = "Ação de fechamento (com máscara):";
// How should we close the topology of the extracted object
tool.mask.closeUnmask = "Ação de fechamento (sem máscara):";
// How should we close the topology of the extracted object
tool.mask.closeAction = "Ação de fechamento:";
// Do not close the mesh (leave it open)
tool.mask.closeActionNone = "Nenhuma";
// Close the mesh with a hole-filling algorithm
tool.mask.closeActionFill = "Preencher";
// Close the mesh by adding a thickness on the surface
tool.mask.closeActionShell = "Casca";
// Close the mesh by using the layer data as a difference thickness
tool.mask.closeActionLayer = "Camada";
tool.mask.closeAction.help = "- Nenhuma
Apenas extrai a parte e deixa as partes extraídas abertas.

- Preencher
Não use esta opção em superfícies planas.

- Casca
Use o valor de espessura para fechar a forma extraída.

- Camada
Extraia a diferença da camada (somente submenu de camada).";

// Transform/Matrix
tool.matrix = "Matriz";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.apply = "Destino";
// Automatic
tool.matrix.apply.auto = "Auto";
// Transform the object alone (the children stands still)
tool.matrix.apply.object = "Objeto";
// Auto apply the transform on the vertices
tool.matrix.apply.vertex = "Vértice";
// Transform the object and its children
tool.matrix.apply.group = "Grupo";
tool.matrix.apply.help = "- Auto
Por padrão, funciona de maneira similar à opção Grupo.
Se a malha tiver máscara ou a simetria do Gizmo estiver ativada, o funcionamento será igual a Vértice.

- Vértice
Tente aplicar a transformação nos vértices (não funciona em primitivas não validadas). As instâncias também serão afetadas.

- Objeto
Mova apenas o objeto, ignorando a simetria e a máscara.
Apenas o nó editado será movido, os secundários permanecerão parados.

- Grupo
Mova o nó, ignorando a simetria e a máscara. O restante da hierarquia também será transformado.";
// Operation on the mesh
tool.matrix.action = "Operação";
tool.matrix.action.help = "- Mover origem
Mova a malha para a origem da cena.

- Redefinir
Redefina a transformação da malha à identidade.

- Selar
Aplique a matriz ao vértice e redefina a matriz. Visualmente, nada deve mudar.";
tool.matrix.translation = "Translação";
tool.matrix.rotation = "Rotação";
tool.matrix.scale = "Escala";
// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "Cisalhamento";
tool.matrix.uniformScale = "Escala uniforme";
tool.matrix.uniformScale.help = "O Nomad não é compatível com a escala não uniforme para transformar objetos. Isto será aplicado como uma transformação de vértice.";
tool.matrix.moveToOrigin = "Mover origem";
tool.matrix.resetTransform = "Redefinir";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "Selar";

tool.transform.tip = "Single tap with second finger to switch mode";

// Size of the gizmo
tool.gizmo.size = "Tamanho do widget";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "Entrada numérica";
tool.gizmo.allowInput.help = "Allow numerical input when tapping one of the gizmo widget";
// Angle threshold
tool.gizmo.linearRollThreshold = "Limite de rolagem da tangente";
tool.gizmo.linearRollThreshold.help = "O limite do ângulo para escolher entre um método de rolagem linear ou circular.

Um valor acima deste limite usará a rolagem circular.

Caso prefira a rolagem linear (direção da tangente), defina este valor em 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Ocultar ao interagir";
tool.gizmo.tap = "Mover pivô personalizado com um toque";
tool.gizmo.tap.help = "Esta opção só tem efeito no modo de pivô personalizado (Auto desativado).

- Nenhum
Nada acontece ao tocar na malha.

- Primeira ocorrência
Mova o Gizmo na primeira interseção.

- Meio corte
Mova o Gizmo na média das duas primeiras interseções.";
tool.gizmo.tapNone = "Nenhum";
tool.gizmo.tapFirstHit = "Primeira ocorrência";
tool.gizmo.tapMiddleStab = "Meio corte";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "Fixo";

// Fill the object's hole
tool.hole = "Preenchimento de furo";
tool.hole.fillHoles = "Preencher furos";
// synonym: Alternative method
tool.hole.bridges = "Booleano de espaço da tela";
tool.hole.bridges.help = "Com esta opção ativada, você pode perfurar o volume.
A inclinação do corte também seguirá a forma do corte mais fielmente.";
tool.hole.threshold = "Épsilon limite";
tool.hole.threshold.help = "O ajuste deste valor pode ajudar no algoritmo de preenchimento de furo.";
tool.hole.smoothing = "Suavização do furo";

tool.smudge.quality = "Qualidade";
tool.smudge.quality.help = "Altere a resolução dos pixels projetados. Valores mais baixos geram traçados mais rápidos.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Forma";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Quadrado";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Centralizado";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Círculo";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Centralizado";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Girar por grau";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Mostrar proporção áurea";

// Topology
topology = "Topologia";
// Synynom: detail value, density
topology.dynamic.detail = "Detalhe";
// See glossary
topology.multires = "Multirresolução";
topology.multires.help = "Mantenha várias resoluções de uma malha.

Se você fizer alterações em resoluções mais baixas, os detalhes das resoluções mais altas serão reprojetados ao alternar.

Camadas estão disponíveis em todas as resoluções.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "Inverter";
topology.multires.reverse.confirm = "Não foi possível criar a subdivisão base.

A topologia atual provavelmente não resulta de uma subdivisão.";
topology.multires.subdivide = "Subdividir";
topology.multires.subdivide.confirm = "A malha terá $0M de vértices, tem certeza?";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "Limite de subdivisão excedido, veja $0";
topology.multires.deleteLower = "Apagar mais baixa";
topology.multires.deleteHigher = "Apagar mais alta";
topology.multires.keepTriangles = "Manter triângulos";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "";
// Synonym: Flat subdivision
topology.multires.linear = "Subdivisão linear";
topology.multires.linear.help = "Simplesmente subdivida a malha, sem aplicar nenhuma suavização.";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Recriação da malha de voxels";
topology.voxel.help = "Tire uma amostra da malha em uma grade para recriar a malha.

Se o objeto não estiver fechado (à prova d’água), um algoritmo de preenchimento de furo será aplicado primeiro.

As camadas são reprojetadas depois de recriar a malha, mas a qualidade sofre degradação.";
topology.voxel.resolution = "Resolução";
topology.voxel.remesh = "Remalhar";
topology.voxel.sharp = "Manter bordas pontiagudas";
topology.voxel.sharp.help = "Esta opção é útil na maioria das vezes para operações booleanas primitivas simples.

Ela introduzirá distorção em certas áreas devido ao ajuste dos pontos nas bordas.";
topology.voxel.subLevel = "Construir multirresolução";
topology.voxel.subLevel.help = "Você pode recriar uma hierarquia multirresolução a partir da saída da recriação da malha de voxels.

Isto também ajuda a executar mais rápido e usar menos memória, especialmente quando o valor de detalhes dos voxels é alto.

Mas se o valor de detalhes dos voxels for baixo e você estiver em busca de muitos níveis multirresolução, os detalhes serão perdidos.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Remalhar";
topology.surface.detail = "Detalhe";
topology.surface.detail.help = "Ao contrário da recriação da malha de voxels, a recriação da malha da superfície não requer que a malha esteja fechada.

Ela também é compatível com máscaras, de forma que você pode proteger certas partes da malha contra alterações de topologia.

As camadas são atualizadas corretamente.";
topology.surface.method = "Método";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Uniformização";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Subdivisão";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Dizimação";
topology.surface.method.help = "Comportamento da topologia dinâmica:
- Uniformização: adicione e remova detalhes
- Subdivisão: adicione detalhes
- Dizimação: remova detalhes";
topology.surface.useMasking = "Proteger área com máscara";
topology.surface.useMasking.help = "The masked areas will protect the topology from being changed.";
topology.surface.extrapolate = "Extrapolação de vértice";
// DynTopo
topology.dynamic = "Topologia dinâmica";
topology.dynamic.activate = "Ativada";
topology.dynamic.activate.help = "Com a topologia dinâmica, as ferramentas de escultura podem subdividir ou simplificar a malha localmente em tempo real.

Este recurso pode afetar perceptivelmente o desempenho.

As camadas são atualizadas corretamente.";
topology.dynamic.method = "Detalhe baseado em...";
topology.dynamic.method.zoom = "Zoom";
topology.dynamic.method.radius = "Raio";
topology.dynamic.method.constant = "Constante";
topology.dynamic.method.help = "/- Zoom
O nível de detalhe é baseado na distância que você está superfície.

- Raio
A ferramenta de raio define a quantidade de detalhes.

- Constante
O detalhe é fixo e o valor de detalhe também é compartilhado com o controle de voxel.";
topology.dynamic.quality = "Preferir...";
topology.dynamic.quality.help = "Caso escolha Qualidade, as 2 principais diferenças são:
- O refinamento é aplicado antes do operador de escultura; você terá menos artefatos ao pintar ou esculpir com detalhes minúsculos
- O refinamento não é aplicado incrementalmente; se você esculpir detalhes minúsculos ou fizer traçados rápidos, a topologia sempre será refinada corretamente

Para ter um desempenho melhor (e caso planeje usar esta opção), considere ativar a opção de desenho parcial no painel de Ajustes.";
topology.dynamic.quality.speed = "Velocidade";
topology.dynamic.quality.quality = "Qualidade";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Usar pressão no raio";
topology.dynamic.usePressure.help = "Use esta opção caso deseje que a pressão da caneta na ferramenta de raio afete o nível de detalhe.";
// Decimate
topology.decimate.title = "Dizimação";
topology.decimate.title.help = "Tente manter o máximo possível de detalhes ao reduzir o número de polígonos.

Este recurso pode ser útil caso deseje exportar para impressão 3D.

Mas não o use caso deseje continuar esculpindo, já que isso pode produzir triângulos desnivelados.

Note que a área com máscara não será dizimada.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Dizimar";
topology.decimateTargetFaces = "Triângulos são destino";
topology.decimatePaintWeight = "Preservar pintura";
topology.decimatePaintWeight.help = "Valores mais altos tentarão preservar a pintura.

Defina este valor em 0 caso a pintura seja irrelevante.";
topology.decimateUniform = "Faces uniformes";
topology.decimateUniform.help = "Valores mais altos gerarão triângulos de tamanhos similares.";
// topology.decimatePreserveBorders = "Preserve borders";
// topology.decimatePreserveBorders.help = "Do not decimate the border of the mesh.";

// Unwrapping means compute UV (texture coordinates), it allows the object to receive on texture (wrap the texturing on the object)
topology.uv.title = "Cálculo Automático de UV";
// UV Unwrapping
topology.uvAtlas = "Cálculo Atlas";
// The operation can be very slow
topology.uvAtlas.warning = "Pode ser muito lento. Use menos de 100k vértices como destino.";
// UV Unwrapping (BFF best left untranslated, stands for Boundary First Flattening)
topology.uvBFF = "Cálculo BFF";
// Handles are topological holes (synonym: genus, hole)
topology.uvBFF.warning = "Can have overlaps if the mesh has handles!";
// Synonym: Point count? Singularity count ?
topology.uvBFFCones = "Contagem de cones";
topology.uvBFFCones.help = "Valores mais altos reduzirão a distorção de objetos complexos.

Valores mais altos levarão mais tempo para calcular.";
topology.uvDelete = "Apagar UVs";

// Transfer the vertex painting in the texture
topology.bake = "Selar pintura do vértice";
topology.bake.help = "Transfira a pintura do vértice para uma textura.

As cores do vértice são redefinidas no processo.";
topology.bakeResolution = "Resolução";

// Reset key-bindings/shortcuts
binding.reset = "Redefinir vínculos";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.materialPicker = "Seletor de Material";
// Edit the tool brush size/radius
binding.editRadius = "Raio da Ferramenta";
// Edit the tool brush size/radius
binding.editIntensity = "Intensidade da Ferramenta";
// Snap the camera
binding.viewFront = "Visualização Frontal";
// Snap the camera
binding.viewLeft = "Visualização Esquerda";
// Snap the camera
binding.viewTop = "Visualização Superior";
// Move/Translate the view
binding.panLeft = "Deslocar para a Esquerda (Visualização)";
// Move/Translate the view
binding.panRight = "Deslocar para a Direita (Visualização)";
// Move/Translate the view
binding.panForward = "Deslocar para a Frente (Visualização)";
// Move/Translate the view
binding.panBackward = "Deslocar para Trás (Visualização)";
// Move/Translate the view
binding.panUp = "Deslocar para Cima (Visualização)";
// Move/Translate the view
binding.panDown = "Deslocar para Baixo (Visualização)";
// Snap the view (while rotating)
binding.snapViewOnRotate = "Ajustar visualização (ao girar)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "Abrir (projeto)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "Adicionar (projeto)";
// Import an external scene file (replace current scene)
binding.import.open = "Abrir (importar)";
// Import an external scene file (add it to the current scene)
binding.import.add = "Adicionar (importar)";
// Select all the objects in the scene
binding.selectAll = "Selecionar Tudo";
// Rotate environment and the lighting
binding.rotateLighting = "Girar iluminação";

// Privacy policy
privacyPolicy.title = "Política de Privacidade";
privacyPolicy.reject = "Rejeitar";
// Hexanomad is the company name
privacyPolicy = "O Hexanomad não coleta nenhum dado do Nomad Sculpt.";

// version trial
version.buyWeb = "A versão da web é apenas uma demonstração";
version.buyFull = "Mudar para versão completa";
version.restorePurchase = "Restaurar compra";

version.trialHistory = "Versão de avaliação: possível desfazer/refazer 4 vezes";
version.trialLayer = "Trial version: 1 layer per object";
version.trialOneProject = "Versão de avaliação: apenas 1 projeto ativo";
version.trialNoImport = "Versão de avaliação: proibido importar";
version.trialNoExport = "Versão de avaliação: proibido exportar";

version.fullFeatures = "- Compra única
- Desfazer/refazer ilimitado
- Camadas ilimitadas
- Salve e carregue
- Exporte e importe";
