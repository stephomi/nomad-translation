// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "请确认是否操作？";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "确认";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "好";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "取消";

// Experimental feature
experimental = "实验性功能！";

// On single tap (should be short)
ontap = "点击";

clipboard = "剪贴板";
clipboard.copy = "复制";
clipboard.paste = "粘贴";

// memory size
bytes = "字节";
kB = "kB";
MB = "MB";
GB = "GB";
TB = "TB";

// Noun
instance = "实例";

// Same value (usually for axis, e.g: x == y == z)
uniform = "均匀";

sync = "同步";

// position
position.top = "顶部";
position.bottom = "底部";
position.left = "左侧";
position.right = "右侧";
position.center = "中心";
// direction
direction.up = "顶部";
direction.down = "底部";
direction.left = "左侧";
direction.right = "右侧";
// 3d cube
cube.top = "顶";
cube.bottom = "底";
cube.left = "左";
cube.right = "右";
cube.front = "前";
cube.back = "后";

// Name of an item (object, tool, etc)
item.name = "重命名";
// Add a new item (object, tool, etc)
item.new = "创建";
// Rename an item (object, tool, etc)
item.rename = "重命名";
// Add a new item (object, tool, project, etc)
item.add = "添加";
// Update an item image with a new image (synonym: Update)
item.replace = "替换";
// Save an item (object, tool, etc)
item.save = "保存";
item.save.confirm = "确认保存 $0？";
// Update an item (update camera view point, etc)
item.update = "更新";
// Reload last save of an item (object, tool, etc)
item.lastSave = "上次保存";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "要加载上一次保存的文件吗？";
// Reset an item to its initial value (object, tool, etc)
item.reset = "重置";
item.reset.confirm = "确认要重置吗？";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "实例";
// Uninstance the object, make the object real
item.uninstance = "去实例";
// Clone an item (object, tool, etc)
item.clone = "克隆";
// Delete an item (object, tool, etc)
item.delete = "删除";
item.delete.confirm = "请确认是否删除？";
item.delete.confirm.yes = "确认删除";
// When we delete the item but the image is used somewhere
item.delete.used = "图片使用";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "转为节点";
// Item visibility (object, layer, etc)
item.visible = "可见";
// Show an item (object, layer, etc)
item.show = "显示";
// Hide an item (object, layer, etc)
item.hide = "隐藏";
// Select an item (object, layer, etc)
item.select = "选择";
// Unselect an item (object, layer, etc)
item.unselect = "取消选中";
// Merge an item with another one below (layer)
item.mergeDown = "向下合并";
// The order of an item in a list
item.order = "顺序";
// Focus on previous item
item.previous = "上一项";
// Focus on next item
item.next = "下一步";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "锁定";
// No item selected
item.none = "无";

// Search something (text entry to filter item)
search = "搜索";

// Three-state toggle button (Auto, Off, On)
toggle.on = "开";
// Three-state toggle button (Auto, Off, On)
toggle.off = "关";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "自动";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "正在载入数据，请稍等...";
loading.reprocess.cancel = "跳过缩略图生成？";

access.title = "无障碍";
access.window = "辅助窗口";
access.pinch = "挤捏";
access.drag = "拖拽";
access.rotate = "旋转";
access.roll = "滚动";

// Color of an object
material.color = "颜色";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "粗糙度";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "光泽度";
// Whether the material is a metal or not
material.metalness = "金属度";
// How much light a surface will reflect
material.specular = "高光亮度";
// Light that the surface can emit (glow)
material.emissive = "自发光";
// Normal map (synonym: detail, bump)
material.normal = "法線";
// flip y coordinate
material.normal.flipY = "翻转Y";
// Ambient Occlusion (AO)
material.occlusion = "环境光遮挡";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "纹理";
// Textures/Image
material.texture = "纹理";
// A warning indicating that the mesh has no UVs
material.warningNoUVs = "无UVs！";
// Texture filtering https://en.wikipedia.org/wiki/Texture_filtering
material.texture.filter = "过滤";
// Nearest Filtering (closest sample)
material.texture.nearest = "最近";
// Bilinear Filter
material.texture.linear = "线性";
// Mipmap filtering
material.texture.mipmap = "Mipmap";
// Triplanar mapping
material.projection = "视图";
material.projection.triplanar = "三面体";

// Minify
about.minify = "全屏显示";
about.minify.help = "在设备支持的情况下，可以通过四指触碰屏幕来开关全屏显示";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "旋转展示";
// Rotation center of the turntable
about.turntable.pivot = "旋转中心";
// Keep current pivot
about.turntable.pivot.keep = "保持当前";
// Turntable pivot will be at the center of the scene
about.turntable.pivot.scene = "场景";
// Make the entire scene turn around (speed of the animation)
about.turntable.speed = "相机速度";
// Stuffs that I used to make the app
about.credits = "鸣谢";
// Link to open source projects that I used for the app
about.credits.openSource = "开源项目";
// Only translate the &
about.credits.arts = "MatCap与HDRI";
// Change languages of the app
about.languages = "用户语言";
about.languages.help = "翻译文件可在 $0获得";
// Link to the App Website
about.website = "官方网站";
// Link to the App Forum
about.forum = "交流论坛";
// Link to the App Manual
about.manual = "使用指引";
// Link to the App Email
about.mail = "联系邮箱";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";
// Link to the App Threads account
about.threads = "Threads";

// The user canceled an operation that was running
alert.aborted = "操作已中止！";
// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "该对象没有孔洞！";
// No operation occured because the mesh is already manifold
alert.manifold.already = "网格已经是流形的！";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "当前对象不可见！";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "没有可裁切的对象。";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "不可裁剪：选择区域完全包含了被裁减对象";
// In order to extract something, the mesh needs to have painted mask
alert.extract.none = "没有可提取对象！";
// In order to split something, the mesh needs to have painted mask
alert.extract.split.none = "没有可分离对象！";
// List of disabled features when View Mode is selected
alert.view.disabled = "在浏览模式下禁用的功能：";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "编辑锚点";
// The object needs to have two parts disconnected
alert.separate.fail = "该对象只有一部分，所以无法分开！";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "网格重构成功！";
alert.voxelRemesh.empty = "网格重构失败，因为结果并未产生面。";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "输入无效！";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "将复制此对象";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "将实例此对象";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "编辑轴心模式";
alert.mask.full = "蒙版 = 100%!";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "编辑对象模式";
// See Glossary (DynTopo)
alert.dynamic.enable = "启用动态拓扑";
// See Glossary (DynTopo)
alert.dynamic.disable = "禁用动态拓扑";
alert.colorPicker = "用手指在对象上拖动选择一个颜色";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "轻点即可退出切换模式";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "简单点击退出编辑对称模式。";
// Show the painted mask on the mesh
alert.mask.show = "显示遮罩";
// Hide the painted mask on the mesh
alert.mask.hide = "隐藏遮罩";
// Selection refers to the objects that are currently selected
alert.selection.lock = "锁定所选项";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "解锁所选项";
// Hide the objects that are not selected
alert.selection.isolate = "隐藏未所选项";
// Show the objects that are hidden
alert.selection.showAll = "显示全部";
// Project quick saving
alert.quickSave = "正在保存...";
// Painting on the object was hidden but the user did paint the object
alert.forcePainting.fill = "显示图层绘画已打开";
// Painting on the object was hidden but the user started to paint on the object
alert.forcePainting.tool = "显示绘画，该对象已被画";
// See Glossary (Multiresolution)
alert.multiresLost = "高分辨率将丢失！";
// Boolean cut mode will ignore some features
alert.booleanIgnored = "布尔操作将忽略被遮罩或隐藏的区域！";
// The user is starting an operation that can lead to a crash
alert.range.warning = "过高的分辨率将会占用大量内存！";
// Autosave popup
alert.autoSave.auto = "将在$0秒后自动保存";
// The selected object doesn't have any layers
alert.needLayer = "使用当前工具需要激活一个图层。";
// The user decided to hide the painting on the objects
alert.paintingHidden = "绘画已被隐藏！";
// The user decided to hide the masking on the objects
alert.maskingHidden = "遮罩已隐藏！";
// The user decided to display hidden faces
alert.hideIgnored = "隐藏被忽略了！";
// The selected object doesn't have any layers
alert.noPartialWireframe = "打开线框显示时，局部绘画将被禁用。";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "如果您想在使用投影仪时避免透视偏差，建议在相机设置里切换到正交视图。";
// Trial version has a limited number of undo
alert.state.trial = "试用版本的撤销次数已用完。";

background = "背景";
// A flat color will be displayed in the background of the scene
background.color = "颜色";
// 2 color with rotation
background.gradient = "颜色渐变";
// The environment (HDRI) will be displayed in the background
background.environment = "环境";
background.blur = "模糊";
background.exposure = "曝光";

// Image that the artist uses as a reference
background.imageEnable = "参考图像";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "覆盖";
// Opposite of transparency (Alpha)
background.imageAlpha = "不透明度";
background.imageReset = "重置参数";
background.imageTransform = "变换";
// X screen coordinate of the image reference
background.imageX = "X轴位置";
// Y screen coordinate of the image reference
background.imageY = "Y轴位置";
// Rotation of the reference image
background.imageRotation = "旋转";
// Scale of the reference image
background.imageScale = "缩放";

// Blend: normal
blend.normal = "法線";
// Blend: darker
blend.darker = "更暗";
blend.darker.darken = "变暗";
blend.darker.multiply = "正片叠底";
blend.darker.linearBurn = "线性加深";
blend.darker.colorBurn = "颜色加深";
// Blend: lighter
blend.lighter = "更亮";
blend.lighter.lighten = "减淡";
blend.lighter.screen = "屏幕分辨率";
blend.lighter.linearDodge = "线性减淡";
blend.lighter.colorDodge = "颜色减淡";
// Blend: contrast
blend.contrast = "对比度";
blend.contrast.hardLight = "强光";
blend.contrast.softLight = "柔光";
blend.contrast.overlay = "覆盖";
blend.contrast.hardMix = "实色混合";
blend.contrast.linearLight = "线性光";
blend.contrast.vividLight = "生动光";
blend.contrast.average = "平均";
// Blend: inversion
blend.inversion = "反相";
blend.inversion.exclusion = "排除";
blend.inversion.difference = "差异";
// Blend: cancelation
blend.cancelation = "取消";
blend.cancelation.divide = "除法";
blend.cancelation.subtract = "减去";
// Blend: component
blend.component = "组件";
blend.component.luminosity = "亮度";

// Camera (point of view in 3d)
camera = "相机";
cameras = "相机";
camera.view = "浏览模式";
// Copy the views
camera.updateView = "更新视角？";
// Add a new camera
camera.addView = "添加视角";
// Focus on the camera
camera.focus = "聚焦";
// Add on the camera camera
camera.focusOn = "聚焦在$0";
// Camera projection, Orthographic or Perspective
camera.projection = "视图";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "正交视图";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "透视视图";
// camera Vertical Field of View
camera.fov = "垂直视角";
// Camera Field of View hint
camera.focal = "聚焦$0mm(35mm传感器)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "旋转";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "转盘";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "轨迹球";
camera.rotation.trackball.help = "轨迹球提供了更多的自由度，让您可以用两个手指滚动相机。";
// Camera interaction mode, 1st person view
camera.firstPerson = "第一人称视角";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "相机速度";
// Camera rotation sensitivity
camera.speed.rotation = "旋转";
// Camera translation sensitivity
camera.speed.panning = "平移";
// Camera zooming sensitivity
camera.speed.zooming = "缩放";
// Reset camera position
camera.resetView = "重置视图";
// Align the view (snap to nearest 90° angle)
camera.snapView = "固定视图";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "相机视图已调正（正交）";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "切换为正交视图";
camera.snapOrthographic.help = "此功能也适用于角落的方位视图。";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "视图中心点";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "双击对象";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "双击背景";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "切换";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "选区";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "场景";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "双击后更改";
camera.doubleTapPivot.help = "双击对象表面以更改旋转轴心。";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "隔空新建轴心";
camera.airPivot.help = "即使缩小到对象外也允许新建轴心。";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "平移/缩放后改变";
camera.autoPivot.help = "双指移动相机后，轴会随之移动。";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "聚焦";
camera.doubleTapFocus.help = "双击物体表面后视图中心将移动至该点。";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "选择多项";
// There is 0 nodes/items selected
context.noSelection = "无选中项";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "预设";
// Quick curve x side shift
curve.shift = "Shift";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "B样条";
curve.bspline = "B样条";
curve.precision = "精度";
// snap
curve.snap = "吸附";
curve.snap.offset = "偏移";
curve.snap.offset.help = "当偏移值为100%时，偏移后的距离即为圆管半径。";
curve.snap.surface = "表面";
curve.snap.vertex = "顶点";
curve.snap.grid = "网格（如果贴合）";
// Regular spaced sampling
curve.uniform = "均匀";
curve.uniform.help = "曲线将以规律间隔进行采样，以确保均匀密度。

您可以禁用此选项，通过在曲线上添加新的控制点来稍微控制边缘环。";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "以对称方式显示衰减。

此选项仅是一个视觉提示，它不会影响衰减本身";
curve.radius = "半径";
curve.twist = "扭曲";
curve.spiral = "螺旋";
curve.spiral.twist = "扭转角度";
curve.spiral.scale = "缩放";
curve.spiral.offset = "偏移";
curve.spiral.angle = "角度偏移";
curve.pivot = "编辑原点";
curve.pivot.self = "曲线";
curve.pivot.children = "子项";

// Set the desired FPS (frame per second, refresh rate)
debug.targetFPS = "目标 FPS";
debug.targetFPS.help = "禁用时，默认值意味着它将与显示器的刷新率同步。";

// Warning about UVs (using extra memory)
debug.uvPrimitive.warning = "如果您不再需要UV选项，请禁用该选项以释放更多内存。";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "规格化UV选项";
debug.uvNormalize.help = "Nomad将会让所有选定面的UV适配 [0-1] 纹理空间。";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "启用BFF UV";
debug.uvBFF.help = "使用BFF算法来展平UV。

请注意，如果对象的拓扑网格与正方体或球体有很大差别的话，结果有可能会产生重叠。";

// Debug option, display an window with some debugging logs
debug.logs = "调试日志";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "高度图";
// Debug options, graphical stuffs
debug.graphics = "图形";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "制作商店缩略图";

// Empty list: there is no projects
file.project.empty = "您还没有保存该项目！";
// The current opened project has some unsaved changes
file.project.unsaved = "更改未保存！";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "如不保存，您的更改将会丢失！";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "上一次手动保存的预览";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "这是试用版本，您将无法重新打开当前项目！";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "这是试用版本，您只能打开当前项目！";

file.project = "项目";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "保存";
// E.g: Save "my_project"?
file.project.save.confirm = "确认保存 $0？";
// Overwrite another project
file.project.saveAs = "另存为";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "确认覆盖 $0？";
// Open a project
file.project.open = "打开";
// E.g: Open "my_project"?
file.project.open.confirm = "确认打开 $0？";
// Load another project and add/append all its data to the current scene
file.project.add = "添加到场景";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "确认添加 $0 至当前项目？";
// Reset the scene and create a new project
file.project.new = "新建";
file.project.new.confirm = "确认新建场景？";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "确认删除 $0？";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "删除 $0？

这是当前打开的项目！";

// Auto save section
file.project.autoSave = "自动保存";
file.project.autoSave.confirm = "确定要禁用自动保存吗？";
file.project.autoSave.help = "每隔一段时间将您的项目另存到一个单独的文件。

这个自动保存文件可以在以下目录找到：";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "自动提醒";
// In minutes
file.project.autoSave.minutes = "自动保存间隔";
// Delete the current autoSave data
file.project.autoSave.delete = "删除自动保存的数据";

// color space (linear or srgb), do not translate linear/srgb if there is a doubt
file.colorSpace = "色彩空间";
file.colorSpace.help = "如果颜色看起来不正确，尝试切换此选项。";
file.colorSpace.linear = "线性";
file.colorSpace.srgb = "sRGB";

// Configure imports option
file.importSettings = "导入选项";

// Load interface preference settings when opening a scene file
file.import.guiSettings = "加载项目GUI设置";
file.import.guiSettings.help = "当您打开或导入项目文件时，同时加载项目中包含的GUI设置。";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.import.obj.splitByGroup = "按组拆分OBJ";
file.import.obj.splitByGroup.help = "启用该选项后，Nomad会将OBJ文件的各个顶点组拆分为单独的对象。";
// Merge all the object layers at when loading a file (deleting them in the process)
file.import.mergeLayers = "合并图层";
// Ignore the textures present in the file to load
file.import.skipTextures = "忽略纹理";
// Do not fiddle with the object topology when loading the file
file.import.keepTopology = "保留拓扑";
file.import.keepTopology.help = "如果你不希望Nomad对导入的网格进行拓扑处理，请勾选此选项。

应用将不会：
• 重新排序顶点和面
• 删除重叠顶点和面
• 移除未使用顶点";

// Import file section
file.import.title = "导入";
file.import.title.help = "支持导入的格式：";
// The user imports a scene file that will replace the current scene
file.import.open = "打开";
file.import.open.confirm = "确定导入新文件？";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "添加到场景";
file.import.add.confirm = "确定添加新文件？";

// Export scene file
file.export.title = "导出";

file.select.include = "包括";
file.select.all = "全部";
file.select.visible = "可见";
file.select.selected = "已选";
file.select.unselected = "未选择";

// Export the current selected objects instead of the entire scene
file.onlySelection = "只导出选择部分";
file.onlySelection.help = "只导出当前选择部分，而不是整个场景。";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "转换为四边形网格";
file.convertToQuad.help = "通过将相邻的三角形合并的方式，将模型网格转换为四边形。";
// ----------------------------------------------
// Whether we include the textures in the exported file
file.export.texture = "纹理";
// Baking means transfering/converting
file.export.texture.help = "此选项不会把Nomad里绘制的顶点颜色烘焙到贴图上。";
// ----------------------------------------------
file.export.color0 = "顶点颜色";
file.export.color1 = "PBR绘画";
file.export.color1.help = "导出粗糙度、金属强度和蒙版绘制。这将被其他软件忽略。";
// ----------------------------------------------
// Whether we include normals vector in the exported file
file.export.normal = "法线";
file.export.normal.help = "如想在其他软件上打开该文件，请勾选此选项。
Nomad总是忽略法线，因为它将重新计算它们。";
// ----------------------------------------------
file.export.tangent = "正切";
file.export.tangent.help = "如果您希望在其他软件中打开此文件，请勾选此选项。

只有模型有法线贴图时，才会使用正切。

Nomad总是忽略正切，因为它会重新计算正切。";
// ----------------------------------------------
file.export.nomad = "导出 Nomad";
file.export.nomad.help = "Nomad Sculpt 内部文件格式。

此格式不会在其他软件上加载，主要用于重新导入。";
// ----------------------------------------------
file.export.gltf = "导出 glTF 2.0";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "图层";
file.export.gltf.layer.help = "将图层作为变形体导出。官方支持glTF，所以它应该也能在其他软件上工作。";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "图层绘画";
file.export.gltf.layerPaint.help = "将导出图层绘画。其他软件不会读取该属性。";
// ----------------------------------------------
file.export.obj = "导出OBJ格式";
file.export.obj.warning = "图层和额外的绘画（粗糙度、金属强度和蒙版）将会丢失。";
// Whether we include the vertex color in the exported file
file.export.obj.color = "顶点颜色";
file.export.obj.color.help = "只有部分3D软件能够识别。";
file.export.obj.color.help.append = "给顶点添加颜色信息。";
file.export.obj.color.help.hexa = "编码颜色的另一种方式。它也支持蒙版数据。";
file.export.obj.faceGroup = "面组";
file.export.obj.object = "写入对象";
file.export.obj.object.help = "保持对象分开。

禁用此选项将导出为单个实体。
如果您想使用Substance Painter的'Mesh ID / Polygroup'功能，您需要禁用此选项。";
file.export.obj.archive = "类型";
file.export.obj.archive.folder = "文件夹";
file.export.obj.archive.zip = "压缩文件";
file.export.obj.archive.help = "某些应用程序（如Google Drive、One Drive等）不支持文件夹导入，因此您可以改用压缩文件。";
// ----------------------------------------------
file.export.stl = "导出STL格式";
file.export.stl.warning = "图层和额外的绘画（粗糙度、金属强度和蒙版）将会丢失。";
// Whether we include the vertex color in the exported file
file.export.stl.color = "顶点颜色";
file.export.stl.color.help = "只有部分3D软件能够识别。";
// ----------------------------------------------
file.export.ply = "导出STL格式";
file.export.ply.warning = "图层和额外的绘画（粗糙度、金属强度和蒙版）将会丢失。";
// ----------------------------------------------
file.export.fbx = "导出FBX";
// ----------------------------------------------
// Advanced settings
settings.advanced = "高级设置";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "这些选项不会在设置中保存。";
settings.reset.title = "设置";
settings.reset.title.help = "这将重置应用的偏好设置。

以下资源会单独保存，因此不会被重置：
• 项目
• 键位绑定
• 工具预设
• HDR 环境
• 材质快照
• Alpha
• 纹理（笔刷）
• 参考图像

注意：任何与项目关联的任何设置都会被保留，例如灯光、后期处理、相机视图等";

// Reset preference settings button
settings.reset = "恢复默认设置";
settings.reset.confirm = "确定要重置偏好设置吗？";

// Render a screenshot of the scene
file.render = "渲染";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "显示界面";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "渲染分辨率";
file.render.renderRatio.help = "当该值为1.0时，软件渲染的图像分辨率保持不变。

如果你不能以特定的分辨率渲染，请使用这个选项（因为缺乏内存而崩溃）。";
// Desired size of the exported screenshot
file.render.size = "渲染尺寸";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "自定";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "屏幕分辨率";
// width of exported screenshot
file.render.width = "宽度";
// height of exported screenshot
file.render.height = "高度";
// export screenshot of the scene
file.render.export = "导出为png";
file.render.warn = "您当前导出的图片分辨率较高（$0x$1)！

请确认文件妥善保存后再继续导出，否则程序可能会因运存占用过高而闪退。";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "透明背景";
file.render.transparent.help = "打开此选项可以让您更方便地把渲染图导入到平面设计软件。

暂不支持导出部分透明对象。";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "使用全局压感设置";
pressure.useGlobal.help = "勾选后，所有工具都会使用相同的压感参数。

如您希望给此工具单独设定压感参数，请取消勾选。";

// Pencil pressure
pressure.title = "压感设置";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "此工具无法使用铅笔压感。";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "此工具会忽略压感设置。";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "半径";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "强度";
// Average pencil pressure event to get smoother result
pressure.average = "压力平滑";
pressure.average.help = "平均铅笔压力事件以获得更平滑的结果。";

// list of inputs allowing camera interaction
gesture.camera = "相机移动";
// list of inputs allowing sculpting interaction
gesture.sculpt = "雕刻";
// Select object
gesture.select = "选择对象";
// Finger/Touch input
gesture.finger = "手指";
// Stylus/Pencil
gesture.stylus = "触控笔";
// Mouse/Trackpad
gesture.mouse = "鼠标";

// long press to pick the color/material under the cursor
gesture.dropper = "选取材质";
gesture.dropper.help = "颜色/材料选择器可以通过在画布上长按来打开。

请注意，只有在当前画笔启用了绘画功能的情况下，它才能发挥作用。";

// Three fingers on screen
gesture.three.title = "三个手指";
gesture.three.light = "旋转照明";
gesture.three.light.help = "可使环境、灯光与MatCap旋转。";
gesture.three.radius = "工具半径";
gesture.three.intensity = "工具强度";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.finger.smooth = "将手指用于平滑";
gesture.finger.smooth.help = "此选项仅在启用雕刻工具时有效。";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "允许未识别的压感";
gesture.unknownPressure.help = "当您的触控笔无法使用压感或者您希望使用手指压感时，请勾选此选项。";

// Action when we press an Android pencil button
gesture.pencilAction.android = "触控笔按键";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "双击Pencil";
gesture.pencilAction.ios.help = "仅支持Apple Pencil第二代";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "无";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "添加或减去";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "单点快捷方式";
gesture.mask.oneTap.help = "轻点屏幕一下就能启用蒙版快捷方式，无需长按蒙版按钮快捷方式。

这将启用以下手势：
• 点击背景以反转此蒙版
• 点击蒙版区域以模糊此蒙版
• 点击非蒙版区域以锐化此蒙版";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.holdStroke = "笔刷";
gesture.mask.holdStroke.help = "长按将在 Mask 和 SelMask 之间切换，并开始新的笔画。

在笔画结束时，将选择回之前的工具。";
gesture.mask.holdIdle = "工具";
gesture.mask.holdIdle.help = "长按并在不移动的情况下释放以在 Mask 和 SelMask 之间切换。";

// Shortcut customization, choose the action that the shortcut will performan (select tool, etc)
gesture.shortcut = "快捷手";

// Shortcuts to undo/redo
gesture.history = "快捷手势";
gesture.history.help = "• 双指轻点撤销。
• 三指轻点重做。";
gesture.history.hold = "长按";
gesture.history.hold.help = "按住2/3个手指（连续）。";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "无法忽略手掌尺寸";
gesture.palmRejection.confirm = "如果您在雕刻时遇到问题，请务必关闭此选项！";
gesture.palmRejection.help = "如果手指与屏幕的接触面积超过设定值，屏幕将忽略手指的本次操作。

部分设备可能不支持此选项";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "最大尺寸阈值";

// Smoothing strategy
extract.polish.all = "全部";
extract.polish.sharp = "锐边";
extract.polish.border = "仅边界";
// Smooth the border in a way that it matches completely with its dual
extract.polish.syncBorder = "同步边界";
// topology of extracted mesh
extract.edgeLoop = "边缘循环（侧面）";
extract.edgeLoop.auto = "自动边缘循环";
extract.edgeLoop.division = "分段数";
// The thickness of the extracted mesh (from the painted mask)
extract.thickness = "厚度";
// Carve the mask into the surface
extract.carve = "雕刻";
// Extract a new mesh from the painted mask
extract = "抽壳";
// Preview extract
extract.preview = "预览";
// Extract two new mesh from the painted mask and from the unmasked area
extract.split = "分离";
// How should we close the topology of the extracted object
extract.action = "关闭操作：";
extract.action.help = "• 无
仅分离蒙版区域，并且不封闭对象。

• 填补
孔洞会被填补并光滑。
不要在平面上使用。

• Shell
通过增加厚度的方式来封闭图形。

• 图层
提取图层差异（仅限图层子菜单）。";
// Do not close the mesh (leave it open)
extract.action.none = "无";
// Close the mesh with a hole-filling algorithm
extract.action.fill = "填补";
// Close the mesh by adding a thickness on the surface
extract.action.shell = "抽壳";
// Close the mesh by using the layer data as a difference thickness
extract.action.layer = "层";

// uv part of revolution surface
genus.main = "主要";
genus.hole = "孔洞";
genus.bottom = "底部";
genus.top = "顶部";

// History, list of undo/redo
history = "历史记录";
// First "undo" state
history.root = "初始状态";
history.undoConfirm = "您确定要撤销所有操作吗？";
history.undoWarning = "如在此之后进行更改，之前的所有操作可能会被撤销。";
// Settings concerning the history stack of undo/redo
history.stack = "撤销/重做集";
// Actions to include in the undo/redo stack
history.include = "包括撤销/重做集";
// include lighting editing in the undo/redo
history.includeLights = "灯光";
history.includeLights.help = "停用该选项后，将仍包含使用Gizmo移动灯光，因为该选项会影响场景层级中的其他对象。";
// include postProcess editing in the undo/redo
history.includePostProcess = "后期处理";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCap与HDRI";
// Can limit the stack of undo/redo size
history.limitSize = "历史记录限制";
history.limitSize.help = "历史记录的最大容量。

历史记录会随着下一个操作记录而更新。";
// Limit the number of undo in the history stack
history.limitStack = "重做记录限量";
history.limitStack.help = "程序可保留的最大操作数量。

历史记录会随着下一个操作记录而更新。";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "重做次数限量";
history.rangeProtect.help = "如果您大幅更改历史记录，在重做大量操作之前会弹出提示框以确认重做。";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "恢复相机视角";
history.restoreCamera.help = "启用该选项后您可以在撤销或重做时同时恢复当时的相机视角。";
// Undo
history.undo = "撤销";
// Redo
history.redo = "重做";
// Shown during undo
history.state.undo = "撤销： $0";
// Shown during redo
history.state.redo = "重做： $0";
// Shown during undo/redo
history.state.symmetrySplit = "显示对比";
// Shown during undo/redo
history.state.voxelRemesh = "体素网格重构";
// Shown during undo/redo
history.state.surfaceRemesh = "表面网格重构";
// Shown during undo/redo
history.state.multiresLevel = "改变分辨率";

// Debugging/Inspect object material (view channel separately color, roughness, normal, uv, etc)
inspect = "检查器";
// Inspector but SHORT
inspect.short = "检查";
// Display the material channel on the background
inspect.onBackground = "背景上";
// Display the material channel on the mesh
inspect.onMesh = "网格上";
// Show UV seams
inspect.seams = "接缝";

// Interface customization
interface = "界面设置";

// UI customization: one item row will stands on one line (synonym: Inlined)
interface.compact = "UI：紧凑";

// UI customization: each row of the list will be bigger
interface.expandList = "UI：放大列表";
// UI customization: each row of the list will be bigger
interface.expandList.help = "使用一个UI选项就能方便列表管理。";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "添加快捷键（底部）...";

// Interface option (main base color)
interface.colorBase = "底色";
// Interface option (accent widget color)
interface.colorSelect = "色盘";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "面板透明度";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "模糊强度";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "面板颜色";

// Interface color style
interface.preset.title = "预设";

// Reset interface settings
interface.resetAll = "重置界面风格";
interface.resetAll.confirm = "确定要重置界面设置吗？";
// help popup when hovering
interface.hoverHelp = "悬停显示帮助弹窗";
// Interface option (main base color)
interface.iconSupport = "高对比度按钮";
interface.iconSupport.help = "一种替代的按钮样式，当按钮启用时使它们更加显眼。

如果设置为自动，Nomad将在启用/禁用之间的UI颜色对比度较低时使用这种模式。";
// Interface customization
interface.flipTop = "翻转顶部菜单栏";
// Interface customization
interface.flipBottom = "翻转底部菜单栏";
// Interface customization
interface.flipMiddle = "翻转侧边栏";
// list of tools
interface.toolbox = "工具箱";
// hide toolbox by default
interface.toolbox.hide = "隐藏";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.columns = "列数";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.rows = "行";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "重设排序";
// Colored text and icon
interface.toolbox.color = "彩色";
// Scale the interface
interface.scale = "界面缩放";
// Spacing between widgets
interface.cursorStep = "垂直间距";
// Width of the interface panels
interface.panelWidth = "面板宽度";
// Size of fonts
interface.fontScale = "字体大小";
// Inset
interface.inset.title = "边偏移";
interface.inset.title.help = "只有屏幕边缘的按钮存在问题时，您才可以更改这些值。

如果滑块已停用，Nomad将使用设备本身返回有效区域值。";

// (see Glossary for Layer)
layer = "图层";
layers.syncTransform = "同步变换";
layers.syncTransform.help = "启用后，所有未选中的图层将根据变换的旋转、缩放和倾斜进行调整。

如果其他图层不打算使用您所应用的新变换，请禁用此选项。

设置为自动时，只有可见的图层会被调整。";
// (see Glossary for Layer)
layers.lock = "保留顶层图层细节";
// (see Glossary for Layer)
layers.lock.yes = "是否锁定顶层图层？";
// (see Glossary for Layer)
layers.lock.warning = "雕刻时，在顶层图层的变形将被忽略。

但是这些图层的细节仍然可见。

只有顶层图层的细节比例较小时，此选项才有用。";
// (see Glossary for Layer)
layers.addLayer = "添加图层";
// (see Glossary for Layer)
layer.factors = "通道参数";
// (see Glossary for Layer)
layer.factor = "吸收系数";
// (see Glossary for Layer)
layer.offset = "偏移";
// Layer blend mode
layer.blendMode = "正常混合";
// (see Glossary for Layer)
layer.base = "基底";
layer.base.nothing = "没有可提取对象！";
layer.base.background = "背景材料";
layer.base.background.help = "如果激活，仅提取与背景材料不同的材料值。";
// (see Glossary for Layer)
layers.title = "图层";
// (see Glossary for Layer)
layers.title.help = "图层能够记录位置偏移和绘画，这对于非线性工作流程来说非常有用。
例如，通过试验不同的面部表情而不依赖于历史记录来撤消更改。

对于绘画数据，图层是从上到下排序的，所以上方的图层会遮盖下方的图层。

您可以使用`DelLayer` 工具来擦除当前图层上的绘画蒙版。";
layers.primitive = "基本体无法添加图层。";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "无";

light = "光线";
lights = "灯光";
// Intensity of light
light.intensity = "强度";
// Color of light
light.color = "颜色";
// Kelvin (the temperature unit)
light.kelvin = "开尔文";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "色温";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "光照方向";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "固定";
// The light will move along the camera
light.attachment.camera = "随相机移动";
light.attachment.help = "• 固定
灯光方向不会改变。

• 随相机移动
灯光方向随着相机视角而改变。";
// Light type (directional, spot, point)
light.type = "类型";
// Directional light (synonym: sun light)
light.type.directional = "定向光";
light.type.sun = "太阳";
// Directional light (synonym: sun light)
light.type.environment = "环境";
light.type.hdri = "HDRI";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "聚光灯";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "点光源";
// For directional light (angle jitter)
light.angle = "角度";
// For point/spot light (offset jitter)
light.size = "尺寸";
// Cone angle for spot angles
light.spot.angle = "入射角";
// Softness of the spot light
light.spot.softness = "柔和度";
// Position of the light
light.position = "位置";
// Enable or disable shadows for a light
light.shadow.cast = "显示阴影";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "点光仅支持屏幕空间阴影。";
light.shadow.type = "阴影类型";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "阴影贴图";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "屏幕空间";
light.shadow.type.screenspace.help = "此为实验性功能，可能会在未来发布版本中移除此功能。

此选项应与柔化阴影功能搭配使用。";
// Adjustment to fix artefacts
light.shadow.bias = "阴影偏差";
// How blurry the shadow is
light.shadow.softness = "边缘柔和度";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "接触阴影";
light.contact.help = "如果选中了“自动”，则只有最显眼的灯光才会有接触阴影。";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "容差";
// Activated the light
light.visible = "显示";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "重新定位";

// Object's material
material = "材料";
// See glossary
material.pbrRoughnessMetalness.warning = "粗糙度与金属强度仅在PBR着色模式下可用。";
// See glossary
material.pbrReflectance.warning = "反射率仅在PBR模式下可用。";
// See glossary
material.pbrRefraction.warning = "折射效果仅在PBR渲染模式下可用。";
// See glossary
material.pbrSubsurface.warning = "次表面仅在PBR模式下可用。";
// Value that says how much light will change direction when hitting the surface
material.ior = "折射率";
// an object-level value that overrides the roughness interior/surface of the mesh
material.paintingOverride = "覆盖绘画";
// The roughness in the inside is turbidity
material.paintingOverride.help = "起作用的有两种粗糙度，分别是作用于表面和内部的粗糙度。

但是仅有一种可绘制粗糙度，因此两种粗糙度拥有一样的值。";
// Glossiness is simply the opposite of roughness
material.refraction.surface = "表面";
// Synonym: turbidity
material.refraction.interior = "内部";
// Set the roughness of the object with a value of 0
material.paintGlossy = "漆面效果";
material.paintGlossy.help = "将对象表面材质的粗糙度变为0，从而呈现更锐利的折射效果。

该操作不会影响材质的颜色。";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "吸收效果";
material.absorptionEnable.help = "该效果能模拟光线穿过物体时被吸收的情况。

薄的部分会比较亮，因为它让更多的光线通过，而厚的地方会相对更暗。

最终效果由网格形状结构决定，仅使用网格厚度的近似值。";
material.absorptionFactor = "吸收系数";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "深度";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "半透明";
material.translucency.help = "您需要借助灯光投下阴影才能看到半透明度。";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "不透明度";
// Fully opaque material
material.type.opaque = "实心";
// See glossary
material.type.subsurface = "次表面";
material.type.subsurface.help = "为了获得最佳效果，您可以切换到PBR着色模式，并使用至少一个定向光源。在昏暗环境下效果最理想。";
// Transparency mode, alpha blending
material.type.blending = "正常混合";
material.type.blending.help = "可通过调节不透明度的值，以实现不同程度的透明效果。

请注意，由于实时渲染的性能限制，当您的模型形状过于复杂时，可能会出现明显的视觉伪影。";
// Transparency mode
material.type.additive = "叠加";
material.type.additive.help = "可通过调节不透明度的值，以实现不同程度的透明效果。

在此模式下，黑色会变成透明，白色不透明。与正常混合相比，该模式下出现的伪影会变少，但会使对象变亮。";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "抖动";
material.type.dithering.help = "加入一些噪点使颜色过渡更为平滑。";
// Simulate glass-like material
material.type.refraction = "折射";
material.type.refraction.help = "此模式可用于模拟出玻璃材料的质感。

由于实时渲染的性能限制，软件无法实现自折射和多层折射的效果。";
material.castShadows = "投射阴影";
material.receiveShadows = "接收阴影";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "不受光显示";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "翻转法线";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "反射率";
material.reflectance.help = "该参数能够控制非金属材质的高光效果。

大多数情况下，建议将该参数保持为默认值，即对应 0.04 的基础反射率。";
// Material preview in the viewport
material.preview = "预览材料颜色";
material.preview.help = "当您修改材质时，选定对象的视口中将显示预览。

在您与颜色、粗糙度、金属度、透明度和强度滑块交互时，预览将显示。";
// Menu name
menu.files = "文件";
// Menu name
menu.scene = "场景";
// Menu name
menu.multires = "多重网格";
// Menu name
menu.voxel = "体素";
// Menu name
menu.dynamic = "动态网格";
// Menu name (Synonym: Misc, Other)
menu.topology = "杂项";
// Menu name
menu.primitive = "基本体";
// Menu name
menu.render = "渲染";
// Menu name
menu.material = "材料";
// Menu name
menu.postprocess = "后期处理";
// Menu name
menu.camera = "相机";
// Menu name
menu.background = "背景";
// Menu name
menu.tool = "工具";
// Menu name
menu.stroke = "笔刷";
// Menu name
menu.alpha = "Alpha";
// Menu name
menu.filter = "过滤器";
// Menu name
menu.falloff = "衰减";
// Menu name
menu.paint = "绘画";
// Menu name
menu.symmetry = "对称";
// Menu name
menu.operation = "操作";
// Menu name (pencil pressure)
menu.pressure = "压感";
// Menu name
menu.gesture = "手势";
// Menu name
menu.layers = "图层";
// Menu name
menu.settings = "设置";
// Menu name
menu.interface = "界面";
// Menu name
menu.bindings = "绑定";
// Menu name
menu.history = "历史记录";
// Menu name
menu.historySettings = "设置";
// Menu name
menu.about = "关于";
// Menu name
menu.debug = "调试";

// Operation on the object (action)
mesh.holes = "孔洞";
// If the object has holes, the algorithm will close them
mesh.holes.close = "封闭孔洞";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holes.detail = "细节";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "分离";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "图层、绘画与模型细分将会丢失。";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "分辨率";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "强制转换为立方体";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "转换";
// Static object means "static topology"
mesh.static = "静态模型";
// See glossary
mesh.multires = "多分辨率";
// Dynamic topology
mesh.dynamic = "动态模型";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "应用全局材料";
paint.useGlobal.help = "如勾选此选项，其他工具的材质也将会与所选材质相同。

注意，它只考虑到粗糙度、金属度和颜色的设置。";
// The current tool will paint the object if this option is enabled
paint.usePainting = "启用绘图";
// If true save the textures data into
paint.preset.embed = "嵌入纹理";
paint.preset.embed.help = "纹理可以在 Nomad textures/ 文件夹中找到。
材质预设可以在 Nomad materials/ 文件夹中找到。

当此选项关闭时，材料预设仅引用 textures/ 文件夹内的纹理。

您可以启用此选项以在材料预设中复制纹理。
如果您想分享带有纹理的预设而不提供相关纹理，这可能很有用。";
paint.preset.embed.apply = "应用于所有材料";
// Factor/Opacity of paint tool
paint.intensity = "画笔强度";
// Apply the paint on the object
paint.paintAll = "全部上色";
paint.paintAll.help = "将当前材质应用到所选对象上。";
paint.paintAll.help.mask = "掩蔽区域将不受影响。";
paint.paintAll.help.hide = "隐藏区域将不受影响。";
paint.paintAll.help.opacity = "使用上方的工具绘画因子。";
paint.paintAll.help.layer = "图层的未绘区域将不受影响。";
paint.strokePainting.title = "上漆";
// Brush stroke texture
paint.texture.warningEnable = "您需要先勾选菜单顶部的“纹理贴图”后才能使用贴图绘制功能！";
paint.texture.warningIgnored = "当前工具无法使用纹理贴图功能！";
// use stencil mode
paint.stencil = "模板";
// Inherit stroke falloff option for the painting
paint.tool.help = "使用工具 Alpha、衰减和随机化器来调节绘画笔触的强度。

这些选项对于全面绘画功能被忽略，但在三平面变种中会考虑 Alpha。";
// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "请输入新名称";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "请输入新阈值";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "请输入新颜色代码（十六进制格式）";

// Post process effect
postprocess = "后期处理";
// Quality vs performance
postprocess.quality = "质量";
postprocess.quality.help = "激活这些选项可以提升质量，但会影响性能。";
// More samples means better quality but slower performance
postprocess.maxSamples = "最大采样值";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "最大实时分辨率";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "最大帧采样量";
postprocess.accumulateCount.help = "渲染停止前积累的最大帧数。

渲染停止后，Nomad不会进行任何操作，因此可以节省电量。

许多渲染功能得益于帧积累，尤其是：
• 柔化阴影
• 全局光照
• 反射(SSR)
• 环境光遮蔽
• 次表面
• 景深

高帧数对于柔化阴影和全局光照是最必要的。
如果停用上述功能，Nomad将更快完成渲染。";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "实时渲染分辨率";
postprocess.renderRatio.warning = "已被像素画效果覆盖。";
postprocess.renderRatio.help = "此选项对性能影响很大。
我们建议您将值保留在“x1.25”以下。

设置中不会保存该选项。";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "时间性抗锯齿（TAA）";
postprocess.taa.help = "减少相机移动时的闪烁。";
// Ditherhing pixel
postprocess.dithering = "抖动";
postprocess.dithering.help = "抖动像素以减少条带伪影。";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "屏幕空间反射（SSR）";
postprocess.ssr.warning = "SSR仅在PBR渲染模式下有效。";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "全局光照(SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "容差";
postprocess.ssgi.warning = "SSGI仅在PBR着色模式下可用。";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "环境光遮蔽（AO）";
// How far the effect spreads
postprocess.ssao.radius = "范围";
// How strong the effect is
postprocess.ssao.factor = "强度";
// Adjustment to fix artefacts
postprocess.ssao.bias = "曲率偏差";
postprocess.ssao.bias.help = "模型表面曲率将会影响效果的强度。";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "景深";
// The blur factor behind the focused point
postprocess.dof.blurFar = "远景模糊";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "近景模糊";
postprocess.dof.focusTip = "点击对象表面可以改变焦点。";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "泛光效果";
// Intensity of the effect
postprocess.bloom.intensity = "强度";
// How far the effect spreads
postprocess.bloom.radius = "范围";
postprocess.bloom.radius.help = "此参数可调节泛光的范围。";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "阈值";
postprocess.bloom.threshold.help = "泛光阈值能够判断泛光的光线强度。
阈值越高，空间里越亮的物体才会产生泛光效果。";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "色调映射";
postprocess.tone.exposure = "曝光";
postprocess.tone.contrast = "对比度";
postprocess.tone.saturation = "饱和度";
postprocess.tone.hue = "色调";
// No tonemapping operator is used
postprocess.tone.mapping.none = "无";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "中性";
// Color curves
postprocess.curve = "色调";
// Curve for pixel luminance
postprocess.curve.luminance = "主要";
postprocess.curve.red = "红";
postprocess.curve.green = "绿";
postprocess.curve.blue = "蓝";
// Reset color grading curves
postprocess.curve.resetAll = "全部重置";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "色彩偏差";
postprocess.chromatic.factor = "强度";
// Darking on the edges
postprocess.vignette = "晕影";
// How far the effect spreads
postprocess.vignette.size = "范围";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "硬度";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "锐化";
postprocess.sharpness.factor = "强度";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "噪点";
postprocess.grain.factor = "强度";
// Accentuate the edges of the model
postprocess.curvature = "曲率描边";
// main strength of curvatre
postprocess.curvature.factor = "吸收系数";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "凹陷";
// Color/Strength of convex curvature
postprocess.curvature.bump = "凸起";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "像素画";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "允许帧采样";
// Simulate scanline rendering (horizontal line)
postprocess.scanline = "扫描线";
postprocess.scanline.factor = "吸收系数";
// Spacing between lines
postprocess.scanline.spacing = "间距";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "基本体";
primitive.box = "立方体";
primitive.sphereCube = "球体";
primitive.sphereUV = "UV球体";
primitive.icosahedron = "二十面体";
primitive.cylinder = "圆柱体";
primitive.cone = "圆锥体";
primitive.torus = "圆环面";
primitive.lathe = "车削";
primitive.tube = "圆管";
primitive.plane = "平面";
primitive.triplanar = "三面体";
primitive.faceXYZ = "X、Y、Z面";
primitive.faceXYZ.help = "由https://texturing.xyz/提供的UV展开的基本网格";
primitive.needValidate = "基本体需转换为可编辑对象后!";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "编辑";
primitive.edit.help = "可以在软件界面直接修改基本体的参数。

如果您喜欢使用轴向变换或自由变换来调整基本体，可以禁用此功能。";

// Primitive configuration
primitive.mainConfig = "参数";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "拓扑参数";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "几何";

// Validating the primitive (then it can be sculpted)
primitive.validate = "转换";
// Maximum number of faces of the primitives
primitive.maxFaces = "面数限量";
primitive.maxFaces.help = "一个基本体可拥有的最大面数。

该参数只能在转换为可编辑对象前修改。";
// Synonym: Flat subdivision
primitive.linear = "线性细分";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "后期细分";

// Radius (of a sphere, torus, etc)
primitive.radius = "半径";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radius.sync = "相同半径";
primitive.radius.start = "起始半径";
primitive.radius.end = "结束半径";
// Size (of cube x dimension)
primitive.size = "尺寸";
primitive.sizeX = "尺寸 X";
primitive.sizeY = "尺寸 Y";
primitive.sizeZ = "尺寸 Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "分段数";
primitive.divisionX = "分段数 X";
primitive.divisionY = "分段数 Y";
primitive.divisionZ = "分段数 Z";
// Angle of torus, etc
primitive.angleX = "角度 X";
primitive.angleY = "角度 Y";
primitive.angleZ = "角度 Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "恒定密度";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "投影在球体上";
primitive.projectOnSphere.help = "将点分布在一个完美的球体上。";

// triplanar
primitive.triplanar.title = "三面体";
primitive.triplanar.title.help = "三面体是将原对象三个平面的投影重新组合起来填充体素网格，然后将其多边形化。

您可以通过在三个投影上修改蒙版或移动滑块的方式来改变几何体。

建议您关闭对称选项，否则可能会导致最终效果与您的预期不符。

您可以开启遮罩面板中的“拓扑连接”选项来在绘制时影响其他平面。";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanar.sameSize = "固定比例（立方体）";
primitive.triplanar.polish = "羽化";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanar.resetMask = "重置蒙版";
// One side of a cube (the back plane)
primitive.isolate.back = "背面";
// One side of a cube (the right plane)
primitive.isolate.right = "右面";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "底面";
// Plane
primitive.planeSameSize = "固定比例（平面）";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "椭圆";
// Box
primitive.boxRegular = "固定比例（立方体）";
// Torus
primitive.torus.radiusOuter = "外圈半径";
primitive.torus.radiusInner = "内圈半径";
primitive.torus.angle = "角度";
primitive.torus.angleOffset = "角度偏移";
// Cylinder
primitive.cylinder.height = "高度";
// Cone
primitive.cone.radius = "半径";
primitive.cone.height = "高度";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "孔洞";
// Make a hole in the primitive to make it hollow
primitive.hasHole = "打洞";
// Curve profile (synonym: profile, curve)
primitive.profile = "轮廓";
primitive.profile.viewport = "在视口中显示";
// If the revolution surface has caps (E.g: cylinder)
primitive.cap = "盖帽";

// Singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "重复器";
// All the new items will be inserted inside the bound rather than outside
repeater.array.fitInside = "内部适配";
// The object will follow the curve
repeater.curve.align = "对齐";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "导入…";
// iOS Photos gallery
resource.import.ios.photos = "照片";
// iOS Files App
resource.import.ios.files = "文件";

scene.title = "场景";
scene.title.help = "当场景内有多个对象时，在复选框处上下滑动即可快速选择多个对象。 

您也可以长按可见/所选按钮来影响子体。";
// The view will focus on the item when we click on it
scene.focus = "UI：双击聚焦项目";
// Add new object on gizmo position
scene.addOnGizmo = "在操作杆上";
scene.addOnGizmo.help = "将节点移动到操作杆位置（如果选择了操作杆工具）";
// Select the gizmo tool after adding a new object
scene.addSelectGizmo = "选择操作杆";
scene.addSelectGizmo.help = "添加新节点时选择操作杆工具";
// Icon size in pixel (min/max)
scene.iconSize = "图标大小";
// Min size of icon
scene.iconSize.min = "最小值";
// Max size of icon
scene.iconSize.max = "最大";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "层级线";
scene.showHierarchy.help = "在视口中显示父项与其子项之间的线条。";
scene.showHierarchyNomadPivot = "使用Nomad枢轴";
scene.showHierarchyNomadPivot.help = "Nomad枢轴是变换和操作杆工具使用的枢轴。

如果此选项被禁用，它将使用自然基础枢轴。
在某些情况下，这个基础枢轴可能远离对象中心！";
// The view will focus on the item when we click on it
scene.syncVisible = "同步可见性";
scene.syncVisible.help = "启用后，使用可见（眼睛）图标将影响所有选定的项目。";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "连接";
// Group the selected object with a new created Empty Node as a parent
scene.group = "组";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "取消父子关系";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "镜像";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "曲线";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "阵列";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "径向";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "重复器";
scene.repeaters.help = "重复节点，使其在场景层级结构中的任何几何体实例化。";
// Validate button
scene.validateGroup = "转换";
// Keep instances in the scene
scene.validateGroup.keepInstances = "保持实例";
// If we should join children
scene.validateGroup.joinChildren = "组合子项";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "体素合并";
scene.voxelResolution = "分辨率";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "相减：隐藏对象";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "相交：隐藏所有对象";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "对象未选择";
// Need to select one object only
scene.noneButNeedOne = "未选中任何对象，请至少选中一个对象。";
// Need to select one object only
scene.onlyOneObject = "您选择了多个对象，无法修改图层。";
// Boolean operation
scene.boolean = "布尔";
scene.boolean.help = "Merge, subtract or intersect objects by performing a boolean operation.

The operation can fail if some objects are not manifold or not watertight.

If the boolean fails, you can always use the voxel remesher on the problematic object to ensure it's a watertight manifold.";
// Weld intersection
scene.boolean.mergeIntersection = "焊接交点";

// General scene display settings
settings.display.title = "显示设置";
// Wireframe (show triangles and quad edges)
settings.wireframe = "对象网格";
// Display the material texture
settings.debugChannel = "显示纹理";
// Display the material texture in the background
settings.debugChannel.onBackground = "在背景中";
// Display the material texture on the mesh
settings.debugChannel.onMesh = "网格上";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "双面显示";
settings.twoSided.help = "两面都可以见。";
// If we colorize the inverted side of faces
settings.backface.color = "背面颜色";
// Color of the inverted side of faces
settings.backface.colored = "背面着色";
// Outline (contour highlight around the selected object)
settings.outline = "轮廓";
// Outline (contour highlight around the selected object)
settings.outline.help = "选定的对象将被勾勒出来。";
settings.outline.thickness = "厚度";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "方位视图";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "置于底部";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "置于左侧";
// Flip the camera (rotate 180° to see the other side)
settings.snapCube.flip = "翻转180°";
settings.snapCube.flip.help = "如果视图已经对准，则翻转视图。";
// Alignment (can be auto/on/off)
settings.snapCube.align = "限制对齐";
settings.snapCube.align.help = "将视图对齐到世界轴。如果启用，只有6个对齐视图是可能的。

在自动模式下，只有当相机处于轨道模式时才会进行限制。";
// Stats (information logs about the scene displayed on screen)
settings.stats = "显示场景状态";
settings.stats.right = "置于右侧";
settings.stats.all = "显示全部";
// Grid
settings.grid = "网格";
// Cursor
settings.cursor.title = "光标";
settings.cursor.whileSculpting = "雕刻时显示圆圈";
// A small indicator dot
settings.cursor.showDot = "显示指示点";
settings.cursor.showDot.help = "指示点会在您移动相机和雕刻时显示。";
settings.cursor.showRope = "显示画笔准星";
// indicator
settings.indicator.title = "指示器";
settings.indicator.title.help = "显示视觉指示器（教程，屏幕捕捉等）。";
settings.indicator.size = "尺寸";
// Highlight (the object glows when we select it)
settings.highlight.selection = "高亮选择对象";
// Highlight settings
settings.highlight = "高亮";
settings.highlight.duration = "时长";
// Mesh that are not selected will be dark
settings.darkenUnselected = "使未选对象变暗";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "平滑阴影";
// Experimental feature
settings.partialDraw = "局部雕刻";
settings.partialDraw.help = "实验性功能！

建议您在雕刻高精度细小模型时使用。

它能让雕刻过程更加流畅，但不建议您打开显示对象网格。

启用此功能可能会在使用画笔时增加视觉上的人工痕迹。";
settings.partialDraw.warning = "如果显示不正常，请不要忘记关闭此选项！";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "图层绘画";
// Show and use the masking on the mesh
settings.showMasking = "显示遮罩";
// Disable this option to force show the hidden faces
settings.showDiscard = "使用隐藏";
// Show icon on the canvas
settings.icon = "图标";
// Show icons on the canvas
settings.icons = "图标";
// Tooltip
settings.icons.help = "在画布上显示图标，以便您直接选择和编辑。";
// Hole filling settings
settings.hole = "填补孔洞";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "填补非流形孔洞";
settings.hole.nonManifold.help = "应用将会尝试填补非流形孔洞。

此选项不会被保存在设置中。";
// Maximum number of vertices (points)
settings.multires.maxVertices = "最大顶点数量";
settings.multires.maxVertices.help = "应用在模型细分之前并不会检查内存，多边形数量过多很容易会导致应用崩溃。";
settings.multires.lowResVertices = "最低分辨率阈值";
settings.multires.lowResVertices.help = "在您移动相机时，模型对象可能会以较低分辨率显示。

如您希望显示更高的分辨率，可以增加此值。";

// The main rendering mode
shading = "渲染模式";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "PBR";
shading.pbr.help = "在这种模式下，你可以添加灯光（带阴影），以及一个HDR环境。

您可以在此模式下对材质的粗糙度与金属度进行修改，更好地观察当前材质的显示效果。";
// Fast rendering mode for sculpting purpose
shading.matcap = "材质捕捉";
shading.matcap.help = "该模式是将光照，材质等信息都存储在一张贴图上。

该模式光照信息相对固定，对模型干扰较小，适合用于雕塑时观察模型。";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "不受光";
shading.unlit.help = "该模式下模型只显示纯色，不受任何外界光照影响。";
// Helper rendering mode that display solid colors
shading.object = "基于对象 ID";
shading.object.help = "无光照渲染模式下每个对象会被随机分配颜色。

当您的场景中有多个对象时，该模式能发挥最大效用。";
// Helper rendering mode that display solid colors
shading.instance = "实例 ID";
shading.instance.help = "与对象 ID 相同，但实例将具有相同的颜色。";
// Helper rendering mode that display solid colors
shading.material = "";
shading.material.help = "";
// Randomize colors
shading.id.randomize = "随机分配颜色";
shading.textures = "使用纹理";
shading.textures.help = "Nomad目前尚未支持创建或编辑贴图。

但您可以导入包含有贴图的文件。（大部分情况下都是能显示的）

• 支持的纹理贴图
不透明贴图：Lit、Matcap、Unlit
法线贴图：Lit、Matcap
彩色贴图：Lit、Unlit
自发光贴图：Lit
粗糙度贴图：Lit
金属度贴图：Lit";
// Lights
shading.lights = "灯光";
shading.lights.addLight = "添加灯光";
shading.lights.warning = "灯光需要PBR着色模式。";
// Environment based lighting (synonym: HDRI)
shading.environment = "环境";
shading.environment.import = "导入环境";
shading.environment.exposure = "曝光";
shading.environment.backgroundBlur = "背景模糊";
shading.environment.rotation = "旋转";
shading.environment.rotation.help = "在屏幕上用三指水平移动可使环境、灯光与材质捕捉旋转。";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "固定环境";
shading.environment.attachedToCamera.help = "启用此选项后，移动相机时将不会移动环境。

这能让光线保持固定，对于雕刻来说非常有用。";
shading.matcap.rotation = "旋转";
shading.matcap.rotation.help = "在屏幕上使用三指水平移动可使环境、灯光与材质捕捉旋转。";
shading.matcap.global = "使用全局材质捕捉";
shading.matcap.global.help = "如果您希望在不同对象上使用不同的材质捕捉，请取消此选项。";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible = "蒙版";
shortcut.solo = "单放";
shortcut.xray = "X光";
shortcut.voxelRemesh = "体素";
shortcut.wireframe = "线框";
shortcut.cameraReset = "重设对称中心";
shortcut.cameraSnap = "切换";
shortcut.lockSelection = "锁定";
shortcut.lockSelection.help = "启用后，您无法通过点击方式选择对象。";
shortcut.perspective = "透视";
shortcut.grid = "世界网格";

// Memory taken by the scene
stat.ramScene = "场景";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "显存场景";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "显存渲染";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "显存贴图";
// Memory taken by the undo/redo history
stat.ramHistory = "历史";
// Memory taken by other stuffs
stat.ramOther = "其他";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "已用内存";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "剩余内存";
// RAM, not storage!
stat.ram = "内存";
stat.used = "已用：$0";
stat.free = "剩余：$0";
stat.faces = "面数";
stat.triangles = "三角面";
stat.vertices = "顶点";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "四边形";
stat.vertex = "基于顶点";
stat.scene.face = "场景面数";
stat.scene.vertex = "场景顶点数";

// Brush stroke
stroke = "笔刷";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "恒定笔刷半径";
// The settings is shared among every tools
stroke.useWorldRadius.help = "这将会影响到所有工具。";
// Share the radius value among every tools.
stroke.useShareRadius = "恒定半径";
stroke.useShareRadius.help = "使所有工具的笔刷半径相同。";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.spacing = "笔刷间距";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.spacing.adjust = "调整间隔强度";
stroke.minSpacingAdjustIntensity.help = "调整笔刷强度，以保证根据笔画间距产生一定的变化。";
stroke.minSpacing.help = "该选项可调节每个笔画之间的距离，与笔画半径有一定的相关性。

将该值调低可使笔刷显得更加顺滑，但也会影响性能。";
// Brush stroke smoothing
stroke.lazySmooth = "平滑笔刷";
stroke.lazySmooth.help = "通过平均计算多个点来获得更加平滑的笔刷。

将该值调高会使笔刷变得不跟手。";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "笔刷落后";
stroke.lazyRadius.help = "笔刷将会按一定的距离落后于指针位置。

此功能可用于绘制平滑线条。";
// It is not a per-tool settings
stroke.globalSettings = "这是一个全局设置。";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "续接笔刷范围";
stroke.snapRadius.help = "如果落笔处在最后一笔的续接范围内，笔刷将会自动续接上。

此功能可用于绘制长线条，但需要频繁停顿时。";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "笔刷偏移";
stroke.sculptOffset.help = "使笔刷持续偏移于触控处

此功能适用于小屏幕设备。在使用时，手指不会遮挡到屏幕。";
stroke.accumulate = "叠加笔刷";
stroke.accumulate.help = "如启用此选项，则每个笔画可添加或减去的数量将不会有限制。";
// The tool can use DynTopo
stroke.useDynamic = "允许动态网格";
// Only sculpt the part that are linked topologically
stroke.connect = "连接拓扑";
stroke.connect.help = "启用此选项后，画笔将会只雕刻连接到所选表面的顶点。

此选项一般适用于移动工具, 例如专门移动与另一零件自相交的零件。 ";
stroke.connect.short = "连接";
// sculpt on hide or mask
stroke.protect = "保护区域";
stroke.protect.hide.help = "设为自动时，如果隐藏面的线框可见，隐藏的面将被编辑（参见线框菜单）。";
// Only sculpt the vertex that points toward the camera
stroke.culling = "只影响对象表面";
stroke.culling.help = "打开此选项后，应用会忽略对“背面”的操作。

该功能可帮助您在不影响另一侧的情况下在几何平面上绘画。

该选项也可用于雕刻，但您可能会遇到一些不便。";
// Infinite depth, move everything under the circle, disregarding depth
stroke.silhouette = "轮廓线";
stroke.silhouette.view = "浏览模式";
stroke.silhouette.snapped = "如果已对准";
stroke.silhouette.closest = "最近的";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.sameSide = "只移动同向顶点";
stroke.sameSide.help = "在修改对象造型时，不移动朝向不同的顶点。";
stroke.onlyLasso = "该设置仅对套索工具有效。";

// Here sampling refers to the app gathering information under the mouse
stroke.area = "区域采样";
stroke.area.help = "一些画笔或笔触选项需要一个垂直于表面的平面才能工作。
您可以通过设置采样区域作为工具半径的比例来控制如何计算这个平均平面。

在100%时，选择圆圈内的每个点都被考虑在内。
在0%时，只考虑最近的顶点或三角形。";
// Sampling radius size (percent)
stroke.area.normal.radius = "法线半径";
// Sampling radius size (percent)
stroke.area.point.radius = "位置半径";
// Sampling averaging
stroke.area.normal.average = "法线平均";
// Sampling averaging
stroke.area.point.average = "位置平均";
// Keep sharp edges
stroke.keepSharp = "保留硬边";
stroke.keepSharp.help = "
深度限定";

// Only paint the part of the mesh above a certain height
stroke.depthFilter = "深度遮罩";
stroke.depthFilter.help = "排除距离计算平面上方或下方一定距离的点（区域采样）。

例如，它可以用来绘制凸起或凹陷。";
stroke.depthFilter.max = "顶部区域";
stroke.depthFilter.min = "底部区域";
stroke.depthFilter.offset = "高度偏移";

// Invert the pixel (black <-> white)
stroke.alpha.invert = "反转像素";
// Repeat the alpha image (pattern)
stroke.alpha.wrap = "平铺";
// No repeat pattern
stroke.alpha.wrap.none = "无";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alpha.wrap.repeat = "重复";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alpha.wrap.mirror = "镜像";
// Tight fit when using tiling
stroke.alpha.fit = "内部适配";
stroke.alpha.fit.help = "此选项仅与Alpha和画笔纹理非方形相关。

启用后，每个图像都会独立平铺，没有间隔。
如果您想保持Alpha和其他图像同步，以防它们的比例不同，您可以禁用此选项。";
// Alpha rotation
stroke.alpha.rotation = "旋转";
stroke.alpha.rotation.lock.help = "锁定阿尔法方向。

如果旋转未锁定，方向将实时跟随笔触方向。";
// Repeat the image
stroke.alpha.tiling = "形状平铺";
// Scale the image (make it bigger or smaller)
stroke.alpha.scale = "形状缩放";
stroke.alpha.scale.help = "当该值最小时，画笔形状将不会大于工具画笔的半径圆。";
// Middle-point value at which no deformation occurs
stroke.alpha.midValue = "中间值";
stroke.alpha.midValue.help = "不发生变形的中间值。

当中间值为0时：
• 黑色：无变化
• 白色：凸起

当中间值为0.5时：
• 黑色：下凹
• 白色：凸起

当中间值为1时：
• 黑色：下凹
• 白色：无变化";
// Synonymous: Scatter/Jitter/Randomize
stroke.jitter = "随机分配颜色";
// Sculpt and paint along the brush stroke at regular spacing
stroke.type.dot = "点";
// Sculpt and paint along with alpha spaced by brush radius
stroke.type.roll = "滚动";
// Sculpt and paint with alpha projected on screen stencil
stroke.type.tile = "瓦片";
// Sculpt and paint with alpha projected on 3 axis
stroke.type.triplanar = "三面体";
// Sculpt continuously
stroke.type.drag = "拖拽";
// Lock a region and move it around
stroke.type.grab = "抓取";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.type.grabRadius = "抓取 • 可调半径";
// Lock a region and sculpt it by changing the tool intensity
stroke.type.grabIntensity = "抓取 • 可调强度";

stroke.falloffProject = "影响力";
stroke.falloffProject.help = "• 球体 (3d)
影响力是通过计算顶点到画笔中心的距离来得出的。

• 圆形 (2d)
顶点首先被投影到区域平面上，然后计算其到画笔中心的距离。
这与采样alpha的方式类似。";
stroke.falloffProject.sphere = "球体";
stroke.falloffProject.circle = "圆形";

// Symmetry
symmetry = "对称";
symmetry.enable = "启用";
symmetry.primitiveWarning = "笔刷对称仅对已转换为可编辑对象的基本体可用，三平面基本体除外。";
symmetry.plane.title = "平面";
symmetry.toolIgnore = "当前工具不适用对称。";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "径向";
symmetry.radialX = "径向X";
symmetry.radialY = "径向Y";
symmetry.radialZ = "径向Z";
// A warning indicating that we limit the number of repetitions ($0 is a number)
symmetry.limited = "重复次数限制为 $0!";
// Synonym: Offset
symmetry.offset.title = "偏移";
symmetry.offsetX = "X轴方向偏移";
symmetry.offsetY = "Y轴方向偏移";
symmetry.offsetZ = "Z轴方向偏移";
// Number of clones
symmetry.count.title = "复制体个数";
symmetry.countX = "X轴方向上的复制体个数";
symmetry.countY = "Y轴方向上的复制体个数";
symmetry.countZ = "Z轴方向上的复制体个数";
// method
symmetry.method = "类型：";
symmetry.method.help = "• 本体对称
可使用轴向变换或自由变换等工具移动调整对称平面。

• 世界对称
对称平面是固定不动的。";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.method.world = "世界对称";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.method.local = "本体对称";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "翻转对象";
// Mirror the mesh
symmetry.mirror = "镜像";
symmetry.mirror.help = "尝试在不影响拓扑的情况下重新应用对称。

拓扑必须对称且至少有一个边缘恰好位于对称平面上才能成功应用。

如果镜像失败，将会建议您强制对称。但这样会影响到拓扑。";
symmetry.mirrorFail = "对称失败：

是否使用镜像来强制对称？";
symmetry.mirrorUseMasking = "保护蒙版区域";
symmetry.mirrorUseMasking.help = "启用后，在镜像时将不会修改蒙版区域。

该选项会忽略非对称网格(或不相连的表面，比如眼睛)。";
symmetry.apply = "镜像
(保持拓扑)";
symmetry.splitMirror = "分割 & 镜像
(新拓扑)";
// Reset the symmetry plane position
symmetry.reset = "重设";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "对象中心";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "世界中心";
// Reset the symmetry plane orientation
symmetry.reset.direction = "方向";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "显示线条";
// Display the symmetry plane in 3d
symmetry.showPlane = "显示平面";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "编辑Gizmo";
symmetry.edit.warning = "编辑镜像平面是实验性功能。";
symmetry.edit.help = "您可以自由改变镜像平面。

此功能并未完善，请尽量不要使用。";

// Ideally <10 chars
tool.dynamic = "动态网格";
// Ideally <10 chars (Symmetry)
tool.symmetry = "对称";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "镜像";
// Ideally <10 chars
tool.clay = "黏土";
// Ideally <10 chars (Subtract)
tool.clay.sub = "反向";
// Ideally <10 chars
tool.brush = "刷子";
// Ideally <10 chars
tool.move = "移动";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "法线方向";
// Ideally <10 chars
tool.drag = "拖拽";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "平滑";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "规整网格";
// Ideally <10 chars (Paint mask)
tool.mask = "蒙版";
// Ideally <10 chars
tool.mask.unmask = "消除蒙版";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "选择蒙版";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "涂抹";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "铲平";
// Ideally <10 chars (Flatten the surface, more strongly than Flatten)
tool.planar = "平面";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "填充";
// Ideally <10 chars (Layer brush)
tool.layer = "层";
// Ideally <10 chars
tool.crease = "褶皱";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "裁切";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "分割";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "投射";
// Ideally <10 chars
tool.inflate = "膨胀";
// Ideally <10 chars
tool.pinch = "挤捏";
// Ideally <10 chars
tool.nudge = "触碰";
// Ideally <10 chars
tool.stamp = "图章";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "擦除";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.select = "选择";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "轴向变换";
// Ideally <10 chars
tool.gizmo.editPivot = "编辑原点";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "角度吸附";
// Ideally <10 chars (Snap translation)
tool.gizmo.moveSnap = "移动吸附";
// Ideally <10 chars (Local/Relative space)
tool.gizmo.local = "轴向";
// Ideally <10 chars (Align/Snap the gizmo to world axis)
tool.gizmo.align = "对齐";
// Ideally <10 chars (Pin the gizmo, so that it stays in place when switching between objects)
tool.gizmo.pin = "钉住";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "自由变换";
// Ideally <10 chars (Translate the object)
tool.transform.move = "移动";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "旋转";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "缩放";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "表面吸附";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "测量";
// Ideally <10 chars (Lattice, deformer)
tool.lattice = "格子";
// If an option is shared among the tools
tool.all = "全部";
// Ideally <10 chars (Quad Remesher)
tool.remesh = "四边形重构";
tool.remesh.guides = "引导线";
tool.remesh.density = "密度";
tool.remesh.same = "相同";
tool.remesh.half = "一半";
// Ideally <10 chars (FaceGroup)
tool.faceGroup = "面组";
tool.faceGroup.autoPick = "自动选择";
tool.faceGroup.flush = "移除未使用";
tool.faceGroup.skip = "根据以下条件跳过小组：";
tool.faceGroup.skipFace = "面数";
tool.faceGroup.skipFace.help = "如果面的数量小于或等于此阈值，则不创建新组。";
tool.faceGroup.skipArea = "表面积";
tool.faceGroup.skipArea.help = "如果新组的表面积小于此阈值，则不创建新组。

阈值以对象的总面积的百分比给出。";
// Ideally <10 chars (Hide)
tool.hide = "隐藏";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "浏览模式";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "车削";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "圆管";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "插入";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "翻转";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "浏览";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "套索";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "曲线";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "多边形";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "路径";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "矩形";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "椭圆";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "直线";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "闭合";

// Radius of the tool (size)
tool.radius = "半径";
// Intensity of the tool (force)
tool.intensity = "强度";

tool.settings = "设置";
tool.settings.none = "该工具无特殊设置。";

tool.crease.pinchFactor = "力度";
tool.crease.offsetFactor = "偏移因子";

tool.layer.removeInfluence = "使用图层偏移";
tool.layer.removeInfluence.help = "仅当选中图层时此功能才能启用。

该选项会用图层数据来限制画笔置换。";
tool.layer.noLayerSelected = "此选项仅在选择图层后可用。";

tool.flatten.planeLockOrigin = "锁定平面原点";
tool.flatten.planeLockNormal = "锁定平面方向";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "同步";
tool.syncInstance.message = "新对象将被添加到所有其他实例中！";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "边线粘性顶点";
tool.smooth.screen = "屏幕平滑";
tool.smooth.screen.help = "使用此选项可获得与拓扑无关的平滑效果，即使在高多边形下也是如此。";
tool.smooth.screen.samples = "屏幕样本";
tool.smooth.stable = "稳定平滑";
tool.smooth.stable.help = "尝试使平滑独立于拓扑。

这种模式最适合于拓扑密度不同和平滑强度值高的情况。";

tool.paint = "绘画";
// Erase the painting
tool.paint.erase = "橡皮";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "图层限定";
tool.paint.layerFilter.help = "启用该选项后，您只能够在已经有绘画的图层上进行二次绘画。";

// Clear the painted mask
tool.mask.clear = "清除";
tool.mask.clearAll = "清除全部";
// Invert the painted mask
tool.mask.invert = "反转";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "反转已连接区域";
// Blur the painted mask
tool.mask.blur = "模糊";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "锐化";
// Transform/Matrix
tool.matrix = "坐标";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.target = "目标";
// Automatic
tool.matrix.target.auto = "自动选择";
tool.matrix.target.auto.help = "默认情况下，这和“组合”选项类似。
如果网格已有蒙版，或者启用了变换工具对称，这会和“顶点”效果相似。";
// Auto apply the transform on the vertices
tool.matrix.target.vertex = "基于顶点";
tool.matrix.target.vertex.help = "您可以尝试转换顶点，但这对于未转换为可编辑状态的基本体不起作用。
这也会影响实例。";
// Transform the object alone (the children stands still)
tool.matrix.target.object = "基于对象";
tool.matrix.target.object.help = "仅移动对象而忽略对称性和蒙版。
仅移动已编辑节点，不移动子项。";
// Transform the object and its children
tool.matrix.target.group = "组";
tool.matrix.target.group.help = "移动节点，忽略对称性和蒙版。
层级中其他节点也会被转换。";
// Operation on the mesh
tool.matrix.action = "操作";
tool.matrix.action.help = "• 返回原点
将对象移回原位。

• 重设
重设对象的所有变换。

• 烘焙
重新记录对象变换后的顶点坐标。在视觉上什么都不会改变。";
tool.matrix.translation = "位移";
tool.matrix.rotation = "旋转";
tool.matrix.scale = "缩放";
// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "剪切";
tool.matrix.uniformScale = "等比缩放";
tool.matrix.moveToOrigin = "返回原点";
tool.matrix.resetTransform = "重设";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "烘焙";

tool.transform.tip = "用第二个手指单击切换模式";

// Size of the gizmo
tool.gizmo.size = "部件尺寸";
// If true, there is less spacing between gizmo handlers (rotate, scale, etc)
tool.gizmo.compact = "紧凑";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "数值输入";
tool.gizmo.allowInput.help = "轻按任一变换工具时允许输入数值";
// Angle threshold
tool.gizmo.linearRollThreshold = "线性旋转阈值";
tool.gizmo.linearRollThreshold.help = "此参数可影响模型旋转时的“跟手程度”。

当旋转角度超过设定值后，将会切换到圆形旋转模式。

如果您更习惯以前的线性旋转模式（切线方向），可以将角度设置为90°。";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "自动隐藏";
tool.gizmo.tap = "点击";
tool.gizmo.tap.help = "此选项仅在自定义坐标原点模式下有效（默认禁用）。";
tool.gizmo.tap.none = "无";
tool.gizmo.tap.none.help = "点击对象后无任何操作。";
tool.gizmo.tap.normal = "法线方向";
tool.gizmo.tap.normal.help = "将 gizmo 移动到第一个交点，并根据表面法线进行对齐。";
tool.gizmo.tap.first = "第点";
tool.gizmo.tap.first.help = "更改第一个交点的原点。";
tool.gizmo.tap.medial = "中点";
tool.gizmo.tap.medial.help = "将在圆点坐标设置在前两次点击直线的中点。";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "固定位置";
tool.lathe.axisOnly = "只限轴";
tool.lathe.stable = "稳定";
tool.lathe.axis = "轴";

// Fill the object's hole
tool.hole = "孔洞填补";
tool.hole.fillHoles = "填补孔洞";
// synonym: Alternative method
tool.hole.method.fill = "填充";
tool.hole.method.legacy = "传统";
tool.hole.method.boolean = "布尔";
tool.hole.bridges = "屏幕空间的布尔值";
tool.hole.bridges.help = "启用此选项后。您可以用裁切的方式在物体上打洞。
裁切效果也会更加接近于您所绘制的形状。";
tool.hole.threshold = "填充阈值";
tool.hole.threshold.help = "调整该值以获得更好的填充效果。";
tool.hole.smoothing = "平滑孔洞";

tool.smudge.quality = "质量";
tool.smudge.quality.help = "此选项可改变投影的分辨率，将该值调低可提高笔刷速度。";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "形状";
// Auto-validate the drawn shape
tool.shape.autoValidate = "自动验证";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "正方形";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "中心";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "圆形";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "中心";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "旋转角度";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "黄金比例";
// volume of a mesh
tool.measure.volume = "体积";
// Surface of a mesh
tool.measure.surface = "表面";

// Always display the camera shortcut buttons on the viewport
tool.view.stickyCamera = "相机快捷键（始终）";

// Topology
topology = "拓扑";
// Synynom: detail value, density
topology.dynamic.detail = "细节等级";
// See glossary
topology.multires = "多重网格";
topology.multires.help = "此功能可保留对象的不同分辨率。

您可以在低分辨率对物体进行修改，之后在高分辨率查看并进一步更改细节效果。

图层在不同分辨率下都可用。";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "取消分割";
topology.multires.reverse.confirm = "无法再进一步简化模型。

当前对象的拓扑无法再进一步细分。";
topology.multires.subdivide = "细分";
topology.multires.subdivide.confirm = "该对象将会产生 $0M 个顶点，您确定要继续吗？";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "超过细分限制，请前往$0提高限制";
topology.multires.deleteLower = "删除低模";
topology.multires.deleteHigher = "删除高模";
topology.multires.keepTriangles = "保留三角形";
topology.multires.lock = "锁定 (LV0)";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "多重分辨率级别 →";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "多重分辨率级别 ←";
// Synonym: Flat subdivision
topology.multires.linear = "平面细分";
topology.multires.linear.help = "直接细分网格，不应用平滑。";
// Only show the lowest resolution wireframe
topology.multires.minWireframe = "仅限级别 0";
// Create a new object by recomputing a new topology
topology.remesh = "重构";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "体素网格重构";
topology.voxel.help = "此功能可重构对象的网格，使其变得更加整齐。

如对象未封闭，则会先填充孔洞。

图层在应用后会重新投影，但质量会受到影响。";
topology.voxel.resolution = "分辨率";
topology.voxel.sharp = "保留硬边";
topology.voxel.sharp.help = "该功能主要用于几何构造比较简单的对象。

可能会使重构结果造成一些失真。";
topology.voxel.subLevel = "多重网格等级";
topology.voxel.subLevel.help = "此功能可以从重构的结果中生成多个不同分辨率的对象。

能够在保留较低分辨率对象的同时，拥有更快的运行速度。
如果重构分辨率过高的话，可能会无法生成多重网格或者失去一些细节。";
// Dynamic topology (DynTopo)
topology.surface.remesh = "重构";
topology.surface.detail = "分辨率";
topology.surface.detail.help = "不同于体素网格重构，表面网格重构不需要封闭对象。

此功能还支持遮罩，可以保护您不希望被更改拓扑的部分。

图层不会受到影响。";
topology.surface.method = "模式";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "标准";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "细分";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "简化";
topology.surface.method.help = "不同模式的影响：
• 标准：智能判断
• 细分：增加细节
• 简化：移除细节";
topology.surface.useMasking = "保护蒙版区域";
topology.surface.useMasking.help = "蒙版区域的拓扑将不会受到影响。";
topology.surface.extrapolate = "顶点扩张";
// DynTopo
topology.dynamic = "动态网格";
topology.dynamic.activate = "启用";
topology.dynamic.activate.help = "启用此功能可以让您在雕刻过程中实时增删网格。

开启此功能可能会对性能产生较大影响。

图层不会受到影响。";
topology.dynamic.method = "细节等级模式";
topology.dynamic.method.screen = "屏幕分辨率";
topology.dynamic.method.radius = "半径";
topology.dynamic.method.constant = "网格";
topology.dynamic.method.help = "
• 缩放
详细程度取决于您离表面有多远。

• 半径
工具的半径决定了细节的数量。

• 常数
细节是固定的，细节值也与体素滑块共享。";
topology.dynamic.quality = "偏向于…";
topology.dynamic.quality.help = "性能模式特性如下：
• 在雕刻前会对模型进行细分，可以减少您在雕刻过程中产生的伪像。
• 无法逐步应用细化功能，如果您雕刻非常小的细节或进行快速笔触，则拓扑将始终正确进行细化。";
topology.dynamic.quality.speed = "速度";
topology.dynamic.quality.quality = "性能";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "在半径上使用压感";
topology.dynamic.usePressure.help = "如果您想让笔压对工具半径的影响也影响到细节层次，请启用此选项。";
topology.dynamic.useFalloff = "使用笔刷衰减";
// Decimate
topology.decimate.title = "成型简化";
topology.decimate.title.help = "减少多边形的数量，尽量保留更多的细节。

如果你想输出用于3D打印，这个功能会很有用。
但是，如果你想继续雕刻，你可能不应该使用它，因为它可能产生不均匀的三角形。

注意，蒙版区域不会被切除。";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "网格简化";
topology.decimatePaintWeight = "保存绘画";
topology.decimatePaintWeight.help = "较高的数值可以对绘画的细节边缘有所保护。

如果并不进行绘画，可以将该值设置为0。";
topology.decimateUniform = "网格均匀化";
topology.decimateUniform.help = "该参数值越高，优化输出的三角面就越统一。";
topology.decimatePreserveBorders = "保留边界";
topology.decimatePreserveBorders.help = "不对网格的边界进行简化。";
// Target a certain number of triangles, faces and vertices
topology.target.triangles = "目标面数";
topology.target.faces = "目标面";
topology.target.quads = "目标四边形";
topology.target.points = "目标点";
// Quad remesher
topology.qremesh = "四边形重构";
topology.qremesh.angle = "折痕角度";
topology.qremesh.border = "保留边界";
topology.qremesh.onlyQuad = "仅限四边形";
topology.qremesh.hole = "最大填洞";
topology.qremesh.hole.help = "
UV展开";

// Unwrapping means compute UV (texture coordinates), with uvs you can appliy (wrap) a texture onto the model
topology.uv.title = "UV自动展开";
// UV Unwrap but as a Verb
topology.uv.unwrap = "展开";
// The operation can be very slow
topology.uv.atlas.warning = "可能需要等待很长时间。
仅限于顶点数小于100k的对象。";
// Handles are topological holes (synonym: genus, hole)
topology.uv.bff.warning = "如果网格有孔时可以有重叠！";
// Solo patch
topology.uv.bff.seamless = "无缝补丁";
topology.uv.bff.seamless.help = "此选项可能会引入重大变形。

通常，当小心设置面部组时可以使用。";
// Synonym: Point count? Singularity count ?
topology.uv.bff.cones = "锥体数量";
topology.uv.bff.help = "数值越高，复杂对象失真越小。

数值越高，需要计算的时间越长。";
topology.uv.delete = "删除UV";

// Transfer the vertex painting in the texture, bake means "create texture (from mesh data)"
topology.bake.title = "烘焙";
// Bake here means "create texture (from mesh data)"
topology.bake.title.help = "纹理烘焙将通过投影场景中的其他可见对象来创建纹理。

烘焙的典型工作流程如下：
• 您有一个细节和绘画精细的网格
• 克隆它
• 简化它（设置`保留绘画`为0！）
• UV展开
• 烘焙它！

Nomad将考虑场景中的每一个可见网格。
您也可以使用Solo模式快速隐藏大部分其他网格。
如果没有其他可见对象，则它将考虑整个场景。

您现在应该拥有一个低分辨率网格，保留了您之前对象的大部分绘画和细节。

操作后，顶点颜色将被移到一个新的禁用图层中，这样它就不会被乘以彩色纹理而被忽略。";
// Bake here means "create texture (from mesh data)"
topology.bake.self = "从本身";
// Bake here means "create texture (from another mesh data)"
topology.bake.other = "从高分辨率";
topology.bake.resolution = "分辨率";
// Cage is a specific term, synonyom: "Bake offset"
topology.bake.offset = "射线偏移";
topology.bake.radius = "笼半径";
// Bake opacity (from mask data)
topology.bake.opacityFromMask = "蒙版 -> 不透明度";
topology.bake.backup = "备份";

// project a high resolution mesh details onto another
topology.reproject.title = "重新投影";
topology.reproject.title.help = "从最近的可见对象投影雕刻细节、绘画和图层。

这主要是用于高分辨率网格，通常具有干净的拓扑结构。";
// tweaking value
topology.reproject.rayBias = "射线偏差";
topology.reproject.rayBias.help = "两种方法用于重新投影：
• 最近：表面上最近的点
• 射线：通过法线方向的交点

更高的偏差值将倾向于射线交点而不是最近表面。";
topology.reproject.normalOffset = "法线偏移";
topology.reproject.shpereCast = "球体投射回退";
topology.reproject.shpereCast.help = "如果法线射线重投影失败，Nomad将回退到最近的表面交点。";
// number of iteration the algorithm will take
topology.reproject.iterations = "迭代次数";
topology.reproject.relax = "规整网格";
topology.reproject.relax.help = "当网格是低多边形时，应优先考虑放松。";
topology.reproject.layers.help = "将其他图层传输到所选网格。";

topology.manifold = "流形";
topology.nonManifold = "非流形";
topology.manifold.clean = "清洁";
topology.manifold.collapse = "删除小面";
topology.manifold.title = "强制流形";
topology.manifold.title.help = "尝试清理非流形边缘。

对于不支持有超过2个共同面的边缘的外部软件，这可能很有用。";

// Reset key-bindings/shortcuts
binding.reset = "重设键位绑定";
// Binding option
binding.context.toggle = "切换上下文";
binding.toggleTool = "切换工具快捷键";
binding.toggleTool.help = "当使用工具快捷键时，如果当前的快捷工具处于活动状态，则会选择之前的工具。";
// When the key is tap once, the value will be toggled
binding.tapToggle = "按键切换快捷键";
// The binding force camera movement
binding.forceCamera = "强制相机";
binding.forceCamera.help = "强制相机交互，以防与其他绑定发生冲突。

如果相同的绑定分配给工具快捷键或添加/减法，这通常会发生。";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickMaterial = "材质选取器";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickFaceGroup = "选择面组";
// Edit the tool brush size/radius
binding.editRadius = "工具半径";
// Edit the tool brush size/radius
binding.editIntensity = "工具强度";
// Snap the camera
binding.view.front = "正面视图";
binding.view.left = "左视图";
binding.view.top = "顶视图";
// Move/Translate the view
binding.pan.left = "向左平移";
binding.pan.right = "向右平移";
binding.pan.forward = "向前平移";
binding.pan.backward = "向后平移";
binding.pan.up = "向上平移";
binding.pan.down = "向下平移";
// Snap the view (while rotating)
binding.snapViewOnRotate = "切换视图（旋转时）";
// Open a Nomad internal project (replace current scene)
binding.project.open = "打开（项目）";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "添加（项目）";
// Select all the objects in the scene
binding.selectAll = "全选";
// Rotate environment and the lighting
binding.rotateLighting = "旋转照明";
// The Camera pivot is the point around which the camera rotates
binding.updatePivot = "视图中心点";

quadremesh.adaptQuadCount = "自适应四边形数量";
quadremesh.curvatureAdaptivness = "自适应大小";
quadremesh.curvatureAdaptivness.help = "在100%时，四边形的大小将根据物体的曲率变化，允许在高曲率处使用更小的四边形。
在0%时，四边形的大小将是统一的。";
quadremesh.autoDetectHardEdges = "自动检测硬边";
quadremesh.useVertexColors = "保存绘画";

// Privacy policy
privacyPolicy.title = "未收集数据";
privacyPolicy.reject = "不好";
// Hexanomad is the company name
privacyPolicy = "Hexanomad 不会从 Nomad Sculpt 收集任何数据。";

sonar.disconnect = "断开SonarPen";
sonar.connect = "连接SonarPen";
sonar.connect.confirm = "连接SonarPen？";
sonar.connect.confirm.warning = "Sonar Pen将使用麦克风（音频回环）来检测笔的压力。";

// Color disc mode
widget.color.disc = "色盘";
widget.color.ring = "环形";
widget.color.square = "正方形";

nomad.mainFolder = "Nomad主文件夹";
nomad.mainFolder.warning = "文件保持不变。
它们没有被复制、删除或移动。";
nomad.mainFolder.error = "选择'是'后，Nomad将关闭，您可以简单地重新启动它。";

// version trial
version.restore = "恢复购买";
version.buyWeb = "该版本仅供演示";
version.buyFull = "购买完整版本";
version.buyQR = "购买";
version.buyQR.promo = "
四边形重构算法是输出以四边形为主的网格的算法。
四边形分布将尝试跟随物体的自然曲率。

算法也可以根据局部曲率调整四边形的大小。

您还可以通过以下方式指导结果拓扑：

• 面组 $0（确保平滑它们的边界以获得更好的结果！）

• 平面X/Y/Z对称性 $1

• 曲线引导 $2

• 密度绘制 $3

四边形重构算法由https://exoside.com/开发。";

version.trialHistory = "试用版本限制：仅允许4次以内的撤销或重做";
version.trialLayer = "试用版本限制：每个物体仅允许添加一个图层";
version.trialOneProject = "试用版本限制：仅允许启用一个项目";
version.trialNoImport = "试用版本限制：不允许导入";
version.trialNoExport = "试用版本限制：不允许导出";

version.fullFeatures = "购买完整版本后您可以：
• 撤消或重做不受限制
• 图层数量不受限制
• 允许保存和载入
• 可以导入和导出文件";

version.demo.purpose = "此版本专为演示用途而制作。";
version.demo.disable = "演示版本不启用此功能。";

// app store main page
store.name = "Nomad Sculpt • 3D雕刻建模";
store.headline = "专业数字雕刻与模型绘画";
store.tag = "sculpt, 3d, nomad, paint, modeling, 雕塑, 绘画, 模型, 设计, 创造";
// ----------------------------------------------
store.description.sculpt = "• 雕塑工具
Clay, flatten, smooth, mask和许多其他画笔让您塑造您的创作。
需要硬线吗？您还会找到一些套索/线/曲线切割工具。";
// ----------------------------------------------
store.description.stroke = "• 笔触自定义
Falloff, alphas, tilings, pencil pressure以及其他笔触参数可以自定义。
您也可以保存和加载您的工具预设。";
// ----------------------------------------------
store.description.paint = "• 绘画工具
Vertex绘画包含颜色，粗糙度和金属性。
您也可以轻松管理所有材质预设。";
// ----------------------------------------------
store.description.layer = "• 图层
在单独的层中记录您的雕塑和绘画操作，以便在创作过程中更容易迭代。
雕塑和绘画的更改都被记录下来。";
// ----------------------------------------------
store.description.multires = "• 多重网格
在模型不同的分辨率之间随心切换，能让您拥有更流畅的创作体验。";
// ----------------------------------------------
store.description.voxel = "• 体素网格重构
重构能够让重新计算您模型的网格布线。
在您创作之初，可用来快速起稿。";
// ----------------------------------------------
store.description.dynamic = "• 动态拓扑
在您的画笔下局部细化您的网格，以获得自动的细节水平。
您甚至可以保留您的图层，因为它们将被自动更新！";
// ----------------------------------------------
store.description.topology = "• 简化
在尽可能保留多的细节的情况下减少多边形数量。";
// ----------------------------------------------
store.description.group = "• 面部分组
使用面部分组工具将您的网格分割成子组。";
// ----------------------------------------------
store.description.unwrap = "• 自动UV展开
自动UV展开器可以使用面部分组来控制展开过程。";
// ----------------------------------------------
store.description.baking = "• 烘焙
您可以将顶点数据如颜色，粗糙度，金属性和小尺度细节转移到纹理中。
您也可以做相反的操作，将纹理数据转移到顶点数据或层中。";
// ----------------------------------------------
store.description.primitive = "• 原始形状
圆柱，圆环，管，车床和其他原始形状可用于从头开始快速开始新形状。";
// ----------------------------------------------
store.description.rendering = "• PBR渲染
默认美丽的PBR渲染，包含光照和阴影。
您总是可以切换到MatCap，以便于雕塑目的使用更标准的着色。";
// ----------------------------------------------
store.description.postprocess = "• 后期处理
屏幕空间反射，景深，环境遮蔽，色调映射等";
// ----------------------------------------------
store.description.files = "• 导出和导入
支持的格式包括glTF、OBJ、STL或PLY文件。";
// ----------------------------------------------
store.description.interface = "• 界面
易于使用的界面，为移动体验设计。
也可以进行自定义！";
// ----------------------------------------------
store.description.remesher = "• 四边形重构（仅限应用内购买）
自动使用符合网格曲率的四边形优势网格重新构建您的物体。
它支持引导线，面部分组和密度绘画。";
// ----------------------------------------------