// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "";

// Name of an item (object, tool, etc)
item.name = "";
// Add a new item (object, tool, etc)
item.new = "";
// Rename an item (object, tool, etc)
item.rename = "";
// Add a new item (object, tool, project, etc)
item.add = "";
// Save an item (object, tool, etc)
item.save = "";
item.save.confirm = "";
// Reload last save of an item (object, tool, etc)
item.lastSave = "";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "";
// Reset an item to its initial value (object, tool, etc)
item.reset = "";
item.reset.confirm = "";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "";
// Uninstance the object, make the object real
item.uninstance = "";
// Clone an item (object, tool, etc)
item.clone = "";
// Delete an item (object, tool, etc)
item.delete = "";
item.delete.confirm = "";
item.delete.confirm.yes = "";
// When we delete the item but the image is used somewhere
item.delete.imageUsed = "";
// Delete an item and link its children to its parent (Synonym: Pop?)
item.collapse = "";
// Item visibility (object, layer, etc)
item.visible = "";
// Show an item (object, layer, etc)
item.show = "";
// Hide an item (object, layer, etc)
item.hide = "";
// Select an item (object, layer, etc)
item.select = "";
// Unselect an item (object, layer, etc)
item.unselect = "";
// Merge an item with another one below (layer)
item.mergeDown = "";
// The order of an item in a list
item.order = "";
// Focus on previous item
item.previous = "";
// Focus on next item
item.next = "";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "";

// Three-state toggle button (Auto, Off, On)
toggle.on = "";
// Three-state toggle button (Auto, Off, On)
toggle.off = "";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "";

// Color of an object
material.color = "";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "";
// Whether the material is a metal or not
material.metalness = "";
// How much light a surface will reflect
material.specular = "";
// Light that the surface can emit (glow)
material.emissive = "";
// Normal map (synonym: detail, bump)
material.normal = "";
// Ambient Occlusion (AO)
material.occlusion = "";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "";

// Minify
about.minify = "";
about.minify.help = "";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "";
// Make the entire scene turn around (speed of the animation)
about.turntableSpeed = "";
// Stuffs that I used to make the app
about.credits = "";
// Link to open source projects that I used for the app
about.credits.openSource = "";
// Only translate the &
about.credits.arts = "";
// Change languages of the app
about.languages = "";
about.languages.help = "";
// Link to the App Website
about.website = "";
// Link to the App Forum
about.forum = "";
// Link to the App Manual
about.manual = "";
// Link to the App Email
about.mail = "";
// Link to the App Twitter account
about.twitter = "";
// Link to the App Instagram account
about.instagram = "";
// Link to the App Facebook account
about.facebook = "";
// Link to the App Discord account
about.discord = "";

// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "";
// In order to extract something, the mesh needs to have painted mask
alert.mask.noExtract = "";
// In order to split something, the mesh needs to have painted mask
alert.mask.noSplit = "";
// List of disabled features when View Mode is selected
alert.view.disabled = "";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "";
// The object needs to have two parts disconnected
alert.separate.fail = "";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "";
alert.voxelRemesh.empty = "";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "";
// A pivot refers the gizmo 3d position
alert.gizmo.usePivot = "";
// A pivot refers the gizmo 3d position
alert.gizmo.useAuto = "";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "";
// See Glossary (DynTopo)
alert.dynamic.enable = "";
// See Glossary (DynTopo)
alert.dynamic.disable = "";
alert.colorPicker = "";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "";
alert.view.reset = "";
// Snap the view to the nearest aligned 90° angle
alert.view.snap = "";
// Show the painted mask on the mesh
alert.mask.show = "";
// Hide the painted mask on the mesh
alert.mask.hide = "";
// Selection refers to the objects that are currently selected
alert.selection.lock = "";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "";
// Hide the objects that are not selected
alert.selection.isolate = "";
// Show the objects that are hidden
alert.selection.showAll = "";
// Project quick saving
alert.quickSave = "";
// Painting on the object was hidden but the user did paint the object
alert.forceShowPainting.fill = "";
// Painting on the object was hidden but the user started to paint on the object
alert.forceShowPainting.tool = "";
// See Glossary (Multiresolution)
alert.multiresLost = "";
// The user is starting an operation that can lead to a crash
alert.range.warning = "";
// Autosave popup
alert.autoSave.auto = "";
// The selected object doesn't have any layers
alert.needLayer = "";
// The user decides to hide the painting on the objects
alert.paintingHidden = "";
// The selected object doesn't have any layers
alert.noPartialWireframe = "";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "";
// Trial version has a limited number of undo
alert.state.trial = "";

background = "";
// A flat color will be displayed in the background of the scene
background.color = "";
// The environment (HDRI) will be displayed in the background
background.environment = "";
background.blur = "";
background.exposure = "";

// Image that the artist uses as a reference
background.imageEnable = "";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "";
// Opposite of transparency (Alpha)
background.imageAlpha = "";
background.imageReset = "";
background.imageTransform = "";
// X screen coordinate of the image reference
background.imageX = "";
// Y screen coordinate of the image reference
background.imageY = "";
// Rotation of the reference image
background.imageRotation = "";
// Scale of the reference image
background.imageScale = "";

// Camera (point of view in 3d)
camera = "";
// Copy the views
camera.updateView = "";
// Add a new camera
camera.addView = "";
// Focus on the camera
camera.focus = "";
// Add on the camera camera
camera.focusOn = "";
// Camera projection, Orthographic or Perspective
camera.projection = "";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "";
// camera Vertical Field of View
camera.fov = "";
// Camera Field of View hint
camera.focal = "";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "";
camera.rotation.trackball.help = "";
// Camera interaction mode, 1st person view
camera.firstPerson = "";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "";
// Camera rotation sensitivity
camera.speed.rotation = "";
// Camera panning sensitivity
camera.speed.panning = "";
// Camera zooming sensitivity
camera.speed.zooming = "";
// Reset camera position
camera.resetView = "";
// Align the view (snap to nearest 90° angle)
camera.snapView = "";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle ="";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection ="";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene ="";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "";
camera.doubleTapPivot.help = "";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "";
camera.airPivot.help = "";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "";
camera.autoPivot.help = "";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "";
camera.doubleTapFocus.help = "";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "";
// There is 0 nodes/items selected
context.noSelection = "";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "";

// Debug option, the newly created primitives will contains texture coordinates (UVs)
debug.uvPrimitive = "";
debug.uvPrimitive.warning = "";
debug.uvPrimitive.help = "";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "";
debug.uvNormalize.help = "";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "";
debug.uvBFF.help = "";
// Debug option, display an window with some debugging logs
debug.logs = "";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "";
// Debug options, graphical stuffs
debug.graphics = "";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "";

// Empty list: there is no projects
file.project.empty = "";
// The current opened project has some unsaved changes
file.project.unsaved = "";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "";

file.project = "";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "";
// E.g: Save "my_project"?
file.project.save.confirm = "";
// Save to another project (either new one or overriding existing one)
file.project.saveAs = "";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "";
// Open a project
file.project.open = "";
// E.g: Open "my_project"?
file.project.open.confirm = "";
// Load another project and add/append all its data to the current scene
file.project.add = "";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "";
// Reset the scene and create a new project
file.project.new = "";
file.project.new.confirm = "";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "";

// Auto save section
file.project.autoSave = "";
file.project.autoSave.confirm = "";
file.project.autoSave.help = "";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "";
// In minutes
file.project.autoSave.minutes = "";
// Delete the current autoSave data
file.project.autoSave.delete = "";

// Load interface preference settings when opening a scene file
file.load.guiSettings = "";
file.load.guiSettings.help = "";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.load.objSplitByGroup = "";
file.load.objSplitByGroup.help = "";
// Merge all the object layers at when loading a file (deleting them in the process)
file.load.mergeLayers = "";
// Ignore the textures present in the file to load
file.load.skipTextures = "";
// Do not fiddle with the object topology when loading the file
file.load.keepTopology = "";
file.load.keepTopology.help = "";
// If the object has more vertices than this value, then we won't attemp to reverse (multiresolution) the object
file.load.reverseVertices = "";
file.load.reverseVertices.help = "";


// Configure imports option
file.importSettings = "";

// Import file section
file.import.title = "";
file.import.title.help = "";
// The user imports a scene file that will replace the current scene
file.import.open = "";
file.import.open.confirm = "";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "";
file.import.add.confirm = "";

// Export scene file
file.export.title = "";
file.export.title.help = "";

// Export the current selected objects instead of the entire scene
file.onlySelection = "";
file.onlySelection.help = "";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "";
file.convertToQuad.help = "";

// Whether we include the textures in the exported file
file.export.texture = "";
// Baking means transfering/converting 
file.export.texture.help = "";
// Whether we include normals vector in the exported file
file.export.normal = "";
file.export.normal.help = "";

file.export.gltf = "";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "";
file.export.gltf.layer.help = "";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "";
file.export.gltf.layerPaint.help = "";
// Whether the exported layer will use the non-standard Nomad encoding (smaller size)
file.export.gltf.layerNomad = "";
file.export.gltf.layerNomad.help = "";
// Whether we include the vertex color in the exported file
file.export.gltf.color0 = "";
file.export.gltf.color0.help = "";
// Whether we include the vertex roughness and vertex metalness in the exported file
file.export.gltf.color1 = "";
file.export.gltf.color1.help = "";

file.export.obj = "";
file.export.obj.warning = "";
// Whether we include the vertex color in the exported file
file.export.obj.colorAppend = "";
file.export.obj.colorAppend.help = "";

file.export.stl = "";
file.export.stl.warning = "";
// Whether we include the vertex color in the exported file
file.export.stl.color = "";
file.export.stl.color.help = "";
file.export.stl.ascii = "";

// Advanced settings
settings.advanced = "";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "";
settings.reset.title = "";
settings.reset.title.help = "";

// Reset preference settings button
settings.reset = "";
settings.reset.confirm = "";

// Render a screenshot of the scene
file.render = "";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "";
file.render.renderRatio.help = "";
// Desired size of the exported screenshot
file.render.size = "";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "";
// width of exported screenshot
file.render.width = "";
// height of exported screenshot
file.render.height = "";
// export screenshot of the scene
file.render.export = "";
file.render.warn = "";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "";
file.render.transparent.help = "";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "";
pressure.useGlobal.help = "";

// Pencil pressure
pressure.title = "";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "";
// The tool can support pressure but its selected stroke type will ignore it 
pressure.noGrab = "";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "";

// Customize whether finger and/or stylus can move the Camera
gesture.cameraInteraction = "";
// Customize whether finger and/or stylus can sculpt on object
gesture.sculptInteraction = "";
// Both the finger and the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.fingerAndStylus = "";
// Only the finger can perform a certain action (move camera, sculpt, etc)
gesture.interaction.finger = "";
// Only the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.stylus = "";

// Three fingers on screen
gesture.three.title = "";
// Drag 3 fingers horizontally on the canvas to rotate the environment, lights and MatCap
gesture.fingerLighting = "";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerLighting.help = "";
// Drag 3 fingers vertically to edit the tool radius
gesture.fingerRadius = "";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerRadius.help = "";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.fingerSmooth = "";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "";
gesture.unknownPressure.help = "";

// Action when we press an Android pencil button
gesture.pencilAction.android = "";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "";
gesture.pencilAction.ios.help = "";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "";
// Pencil button (or iOS pencil double tap) action: Smooth tool
gesture.pencilAction.smooth = "";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "";
gesture.mask.oneTap.help = "";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress = "";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress.help = "";
// Indicator that the tool has been set as the new shortcut
gesture.mask.infoShortcut = ""

// Shortcuts to undo/redo
gesture.history = "";
gesture.history.help = "";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "";
gesture.palmRejection.confirm = "";
gesture.palmRejection.help = "";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "";

// History, list of undo/redo
history = "";
// First "undo" state
history.root = "";
history.undoConfirm = "";
history.undoWarning = "";
// Settings concerning the history stack of undo/redo
history.stack = "";
// Can limit the stack of undo/redo size
history.limitSize = "";
history.limitSize.help = "";
// Limit the number of undo in the history stack
history.limitStack = "";
history.limitStack.help = "";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "";
history.rangeProtect.help = "";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "";
history.restoreCamera.help = "";
// Undo
history.undo = "";
// Redo
history.redo = "";
// Shown during undo
history.state.undo = "";
// Shown during redo
history.state.redo = "";
// Shown during undo/redo
history.state.symmetrySplit = "";
// Shown during undo/redo
history.state.voxelRemesh = "";
// Shown during undo/redo
history.state.surfaceRemesh = "";
// Shown during undo/redo
history.state.multiresLevel = "";
// Shown during undo/redo
history.state.multiresToDynamic = "";
// Shown during undo/redo (mesh type conversion)
history.state.meshDynamicToStatic = "";
// Shown during undo/redo (mesh type conversion)
history.state.meshStaticToDynamic = "";

// Interface customization
interface = "";

// UI customization: each row of the list will be bigger
interface.expandList = "";
// UI customization: each row of the list will be bigger
interface.expandList.help = "";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "";

// Interface option (main base color)
interface.colorBase = "";
// Interface option (accent widget color)
interface.colorSelect = "";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "";

// Interface color style
interface.preset.title = "";
// Interface color style
interface.preset.default = "";
// Interface color style
interface.preset.orange = "";
// Interface color style (~red)
interface.preset.cardinal = "";
// Interface Color style (~pink)
interface.preset.mulberry = "";
// Interface color style
interface.preset.brown = "";
// Interface color style (~green)
interface.preset.emerald = "";
// Interface color style (~blue)
interface.preset.neon = "";
// Interface color style
interface.preset.violet = "";
// Interface color style
interface.preset.grey = "";
// Interface color style
interface.preset.black = "";
// Interface color style
interface.preset.white = "";

// Reset interface settings
interface.resetAll = "";
interface.resetAll.confirm = "";
// Interface customization
interface.flipTop = "";
// Interface customization
interface.flipBottom = "";
// Interface customization
interface.flipMiddle = "";
// Interface customization (preview material in the viewport when editing material color)
interface.materialPreview = "";
// Interface customization
interface.materialPreview.help = "";
interface.toolbox.hide = "";
interface.toolboxHide.help = "";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.maxColumn = "";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "";
// Mirror the curve in the tool falloff
interface.curveToolSymmetric = "";
interface.curveToolSymmetric.help = "";
// Scale the interface
interface.scale = "";
// Spacing between widgets
interface.cursorStep = "";
// Width of the interface panels
interface.panelWidth = "";
// Size of fonts
interface.fontScale = "";

// (see Glossary for Layer)
layer = "";
// (see Glossary for Layer)
layers.lock = "";
// (see Glossary for Layer)
layers.lock.yes = ""
// (see Glossary for Layer)
layers.lock.warning = "";
// (see Glossary for Layer)
layers.addLayer = "";
// (see Glossary for Layer)
layer.factors = "";
// (see Glossary for Layer)
layer.factor = "";
// (see Glossary for Layer)
layer.offset = "";
// (see Glossary for Layer)
layers.title = "";
// (see Glossary for Layer)
layers.title.help = "";
layers.primitive = "";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "";

light = "";
// Intensity of light
light.intensity = "";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "";
// The light will move along the camera
light.attachment.camera = "";
light.attachment.help = "";
// Light type (directional, spot, point)
light.type = "";
// Directional light (synonym: sun light)
light.type.directional = "";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "";
// Cone angle for spot angles
light.spot.angle = "";
// Softness of the spot light
light.spot.softness = "";
// Position of the light
light.position = "";
// Enable or disable shadows for a light
light.shadow.cast = "";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "";
light.shadow.type = "";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "";
light.shadow.type.screenspace.help = "";
// Adjustment to fix artefacts
light.shadow.bias = "";
// How blurry the shadow is
light.shadow.softness = "";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "";
light.contact.help = "";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "";
// Activated the light
light.visible = "";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "";

// Object's material
material = "";
// See glossary
material.pbrRoughnessMetalness.warning = "";
// See glossary
material.pbrReflectance.warning = "";
// See glossary
material.pbrRefraction.warning = "";
// See glossary
material.pbrSubsurface.warning = "";
// Value that says how much light will change direction when hitting the surface
material.ior = "";
// an object-level value that overrides the painting of the mesh
material.paintingOverride = "";
// The roughness in the inside is turbidity
material.paintingOverride.help = "";
// Glossiness is simply the opposite of roughness
material.refractionSurfaceGlossiness = "";
material.refractionSurfaceGlossiness.help = "";
// Synonym: turbidity
material.refractionInteriorRoughness = "";
material.refractionInteriorRoughness.help = "";
// Set the roughness of the object with a value of 0
material.paintGlossy = "";
material.paintGlossy.help = "";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "";
material.absorptionEnable.help = "";
material.absorptionFactor = "";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "";
material.translucency.help = "";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "";
// Fully opaque material
material.type.opaque = "";
// See glossary
material.type.subsurface = "";
material.type.subsurface.help = "";
// Transparency mode, alpha blending
material.type.blending = "";
material.type.blending.help = "";
// Transparency mode
material.type.additive = "";
material.type.additive.help = "";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "";
material.type.dithering.help = "";
// Simulate glass-like material
material.type.refraction = "";
material.type.refraction.help = "";
material.castShadows = "";
material.receiveShadows = "";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "";
material.reflectance.help = "";

// Menu name
menu.files = "";
// Menu name
menu.scene = "";
// Menu name
menu.multires = "";
// Menu name
menu.voxel = "";
// Menu name
menu.dynTopo = "";
// Menu name
menu.topology = "";
// Menu name
menu.primitive = "";
// Menu name
menu.render = "";
// Menu name
menu.material = "";
// Menu name
menu.postProcess = "";
// Menu name
menu.camera = "";
// Menu name
menu.background = "";
// Menu name
menu.tool = "";
// Menu name
menu.stroke = "";
// Menu name
menu.paint = "";
// Menu name
menu.symmetry = "";
// Menu name (pencil pressure)
menu.pressure = "";
// Menu name
menu.gesture = "";
// Menu name
menu.layers = "";
// Menu name
menu.settings = "";
// Menu name
menu.interface = "";
// Menu name
menu.bindings = "";
// Menu name
menu.history = "";
// Menu name
menu.historySettings = "";
// Menu name
menu.about = "";
// Menu name
menu.debug = "";

// Operation on the object (action)
mesh.action = "";
// If the object has holes, the algorithm will close them
mesh.holeClose = "";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holeDetail = "";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "";
// Static object means "static topology"
mesh.typeStatic = "";
// See glossary
mesh.typeMultiresolution = "";
// Dynamic topology 
mesh.typeDynamic = "";

// Node is an abstract type in the scene, examples of Nodes: Mesh, Light, etc
node = "";
// Make the view focused on the selected item
node.focus = "";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "";
paint.useGlobal.help = "";
// The current tool will paint the object if this option is enabled
paint.usePainting = "";
// Factor/Opacity of paint tool
paint.intensity = "";
// Apply the paint on the object
paint.paintAll = "";
paint.paintAll.help = "";
// Apply the paint on the object but ignore painting intensity (force full intensity)
paint.paintAllForce = "";
paint.strokePainting.title = "";
paint.layerWarning = "";
// Brush stroke texture
paint.texture.title = "";
paint.texture.title.help = "";
paint.texture.warningEnable = "";
paint.texture.warningIgnored = "";
// Whether the Brush Alpha will be used to module painting
paint.useAlpha = "";
paint.useAlpha.help = "";
// Whether the Brush Falloff will be used to module painting
paint.useFalloff = "";
paint.useFalloff.help = "";

// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "";

// Post process effect
postprocess = "";
// Quality vs performance
postprocess.quality = "";
postprocess.quality.help = "";
// More samples means better quality but slower performance
postprocess.maxSamples = "";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "";
postprocess.accumulateCount.help = "";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "";
postprocess.renderRatio.warning = "";
postprocess.renderRatio.help = "";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "";
postprocess.taa.help = "";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "";
postprocess.ssr.warning = "";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "";
postprocess.ssgi.experimental = "";
postprocess.ssgi.warning = "";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "";
// How far the effect spreads
postprocess.ssao.radius = "";
// How strong the effect is
postprocess.ssao.factor = "";
// Adjustment to fix artefacts
postprocess.ssao.bias = "";
postprocess.ssao.bias.help = "";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "";
// The blur factor behind the focused point 
postprocess.dof.blurFar = "";
// The blur factor in front of the focused point 
postprocess.dof.blurNear = "";
postprocess.dof.focusTip = "";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "";
// Intensity of the effect
postprocess.bloom.intensity = "";
// How far the effect spreads
postprocess.bloom.radius = "";
postprocess.bloom.radius.help = "";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "";
postprocess.bloom.threshold.help = "";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "";
postprocess.tone.exposure = "";
postprocess.tone.contrast = "";
postprocess.tone.saturation = "";
// No tonemapping operator is used
postprocess.tone.mapping.none = "";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "";
// Color curves
postprocess.curve = "";
// Curve for pixel luminance
postprocess.curve.luminance = "";
postprocess.curve.red = "";
postprocess.curve.green = "";
postprocess.curve.blue = "";
postprocess.curve.reset = "";
// Reset color grading curves
postprocess.curve.resetAll = "";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "";
postprocess.chromatic.factor = "";
// Darking on the edges
postprocess.vignette = "";
// How far the effect spreads
postprocess.vignette.size = "";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "";
postprocess.sharpness.factor = "";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "";
postprocess.grain.factor = "";
// Accentuate the edges of the model
postprocess.curvature = "";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "";
// Color/Strength of convex curvature
postprocess.curvature.bump = "";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "";
// Simulate scanline rendering (horizonal line)
postprocess.scanline = "";
postprocess.scanline.factor = "";
// Spacing between lines
postprocess.scanline.spacing = "";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "";
primitive.box = "";
primitive.sphereCube = "";
primitive.sphereUV = "";
primitive.icosahedron = "";
primitive.cylinder = "";
primitive.cone = "";
primitive.torus = "";
primitive.lathe = "";
primitive.tube = "";
primitive.plane = "";
primitive.triplanar = "";
primitive.faceXYZ = "";
primitive.faceXYZ.help = "";
primitive.needValidate = "";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "";
primitive.edit.help = "";

// Primitive configuration
primitive.mainConfig = "";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "";

// Validating the primitive (then it can be sculpted)
primitive.validate = "";
// Maximum number of faces of the primitives
primitive.maxFaces = "";
primitive.maxFaces.help = "";
// Synonym: Flat subdivision
primitive.linear = "";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "";

// Radius (of a sphere, torus, etc)
primitive.radius = "";
// Size (of cube x dimension)
primitive.size = "";
primitive.sizeX = "";
primitive.sizeY = "";
primitive.sizeZ = "";
// Division only impacts the topology (synonym: resolution)
primitive.division = "";
primitive.divisionX = "";
primitive.divisionY = "";
primitive.divisionZ = "";
// Angle of torus, etc
primitive.angleX = "";
primitive.angleY = "";
primitive.angleZ = "";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "";
primitive.projectOnSphere.help = "";

// triplanar
primitive.triplanar.title = "";
primitive.triplanar.title.help = "";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanarSameSize = "";
primitive.triplanarPolish = "";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanarResetMask = "";
// One side of a cube (the back plane)
primitive.isolate.back = "";
// One side of a cube (the right plane)
primitive.isolate.right = "";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "";
// Plane
primitive.planeSameSize = "";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "";
// Box
primitive.boxRegular = "";
// Distance to the snapping point
primitive.tubeSnapOffset = "";
primitive.tubeSnapOffset.help = "";
// Radius of the tube (starting end-point of the tube)
primitive.tubeThicknessStart = "";
// Radius of the tube (ending end-point of the tube)
primitive.tubeThicknessEnd = "";
primitive.tubeTwist = "";
primitive.tubeTwistRotate = "";
primitive.tubeTwistRadius = "";
primitive.tubeTwistOffset = "";
primitive.tubeSnap = "";
primitive.torusRadiusOuter = "";
primitive.torusRadiusInner = "";
primitive.torusAngle = "";
primitive.torusAngleOffset = "";
primitive.cylinderHeight = "";
primitive.coneRadius = "";
primitive.coneHeight = "";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "";
// Make a hole in the primtive to make it hollow
primitive.hasHole = "";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radiusSync = "";
primitive.radiusStart = "";
primitive.radiusEnd = "";
curve.spline = "";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "";

scene.title = "";
scene.title.help = "";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "";
// Group the selected object with a new created Empty Node as a parent
scene.group = "";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "";
scene.voxelResolution = "";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "";
// Need to select one object only
scene.noneButNeedOne = "";
// Need to select one object only
scene.onlyOneObject = ""

// General scene display settings
settings.display.title = "";
// Wireframe (show triangles and quad edges)
settings.wireframe = "";
// Display UV
settings.debugUV = "";
settings.debugUV.help = "";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "";
settings.twoSided.help = "";
// If we colorize the inverted side of faces
settings.backface.color = "";
// Color of the inverted side of faces
settings.backface.colored = "";
// Outline (contour highlight around the selected object)
settings.outline = "";
// Outline (contour highlight around the selected object)
settings.outline.help = ""
settings.outline.thickness = "";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "";
// Stats (information logs about the scene displayed on screen)
settings.stats = "";
settings.stats.right = "";
settings.stats.all = "";
// Grid
settings.grid = "";
// Cursor
settings.cursor.whileSculpting = "";
// A small indicator dot
settings.cursor.showDot = "";
settings.cursor.showDot.help = "";
settings.cursor.showRope = "";
// Highlight (the object glows when we select it)
settings.highlight.selection = "";
// Highlight settings
settings.highlight = "";
settings.highlight.duration = "";
// Mesh that are not selected will be dark
settings.darkenUnselected = "";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "";
// Experimental feature
settings.partialDraw = "";
settings.partialDraw.help = "";
settings.partialDraw.warning = "";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "";
// Display the empty node icons in the viewport
settings.emptyIcon = "";
// Display the light icons in the viewport
settings.lightIcon = "";
// Display the camera icons in the viewport
settings.cameraIcon = "";
// Tooltip
settings.icon.help = "";
// Hole filling settings
settings.hole = "";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "";
settings.hole.nonManifold.help = "";
// Maximum number of vertices (points)
settings.multires.maxVertices = "";
settings.multires.maxVertices.help = "";
settings.multires.lowResVertices = "";
settings.multires.lowResVertices.help = "";

// The main rendering mode
shading = "";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "";
shading.pbr.help = "";
// Fast rendering mode for sculpting purpose (do not translate) 
shading.matcap = "";
shading.matcap.help = "";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "";
shading.unlit.help = "";
// Helper rendering mode that display a (do not translate)
shading.id = "";
shading.id.help = "";
// Randomize colors
shading.id.randomize = "";
shading.textures = "";
shading.textures.help = "";
// Lights
shading.lights = "";
shading.lights.addLight = "";
shading.lights.warning = "";
// Environment based lighting (synonym: HDRI)
shading.environment = "";
shading.environment.import = "";
shading.environment.exposure = "";
shading.environment.backgroundBlur = "";
shading.environment.rotation = "";
shading.environment.rotation.help = "";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "";
shading.environment.attachedToCamera.help = "";
shading.matcap.rotation = "";
shading.matcap.rotation.help = "";
shading.matcap.global = "";
shading.matcap.global.help = "";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible.short = "";
shortcut.maskVisible.long = "";
// bottom shortcut buttons (should be SHORT)
shortcut.solo.short = "";
shortcut.solo.long = "";
// bottom shortcut buttons (should be SHORT)
shortcut.voxelRemesh.short = "";
shortcut.voxelRemesh.long = "";
// bottom shortcut buttons (should be SHORT)
shortcut.wireframe.short = "";
shortcut.wireframe.long = "";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraReset.short = "";
shortcut.cameraReset.long = "";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraSnap.short = "";
shortcut.cameraSnap.long = "";
// bottom shortcut buttons (should be SHORT)
shortcut.lockSelection.short = "";
shortcut.lockSelection.long = "";
shortcut.lockSelection.long.help = "";
// bottom shortcut buttons (should be SHORT)
shortcut.perspective.short = "";
shortcut.perspective.long = "";
// bottom shortcut buttons (should be SHORT)
shortcut.grid.short = "";
shortcut.grid.long = "";
// bottom shortcut buttons (should be SHORT)
shortcut.uv.short = "";
shortcut.uv.long = "";

// Memory taken by the scene
stat.ramScene = "";
// Vram = Video RAM (Video Memory, the memory of the graphic card) 
stat.vramScene = "";
// Vram = Video RAM (Video Memory, the memory of the graphic card) 
stat.vramRender = "";
// Vram = Video RAM (Video Memory, the memory of the graphic card) 
stat.vramTextures = "";
// Memory taken by the undo/redo history
stat.ramHistory = "";
// Memory taken by other stuffs
stat.ramOther = "";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "";
// RAM, not storage!
stat.ram = "";
stat.used = "";
stat.free = "";
stat.faces = "";
stat.triangles = "";
stat.vertices = "";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "";
stat.sceneFaces = "";
stat.sceneVertices = "";

// Brush stroke
stroke = "";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "";
// The settings is shared among every tools
stroke.useWorldRadius.help = "";
// Share the radius value among every tools.
stroke.useShareRadius = "";
stroke.useShareRadius.help = "";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.minSpacing = "";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.minSpacing.adjustIntensity = "";
stroke.minSpacingAdjustIntensity.help = "";
stroke.minSpacing.help = "";
// Brush stroke smoothing
stroke.lazySmooth = "";
stroke.lazySmooth.help = "";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "";
stroke.lazyRadius.help = "";
// It is not a per-tool settings
stroke.globalSettings = "";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "";
stroke.snapRadius.help = "";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "";
stroke.sculptOffset.help = "";
stroke.accumulate = "";
stroke.accumulate.help = "";
// The tool can use DynTopo
stroke.useDynamicTopology = "";
// Only sculpt the part that are linked topologically
stroke.connectedTopology = "";
stroke.connectedTopology.help = "";
// Only sculpt the vertex that points toward the camera
stroke.onlyFrontFace = "";
stroke.onlyFrontFace.help = "";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.onlySameSide = "";
stroke.onlySameSide.help = "";
// Module the intensity of the sculpting operation by using a falloff curve
stroke.curveFalloff = "";
stroke.onlyLasso = "";
// Alpha
stroke.alpha = "";
// Invert the pixel (black <-> white)
stroke.alphaInvert = "";
// Repeat the alpha image (pattern)
stroke.alphaWrap = "";
// No repeat pattern
stroke.alphaWrap.none = "";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alphaWrap.repeat = "";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alphaWrap.mirror = "";
stroke.alphaProject = "";
// Project the alpha perpendicularly onto the surface 
stroke.alphaProject.surfaceContinuous = "";
// Project the alpha onto the surface in the direction of the camera view
stroke.alphaProject.screenFixed = "";
stroke.alphaRotation = "";
// Repeat the image
stroke.alphaTiling = "";
// Scale the image (make it bigger or smaller)
stroke.alphaScale = "";
stroke.alphaScale.help = "";
// Middle-point value at which no deformation occurs
stroke.alphaMidValue = "";
stroke.alphaMidValue.help = "";
// Stroke type
stroke.strokeType = "";
// Sculpt and paint along the brush stroke at regular spacing
stroke.strokeTypeDot = "";
// Sculpt continuously
stroke.strokeTypeDrag = "";
// Lock a region and move it around
stroke.strokeTypeGrab = "";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.strokeTypeGrabRadius = "";
// Lock a region and sculpt it by changing the tool intensity
stroke.strokeTypeGrabIntensity = "";

// Symmetry
symmetry = "";
symmetry.enable = "";
symmetry.plane.title = "";
symmetry.toolIgnore = "";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "";
symmetry.radialX = "";
symmetry.radialY = "";
symmetry.radialZ = "";
// method
symmetry.method = "";
symmetry.method.help = "";
// Local means: in the coordinate of the scene 
symmetry.methodWorld = "";
// Local means: in the coordinate of the object (internal) 
symmetry.methodLocal = "";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "";
// Mirror the mesh
symmetry.mirror = "";
symmetry.mirror.help = "";
symmetry.mirrorLeftToRight = "";
symmetry.mirrorRightToLeft = "";
symmetry.mirrorFail = "";
symmetry.mirrorUseMasking = "";
symmetry.mirrorUseMasking.help = "";
// Reset the symmetry plane position
symmetry.reset = "";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "";
// Reset the symmetry plane orientation
symmetry.reset.direction = "";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "";
// Display the symmetry plane in 3d
symmetry.showPlane = "";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "";
symmetry.edit.warning = "";
symmetry.edit.help = "";

// Ideally <10 chars
tool.dynTopo = "";
// Ideally <10 chars (Symmetry)
tool.symmetry = "";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "";
// Ideally <10 chars
tool.clay = "";
// Ideally <10 chars (Subtract)
tool.clay.sub = "";
// Ideally <10 chars
tool.brush = "";
// Ideally <10 chars
tool.move = "";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "";
// Ideally <10 chars
tool.drag = "";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "";
// Ideally <10 chars (Paint mask)
tool.mask = "";
// Ideally <10 chars
tool.mask.unmask = "";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "";
// Ideally <10 chars (Layer brush)
tool.layer = "";
// Ideally <10 chars
tool.crease = "";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "";
// Ideally <10 chars
tool.inflate = "";
// Ideally <10 chars
tool.pinch = "";
// Ideally <10 chars
tool.nudge = "";
// Ideally <10 chars
tool.stamp = "";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.lassoSelect = "";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "";
// Ideally <10 chars (Automatic)
tool.gizmo.auto = "";
// Ideally <10 chars
tool.gizmo.editPivot = "";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "";
// Ideally <10 chars (Local space)
tool.gizmo.local = "";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "";
// Ideally <10 chars (Translate the object)
tool.transform.move = "";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "";

// Popup when editing the vertical sliders on the left
tool.slider.radius = "";
// Popup when editing the vertical sliders on the left
tool.slider.intensity = "";

tool.settings = "";
tool.settings.none = "";

// Flatten distance offset
tool.clay.flattenOffset = "";
tool.crease.pinchFactor = "";

tool.layer.removeInfluence = "";
tool.layer.removeInfluence.help = "";
tool.layer.noLayerSelected = "";

tool.flatten.warning = "";
tool.flatten.planeLockOrigin = "";
tool.flatten.planeLockNormal = "";
tool.flatten.planeAverageOrigin = "";
tool.flatten.planeAverageNormal = "";
tool.flatten.planeOffset = "";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "";

tool.paint = "";
// Erase the painting
tool.paint.erase = "";
// Only paint the part of the mesh above a certain height
tool.paint.depthFilter = "";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "";
tool.paint.layerFilter.help = "";

// Clear the painted mask
tool.mask.clear = "";
// Invert the painted mask
tool.mask.invert = "";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "";
// Blur the painted mask
tool.mask.blur = "";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "";
// The thickness of the extracted mesh (from the painted mask)
tool.mask.thickness = "";
// Smooth the border of the extracted mesh (from the painted mask)
tool.mask.polish = "";
// Extract a new mesh from the painteed mask and carve/emboss the base mesh
tool.mask.engraveEmboss = "";
// Extract a new mesh from the painted mask
tool.mask.extract = "";
// Extract two new mesh from the painted mask and from the unmasked area
tool.mask.split = "";
// How should we close the topology of the extracted object
tool.mask.closeMask = "";
// How should we close the topology of the extracted object
tool.mask.closeUnmask = "";
// How should we close the topology of the extracted object
tool.mask.closeAction = "";
// Do not close the mesh (leave it open)
tool.mask.closeActionNone = "";
// Close the mesh with a hole-filling algorithm
tool.mask.closeActionFill = "";
// Close the mesh by adding a thickness on the surface
tool.mask.closeActionShell = "";
// Close the mesh by using the layer data as a difference thickness
tool.mask.closeActionLayer = "";
tool.mask.closeAction.help = "";

// Transform/Matrix
tool.matrix = "";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.apply = "";
// Automatic
tool.matrix.apply.auto = "";
// Vertex/Point of a mesh
tool.matrix.apply.vertex = "";
// Object-level transform (Matrix)
tool.matrix.apply.object = "";
tool.matrix.apply.help = "";
// Operation on the mesh
tool.matrix.action = "";
tool.matrix.action.help = "";
tool.matrix.translation = "";
tool.matrix.rotation = "";
tool.matrix.scale = "";
tool.matrix.uniformScale = "";
tool.matrix.uniformScale.help = "";
tool.matrix.moveToOrigin = "";
tool.matrix.resetTransform = "";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "";

tool.transform.multiTouch = "";
tool.transform.multiTouch.help = "";
tool.transform.transformRestrictRotationY = "";
tool.transform.transformRestrictRotationY.help = "";

// Size of the gizmo
tool.gizmo.size = "";
// When enabled, taping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "";
tool.gizmo.allowInput.help = "";
// Angle threshold
tool.gizmo.linearRollThreshold = "";
tool.gizmo.linearRollThreshold.help = "";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "";
tool.gizmo.tap = "";
tool.gizmo.tap.help = "";
tool.gizmo.tapNone = "";
tool.gizmo.tapFirstHit = "";
tool.gizmo.tapMiddleStab = "";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "";

// Fill the object's hole
tool.hole = "";
tool.hole.fillHoles = "";
// synonym: Alternative method
tool.hole.bridges = "";
tool.hole.bridges.help = "";
tool.hole.threshold = "";
tool.hole.threshold.help = "";
tool.hole.smoothing = "";

tool.smudge.quality = "";
tool.smudge.quality.help = "";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "";

// Topology
topology = "";
// Synynom: detail value, density
topology.dynamic.detail = "";
// See glossary
topology.multires = "";
topology.multires.help = "";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "";
topology.multires.reverse.confirm = "";
topology.multires.subdivide = "";
topology.multires.subdivide.confirm = "";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = ""
topology.multires.deleteLower = "";
topology.multires.deleteHigher = "";
topology.multires.keepTriangles = "";
// Synonym: Flat subdivision
topology.multires.linear = "";
topology.multires.linear.help = "";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "";
topology.voxel.help = "";
topology.voxel.resolution = "";
topology.voxel.remesh = "";
topology.voxel.sharp = "";
topology.voxel.sharp.help = "";
topology.voxel.subLevel = "";
topology.voxel.subLevel.help = "";
// Dynamic topology (DynTopo)
topology.surface.remesh = "";
topology.surface.detail = "";
topology.surface.detail.help = "";
topology.surface.method = "";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "";
topology.surface.method.help = "";
topology.surface.useMasking = "";
topology.surface.useMasking.help = "";
topology.surface.extrapolate = "";
// DynTopo
topology.dynamic = "";
topology.dynamic.activate = "";
topology.dynamic.activate.help = "";
topology.dynamic.method = "";
topology.dynamic.method.zoom = "";
topology.dynamic.method.radius = "";
topology.dynamic.method.constant = "";
topology.dynamic.method.help = "";
topology.dynamic.quality = "";
topology.dynamic.quality.help = "";
topology.dynamic.quality.speed = "";
topology.dynamic.quality.quality = "";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "";
topology.dynamic.usePressure.help = "";
// Decimate
topology.decimate.title = "";
topology.decimate.title.help = "";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "";
topology.decimateTargetFaces = "";
topology.decimatePaintWeight = "";
topology.decimatePaintWeight.help = "";
topology.decimateUniform = "";
topology.decimateUniform.help = "";
// topology.decimatePreserveBorders "Preserve borders"
// topology.decimatePreserveBorders.help "Do not decimate the border of the mesh.

// Unwrapping means compute UV (texture coordinates), it allows the object to receive on texture (wrap the texturing on the object)
topology.uv.title = "";
// UV Unwrapping
topology.uvAtlas = "";
// The operation can be very slow
topology.uvAtlas.warning = "";
// UV Unwrapping (BFF best left untranslated, stands for Boundary First Flattening)
topology.uvBFF = "";
// Handles are topological holes (synonym: genus, hole)
topology.uvBFF.warning = "";
// Synonym: Point count? Singularity count ?
topology.uvBFFCones = "";
topology.uvBFFCones.help = "";
topology.uvDelete = "";

// Transfer the vertex painting in the texture
topology.bake = "";
topology.bake.help = "";
topology.bakeResolution = "";

// Reset key-bindings/shortcuts
binding.reset = "";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.materialPicker = "";
// Edit the tool brush size/radius
binding.editRadius = "";
// Edit the tool brush size/radius
binding.editIntensity = "";
// Snap the camera
binding.viewFront = "";
// Snap the camera
binding.viewLeft = "";
// Snap the camera
binding.viewTop = "";
// Move/Translate the view
binding.panLeft = "";
// Move/Translate the view
binding.panRight = "";
// Move/Translate the view
binding.panForward = "";
// Move/Translate the view
binding.panBackward = "";
// Move/Translate the view
binding.panUp = "";
// Move/Translate the view
binding.panDown = "";
// Snap the view (while rotating)
binding.snapViewOnRotate = "";
// Open a Nomad internal project (replace current scene)
binding.project.open = "";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "";
// Import an external scene file (replace current scene)
binding.import.open = "";
// Import an external scene file (add it to the current scene)
binding.import.add = "";
// Select all the objects in the scene
binding.selectAll = "";
// Rotate environment and the lighting
binding.rotateLighting = "";

// Privacy policy
privacyPolicy.title = "";
privacyPolicy.reject = "";
// Hexanomad is the company name
privacyPolicy = "";

// version trial
version.buyWeb = "";
version.buyFull = "";
version.restorePurchase = "";

version.trialHistory = "";
version.trialLayer = "";
version.trialOneProject = "";
version.trialNoImport = "";
version.trialNoExport = "";

version.fullFeatures = "";
