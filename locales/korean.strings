// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "승인하시겠습니까?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "네";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "확인";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "취소";

// Experimental feature
experimental = "";

// common
position.top = "위";
position.right = "오른쪽";
position.left = "왼쪽";
position.bottom = "아래";
position.center = "가운데 정렬";
direction.up = "위";
direction.right = "오른쪽";
direction.left = "왼쪽";
direction.down = "아래";

// Name of an item (object, tool, etc)
item.name = "이름";
// Add a new item (object, tool, etc)
item.new = "신규";
// Rename an item (object, tool, etc)
item.rename = "이름변경";
// Add a new item (object, tool, project, etc)
item.add = "추가";
// Update an item image with a new image (synonym: Update)
item.replace = "";
// Save an item (object, tool, etc)
item.save = "저장";
item.save.confirm = "저장하시겠습니까?";
// Reload last save of an item (object, tool, etc)
item.lastSave = "최근 저장";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "마지막 저장 내용을 불러오시겠습니까?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "초기화";
item.reset.confirm = "초기화하시겠습니까?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "인스턴스";
// Uninstance the object, make the object real
item.uninstance = "인스턴스 해제";
// Clone an item (object, tool, etc)
item.clone = "복제";
// Delete an item (object, tool, etc)
item.delete = "삭제";
item.delete.confirm = "삭제하시겠습니까?";
item.delete.confirm.yes = "네, 삭제합니다";
// When we delete the item but the image is used somewhere
item.delete.imageUsed = "다음 도구에 의해 사용됨:";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "노드로 변환";
// Item visibility (object, layer, etc)
item.visible = "보이기";
// Show an item (object, layer, etc)
item.show = "보기";
// Hide an item (object, layer, etc)
item.hide = "가리기";
// Select an item (object, layer, etc)
item.select = "선택";
// Unselect an item (object, layer, etc)
item.unselect = "선택 해제";
// Merge an item with another one below (layer)
item.mergeDown = "아래 레이어와 병합";
// The order of an item in a list
item.order = "순서";
// Focus on previous item
item.previous = "이전";
// Focus on next item
item.next = "다음";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "잠금";
// No item selected
item.none = "없음";

// Search something (text entry to filter item)
search = "검색";

// Three-state toggle button (Auto, Off, On)
toggle.on = "켬";
// Three-state toggle button (Auto, Off, On)
toggle.off = "끔";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "자동";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "썸네일 이미지가 없습니다. 파일 재처리 중... ($0/$1)

$2";
loading.reprocess.cancel = "";

access.title = "";
access.window = "";
access.pinch = "";
access.drag = "";
access.roll = "";

// Color of an object
material.color = "색상";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "거칠기";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "광택";
// Whether the material is a metal or not
material.metalness = "메탈릭";
// How much light a surface will reflect
material.specular = "스페큘러";
// Light that the surface can emit (glow)
material.emissive = "이미시브";
// Normal map (synonym: detail, bump)
material.normal = "보통";
// Ambient Occlusion (AO)
material.occlusion = "오클루전";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "텍스처";
// Textures/Image
material.texture = "";
// A warning indicating that the mesh has no UVs
material.warningNoUVs = "";
// Texture filtering https://en.wikipedia.org/wiki/Texture_filtering
material.texture.filter = "";
// Nearest Filtering (closest sample)
material.texture.nearest = "";
// Bilinear Filter
material.texture.linear = "";
// Mipmap filtering
material.texture.mipmap = "";

// Minify
about.minify = "인터페이스 축소";
about.minify.help = "장치가 지원하는 경우 네 손가락으로 화면을 탭할 수도 있습니다.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "턴테이블";
// Rotation center of the turntable
about.turntable.pivot = "";
// Keep current pivot
about.turntable.pivot.keep = "";
// Turntable pivot will be at the center of the scene
about.turntable.pivot.scene = "씬";
// Make the entire scene turn around (speed of the animation)
about.turntable.speed = "턴테이블 속도";
// Stuffs that I used to make the app
about.credits = "감사의 말";
// Link to open source projects that I used for the app
about.credits.openSource = "오픈 소스";
// Only translate the &
about.credits.arts = "MatCap 및 HDRI";
// Change languages of the app
about.languages = "언어";
about.languages.help = "$0에서 번역 파일 사용 가능";
// Link to the App Website
about.website = "웹사이트";
// Link to the App Forum
about.forum = "포럼";
// Link to the App Manual
about.manual = "설명서";
// Link to the App Email
about.mail = "지원";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";

// The user canceled an operation that was running
alert.aborted = "";
// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "오브젝트에 구멍이 없습니다!";
// No operation occured because the mesh is already manifold
alert.manifold.already = "";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "현재 오브젝트가 보이지 않습니다!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "잘라낼 대상이 없음.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "잘라내기 중지: 오브젝트가 완전히 다듬어져 있습니다.";
// In order to extract something, the mesh needs to have painted mask
alert.mask.noExtract = "추출할 대상이 없음!";
// In order to split something, the mesh needs to have painted mask
alert.mask.noSplit = "분할할 대상이 없음!";
// List of disabled features when View Mode is selected
alert.view.disabled = "뷰 모드에서 비활성화된 기능:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "프리미티브 위젯";
// The object needs to have two parts disconnected
alert.separate.fail = "분리할 수 없음: 오브젝트가 하나로 되어 있습니다!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "리메시 완료!";
alert.voxelRemesh.empty = "리메시 중단: 출력된 메시에 면이 없습니다.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "입력이 유효하지 않습니다!";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "오브젝트가 복제됩니다";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "오브젝트가 인스턴스화됩니다";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "피벗 모드 편집.";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "오브젝트 모드 편집.";
// See Glossary (DynTopo)
alert.dynamic.enable = "동적 토폴로지 활성화";
// See Glossary (DynTopo)
alert.dynamic.disable = "동적 토폴로지 비활성화";
alert.colorPicker = "오브젝트를 손가락으로 드래그하여 색상을 선택합니다.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "가볍게 탭하여 트랜스폼 모드를 종료합니다.";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "";
// Show the painted mask on the mesh
alert.mask.show = "마스크 보기";
// Hide the painted mask on the mesh
alert.mask.hide = "마스크 가리기";
// Selection refers to the objects that are currently selected
alert.selection.lock = "선택 잠금";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "선택 잠금해제";
// Hide the objects that are not selected
alert.selection.isolate = "선택 대상 분리";
// Show the objects that are hidden
alert.selection.showAll = "모두 보기";
// Project quick saving
alert.quickSave = "저장 중...";
// Painting on the object was hidden but the user did paint the object
alert.forceShowPainting.fill = "페인트 표시가 활성화되었으며, [모두 칠하기]가 사용되었습니다.";
// Painting on the object was hidden but the user started to paint on the object
alert.forceShowPainting.tool = "페인트 표시가 활성화되었으며, 오브젝트가 페인팅되었습니다.";
// See Glossary (Multiresolution)
alert.multiresLost = "다중해상도가 손실됩니다!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "디테일 값이 높아 많은 메모리가 필요할 수 있습니다!";
// Autosave popup
alert.autoSave.auto = "$0초 후 자동저장";
// The selected object doesn't have any layers
alert.needLayer = "현재 도구는 활성화된 레이어를 요구합니다.";
// The user decides to hide the painting on the objects
alert.paintingHidden = "페인팅 숨김: 설정 패널에서 다시 볼 수 있습니다.";
// The selected object doesn't have any layers
alert.noPartialWireframe = "와이어프레임을 표시하면 부분 드로잉이 비활성화됩니다.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "화면 투시를 사용할 때 원근감 왜곡을 방지히려면 카메라 설정을 직교 방식으로 전환하는 것이 좋습니다.";
// Trial version has a limited number of undo
alert.state.trial = "평가판: '실행 취소'가 취소됨";

background = "배경";
// A flat color will be displayed in the background of the scene
background.color = "색상";
// The environment (HDRI) will be displayed in the background
background.environment = "환경";
background.blur = "흐림 효과";
background.exposure = "노출";

// Image that the artist uses as a reference
background.imageEnable = "참조 이미지";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "오버레이";
// Opposite of transparency (Alpha)
background.imageAlpha = "불투명도";
background.imageReset = "설정 초기화";
background.imageTransform = "변형";
// X screen coordinate of the image reference
background.imageX = "위치 X";
// Y screen coordinate of the image reference
background.imageY = "위치 Y";
// Rotation of the reference image
background.imageRotation = "회전";
// Scale of the reference image
background.imageScale = "비율";

// Camera (point of view in 3d)
camera = "카메라";
// Copy the views
camera.updateView = "뷰 포인트를 업데이트하시겠습니까?";
// Add a new camera
camera.addView = "뷰 추가";
// Focus on the camera
camera.focus = "포커스";
// Add on the camera camera
camera.focusOn = "$0에 포커스";
// Camera projection, Orthographic or Perspective
camera.projection = "투사도";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "직교";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "원근";
// camera Vertical Field of View
camera.fov = "수직 시야각";
// Camera Field of View hint
camera.focal = "35mm 환산 초점 거리: $0mm";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "회전";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "턴테이블";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "트랙볼";
camera.rotation.trackball.help = "트랙볼을 사용하면 두 손가락으로 카메라를 돌릴 수 있는 더 높은 자유도를 제공합니다.";
// Camera interaction mode, 1st person view
camera.firstPerson = "일인칭";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "속도";
// Camera rotation sensitivity
camera.speed.rotation = "회전";
// Camera translation sensitivity
camera.speed.panning = "패닝";
// Camera zooming sensitivity
camera.speed.zooming = "확대/축소";
// Reset camera position
camera.resetView = "뷰 초기화";
// Align the view (snap to nearest 90° angle)
camera.snapView = "스냅 뷰";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "카메라가 스냅됨 (직교)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "직교 스냅";
camera.snapOrthographic.help = "이 옵션은 화면 모서리에서 스냅 큐브를 사용하는 경우에도 유효합니다.";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "피벗";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "오브젝트에서 이중 탭";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "배경에서 이중 탭";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "전환";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "선택 영역";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "씬";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "이중 탭으로 업데이트";
camera.doubleTapPivot.help = "오브젝트의 표면을 두 번 탭하면 회전축(피벗)을 업데이트합니다.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "에어 피벗";
camera.airPivot.help = "오브젝트의 표면 밖에서 확대/축소하는 경우에도 새로운 피벗을 허용합니다.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "카메라 제스처가 시작할 때";
camera.autoPivot.help = "카메라와 상호 작용하기 시작하면 피벗이 업데이트됩니다.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "포커스";
camera.doubleTapFocus.help = "오브젝트를 이중-탭하면 카메라가 이동하여 선택한 지점에 포커스를 맞춥니다.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "다중선택";
// There is 0 nodes/items selected
context.noSelection = "선택 없음";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "프리셋";
// Quick curve x side shift
curve.shift = "";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "스플라인 곡선";
// Regular spaced sampling
curve.uniform = "";
curve.uniform.help = "";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "";

// Set the desired FPS (frame per second, refresh rate)
debug.targetFPS = "";
debug.targetFPS.help = "";

// Debug option, the newly created primitives will contains texture coordinates (UVs)
debug.uvPrimitive = "프리미티브 UV 유지하기";
debug.uvPrimitive.warning = "UV가 필요하지 않은 경우 이 옵션을 비활성화하십시오 (추가 메모리 확보).";
debug.uvPrimitive.help = "현재는 상자와 구체만 지원됩니다.

다른 유형은 향후 지원될 예정입니다.";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "UV 노멀라이즈";
debug.uvNormalize.help = "Nomad는 [0-1] 타일 안에 있는 UV를 노멀라이즈합니다.";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "BFF UV 추가";
debug.uvBFF.help = "대체 언랩 방법(BFF, Boundary First Flattening)을 추가합니다.

메시 토폴로지가 원반 또는 구체와 다른 경우 BFF에 의해 중첩이 발생하니 주의해주십시오.";

debug.quadriflow = "";
debug.quadriflow.help = "";


// Debug option, display an window with some debugging logs
debug.logs = "로그";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "하이트맵";
// Debug options, graphical stuffs
debug.graphics = "그래픽";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "스토어 썸네일 생성";

// Empty list: there is no projects
file.project.empty = "아직 저장된 프로젝트가 없습니다!";
// The current opened project has some unsaved changes
file.project.unsaved = "변경 내용이 저장되지 않았습니다!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "저장되지 않은 변경사항은 손실됩니다!";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "마지막으로 수동 저장한 내용 미리보기";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "평가판: 현재 프로젝트를 다시 열 수 없습니다!";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "평가판: 현재 프로젝트만 다시 열 수 있습니다!";

file.project = "프로젝트";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "저장";
// E.g: Save "my_project"?
file.project.save.confirm = "$0 항목을 저장하시겠습니까?";
// Overwrite another project
file.project.saveAs = "다음으로 저장";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "$0 항목을 덮어쓰시겠습니까?";
// Open a project
file.project.open = "열기";
// E.g: Open "my_project"?
file.project.open.confirm = "$0 항목을 여시겠습니까?";
// Load another project and add/append all its data to the current scene
file.project.add = "씬에 추가";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "$0 항목을 씬에 추가하시겠습니까?";
// Reset the scene and create a new project
file.project.new = "신규";
file.project.new.confirm = "새로운 씬을 생성하시겠습니까?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "$0 항목을 삭제하시겠습니까?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "$0 항목을 삭제하시겠습니까?

해당 항목은 현재 진행 중인 프로젝트입니다!";

// Auto save section
file.project.autoSave = "자동 저장";
file.project.autoSave.confirm = "자동 저장 기능을 끄시겠습니까?";
file.project.autoSave.help = "일정 간격으로 프로젝트를 별도의 파일로 저장합니다.
자동저장 파일은 다음 위치에서 찾을 수 있습니다:

$0";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "팝업 시간초과";
// In minutes
file.project.autoSave.minutes = "타이머 팝업";
// Delete the current autoSave data
file.project.autoSave.delete = "자동 저장 취소";

// color space (linear or srgb), do not translate linear/srgb if there is a doubt
file.colorSpace = ""
file.colorSpace.help = "";
file.colorSpace.linear = "";
file.colorSpace.srgb = "";

// Configure imports option
file.importSettings = "임포트 옵션";

// Load interface preference settings when opening a scene file
file.import.guiSettings = "GUI 설정 유지하기";
file.import.guiSettings.help = "프로젝트 파일을 열거나 임포트할 때 프로젝트에 포함된 GUI 관련 설정을 모두 불러옵니다.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.import.objSplitByGroup = "OBJ를 그룹으로 분할";
file.import.objSplitByGroup.help = "활성화되면 Nomad는 OBJ 그룹을 별도의 객체로 분할합니다.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.import.mergeLayers = "레이어 병합";
// Ignore the textures present in the file to load
file.import.skipTextures = "텍스처 건너뛰기";
// Do not fiddle with the object topology when loading the file
file.import.keepTopology = "토폴로지 유지하기";
file.import.keepTopology.help = "Nomad로 불러온 메시 토폴로지를 건드리지 않으려면 이 옵션을 사용하십시오.

이렇게 하면 버텍스/면 재정렬, 버텍스/면 복제본 제거, 사용하지 않는 버텍스 제거가 비활성화됩니다.";


// Import file section
file.import.title = "임포트";
file.import.title.help = "지원 포맷:
- Wavefront (.obj)
- glTF 2.0 (.glb .gltf)
- STL (.stl)";
// The user imports a scene file that will replace the current scene
file.import.open = "열기";
file.import.open.confirm = "새로운 파일을 가져오시겠습니까?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "씬에 추가";
file.import.add.confirm = "새로운 파일을 가져오시겠습니까?";

// Export scene file
file.export.title = "익스포트";

// Export the current selected objects instead of the entire scene
file.onlySelection = "선택한 오브젝트만 포함";
file.onlySelection.help = "전체 씬 대신 선택 항목만 포함합니다.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "사각형 재구성";
file.convertToQuad.help = "삼각형의 짝을 짓는 방식으로 삼각형으로부터 사각형을 재구성합니다 (파일 안에서 인접한 경우).";

// Whether we include the textures in the exported file
file.export.texture = "텍스처";
// Baking means transfering/converting
file.export.texture.help = "이 옵션은 버텍스 색상을 텍스처로 베이킹하지 않습니다.";
// Whether we include normals vector in the exported file
file.export.normal = "노멀";
file.export.normal.help = "다른 소프트웨어에서 파일을 열려면 이 옵션을 선택합니다.

Nomad는 노멀을 다시 계산하므로 항상 무시합니다.";

file.export.nomad = "";
file.export.nomad.help = "";

file.export.gltf = "glTF 2.0 익스포트";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "레이어";
file.export.gltf.layer.help = "레이어를 모프(morph)로 내보냅니다. glTF에서 공식적으로 지원하므로 다른 소프트웨어에서도 작동합니다.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "레이어 페인트";
file.export.gltf.layerPaint.help = "레이어 페인팅을 내보냅니다. 일반적으로 다른 소프트웨어에서는 무시됩니다.";
// Whether we include the vertex color in the exported file
file.export.gltf.color0 = "버텍스 색상";
file.export.gltf.color0.help = "버텍스 색상을 내보냅니다. glTF에서 공식적으로 지원하므로 다른 소프트웨어에서도 작동합니다.";
// Whether we include the vertex roughness and vertex metalness in the exported file
file.export.gltf.color1 = "PBR 페인트";
file.export.gltf.color1.help = "러프니스와 메탈릭, 마스크 페인팅을 내보냅니다. 다른 소프트웨어에서는 무시됩니다.";

file.export.obj = "OBJ 익스포트";
file.export.obj.warning = "레이어 및 추가 페인팅 정보(러프니스, 메탈릭, 마스크)가 손실됩니다.";
// Whether we include the vertex color in the exported file
file.export.obj.colorAppend = "버텍스 색상";
file.export.obj.colorAppend.help = "버텍스에 색상 정보를 덧붙입니다.

해당 정보는 일부 3D 소프트웨어에서 읽을 수 있지만, 호환되지 않는 소프트웨어도 있습니다.";
file.export.obj.colorHexa = "";
file.export.obj.colorHexa.help = "";

file.export.stl = "STL 익스포트";
file.export.stl.warning = "레이어 및 추가 페인트(러프니스, 메탈릭, 마스크)가 손실됩니다.";
// Whether we include the vertex color in the exported file
file.export.stl.color = "버텍스 색상";
file.export.stl.color.help = "일부 3D 소프트웨어에서 열 수 있지만, 모든 소프트웨어에서 지원되는 것은 아닙니다.";
file.export.stl.ascii = "기본 포맷은 바이너리입니다.

텍스트 형식(ASCII)으로 내보내는 것도 가능하지만 파일 크기가 더 커집니다.";

// Advanced settings
settings.advanced = "고급";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "해당 옵션은 설정에 저장되지 않습니다.";
settings.reset.title = "설정";
settings.reset.title.help = "이 작업은 앱 설정을 초기화합니다.

일부 리소스는 별도로 저장되므로 초기화되지 않으며, 다음과 같은 항목을 포함합니다:
- 프로젝트
- 키 바인딩
- 도구 프리셋
- HDR 환경
- MatCap
- 알파
- 텍스처 (브러시)
- 레퍼런스 이미지

프로젝트에 연결된 모든 항목과 설정, 예를 들어 광원과 포스트 프로세싱, 카메라 뷰 등은 모두 현상태로 유지됩니다.";

// Reset preference settings button
settings.reset = "기본값으로 초기화";
settings.reset.confirm = "환경설정을 초기화하시겠습니까?";

// Render a screenshot of the scene
file.render = "렌더";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "인터페이스 보기";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "렌더 비율";
file.render.renderRatio.help = "값이 1.0인 경우는 아래 요청된 이미지 크기와 동일한 해상도로 렌더링됨을 의미합니다.

특정 해상도에서 렌더링할 수 없는 경우 (메모리 부족 등의 이유로 충돌) 이 옵션을 사용하십시오.";
// Desired size of the exported screenshot
file.render.size = "최종 크기";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "커스텀";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "스크린";
// width of exported screenshot
file.render.width = "너비";
// height of exported screenshot
file.render.height = "높이";
// export screenshot of the scene
file.render.export = "PNG 내보내기";
file.render.warn = "익스포트 해상도가 높습니다 ($0x$1)!

VRAM이 부족하여 장치에서 충돌이 발생할 경우를 대비해 프로젝트를 저장하시기 바랍니다.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "투명한 배경";
file.render.transparent.help = "이 옵션은 2D 제작 소프트웨어에서 메시를 삽입하려는 경우 유용합니다.

현재 부분적인 오브젝트 투명도는 지원되지 않습니다.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "전역 설정 사용";
pressure.useGlobal.help = "기본적으로 도구는 동일한 압력 설정을 공유합니다.

이 도구에 특정 압력 설정을 적용하려면 이 옵션의 체크를 해제하십시오.";

// Pencil pressure
pressure.title = "압력";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "이 도구는 펜슬 압력을 사용하지 않습니다.";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "붙잡기(Grab) 스트로크 유형은 압력 설정을 무시합니다.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "반지름";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "강도";
// Average pencil pressure event to get smoother result
pressure.average = "";
pressure.average.help = "";

// list of inputs allowing camera interaction
gesture.camera = "카메라";
// list of inputs allowing sculpting interaction
gesture.sculpt = "스컬프팅";
// Finger/Touch input
gesture.finger = "손가락";
// Stylus/Pencil
gesture.stylus = "스타일러스";
// Mouse/Trackpad
gesture.mouse = "";

// long press to pick the color/material under the cursor
gesture.dropper = "머티리얼 선택";
gesture.dropper.help = "버스를 길게 누르면 색상/머티리얼 피커가 표시됩니다.

현재 사용하는 브러시에 페인트가 활성화된 경우에만 작동합니다.";

// Three fingers on screen
gesture.three.title = "세 손가락";
// Drag 3 fingers horizontally on the canvas to rotate the environment, lights and MatCap
gesture.fingerLighting = "광원 회전 (세 손가락)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerLighting.help = "세 손가락으로 캔버스 위를 가로로 드래그하면 환경, 광원, MatCap을 회전할 수 있습니다.";
// Drag 3 fingers vertically to edit the tool radius
gesture.fingerRadius = "도구 반지름 편집 (세 손가락)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerRadius.help = "캔버스에서 세 손가락을 수직으로 드래그하여 도구의 반지름을 수정합니다.";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.fingerSmooth = "손가락을 항상 스무드 도구로 사용";
gesture.fingerSmooth.help = "";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "인식되지 않는 압력 허용";
gesture.unknownPressure.help = "연필로 압력을 가할 수 없거나 압력 손가락이 필요한 경우 이 옵션을 선택하십시오.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "펜슬 버튼";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "펜슬 이중 탭";
gesture.pencilAction.ios.help = "Apple Pencil 2세대만 대응합니다.";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "없음";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "더하기/빼기";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "싱글 탭 바로 가기";
gesture.mask.oneTap.help = "씬을 한 번 탭하면 마스크 바로 가기가 허용되며, 마스크 버튼 바로 가기를 누르고 있지 않아도 됩니다.

다음 제스처 사용 가능:
- 백그라운드를 탭하여 마스크 반전
- 마스크 영역을 탭하여 마스크를 흐리게
- 마스크되지 않은 영역을 탭하여 마스크를 선명하게";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress = "길게 누르기 (마스크 ↔ 마스크 선택자)";
gesture.mask.holdStroke = "스트로크";
gesture.mask.holdStroke.help = "";
gesture.mask.holdIdle = "도구";
gesture.mask.holdIdle.help = "";

// Shortcut customization, choose the action that the shortcut will performan (select tool, etc)
gesture.shortcut = "바로 가기";

// Shortcuts to undo/redo
gesture.history = "작업 내역 바로 가기";
gesture.history.help = "- 실행 취소: 두 손가락으로 탭
- 다시 실행: 세 손가락으로 탭
- 실행 취소/다시 실행: 두/세 손가락으로 꾸욱 누르기 (지속)";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "손바닥 인식 방지";
gesture.palmRejection.confirm = "캔버스와 상호 작용하는 데 문제가 있는 경우 이 옵션을 비활성화하십시오!";
gesture.palmRejection.help = "이 값보다 접촉 면적이 넓으면 입력을 거부합니다.

모든 장치에서 작동하지 않을 수 있습니다.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "최대 크기 임계값";

// History, list of undo/redo
history = "작업 내역";
// First "undo" state
history.root = "시작";
history.undoConfirm = "모든 작업을 취소하시겠습니까?";
history.undoWarning = "나중에 편집을 추가하면 많은 변경사항이 손실될 수 있습니다.";
// Settings concerning the history stack of undo/redo
history.stack = "스택";
// Actions to include in the undo/redo stack
history.include = "동작 포함";
// include lighting editing in the undo/redo
history.includeLights = "광원";
history.includeLights.help = "이 옵션을 비활성화하면 씬 계층 구조의 다른 오브젝트에 영향을 줄 수 있으므로 기즈모를 사용한 광원 이동이 계속 포함됩니다.";
// include postProcess editing in the undo/redo
history.includePostProcess = "포스트 프로세싱";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCap 및 HDRI";
// Can limit the stack of undo/redo size
history.limitSize = "작업 내역 제한 (Mb)";
history.limitSize.help = "작업 내역의 최소 크기 (Mb 단위)";
// Limit the number of undo in the history stack
history.limitStack = "스택 제한";
history.limitStack.help = "응용 프로그램이 기억할 수 있는 최대 작업 수입니다.

작업 내역은 다음 작업이 기록되면 업데이트됩니다.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "최대로 가능한 실행 취소";
history.rangeProtect.help = "작업 내역에서 여러 칸을 이동하면 다수의 작업을 실행 취소하기 전에 사용자의 확인을 요청하는 대화 상자가 표시됩니다.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "카메라 복원";
history.restoreCamera.help = "이 옵션을 활성화하면, 동작을 실행 취소하거나 다시 실행할 때 저장된 카메라의 뷰포인트를 복원합니다.";
// Undo
history.undo = "실행 취소";
// Redo
history.redo = "다시 실행";
// Shown during undo
history.state.undo = "실행 취소: $0";
// Shown during redo
history.state.redo = "다시 실행: $0";
// Shown during undo/redo
history.state.symmetrySplit = "대칭 분할";
// Shown during undo/redo
history.state.voxelRemesh = "복셀 리메시";
// Shown during undo/redo
history.state.surfaceRemesh = "표면 리메시";
// Shown during undo/redo
history.state.multiresLevel = "해상도 변경";

// Debugging/Inspect object material (view channel separately color, roughness, normal, uv, etc)
inspector = "";
// Inspector but SHORT
inspector.short = "";
// Display the material channel on the background
inspector.onBackground = "";
// Display the material channel on the mesh
inspector.onMesh = "";

// Interface customization
interface = "인터페이스";

// UI customization: one item row will stands on one line (synonym: Inlined)
interface.compact = "";

// UI customization: each row of the list will be bigger
interface.expandList = "UI: 목록 확장";
// UI customization: each row of the list will be bigger
interface.expandList.help = "쉬운 목록 관리를 위한 UI 옵션입니다.";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "바로 가기 추가 (아래)...";

// Interface option (main base color)
interface.colorBase = "색상 베이스";
// Interface option (accent widget color)
interface.colorSelect = "색상 위젯";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "패널 투명도";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "블러 효과 강도";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "색상 패널";

// Interface color style
interface.preset.title = "색상 프리셋";
// Interface color style (original color of Nomad Sculpt)
interface.preset.classic = "클래식";
// Interface color style
interface.preset.orange = "주황색";
// Interface color style (~red)
interface.preset.cardinal = "진홍색";
// Interface Color style (~pink)
interface.preset.mulberry = "적자색";
// Interface color style
interface.preset.brown = "갈색";
// Interface color style (~green)
interface.preset.emerald = "선녹색";
// Interface color style (~blue)
interface.preset.neon = "Neon";
// Interface color style
interface.preset.violet = "보라색";
// Interface color style
interface.preset.gray = "회색";
// Interface color style
interface.preset.black = "검은색";
// Interface color style
interface.preset.white = "흰색";

// Reset interface settings
interface.resetAll = "스타일 초기화";
interface.resetAll.confirm = "인터페이스 설정을 초기화하시겠습니까?";
// Interface option (main base color)
interface.iconSupport = "";
interface.iconSupport.help = "";
// Interface customization
interface.flipTop = "상단 바 반전";
// Interface customization
interface.flipBottom = "하단 바 반전";
// Interface customization
interface.flipMiddle = "측면 바 반전";
// Interface customization (preview material in the viewport when editing material color)
interface.materialPreview = "머티리얼 색상 미리보기";
// Interface customization
interface.materialPreview.help = "머티리얼의 색상을 선택하면, 이 머티리얼에 대한 미리보기가 현재 선택한 오브젝트에 표시됩니다.";
interface.toolbox.hide = "도구 상자 가리기";
interface.toolboxHide.help = "도구 상자를 숨기려면 이 옵션을 켜십시오.";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.maxColumn = "도구 상자 최대 열";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "도구 상자 순서 초기화";
// Scale the interface
interface.scale = "인터페이스 스케일";
// Spacing between widgets
interface.cursorStep = "수직 간격";
// Width of the interface panels
interface.panelWidth = "패널 너비";
// Size of fonts
interface.fontScale = "폰트 스케일";
// Inset
interface.inset.title = "변 오프셋";
interface.inset.title.help = "화면 가장자리에 있는 버튼과 상호 작용하는 데 문제가 있는 경우에 한하여 이 값을 변경할 수 있습니다.

슬라이더가 비활성화된 경우, Nomad는 장치 자체에서 반환된 안전 영역 값을 사용합니다.";

// (see Glossary for Layer)
layer = "레이어";
// (see Glossary for Layer)
layers.lock = "상단 레이어들의 디테일 유지하기";
// (see Glossary for Layer)
layers.lock.yes = "맨 위에 있는 레이어를 잠그시겠습니까?";
// (see Glossary for Layer)
layers.lock.warning = "스컬프팅을 하는 동안 상단 레이어로부터 오는 변형을 무시합니다.

다만, 이러한 레이어의 디테일은 계속 표시됩니다.

이 옵션은 상단 레이어에 비교적 작은 크기의 디테일이 있는 경우에만 작동합니다.";
// (see Glossary for Layer)
layers.addLayer = "레이어 추가";
// (see Glossary for Layer)
layer.factors = "채널 인수";
// (see Glossary for Layer)
layer.factor = "인수";
// (see Glossary for Layer)
layer.offset = "오프셋";
// (see Glossary for Layer)
layers.title = "레이어";
// (see Glossary for Layer)
layers.title.help = "레이어는 위치 오프셋 값과 페인팅을 기록할 수 있으므로 비선형적인 작업흐름을 할 때 유용합니다.
예를 들어, 변경 사항을 취소하기 위해 과거로 돌아가지 않아도 여러 가지 표정을 시도해 볼 수 있습니다.

페인팅 데이터의 경우 레이어가 탑다운 형식으로 위에서 아래로 정렬됩니다. 즉, 위에 있는 레이어가 아래 있는 레이어를 가립니다.

'DelLayer' 도구를 사용하면 레이어의 일부(따라서 레이어의 영향)를 지우는 것도 가능합니다.";
layers.primitive = "레이어는 프리미티브에 사용할 수 없습니다.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "없음";

light = "광원";
// Intensity of light
light.intensity = "강도";
// Kelvin (the temperature unit)
light.kelvin = "";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "온도";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "어태치먼트";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "고정";
// The light will move along the camera
light.attachment.camera = "카메라";
light.attachment.help = "-- 고정
광원의 방향이 바뀌지 않습니다.

-- 카메라
광원의 방향은 카메라 뷰에 따라 다릅니다.";
// Light type (directional, spot, point)
light.type = "유형";
// Directional light (synonym: sun light)
light.type.directional = "방향성";
light.type.directional.short = "";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "스폿";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "포인트";
// Cone angle for spot angles
light.spot.angle = "원뿔 각도";
// Softness of the spot light
light.spot.softness = "부드러움";
// Position of the light
light.position = "위치";
// Enable or disable shadows for a light
light.shadow.cast = "그림자";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "포인트 광원은 스크린 스페이스 그림자만 지원합니다.";
light.shadow.type = "그림자 유형";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "그림자 맵";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "화면공간";
light.shadow.type.screenspace.help = "실험적 기능으로 향후 릴리스에서 제거될 수 있습니다.

이 옵션은 부드러움 그림자 기능과 함께 사용하기 위한 것입니다.";
// Adjustment to fix artefacts
light.shadow.bias = "그림자 편향";
// How blurry the shadow is
light.shadow.softness = "부드러움";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "접점";
light.contact.help = "자동을 선택하면 가장 지배적인 광원에 대해서만 접촉 그림자가 생깁니다.";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "허용 오차";
// Activated the light
light.visible = "보기";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "위치 재설정";

// Object's material
material = "머티리얼";
// See glossary
material.pbrRoughnessMetalness.warning = "러프니스와 메탈릭은 PBR 셰이딩 모드를 요구합니다.";
// See glossary
material.pbrReflectance.warning = "반사율은 PBR 셰이딩 모드를 요구합니다.";
// See glossary
material.pbrRefraction.warning = "굴절은 PBR 셰이딩 모드를 요구합니다.";
// See glossary
material.pbrSubsurface.warning = "서브서피스는 PBR 셰이딩 모드를 요구합니다.";
// Value that says how much light will change direction when hitting the surface
material.ior = "굴절률";
// an object-level value that overrides the painting of the mesh
material.paintingOverride = "페인팅 오버라이드";
// The roughness in the inside is turbidity
material.paintingOverride.help = "러프니스는 크게 두 종류로 나뉘는데, 하나는 표면에 적용되고 다른 하나는 내부에 적용됩니다.

그러나 하나의 러프니스만 페인팅할 수 있으므로 두 러프니스는 같은 값을 가집니다.

이 슬라이더를 사용하면 기존의 표면 러프니스를 무시하고 더욱 메끈하게 광택을 높일 수 있습니다.";
// Glossiness is simply the opposite of roughness
material.refractionSurfaceGlossiness = "표면 광택";
material.refractionSurfaceGlossiness.help = "- 0인 경우, 표면에 칠해진 러프니스를 사용합니다.
- 1인 경우, 표면이 완전히 매끄럽습니다.";
// Synonym: turbidity
material.refractionInteriorRoughness = "내부 러프니스";
material.refractionInteriorRoughness.help = "- 0인 경우, 내부에 칠해진 러프니스를 사용합니다.
- 1인 경우, 내부가 완전히 매끄럽습니다.";
// Set the roughness of the object with a value of 0
material.paintGlossy = "페인트 광택";
material.paintGlossy.help = "러프니스와 메탈릭이 '0'인 상태에서 오브젝트를 칠하여 날카로운 굴절을 허용합니다.

이는 페인팅 메뉴로 이동하여 색상 및 메탈릭을 비활성화한 상태로 '모두 칠하기' 기능을 사용하는 것과 동일합니다.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "흡수";
material.absorptionEnable.help = "볼륨을 통과할 때 흡수되는 빛을 시뮬레이션합니다.

얇은 부분은 빛이 많이 통과하므로 밝아지며, 두꺼운 부분은 어두워집니다.

효과는 오브젝트의 형태에 크게 의존하며 오브젝트의 대략적인 두께만 사용됩니다.";
material.absorptionFactor = "인수";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "깊이";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "반투명";
material.translucency.help = "반투명도 효과를 보려면 그림자를 드리우는 광원이 필요합니다.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "불투명도";
// Fully opaque material
material.type.opaque = "불투명";
// See glossary
material.type.subsurface = "서브서피스";
material.type.subsurface.help = "최상의 결과를 얻으려면 PBR 셰이딩 모드로 전환하고, 가급적 어두운 환경에서 최소한 하나 이상의 지향성 광원을 사용하십시오.";
// Transparency mode, alpha blending
material.type.blending = "혼합";
material.type.blending.help = "불투명도 값을 조정하여 오브젝트를 반투명하게 만듭니다.

오브젝트 형태가 복잡한 경우 실시간 성능 제약으로 인해 눈에 띄는 시각적 아티팩트가 발생할 수 있습니다.";
// Transparency mode
material.type.additive = "더하기";
material.type.additive.help = "불투명도 값을 조정하여 오브젝트를 반투명하게 만듭니다.

이 방법은 혼합형 방식보다 아티팩트가 적게 발생하는 경향이 있지만, 오브젝트를 더 밝게 만듭니다.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "디더링";
material.type.dithering.help = "임의의 방식으로 일부 픽셀을 제거하여 오브젝트를 반투명하게 만듭니다.";
// Simulate glass-like material
material.type.refraction = "굴절";
material.type.refraction.help = "이 모드는 유리 머티리얼을 시뮬레이션하는 데 사용할 수 있습니다.

실시간 렌더링 성능 제한으로 인해 자체 굴절 또는 다중 레이어 굴절 효과가 제한됩니다.";
material.castShadows = "Cast Shadows";
material.receiveShadows = "Receive Shadows";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "항상 조명제외";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "컬링 반전";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "반사율";
material.reflectance.help = "비금속 머티리얼에 대해 머티리얼이 받는 반사 양을 제어합니다.

대부분의 경우 기본값을 사용해야 합니다 (일반적인 각도에서 표준 4% 반사광에 해당).";

// Menu name
menu.files = "파일";
// Menu name
menu.scene = "씬";
// Menu name
menu.multires = "다중해상도";
// Menu name
menu.voxel = "복셀";
// Menu name
menu.dynTopo = "동적 토폴로지";
// Menu name (Synonym: Misc, Other)
menu.topology = "";
// Menu name
menu.primitive = "프리미티브";
// Menu name
menu.render = "렌더";
// Menu name
menu.material = "머티리얼";
// Menu name
menu.postProcess = "포스트 프로세싱";
// Menu name
menu.camera = "카메라";
// Menu name
menu.background = "배경";
// Menu name
menu.tool = "도구";
// Menu name
menu.stroke = "스트로크";
// Menu name
menu.alpha = "알파";
// Menu name
menu.filter = "";
// Menu name
menu.falloff = "폴오프";
// Menu name
menu.paint = "페인트";
// Menu name
menu.symmetry = "대칭";
// Menu name (pencil pressure)
menu.pressure = "압력";
// Menu name
menu.gesture = "제스처";
// Menu name
menu.layers = "레이어";
// Menu name
menu.settings = "설정";
// Menu name
menu.interface = "인터페이스";
// Menu name
menu.bindings = "바인딩";
// Menu name
menu.history = "작업 내역";
// Menu name
menu.historySettings = "설정";
// Menu name
menu.about = "정보";
// Menu name
menu.debug = "디버그";

// Operation on the object (action)
mesh.holes = "구멍";
// If the object has holes, the algorithm will close them
mesh.holes.close = "구멍 닫기";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holes.detail = "디테일";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "분리";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "레이어, 페인팅, 다중해상도가 손실됩니다.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "해상도";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "큐빅 강제 적용";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "변환";
// Static object means "static topology"
mesh.static = "메시";
// See glossary
mesh.multires = "다중해상도";
// Dynamic topology
mesh.dynamic = "동적 토폴로지";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "전역 머티리얼";
paint.useGlobal.help = "이 옵션이 활성화되면, 선택한 머티리얼이 다른 도구와 동일해집니다.

단, 러프니스와 메탈릭, 색상 설정만 연동된다는 점 유념하시기 바랍니다.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "스트로크 페인팅";
// Factor/Opacity of paint tool
paint.intensity = "페인트 강도";
// Apply the paint on the object
paint.paintAll = "모두 칠하기";
paint.paintAll.help = "현재 머티리얼을 오브젝트에 적용합니다.

마스크 부분과 비활성화된 채널은 페인팅되지 않습니다.";
// Apply the paint on the object but ignore painting intensity (force full intensity)
paint.paintAllForce = "강제로 모두 칠하기";
paint.strokePainting.title = "페인팅";
// Brush stroke texture
paint.texture.warningEnable = "텍스처 투영을 허용하려면 스트로크 페인팅을 활성화해야 합니다 (상단의 체크상자)!";
paint.texture.warningIgnored = "현재 도구는 텍스처를 사용할 수 없습니다!";
// Whether the Brush Alpha will be used to modulate painting intensity
paint.useAlpha = "스트로크 알파 사용";
paint.useAlpha.help = "스트로크 메뉴에 있는 알파 세트를 사용하여 페인팅을 조절할 수 있습니다.";
// Whether the Brush Falloff will be used to modulate painting intensity
paint.useCurve = "스트로크 폴오프 사용";
paint.useFalloff.help = "스트로크 메뉴에 있는 폴오프 세트를 사용하여 페인팅을 조절할 수 있습니다.";
// Whether the Brush Randomize will be used to modulate painting intensity
paint.useJitter = "";
paint.useJitter.help = "";

// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "새로운 이름";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "새로운 값";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "새로운 색상 (16진수 형식)";

// Post process effect
postprocess = "포스트 프로세싱";
// Quality vs performance
postprocess.quality = "품질";
postprocess.quality.help = "이 옵션은 렌더링 품질을 향상시키지만, 성능 저하가 발생할 수 있습니다.";
// More samples means better quality but slower performance
postprocess.maxSamples = "최대 샘플";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "전체 해상도";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "최대 프레임 샘플링";
postprocess.accumulateCount.help = "렌더링이 중지되기 전까지 누적할 최대 프레임 수입니다.

렌더링이 중지되면 Nomad는 배터리를 절약하기 위해 아무 동작을 취하지 않습니다.

프레임 축적을 통해 많은 렌더링 기능이 다음과 같은 이점을 얻습니다:
- 부드러운 그림자
- 전역 조명 (Global Illumination)
- 반사 (SSR)
- 앰비언트 오클루전
- 서브서피스
- 피사계 심도

특히 부드러운 그림자와 전역 조명에 있어 높은 프레임 수는 필수 요소입니다.
위의 기능이 비활성화된 경우 Nomad는 렌더링을 빠르게 중지할 수 있습니다.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "렌더 해상도";
postprocess.renderRatio.warning = "픽셀 아트 효과에 의해 오버라이드 되었습니다.";
postprocess.renderRatio.help = "이 옵션은 성능에 큰 영향을 미칩니다.
값을 'x1.25' 미만으로 유지하는 것이 좋습니다.

이 옵션은 설정에 저장되지 않습니다.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "안티앨리어싱 (TAA)";
postprocess.taa.help = "카메라를 이동할 때 깜박임을 줄입니다.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "반사 (SSR)";
postprocess.ssr.warning = "SSR은 PBR 셰이딩 모드를 요구합니다.";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "전역 조명 (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "허용 오차";
postprocess.ssgi.experimental = "실험적!";
postprocess.ssgi.warning = "SSGI는 PBR 셰이딩 모드를 요구합니다.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "앰비언트 오클루전 (AO)";
// How far the effect spreads
postprocess.ssao.radius = "크기";
// How strong the effect is
postprocess.ssao.factor = "강도";
// Adjustment to fix artefacts
postprocess.ssao.bias = "곡률 편향";
postprocess.ssao.bias.help = "효과의 민감도는 표면 곡률에 따라 다릅니다.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "피사계 심도";
// The blur factor behind the focused point
postprocess.dof.blurFar = "원거리 블러 효과";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "근거리 블러 효과";
postprocess.dof.focusTip = "오브젝트를 탭하면 초점 포인트를 변경할 수 있습니다.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "빛산란";
// Intensity of the effect
postprocess.bloom.intensity = "강도";
// How far the effect spreads
postprocess.bloom.radius = "반지름";
postprocess.bloom.radius.help = "블룸이 얼마나 확산되는지 의미합니다.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "한계값";
postprocess.bloom.threshold.help = "광도 임계값은 픽셀이 블룸을 방출할지 여부를 결정합니다.
값이 0이면 모든 픽셀이 빛납니다.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "톤 매핑";
postprocess.tone.exposure = "노출";
postprocess.tone.contrast = "대비";
postprocess.tone.saturation = "채도";
// No tonemapping operator is used
postprocess.tone.mapping.none = "없음";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "중성";
// Color curves
postprocess.curve = "컬러 그레이딩";
// Curve for pixel luminance
postprocess.curve.luminance = "메인";
postprocess.curve.red = "빨강";
postprocess.curve.green = "초록";
postprocess.curve.blue = "파랑";
// Reset color grading curves
postprocess.curve.resetAll = "모두 초기화";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "색수차";
postprocess.chromatic.factor = "강도";
// Darking on the edges
postprocess.vignette = "비네팅";
// How far the effect spreads
postprocess.vignette.size = "크기";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "경도";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "선명도";
postprocess.sharpness.factor = "강도";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "그레인";
postprocess.grain.factor = "강도";
// Accentuate the edges of the model
postprocess.curvature = "곡률";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "캐비티";
// Color/Strength of convex curvature
postprocess.curvature.bump = "범프";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "픽셀 아트";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "프레임 샘플링 허용";
// Simulate scanline rendering (horizonal line)
postprocess.scanline = "스캔라인";
postprocess.scanline.factor = "인수";
// Spacing between lines
postprocess.scanline.spacing = "간격";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "프리미티브";
primitive.box = "상자";
primitive.sphereCube = "구체";
primitive.sphereUV = "UV 구체";
primitive.icosahedron = "이십면체";
primitive.cylinder = "원통";
primitive.cone = "원뿔";
primitive.torus = "원환체";
primitive.lathe = "선반";
primitive.tube = "튜브";
primitive.plane = "평면";
primitive.triplanar = "트라이플레이너";
primitive.faceXYZ = "면 XYZ";
primitive.faceXYZ.help = "https://texturing.xyz/ 에서 제공하는 UV-언랩 기본 메시";
primitive.needValidate = "프리미티브를 스컬프팅하기 전에 유효성 검사를 해야 합니다.";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "편집";
primitive.edit.help = "뷰포트에서 3D 편집을 허용합니다.

프리미티브를 수정하지 않고 기즈모 또는 트랜스폼 도구와 상호 작용하려면 이 기능을 비활성화할 수 있습니다.";

// Primitive configuration
primitive.mainConfig = "매개변수";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "토폴로지";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "기하학";

// Validating the primitive (then it can be sculpted)
primitive.validate = "검증";
// Maximum number of faces of the primitives
primitive.maxFaces = "최대 면";
primitive.maxFaces.help = "프리미티브가 가질 수 있는 면의 최대 개수입니다.

이러한 제한은 프리미티브가 검증되지 않은 동안에만 활성화되며, 그 이후부터는 제한이 없어집니다.";
// Synonym: Flat subdivision
primitive.linear = "직선 서브디비전";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "포스트 서비디비전";

// Radius (of a sphere, torus, etc)
primitive.radius = "반지름";
// Size (of cube x dimension)
primitive.size = "크기";
primitive.sizeX = "크기 X";
primitive.sizeY = "크기 Y";
primitive.sizeZ = "크기 Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "디비전";
primitive.divisionX = "디비전 X";
primitive.divisionY = "디비전 Y";
primitive.divisionZ = "디비전 Z";
// Angle of torus, etc
primitive.angleX = "각도 X";
primitive.angleY = "각도 Y";
primitive.angleZ = "각도 Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "일정한 밀도";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "구체에 투영";
primitive.projectOnSphere.help = "완전한 구형에 포인트를 스냅합니다.";

// triplanar
primitive.triplanar.title = "트라이플레이너";
primitive.triplanar.title.help = "트라이플레이너는 3개의 평면으로부터 얻은 마스크 정보를 사용하여 복셀 그리드를 채우고 폴리곤으로 변환합니다.

디비전 또는 크기 슬라이더를 조작하면 페인트 정보가 초기화됩니다 (평활도는 제외).

대칭은 예상대로 작동하지 않을 수 있으므로 사용하지 않는 것이 좋습니다.

마스크 패널에서 '토폴로지 연결' 옵션을 사용하면 다른 평면에 영향을 주는 평면을 그릴 수 있습니다.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanarSameSize = "같은 크기 (정육면체)";
primitive.triplanarPolish = "평활도";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanarResetMask = "마스크 초기화";
// One side of a cube (the back plane)
primitive.isolate.back = "뒤로";
// One side of a cube (the right plane)
primitive.isolate.right = "오른쪽";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "아래";
// Plane
primitive.planeSameSize = "같은 크기 (정사각형)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "원반";
// Box
primitive.boxRegular = "같은 크기 (정육면체)";
// Distance to the snapping point
primitive.tubeSnapOffset = "스냅 오프셋";
primitive.tubeSnapOffset.help = "값 '1.0'은 튜브의 반지름과 같습니다.";
// Radius of the tube (starting end-point of the tube)
primitive.tubeThicknessStart = "반지름 시작";
// Radius of the tube (ending end-point of the tube)
primitive.tubeThicknessEnd = "반지름 종료";
primitive.tubeTwist = "뒤틀림";
primitive.tubeTwistRotate = "회전";
primitive.tubeTwistRadius = "세기";
primitive.tubeTwistOffset = "오프셋";
primitive.tubeSnap = "스냅";
primitive.torusRadiusOuter = "외부 원 반지름";
primitive.torusRadiusInner = "내부 원 반지름";
primitive.torusAngle = "각도";
primitive.torusAngleOffset = "각도 오프셋";
primitive.cylinderHeight = "높이";
primitive.coneRadius = "반지름";
primitive.coneHeight = "높이";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "구멍";
// Make a hole in the primtive to make it hollow
primitive.hasHole = "구멍 있음";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radiusSync = "동일한 반지름";
primitive.radiusStart = "반지름 시작";
primitive.radiusEnd = "반지름 종료";
// Curve profile (synonym: profile, curve)
primitive.profile = "";

// Singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "";
// All the new items will be inserted inside the bound rather than outside
repeater.array.fitInside = "";
// The object will follow the curve
repeater.curve.align = "";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "임포트...";
// iOS Photos gallery
resource.import.ios.photos = "";
// iOS Files App
resource.import.ios.files = "";

scene.title = "씬";
scene.title.help = "보이기/선택 버튼을 사용할 때 손가락을 누른 상태로 드래그하면 다른 객체를 쉽게 선택할 수 있습니다.

또한 보이기/선택 버튼을 길게 누르면 자식에게도 영향을 줄 수 있습니다.";
// The view will focus on the item when we click on it
scene.focus = "항목에 포커스 맞춤";
// Add new object on gizmo position
scene.addOnGizmo = "";
scene.addOnGizmo.help = "";
// Select the gizmo tool after adding a new object
scene.addSelectGizmo = "";
scene.addSelectGizmo.help = "";
// Icon size in pixel (min/max)
scene.iconSize = "";
// Min size of icon
scene.iconSize.min = "최소";
// Max size of icon
scene.iconSize.max = "최대";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "";
scene.showHierarchy.help = "";
scene.showHierarchyNomadPivot = "";
scene.showHierarchyNomadPivot.help = "";
// The view will focus on the item when we click on it
scene.syncVisible = "";
scene.syncVisible.help = "";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "연결";
// Group the selected object with a new created Empty Node as a parent
scene.group = "그룹";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "거울";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "곡선";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "배열";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "방사성";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "";
scene.repeaters.help = "";
// Validate button
scene.validateGroup = "검증";
// Keep instances in the scene
scene.validateGroup.keepInstances = "";
// If we should join children
scene.validateGroup.joinChildren = "자식 병합";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "복셀 병합";
scene.voxelResolution = "해상도";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "빼기: 오브젝트 가리기 (눈 모양 아이콘)";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "교차 부분: 모든 오브젝트 숨김";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "선택한 오브젝트가 없습니다. 최소한 하나의 오브젝트를 선택하십시오.";
// Need to select one object only
scene.noneButNeedOne = "선택한 오브젝트가 없습니다. 최소한 하나의 오브젝트를 선택하십시오.";
// Need to select one object only
scene.onlyOneObject = "복수의 오브젝트가 선택되어 있습니다. 단 하나의 오브젝트만 선택하십시오.";

// General scene display settings
settings.display.title = "디스플레이 설정";
// Wireframe (show triangles and quad edges)
settings.wireframe = "와이어프레임";
// Display the material texture
settings.debugChannel = "";
// Display the material texture in the background
settings.debugChannel.onBackground = "";
// Display the material texture on the mesh
settings.debugChannel.onMesh = "";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "양면";
settings.twoSided.help = "면은 양쪽에서 볼 수 있습니다.";
// If we colorize the inverted side of faces
settings.backface.color = "후면 색상";
// Color of the inverted side of faces
settings.backface.colored = "착색된 후면";
// Outline (contour highlight around the selected object)
settings.outline = "윤곽선";
// Outline (contour highlight around the selected object)
settings.outline.help = "선택한 오브젝트의 윤곽이 표시됩니다.";
settings.outline.thickness = "두께";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "스냅 큐브";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "아래";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "왼쪽";
// Flip the camera (rotate 180° to see the other side)
settings.snapCube.flip = "";
settings.snapCube.flip.help = "";
// Alignment (can be auto/on/off)
settings.snapCube.align = "";
settings.snapCube.align.help = "";
// Stats (information logs about the scene displayed on screen)
settings.stats = "통계";
settings.stats.right = "오른쪽";
settings.stats.all = "전체 씬 보기";
// Grid
settings.grid = "격자";
// Cursor
settings.cursor.title = "";
settings.cursor.whileSculpting = "스컬프팅하는 동안 원 표시";
// A small indicator dot
settings.cursor.showDot = "작은 점 보기";
settings.cursor.showDot.help = "카메라 피벗 포인트를 표시하거나 스컬프팅 중에 점이 표시될 수 있습니다.";
settings.cursor.showRope = "로프 스태빌라이저 보기";
// indicator
settings.indicator.title = "";
settings.indicator.title.help = "";
settings.indicator.size = "";
// Highlight (the object glows when we select it)
settings.highlight.selection = "선택 영역 강조";
// Highlight settings
settings.highlight = "밝은 영역";
settings.highlight.duration = "지속시간";
// Mesh that are not selected will be dark
settings.darkenUnselected = "선택하지 않은 오브젝트를 어둡게";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "부드러운 셰이딩";
// Experimental feature
settings.partialDraw = "부분 드로잉";
settings.partialDraw.help = "실험적인 기능!

높은 폴리 수를 가진 메시의 비교적 작은 부분을 스컬프팅할 때 사용하십시오.

더 매끄러운 스컬프팅이 가능하지만, 와이어프레임을 활성화하면 안 됩니다!

또 브러시 스트로크 중에 눈에 띄는 아티팩트가 발생할 수 있습니다";
settings.partialDraw.warning = "눈에 띄는 아티팩트가 너무 성가시다면 이 옵션을 해제하십시오!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "페인팅 보기";
// Display the light icons in the viewport
settings.lightIcon = "광원 아이콘";
// Display the camera icons in the viewport
settings.cameraIcon = "카메라 아이콘";
// Show icon on the canvas
settings.icon = "아이콘";
// Show icons on the canvas
settings.icons = "아이콘";
// Tooltip
settings.icons.help = "아이콘을 선택하고 바로 편집할 수 있도록 캔버스에 아이콘을 표시합니다.";
// Hole filling settings
settings.hole = "구멍 채우기";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "비-다양체 채우기";
settings.hole.nonManifold.help = "비-다양체 구멍을 채우려고 시도합니다.
이 옵션은 설정에서 저장되지 않습니다.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "최대 버텍스 수";
settings.multires.maxVertices.help = "Nomad는 세분화를 하기 전에 메모리 검사를 수행하지 않으며, 폴리곤 수가 많으면 충돌이 쉽게 발생할 수 있습니다.";
settings.multires.lowResVertices = "낮은 해상도 임계값";
settings.multires.lowResVertices.help = "카메라를 이동할 때 저해상도 메시가 표시될 수 있습니다.

이 값을 늘리면 고해상도 메시를 표시할 수 있습니다.";

// The main rendering mode
shading = "셰이딩";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "조명포함 (PBR)";
shading.pbr.help = "이 모드에서는 광원(그림자 포함)과 함께 HDR 환경을 추가할 수 있습니다.

또한 메탈릭과 러프니스 제어할 수 있으므로, 머티리얼의 외형을 보다 세밀하게 다듬을 수 있습니다.";
// Fast rendering mode for sculpting purpose (do not translate)
shading.matcap = "MatCap";
shading.matcap.help = "머티리얼 캡처(MAterial CAPture)의 약자인 MatCap은 하나의 이미지에서 광원과 머티리얼 정보를 모두 처리합니다.";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "조명제외";
shading.unlit.help = "광원이 없는 단색 셰이딩 모드.";
// Helper rendering mode that display a (do not translate)
shading.id = "ID";
shading.id.help = "각 오브젝트에 무작위로 색상이 할당된 조명이 없는 렌더링 모드입니다.

주로 한 장면에 많은 오브젝트가 있을 때 유용합니다.";
// Randomize colors
shading.id.randomize = "무작위 ID";
shading.textures = "텍스처 사용";
shading.textures.help = "현재 Nomad 내에서 텍스처를 생성하거나 편집할 수 없습니다.

하지만 텍스처가 있는 파일을 Nomad로 불러오면 정상적으로 작동합니다.

- 지원하는 텍스처 -
불투명도: 조명포함, MatCap, 조명제외
노멀: MatCap
색상: 조명포함, 조명제외
이미시브: 조명포함
러프니스: 조명포함
메탈릭: 조명포함";
// Lights
shading.lights = "광원";
shading.lights.addLight = "광원 추가";
shading.lights.warning = "광원은 PBR 셰이딩 모드를 요구합니다.";
// Environment based lighting (synonym: HDRI)
shading.environment = "주변환경";
shading.environment.import = "HDR 임포트";
shading.environment.exposure = "노출";
shading.environment.backgroundBlur = "블러 효과 (배경)";
shading.environment.rotation = "회전";
shading.environment.rotation.help = "뷰포트에서 세 손가락을 가로로 드래그하면 HDRI를 회전할 수 있습니다.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "카메라에 연결";
shading.environment.attachedToCamera.help = "환경을 카메라에 연결합니다.

이렇게 하면 조명이 고정되므로 스컬프팅 목적으로 유용한 옵션이 될 수 있습니다.";
shading.matcap.rotation = "회전";
shading.matcap.rotation.help = "뷰포트에서 세 손가락을 가로로 드래그하면 MatCap을 회전할 수 있습니다.";
shading.matcap.global = "전역 MatCap 사용";
shading.matcap.global.help = "특정 메시에 다른 MatCap을 사용하려면 이 옵션의 체크를 해제하십시오.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible = "마스크";
shortcut.maskVisible.short = "마스크";
// bottom shortcut buttons (should be SHORT)
shortcut.solo = "솔로";
shortcut.solo.short = "솔로";
// bottom shortcut buttons (should be SHORT)
shortcut.voxelRemesh = "복셀 리메시";
shortcut.voxelRemesh.short = "복셀";
// bottom shortcut buttons (should be SHORT)
shortcut.wireframe = "와이어프레임";
shortcut.wireframe.short = "와이어";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraReset = "카메라 초기화";
shortcut.cameraReset.short = "초기화";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraSnap = "카메라 스냅";
shortcut.cameraSnap.short = "스냅";
// bottom shortcut buttons (should be SHORT)
shortcut.lockSelection = "선택 잠금";
shortcut.lockSelection.short = "잠금";
shortcut.lockSelection.help = "활성화되면 메시를 탭하더라도 선택 항목을 변경할 수 없습니다.";
// bottom shortcut buttons (should be SHORT)
shortcut.perspective = "원근";
shortcut.perspective.short = "원근";
// bottom shortcut buttons (should be SHORT)
shortcut.grid = "격자";
shortcut.grid.short = "격자";

// Memory taken by the scene
stat.ramScene = "씬";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Vram 씬";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "VRAM 렌더";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "VRAM 텍스처";
// Memory taken by the undo/redo history
stat.ramHistory = "사용기록";
// Memory taken by other stuffs
stat.ramOther = "기타";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "사용 중인 메모리";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "사용 가능한 메모리";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "사용 중: $0 MB";
stat.free = "사용 가능: $0 MB";
stat.faces = "면";
stat.triangles = "삼각형";
stat.vertices = "버텍스";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "사변형";
stat.sceneFaces = "씬의 면";
stat.sceneVertices = "씬 버텍스";

// Brush stroke
stroke = "스트로크";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "전역 공간 반지름";
// The settings is shared among every tools
stroke.useWorldRadius.help = "이 설정은 모든 도구에서 공유됩니다.";
// Share the radius value among every tools.
stroke.useShareRadius = "공유 반지름";
stroke.useShareRadius.help = "모든 도구에서 반지름 값을 공유합니다.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.spacing = "스트로크 간격";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.spacing.adjust = "간격 강도 조정";
stroke.minSpacingAdjustIntensity.help = "스트로크 간격에 따른 일관된 변형을 유지하기 위해 브러시 강도를 조정하세요.";
stroke.minSpacing.help = "도구 반지름을 기준으로 한 스트로크 사이의 간격입니다.

값이 낮을수록 스트로크가 더 부드러워지지만 성능이 저하됩니다.";
// Brush stroke smoothing
stroke.lazySmooth = "스트로크 스무딩";
stroke.lazySmooth.help = "더 부드러운 스트로크를 얻기 위해 여러 포인터 위치의 평균을 구합니다.

값이 높을 수록 스트로크가 포인터에서 멀리 뒤처지지만, 결국에는 따라잡을 것입니다.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "레이지 로프 스태빌라이저";
stroke.lazyRadius.help = "스트로크가 포인터와 일정 거리를 두고 그려집니다.

부드러운 선을 그릴 때 사용할 수 있습니다.";
// It is not a per-tool settings
stroke.globalSettings = "전역 설정입니다";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "스냅 반지름";
stroke.snapRadius.help = "포인터가 가장 최근 그린 스트로크에 가까이 있으면 스트로크를 스냅합니다.

여러번 끊어서 연속된 긴 선을 그릴 때 유용합니다.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "스트로크 오프셋";
stroke.sculptOffset.help = "스트로크에 일정한 오프셋을 적용합니다.

이 옵션이 활성화되면 손가락이 스트로크를 가리지 않으므로 작은 화면에서 손가락을 사용할 때 유용합니다.";
stroke.accumulate = "스트로크 축적";
stroke.accumulate.help = "이 옵션이 활성화되면 스트로크당 추가/제거할 수 있는 물질의 양에 제한이 없습니다.";
// The tool can use DynTopo
stroke.useDynamicTopology = "동적 토폴로지 허용";
// Only sculpt the part that are linked topologically
stroke.connected = "연결된 토폴로지";
stroke.connected.help = "이 옵션은 선택된 표면과 연결되어 있는 버텍스만 스컬프팅합니다.

이 옵션은 일반적으로 '이동' 도구를 위해 사용됩니다. 예를 들어, 다른 부분과 자가 교차하는 부분만 이동하고 싶은 경우 등입니다.";
// Only sculpt the vertex that points toward the camera
stroke.culling = "정면을 향하는 버텍스만";
stroke.culling.help = "이 옵션은 뒷면을 바라보는 버텍스를 무시합니다.

다른 면에 영향을 주지 않고 얇은 형상의 일부를 페인팅하려는 경우 유용할 수 있습니다.

스컬프팅에도 효과가 있지만 눈에 띄는 아티팩트가 발생할 수 있습니다.";
// Infinite depth, move everything under the circle, disregarding depth
stroke.silhouette = "";
stroke.silhouette.view = "";
stroke.silhouette.snapped = "";
stroke.silhouette.closest = "";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.sameSide = "같은 면에 있는 버텍스만";
stroke.sameSide.help = "변형하려는 방향의 반대를 가리키는 버텍스는 무시합니다.";
stroke.onlyLasso = "이 설정은 올가미 도구에만 적용됩니다.";

// Here sampling refers to the app gathering information under the mouse
stroke.area = "";
stroke.area.help = "";
// Sampling radius size (percent)
stroke.area.normal.radius = "";
// Sampling radius size (percent)
stroke.area.point.radius = "";
// Sampling averaging
stroke.area.normal.average = "";
// Sampling averaging
stroke.area.point.average = "";
// Keep sharp edges
stroke.keepSharp = "날카로운 변 유지";
stroke.keepSharp.help = ""

// Only paint the part of the mesh above a certain height
stroke.depthFilter = "깊이 필터링";
stroke.depthFilter.help = "";
stroke.depthFilter.max = "";
stroke.depthFilter.min = "";
stroke.depthFilter.offset = "";

// Module the intensity of the sculpting operation by using a falloff curve
menu.falloff = "폴오프";
// Alpha
menu.alpha = "알파";
// Invert the pixel (black <-> white)
stroke.alphaInvert = "픽셀 반전";
// Repeat the alpha image (pattern)
stroke.alphaWrap = "타일링";
// No repeat pattern
stroke.alphaWrap.none = "없음";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alphaWrap.repeat = "반복";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alphaWrap.mirror = "거울";
stroke.alphaFetch = "방법";
// Project the alpha perpendicularly onto the surface
stroke.alphaFetch.surface = "표면";
// Project the alpha onto the surface in the direction of the camera view
stroke.alphaFetch.screen = "스크린 투시";
stroke.alphaRotation = "회전";
stroke.alphaRotation.lock.help = "";
// Repeat the image
stroke.alphaTiling = "타일링";
// Scale the image (make it bigger or smaller)
stroke.alphaScale = "스케일링";
stroke.alphaScale.help = "최소값에서 알파 사각형이 도구 원의 반지름 안에 있습니다.";
// Middle-point value at which no deformation occurs
stroke.alphaMidValue = "중간값";
stroke.alphaMidValue.help = "변형을 일으키지 않는 중간값.

(중간값 = 0)
- 검은색: 변위 없음
- 흰색: 양수의 변위

(중간값 = 0.5)
- 검은색: 음수의 변위
- 흰색: 양수의 변위

(중간값 = 1)
- 검은색: 음수의 변위
- 흰색: 변위 없음";
// Synonymous: Scatter/Jitter/Randomize
stroke.jitter = "";
// Sculpt and paint along the brush stroke at regular spacing
stroke.type.dot = "점";
// Sculpt continuously
stroke.type.drag = "끌기";
// Lock a region and move it around
stroke.type.grab = "붙잡기";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.type.grabRadius = "붙잡기 - 동적 반지름";
// Lock a region and sculpt it by changing the tool intensity
stroke.type.grabIntensity = "붙잡기 - 유동적인 강도";

// Symmetry
symmetry = "대칭";
symmetry.enable = "활성화";
// Display a warning (the feature is only available for mesh object)
symmetry.primitiveWarning = "브러시 대칭은 트라이플레이너를 제외하면 검증된 프리미티브에만 사용할 수 있습니다.";
symmetry.plane.title = "평면";
symmetry.toolIgnore = "현재 도구는 대칭을 무시합니다.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "방사성";
symmetry.radialX = "방사성 X";
symmetry.radialY = "방사성 Y";
symmetry.radialZ = "방사성 Z";
// A warning indicating that we limit the number of repetitions ($0 is a number)
symmetry.limited = "";
// Synonym: Offset
symmetry.offset.title = "오프셋";
symmetry.offsetX = "오프셋 X";
symmetry.offsetY = "오프셋 Y";
symmetry.offsetZ = "오프셋 Z";
// Number of clones
symmetry.count.title = "횟수";
symmetry.countX = "카운트 X";
symmetry.countY = "카운트 Y";
symmetry.countZ = "카운트 Z";
// method
symmetry.method = "방법:";
symmetry.method.help = "- 로컬
트랜스폼 도구(기즈모 또는 트랜스폼) 중 하나를 사용하는 동안 대칭 평면은 메시를 따라 이동합니다.

- 전역
대칭 평면이 고정되어 이동하지 않습니다.";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.method.world = "세계";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.method.local = "로컬";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "오브젝트 뒤집기";
// Mirror the mesh
symmetry.mirror = "미러링";
symmetry.mirror.help = "토폴로지에 영향을 주지 않고 대칭을 다시 적용하기를 시도합니다.

방사성 대칭은 무시됩니다.

토폴로지가 대칭으로 간주되지 않아 유지할 수 없는 경우, 강제로 미러링을 적용할 수 있는 옵션이 주어집니다.";
symmetry.mirrorLeftToRight = "왼쪽에서 오른쪽으로";
symmetry.mirrorRightToLeft = "오른쪽에서 왼쪽으로";
symmetry.mirrorFail = "대칭을 적용하지 못했습니다.

메시를 미러링하여 대칭을 강제 적용하시겠습니까?";
symmetry.mirrorUseMasking = "마스크 영역 보호";
symmetry.mirrorUseMasking.help = "마스크 영역을 그대로 유지합니다.

이 옵션은 비대칭 토폴로지(또는 한 쌍의 눈처럼 연결이 끊긴 표면)에서는 무시됩니다.";
// Reset the symmetry plane position
symmetry.reset = "초기화";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "오브젝트 중심";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "세계 중심";
// Reset the symmetry plane orientation
symmetry.reset.direction = "방향";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "선 보기";
// Display the symmetry plane in 3d
symmetry.showPlane = "평면 보기";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "기즈모 편집";
symmetry.edit.warning = "대칭 편집은 실험적인 기능입니다.";
symmetry.edit.help = "대칭 평면을 자유롭게 설정할 수 있습니다.

이 기능은 다소 실험적인 기능이므로 사용을 지양하시기 바랍니다.";

// Ideally <10 chars
tool.dynTopo = "동적 토폴로지";
// Ideally <10 chars (Symmetry)
tool.symmetry = "대칭";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "거울";
// Ideally <10 chars
tool.clay = "점토";
// Ideally <10 chars (Subtract)
tool.clay.sub = "빼기";
// Ideally <10 chars
tool.brush = "브러시";
// Ideally <10 chars
tool.move = "이동";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "보통";
// Ideally <10 chars
tool.drag = "끌기";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "부드럽게";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "릴렉스";
// Ideally <10 chars (Paint mask)
tool.mask = "마스크";
// Ideally <10 chars
tool.mask.unmask = "마스크해제";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "마스크 선택자";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "손가락";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "병합";
// Ideally <10 chars (Flatten the surface, more strongly than Flatten)
tool.planar = "";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "채우기";
// Ideally <10 chars (Layer brush)
tool.layer = "레이어";
// Ideally <10 chars
tool.crease = "주름";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "자르기";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "분할";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "프로젝트";
// Ideally <10 chars
tool.inflate = "팽창";
// Ideally <10 chars
tool.pinch = "꼬집기";
// Ideally <10 chars
tool.nudge = "소량이동";
// Ideally <10 chars
tool.stamp = "도장";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "DelLayer";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.select = "선택";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "기즈모";
// Ideally <10 chars
tool.gizmo.editPivot = "피벗";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "스냅";
// Ideally <10 chars (Snap translation)
tool.gizmo.moveSnap = "스냅";
// Ideally <10 chars (Local/Relative space)
tool.gizmo.local = "로컬";
// Ideally <10 chars (Align/Snap the gizmo to world axis)
tool.gizmo.align = "";
// Ideally <10 chars (Pin the gizmo, so that it stays in place when switching between objects)
tool.gizmo.pin = "";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "변형";
// Ideally <10 chars (Translate the object)
tool.transform.move = "이동";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "회전";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "비율";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "스냅";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "측정";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "보기";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "선반";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "튜브";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "삽입";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "뒤집기";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "보기";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "올가미";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "곡선";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "다각형";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "패스";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "직사각형";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "타원";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "선";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "닫힘";

// Radius of the tool (size)
tool.radius = "반지름";
// Intensity of the tool (force)
tool.intensity = "강도";

tool.settings = "설정";
tool.settings.none = "이 도구에는 특정 설정이 없습니다.";

tool.crease.pinchFactor = "핀치 강도";

tool.layer.removeInfluence = "레이어 데이터 사용";
tool.layer.removeInfluence.help = "이 옵션은 선택한 레이어가 있는 경우에만 활성화됩니다.

레이어 데이터를 사용하여 스트로크에 대한 변위를 제한합니다.";
tool.layer.noLayerSelected = "이 옵션은 선택한 레이어가 있는 경우에만 사용 가능";

tool.flatten.planeLockOrigin = "평면 원점 잠금";
tool.flatten.planeLockNormal = "평면 방향 잠금";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "";
tool.syncInstance.message = "";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "버텍스를 테두리에 고정";

tool.paint = "페인트";
// Erase the painting
tool.paint.erase = "지우기";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "레이어 필터링";
tool.paint.layerFilter.help = "레이어의 이미 칠해진 영역을 다시 칠하려는 경우에만 이 옵션을 사용하십시오.";

// Clear the painted mask
tool.mask.clear = "지우기";
// Invert the painted mask
tool.mask.invert = "반전";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "연결 뒤집기";
// Blur the painted mask
tool.mask.blur = "흐림 효과";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "선명 효과";
// Smoothing strategy
tool.mask.polish.all = "";
tool.mask.polish.sharp = "";
tool.mask.polish.border = "";
// Smooth the border in a way that it matches completely with its dual
tool.mask.polish.syncBorder = "";
// topology of extracted mesh
tool.mask.autoDivision = "";
tool.mask.division = "";
// The thickness of the extracted mesh (from the painted mask)
tool.mask.thickness = "두께";
// The extracted mesh has the same height everywhere
tool.mask.thicknessUniform = "";
tool.mask.thicknessUniform.help = "";
// Carve the mask into the surface
tool.mask.carve = "조각";
// Extract a new mesh from the painted mask
tool.mask.extract = "추출";
// Extract two new mesh from the painted mask and from the unmasked area
tool.mask.split = "분할";
// How should we close the topology of the extracted object
tool.mask.split.mask = "닫기 동작 (마스킹 영역):";
// How should we close the topology of the extracted object
tool.mask.split.unmask = "닫기 동작 (마스킹 되지 않은 영역):";
// How should we close the topology of the extracted object
tool.mask.action = "닫기 동작:";
tool.mask.action.help = "-- 없음
일부분을 추출하고 추출된 부분을 열린 상태로 유지합니다.

-- 채우기
구멍이 채우고 다듬어 매끄럽게 만듭니다. 
이 옵션을 평평한 표면에는 사용하지 마십시오.

-- 셸
두께 값을 사용하여 추출한 모양을 닫습니다.

-- 레이어
레이어 차이를 추출합니다 (레이어 하위 메뉴만 해당).";
// Do not close the mesh (leave it open)
tool.mask.action.none = "없음";
// Close the mesh with a hole-filling algorithm
tool.mask.action.fill = "채우기";
// Close the mesh by adding a thickness on the surface
tool.mask.action.shell = "셸";
// Close the mesh by using the layer data as a difference thickness
tool.mask.action.layer = "레이어";

// Transform/Matrix
tool.matrix = "매트릭스";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.apply = "목표";
// Automatic
tool.matrix.apply.auto = "자동";
// Transform the object alone (the children stands still)
tool.matrix.apply.object = "오브젝트";
// Auto apply the transform on the vertices
tool.matrix.apply.vertex = "버텍스";
// Transform the object and its children
tool.matrix.apply.group = "그룹";
tool.matrix.apply.help = "- 자동
기본적으로 이 옵션은 그룹 옵션과 비슷하게 동작합니다.
메시에 마스킹되어 있거나 기즈모 대칭이 활성화되어 경우, 버텍스와 같은 방식으로 작동합니다.

- 버텍스
버텍스에 변형을 적용하려고 시도하며. 검증되지 않은 프리미티브에서는 작동하지 않습니다.
인스턴스도 영향을 받습니다.

- 오브젝트
오브젝트만 이동하며, 대칭과 마스크는 무시됩니다.
편집된 노드만 이동하고 자식은 그대로 유지됩니다.

- 그룹
노드를 움직이며, 대칭과 마스크는 무시됩니다. 계층의 나머지 부분도 동일하게 변형됩니다.";
// Operation on the mesh
tool.matrix.action = "작동";
tool.matrix.action.help = "- 원점 이동
메시를 세계 원점으로 이동합니다.

- 초기화
메시 변환을 초기 상태로 재설정합니다.

- 베이크
매트릭스를 버텍스에 적용하고 매트릭스를 초기화합니다. 시각적으로 아무것도 변하지 않아야 합니다.";
tool.matrix.translation = "이동";
tool.matrix.rotation = "회전";
tool.matrix.scale = "비율";
// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "기울임";
tool.matrix.uniformScale = "균등 스케일";
tool.matrix.moveToOrigin = "원점 이동";
tool.matrix.resetTransform = "초기화";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "베이크";

tool.transform.tip = "";

// Size of the gizmo
tool.gizmo.size = "위젯 크기";
// If true, there is less spacing between gizmo handlers (rotate, scale, etc)
tool.gizmo.compact = "";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "수치 입력";
tool.gizmo.allowInput.help = "기즈모 위젯 중 하나를 탭할 때 숫자 입력 허용";
// Angle threshold
tool.gizmo.linearRollThreshold = "탄젠트 롤 임계값";
tool.gizmo.linearRollThreshold.help = "선형 또는 원형 롤 방법을 선택하기 위한 각도 임계값.

이 임계값을 초과하는 값은 원형 롤을 사용합니다.

선형 롤(탄젠트의 방향)을 선호하는 경우, 이 값을 90°로 설정하기만 하면 됩니다.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "상호작용 중일 때 가리기";
tool.gizmo.tap = "탭 한 번";
tool.gizmo.tap.help = "이 옵션은 커스텀 피벗 모드에서만 유효합니다 ('자동'이 비활성화된 경우).

- 없음
메시를 탭해도 아무 일이 일어나지 않습니다.

- 첫 교차점
첫 번째 교차점으로 기즈모를 이동합니다.

- 중간점
처음 두 교차점의 평균 위치로 기즈모를 이동합니다.";
tool.gizmo.tap.none = "없음";
tool.gizmo.tap.normal = "보통";
tool.gizmo.tap.first = "첫 교차점";
tool.gizmo.tap.medial = "중간점";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "고정";

// Fill the object's hole
tool.hole = "구멍 채우기";
tool.hole.fillHoles = "구멍 채우기";
// synonym: Alternative method
tool.hole.bridges = "화면 공간 부울";
tool.hole.bridges.help = "이 옵션이 활성화되면 볼륨에 구멍을 뚫을 수 있습니다.
또한 절단 경사도 역시 절단한 형태를 더 가깝게 따릅니다.";
tool.hole.threshold = "임계값 엡실론";
tool.hole.threshold.help = "이 값을 조정하면 구멍 채우기 알고리즘에 도움이 될 수 있습니다.";
tool.hole.smoothing = "구멍 스무딩";

tool.smudge.quality = "품질";
tool.smudge.quality.help = "투영된 픽셀의 해상도를 변경하며, 값이 낮을수록 스트로크가 빨라집니다.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "모양";
// Auto-validate the drawn shape
tool.shape.autoValidate = "";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "사각형";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "가운데 정렬";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "원";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "가운데 정렬";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "회전 단계";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "황금 비율 보기";


// Always display the camera shortcut buttons on the viewport
tool.view.stickyCamera = "";

// Topology
topology = "토폴로지";
// Synynom: detail value, density
topology.dynamic.detail = "디테일";
// See glossary
topology.multires = "다중해상도";
topology.multires.help = "다수의 메시 해상도를 유지합니다. 

낮은 해상도에서 변경사항이 발생하면, 높은 해상도로 전환했을 때 디테일이 다시 투영됩니다.

레이어는 모든 해상도에서 사용할 수 있습니다.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "반전";
topology.multires.reverse.confirm = "베이스 서브디비전을 생성할 수 없습니다.

현재 토폴로지가 서브디비전의 결과가 아닐 수 있습니다.";
topology.multires.subdivide = "세분화";
topology.multires.subdivide.confirm = "메시가 $0M개의 버텍스를 가지게 됩니다. 계속 진행하시겠습니까?";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "세분화 제한 초과, $0 참조";
topology.multires.deleteLower = "하단 삭제";
topology.multires.deleteHigher = "상단 삭제";
topology.multires.keepTriangles = "삼각형 유지";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "";
// Synonym: Flat subdivision
topology.multires.linear = "직선 서브디비전";
topology.multires.linear.help = "스무딩 적용 없이 메시를 더 잘게 세분화합니다.";
// Create a new object by recomputing a new topology
topology.remesh = "리메시";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "복셀 리메싱";
topology.voxel.help = "그리드 위에 메시를 샘플링하여 리메싱합니다.

오브젝트를 (빈틈없이) 닫지 않은 경우, 구멍 채우기 알고리즘이 먼저 적용됩니다.

레이어는 리메시 후 다시 투영되지만 품질이 저하됩니다.";
topology.voxel.resolution = "해상도";
topology.voxel.sharp = "날카로운 변 유지";
topology.voxel.sharp.help = "이 옵션은 주로 단순한 프리미티브 부울 연산에 유용합니다. 

모서리에 있는 점이 스냅되어 일부 영역에 왜곡이 발생합니다.";
topology.voxel.subLevel = "다중해상도 구축";
topology.voxel.subLevel.help = "복셀 리메셔 출력을 통해 다중해상도 계층을 재구축할 수 있습니다.

또한 복셀 디테일 값이 높으면 작업이 더 빠르게 실행되고 메모리를 덜 사용합니다.
그러나 복셀 디테일 값이 낮고 요구되는 다중해상도 레벨이 너무 높은 경우 디테일이 손상됩니다.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "리메시";
topology.surface.detail = "디테일";
topology.surface.detail.help = "복셀 리메시싱과 다르게 표면 리메싱은 메시를 닫을 필요가 없습니다.

토폴로지를 변경할 때 메시의 일부를 보호할 수 있도록 마스킹을 지원합니다.

레이어가 올바르게 업데이트됩니다.";
topology.surface.method = "방법";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "균일화";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "서브디비전";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "데시메이션";
topology.surface.method.help = "동적 토폴로지의 동작 특성:
- 균일화: 디테일 추가 및 제거
- 서브디비전: 디테일 추가
- 데시메이션: 디테일 제거";
topology.surface.useMasking = "마스크 영역 보호";
topology.surface.useMasking.help = "마스크 영역은 토폴로지가 변경되지 않도록 보호합니다.";
topology.surface.extrapolate = "버텍스 엑스트라폴레이션";
// DynTopo
topology.dynamic = "동적 토폴로지";
topology.dynamic.activate = "활성화";
topology.dynamic.activate.help = "동적 토폴로지를 사용하면 조각 도구를 사용해 실시간으로 메시를 분할하거나 단순화할 수 있습니다.

이 기능은 성능에 현저한 영향을 미칩니다.

레이어가 올바르게 업데이트됩니다.";
topology.dynamic.method = "디테일 기본 바탕:";
topology.dynamic.method.zoom = "확대/축소";
topology.dynamic.method.radius = "반지름";
topology.dynamic.method.constant = "일정";
topology.dynamic.method.help = "- 확대/축소
디테일 레벨은 표면에서 얼마나 멀리 떨어져 있는지에 따라 달라집니다.

- 반경
도구의 반지름은 디테일의 양을 정의합니다.

- 일정
디테일이 고정되며, 디테일 값이 복셀 슬라이더와 공유됩니다.";
topology.dynamic.quality = "선호...";
topology.dynamic.quality.help = "'품질'을 선택하는 경우 두 가지 주요 차이점:
- 세분화가 스컬프팅 연산자보다 먼저 적용되므로 매우 디테일한 부분을 스컬프팅하거나 페인팅할 때 보간 아티팩트가 적게 발생합니다.
- 세분화는 점진적으로 적용되지 않습니다. 매우 디테일한 부분을 스컬프팅하거나 브러시 스트로크 작업을 할 때도 토폴로지가 항상 올바르게 세분화됩니다.

더 나은 성능을 위해 이 옵션을 사용하려는 경우 설정 패널에서 '부분 그리기' 옵션을 켜는 것도 하나의 방법입니다.";
topology.dynamic.quality.speed = "속도";
topology.dynamic.quality.quality = "품질";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "반지름에 압력 사용";
topology.dynamic.usePressure.help = "펜 압력이 도구 반지름에 영향을 미칠 때 세부 수준으로 영향을 미치도록 하려면 이 옵션을 사용하세요.";
// Decimate
topology.decimate.title = "데시메이션";
topology.decimate.title.help = "가능한 디테일을 최대한 유지하면서 폴리곤 개수를 줄입니다.

이 기능은 3d 프린팅용으로 내보내려는 경우 유용할 수 있습니다.
그러나 불균일한 삼각형이 생성될 수 있으므로 스컬프팅 작업을 계속하려면 사용하지 않아야 합니다.

마스크 영역은 제거되지 않습니다.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "데시메이트";
topology.decimatePaintWeight = "패인팅 보존";
topology.decimatePaintWeight.help = "값이 높을수록 페인팅을 보존하려는 성향이 강합니다.

페인팅에 신경 쓰지 않는다면 이 값을 0으로 설정하십시오.";
topology.decimateUniform = "균일한 면";
topology.decimateUniform.help = "값이 높을수록 출력되는 삼각형의 크기가 비슷해집니다.";
topology.decimatePreserveBorders = "";
topology.decimatePreserveBorders.help = "";
// Target a certain number of triangles, faces and vertices
topology.target.triangles = "목표 삼각형";
topology.target.faces = "";
topology.target.quads = "";
topology.target.points = "";
// Quad remesher
topology.qremesh = "";
topology.qremesh.angle = "";
topology.qremesh.border = "";
topology.qremesh.onlyQuad = "";
topology.qremesh.hole = "";
topology.qremesh.hole.help = ""

// Unwrapping means compute UV (texture coordinates), with uvs you can appliy (wrap) a texture onto the model
topology.uv.title = "UV 언랩";
// UV Unwrap but as a Verb
topology.uv.unwrap = "언랩";
// The operation can be very slow
topology.uv.atlas.warning = "매우 느릴 수 있습니다. 버텍스 10만 개 이하를 목표로 하세요!";
// Handles are topological holes (synonym: genus, hole)
topology.uv.bff.warning = "메시에 핸들이 있으면 겹칠 수 있습니다!";
// Synonym: Point count? Singularity count ?
topology.uv.bff.cones = "원뿔 카운트";
topology.uv.bff.help = "값이 높을수록 형태가 복잡한 오브젝트의 왜곡 현상이 줄어듭니다.

값이 높을수록 연산 시간이 길어집니다.";
topology.uv.delete = "UV 삭제";

// Transfer the vertex painting in the texture, bake means "create texture (from mesh data)"
topology.bake.title = "베이크";
// Bake here means "create texture (from mesh data)"
topology.bake.title.help = "";
// Bake here means "create texture (from mesh data)"
topology.bakeSelf = "";
// Bake here means "create texture (from another mesh data)"
topology.bakeOther = "";
topology.bakeResolution = "해상도";
// Cage is a specific term, synonyom: "Bake offset"
topology.bakeOffset = "";
topology.bakeRadius = "";
// Bake opacity (from mask data)
topology.bake.opacityFromMask = "";

// project a high resolution mesh details onto another
topology.reproject.title = "";
topology.reproject.title.help = "";
// tweaking value
topology.reproject.rayBias = "";
topology.reproject.rayBias.help = "";
topology.reproject.normalOffset = "";
// number of iteration the algorithm will take
topology.reproject.iterations = "";
topology.reproject.relax = "";
topology.reproject.relax.help = "";

topology.manifold = "";
topology.nonManifold = "";
topology.manifold.clean = "";
topology.manifold.title = "";
topology.manifold.title.help = "";

// Reset key-bindings/shortcuts
binding.reset = "바인딩 초기화";
// Binding option
binding.toggleTool = "";
binding.toggleTool.help = "";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.materialPicker = "머티리얼 피커";
// Edit the tool brush size/radius
binding.editRadius = "도구 반지름";
// Edit the tool brush size/radius
binding.editIntensity = "도구 강도";
// Snap the camera
binding.viewFront = "정면도";
// Snap the camera
binding.viewLeft = "좌측면도";
// Snap the camera
binding.viewTop = "평면도";
// Move/Translate the view
binding.panLeft = "왼쪽으로 패닝 (뷰)";
// Move/Translate the view
binding.panRight = "오른쪽으로 패닝 (뷰)";
// Move/Translate the view
binding.panForward = "앞으로 패닝 (뷰)";
// Move/Translate the view
binding.panBackward = "뒤로 패닝 (뷰)";
// Move/Translate the view
binding.panUp = "위로 패닝 (뷰)";
// Move/Translate the view
binding.panDown = "아래로 패닝 (뷰)";
// Snap the view (while rotating)
binding.snapViewOnRotate = "뷰 스냅 (회전 도중)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "열기 (프로젝트)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "추가 (프로젝트)";
// Import an external scene file (replace current scene)
binding.import.open = "열기 (임포트)";
// Import an external scene file (add it to the current scene)
binding.import.add = "추가 (임포트)";
// Select all the objects in the scene
binding.selectAll = "모두 선택";
// Rotate environment and the lighting
binding.rotateLighting = "광원 회전";

// Privacy policy
privacyPolicy.title = "개인 정보 보호 정책";
privacyPolicy.reject = "거부";
// Hexanomad is the company name
privacyPolicy = "Hexanomad는 Nomad Sculpt로부터 어떠한 데이터도 수집하지 않습니다.";

// Color disc mode
widget.color.disc = "";
// Color square mode
widget.color.square = "";

// version trial
version.buyWeb = "웹 버전은 데모 목적으로만 사용할 수 있습니다";
version.buyFull = "풀 버전으로 업그레이드";
version.restorePurchase = "구매내역 복원";

version.trialHistory = "평가판: 4번의 실행 취소/다시 실행 가능";
version.trialLayer = "평가판: 메시 당 1개의 레이어";
version.trialOneProject = "퍙기판: 1개의 프로젝트만 활성화 가능";
version.trialNoImport = "평가판: 임포트 기능을 사용할 수 없음";
version.trialNoExport = "평가판: 익스포트 기능을 사용할 수 없음";

version.fullFeatures = "- 일회성 구매
- 무제한 실행 취소/다시 실행
- 무제한 레이어
- 저장 및 불러오기
- 익스포트 및 임포트";

meta.colon = "";