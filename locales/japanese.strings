// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "よろしいですか？";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "はい";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "OK";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "キャンセル";

// Name of an item (object, tool, etc)
item.name = "名前";
// Add a new item (object, tool, etc)
item.new = "新規";
// Rename an item (object, tool, etc)
item.rename = "名前を変更";
// Add a new item (object, tool, project, etc)
item.add = "追加";
// Save an item (object, tool, etc)
item.save = "保存";
item.save.confirm = "保存しますか？";
// Reload last save of an item (object, tool, etc)
item.lastSave = "最後の保存内容";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "最後の保存内容を読み込みますか？";
// Reset an item to its initial value (object, tool, etc)
item.reset = "リセット";
item.reset.confirm = "リセットしますか？";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "インスタンス";
// Uninstance the object, make the object real
item.uninstance = "インスタンスを解除";
// Clone an item (object, tool, etc)
item.clone = "クローン";
// Delete an item (object, tool, etc)
item.delete = "削除";
item.delete.confirm = "削除しますか？";
item.delete.confirm.yes = "はい、削除します";
// When we delete the item but the image is used somewhere
item.delete.imageUsed = "以下のツールを使用:";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "ノードに";
// Item visibility (object, layer, etc)
item.visible = "可視";
// Show an item (object, layer, etc)
item.show = "表示";
// Hide an item (object, layer, etc)
item.hide = "隠す";
// Select an item (object, layer, etc)
item.select = "選択";
// Unselect an item (object, layer, etc)
item.unselect = "選択解除";
// Merge an item with another one below (layer)
item.mergeDown = "下へ結合";
// The order of an item in a list
item.order = "順序";
// Focus on previous item
item.previous = "前へ";
// Focus on next item
item.next = "次へ";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "ロック";

// Three-state toggle button (Auto, Off, On)
toggle.on = "オン";
// Three-state toggle button (Auto, Off, On)
toggle.off = "オフ";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "自動";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "サムネールがありません。ファイルを再処理中... ($0/$1)

$2";
loading.reprocess.cancel = "";

// Color of an object
material.color = "カラー";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "粗さ";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "光沢";
// Whether the material is a metal or not
material.metalness = "メタリック";
// How much light a surface will reflect
material.specular = "スペキュラ";
// Light that the surface can emit (glow)
material.emissive = "エミッシブ";
// Normal map (synonym: detail, bump)
material.normal = "標準";
// Ambient Occlusion (AO)
material.occlusion = "オクルージョン";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "テクスチャ";

// Minify
about.minify = "UIをMinify";
about.minify.help = "指4本でスクリーンをタップすることもできます（デバイスがサポートする場合)。";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "ターンテーブル";
// Make the entire scene turn around (speed of the animation)
about.turntableSpeed = "ターンテーブルの速度";
// Stuffs that I used to make the app
about.credits = "クレジット";
// Link to open source projects that I used for the app
about.credits.openSource = "オープンソース";
// Only translate the &
about.credits.arts = "MatCap & HDRI";
// Change languages of the app
about.languages = "言語";
about.languages.help = "翻訳ファイルは $0 から利用できます";
// Link to the App Website
about.website = "Webサイト";
// Link to the App Forum
about.forum = "フォーラム";
// Link to the App Manual
about.manual = "手動";
// Link to the App Email
about.mail = "サポート";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";

// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "オブジェクトに穴がありません。";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "現在のオブジェクトは不可視です！";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "トリムするものがありません！";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "トリムを中止: オブジェクトは完全にトリムされています。";
// In order to extract something, the mesh needs to have painted mask
alert.mask.noExtract = "取り出すものがありません！";
// In order to split something, the mesh needs to have painted mask
alert.mask.noSplit = "分割するものがありません！";
// List of disabled features when View Mode is selected
alert.view.disabled = "表示モードで無効になっている機能:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "プリミティブのウィジェット";
// The object needs to have two parts disconnected
alert.separate.fail = "分割できません: オブジェクトに1つのパーツしかありません！";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "リメッシュしました！";
alert.voxelRemesh.empty = "リメッシュを破棄: 結果のメッシュに面がありません。";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "無効な入力です！";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "オブジェクトは複製されます";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "オブジェクトはインスタンス化されます";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "回転軸モードを編集してください。";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "オブジェクトモードを編集してください。";
// See Glossary (DynTopo)
alert.dynamic.enable = "アクティブなダイナミックトポロジー";
// See Glossary (DynTopo)
alert.dynamic.disable = "ダイナミックトポロジーを無効にする";
alert.colorPicker = "指をオブジェクトにドラッグして、カラーを選択してください。";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "変換モードを終了するには、タップしてください。";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "";
alert.view.reset = "ビューをリセット";
// Snap the view to the nearest aligned 90° angle
alert.view.snap = "スナップビュー";
// Show the painted mask on the mesh
alert.mask.show = "マスクを表示";
// Hide the painted mask on the mesh
alert.mask.hide = "マスクを隠す";
// Selection refers to the objects that are currently selected
alert.selection.lock = "選択部分をロック";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "選択部分をロック解除";
// Hide the objects that are not selected
alert.selection.isolate = "選択部分を分離";
// Show the objects that are hidden
alert.selection.showAll = "すべてを表示";
// Project quick saving
alert.quickSave = "保存中…";
// Painting on the object was hidden but the user did paint the object
alert.forceShowPainting.fill = "“ペイントを表示”が有効で、[すべてをペイント] が使用されました。";
// Painting on the object was hidden but the user started to paint on the object
alert.forceShowPainting.tool = "“ペイントを表示”が有効で、オブジェクトがペイントされました。";
// See Glossary (Multiresolution)
alert.multiresLost = "マルチレゾリューションは喪失します！";
// The user is starting an operation that can lead to a crash
alert.range.warning = "ディテールの値が高いので、多くのメモリを必要とする可能性があります！";
// Autosave popup
alert.autoSave.auto = "自動保存... $0s後";
// The selected object doesn't have any layers
alert.needLayer = "使用中のツールはアクティブなレイヤーが必要です。";
// The user decides to hide the painting on the objects
alert.paintingHidden = "ペイントが非表示です: “設定”パネルからもう一度表示できます。";
// The selected object doesn't have any layers
alert.noPartialWireframe = "ワイヤーフレームが表示されている場合、部分的な描画は無効です。";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "スクリーンプロジェクタを使用する際、遠近法のfrustumの歪みを避けたい場合は、Orthographicカメラの使用を検討してください。";
// Trial version has a limited number of undo
alert.state.trial = "お試し版: 取り消しはキャンセルされました";

background = "背景";
// A flat color will be displayed in the background of the scene
background.color = "カラー";
// The environment (HDRI) will be displayed in the background
background.environment = "環境";
background.blur = "ブラー";
background.exposure = "露出";

// Image that the artist uses as a reference
background.imageEnable = "参照イメージ";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "オーバーレイ";
// Opposite of transparency (Alpha)
background.imageAlpha = "不透明度";
background.imageReset = "設定をリセット";
background.imageTransform = "変形";
// X screen coordinate of the image reference
background.imageX = "位置 X";
// Y screen coordinate of the image reference
background.imageY = "位置 Y";
// Rotation of the reference image
background.imageRotation = "回転";
// Scale of the reference image
background.imageScale = "比率";

// Camera (point of view in 3d)
camera = "カメラ";
// Copy the views
camera.updateView = "ビューポイントをアップデートしますか？";
// Add a new camera
camera.addView = "ビューを追加";
// Focus on the camera
camera.focus = "焦点";
// Add on the camera camera
camera.focusOn = "$0に焦点を当てる";
// Camera projection, Orthographic or Perspective
camera.projection = "投影";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Orthographic (平行投影)";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "遠近法";
// camera Vertical Field of View
camera.fov = "垂直画角";
// Camera Field of View hint
camera.focal = "焦点 $0mm (35mm センサー)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "回転";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "ターンテーブル";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "トラックボール";
camera.rotation.trackball.help = "トラックボールを使うと、指2本でカメラを回すことで自由度が増します。";
// Camera interaction mode, 1st person view
camera.firstPerson = "ファーストパーソン";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "速度";
// Camera rotation sensitivity
camera.speed.rotation = "回転";
// Camera panning sensitivity
camera.speed.panning = "パン";
// Camera zooming sensitivity
camera.speed.zooming = "ズーム";
// Reset camera position
camera.resetView = "ビューをリセット";
// Align the view (snap to nearest 90° angle)
camera.snapView = "スナップビュー";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "カメラがスナップされています (Orthographic)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "Orthographicスナップ";
camera.snapOrthographic.help = "このオプションは画面の隅で方向キューブを使用している場合も有効です。";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "回転軸";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "オブジェクトをダブルタップ";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "背景をダブルタップ";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "切り替える";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "選択内容";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "シーン";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "ダブルタップでアップデート";
camera.doubleTapPivot.help = "オブジェクトの表面をダブルタップすると、回転軸をアップデートします。";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "エアーピボット";
camera.airPivot.help = "オブジェクトのサーフェスの外側でズームしている場合でも、新しい回転軸を使用できます。";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "カメラの使用と同時に";
camera.autoPivot.help = "カメラと動作し始めると回転軸がアップデートされます。";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "フォーカス";
camera.doubleTapFocus.help = "オブジェクトをダブルタップすると、カメラはパンし、選択したポイントにフォーカスします。";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "複数選択";
// There is 0 nodes/items selected
context.noSelection = "選択されていません";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "プリセット";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "スプライン曲線";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "";

// set the desired FPS (frame per second, refresh rate)
debug.targetFPS = "";
debug.targetFPS.help = "";

// Debug option, the newly created primitives will contains texture coordinates (UVs)
debug.uvPrimitive = "プリミティブのUVを残す";
debug.uvPrimitive.warning = "UV (追加のメモリ) が必要でない場合、このオプションを無効にしてください。";
debug.uvPrimitive.help = "現時点では、ボックスと球のみがサポートされています。

その他のタイプは今後サポートされる予定です。";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "UVを標準化";
debug.uvNormalize.help = "Nomadは [0-1] のタイル内のUVを標準化します。";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "BFF UVを追加";
debug.uvBFF.help = "代替のラップ解除方法 (Boundary First Flattening) を追加します。

BFFは、メッシュトポロジーがディスクまたは球と異なる場合、オーバーラップを生成します。 ご注意ください。";
// Debug option, display an window with some debugging logs
debug.logs = "ログ";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "ハイトマップ";
// Debug options, graphical stuffs
debug.graphics = "グラフィック";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "ストアのサムネールを作成";

// Empty list: there is no projects
file.project.empty = "まだ保存されたプロジェクトがありません！";
// The current opened project has some unsaved changes
file.project.unsaved = "変更内容が保存されていません！";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "未保存の変更内容は喪失します！";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "最後に手動で保存した内容のプレビュー";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "お試し版: 現在のプロジェクトをもう一度開けません！";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "お試し版: 現在のプロジェクトのみを再開できます！";

file.project = "プロジェクト";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "保存";
// E.g: Save "my_project"?
file.project.save.confirm = "$0を保存しますか？";
// Save to another project (either new one or overriding existing one)
file.project.saveAs = "別名で保存";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "$0を上書きしますか？";
// Open a project
file.project.open = "開く";
// E.g: Open "my_project"?
file.project.open.confirm = "$0を開きますか？";
// Load another project and add/append all its data to the current scene
file.project.add = "シーンに追加";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "$0をシーンに追加しますか？";
// Reset the scene and create a new project
file.project.new = "新規";
file.project.new.confirm = "新規シーンを作成しますか？";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "$0を削除しますか？";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "$0を削除しますか？

これは現在アクティブなプロジェクトです！";

// Auto save section
file.project.autoSave = "自動保存";
file.project.autoSave.confirm = "自動保存をオフにしますか？";
file.project.autoSave.help = "プロジェクトを一定の間隔で別のファイルに保存します。
自動保存されたファイルの保存先:

$0";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "ポップアップのタイムアウト";
// In minutes
file.project.autoSave.minutes = "タイマーのポップアップ";
// Delete the current autoSave data
file.project.autoSave.delete = "自動保存の内容を破棄";

// Load interface preference settings when opening a scene file
file.load.guiSettings = "GUI設定を残す";
file.load.guiSettings.help = "プロジェクトファイルを開く、または読み込む際、プロジェクトに埋め込まれたGUIに関連するすべての設定は読み込まれます。";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.load.objSplitByGroup = "OBJをグループで分割";
file.load.objSplitByGroup.help = "有効にすると、NomadはOBJグループを別々のオブジェクトに分割します。";
// Merge all the object layers at when loading a file (deleting them in the process)
file.load.mergeLayers = "レイヤーを結合";
// Ignore the textures present in the file to load
file.load.skipTextures = "テクスチャをスキップ";
// Do not fiddle with the object topology when loading the file
file.load.keepTopology = "トポロジーを残す";
file.load.keepTopology.help = "Nomadに読み込んだメッシュのトポロジーをいじらせたくない場合は、このオプションを使用してください。

こうすることで、頂点/面の並べ替え、頂点/面の複製の削除、および未使用の頂点の削除を無効にします。";
// If the object has more vertices than this value, then we won't attemp to reverse (multiresolution) the object
file.load.reverseVertices = "しきい値を反転";
file.load.reverseVertices.help = "メモリの使用容量を少なくするために、Nomadはメッシュの低い方の解像度を保存しません。

しかし、頂点の数がこのしきい値よりも低い場合、低いほうの解像度が再構築されます。";


// Configure imports option
file.importSettings = "オプションを読み込む";

// Import file section
file.import.title = "読み込む";
file.import.title.help = "対応フォーマット:
- Wavefront (.obj)
- glTF 2.0 (.glb .gltf)
- STL (.stl)";
// The user imports a scene file that will replace the current scene
file.import.open = "開く";
file.import.open.confirm = "新しいファイルを読み込みますか？";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "シーンに追加";
file.import.add.confirm = "新しいファイルを読み込みますか？";

// Export scene file
file.export.title = "書き出す";
file.export.title.help = "可能であれば、glTFは他のフォーマットよりも多くの機能をサポートするので、glTF書き出しを優先してください。";

// Export the current selected objects instead of the entire scene
file.onlySelection = "選択中のオブジェクトのみを含める";
file.onlySelection.help = "シーン全体ではなく、選択部分のみを含めます。";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "四角形を再構築";
file.convertToQuad.help = "三角形を組み合わせて三角形から四角形を再構築します (ファイルで隣接している場合)。";

// Whether we include the textures in the exported file
file.export.texture = "テクスチャを書き出す";
// Baking means transfering/converting
file.export.texture.help = "このオプションはテクスチャに頂点カラーをベイクしません。";
// Whether we include normals vector in the exported file
file.export.normal = "法線を書き出す";
file.export.normal.help = "別のソフトウェアでファイルを開きたい場合は、このオプションをチェックしてください。

Nomadは法線を計算し直すので、必ずそれらを無視します。";

file.export.gltf = "glTF 2.0で書き出す";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "レイヤーを書き出す";
file.export.gltf.layer.help = "レイヤーをモーフとして書き出します。glTFに公式にサポートされているので、他のソフトウェアでも同様に動作することが期待されます。";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "レイヤーペイントを書き出す";
file.export.gltf.layerPaint.help = "レイヤーペイントを書き出します。通常、他のソフトウェアには無視されます。";
// Whether the exported layer will use the non-standard Nomad encoding (smaller size)
file.export.gltf.layerNomad = "Nomad レイヤーエンコーディング";
file.export.gltf.layerNomad.help = "ペイントのレイヤーを16ビットでなく、8ビットで書くことでファイルサイズを小さくします。

このエンコーディングは絶対的なペイントを使用するので、Nomadでのみ動作します。
glTFは相対的なエンコーディングを要求するので、他のソフトウェアでは正確な結果を得られません。";
// Whether we include the vertex color in the exported file
file.export.gltf.color0 = "頂点カラーを書き出す";
file.export.gltf.color0.help = "頂点カラーを書き出します。glTFに公式にサポートされているので、他のソフトウェアでも同様に動作することが期待されます。";
// Whether we include the vertex roughness and vertex metalness in the exported file
file.export.gltf.color1 = "PBRペイントを書き出す";
file.export.gltf.color1.help = "粗さ、メタリック、およびマスクペイントを書き出します。これは他のソフトウェアに無視されます。";

file.export.obj = "OBJを書き出す";
file.export.obj.warning = "レイヤーとその他のペイント (粗さ、メタリック、マスク) は喪失します。";
// Whether we include the vertex color in the exported file
file.export.obj.colorAppend = "頂点カラーを書き出す";
file.export.obj.colorAppend.help = "頂点の後にカラーの情報を追加します。

これを読み取れる3Dソフトウェアもありますが、読み取れないソフトウェアもあります。";

file.export.stl = "STLを書き出す";
file.export.stl.warning = "レイヤーとその他のペイント (粗さ、メタリック、マスク) は喪失します。";
// Whether we include the vertex color in the exported file
file.export.stl.color = "頂点カラーを書き出す";
file.export.stl.color.help = "それを読み出せる3Dソフトウェアもありますが、すべてのソフトウェアができるとは限りません。";
file.export.stl.ascii = "デフォルトで、フォーマットはバイナリです。

テキストフォーマット (ASCII) に書き出す選択もできますが、ファイルサイズが大きくなります。";

// Advanced settings
settings.advanced = "高度な機能";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "これらのオプションは設定に保存されていません。";
settings.reset.title = "設定";
settings.reset.title.help = "この操作はアプリの設定をリセットします。

いくつかのリソースは別々に保存されているので、リセットされません。リセットされないものは以下の通りです:
- プロジェクト
- キーバインド
- ツールのプリセット
- HDR 環境
- MatCap
- アルファ
- テクスチャ (ブラシ)
- 参照イメージ

プロジェクトにリンクされているもの、例えば、ライティング、ポスト処理、カメラビューなど、はすべてそのまま残ります。";

// Reset preference settings button
settings.reset = "デフォルトにリセット";
settings.reset.confirm = "環境設定をリセットしますか？";

// Render a screenshot of the scene
file.render = "レンダリング";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "インターフェースを表示";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "レンダーの比率";
file.render.renderRatio.help = "値が 1.0 の場合、Nomadが下の要求されたイメージサイズと同じ解像度でレンダーすることを意味します。

特定の解像度でレンダーできない場合 (メモリ不足でクラッシュするなど)、このオプションを使用してください。";
// Desired size of the exported screenshot
file.render.size = "最終サイズ";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "カスタム";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "スクリーン";
// width of exported screenshot
file.render.width = "幅";
// height of exported screenshot
file.render.height = "高さ";
// export screenshot of the scene
file.render.export = "pngを書き出す";
file.render.warn = "書き出しの解像度が高いです ($0x$1)！

デバイスでVRAMが不足し、クラッシュするような場合に備えて、必ずプロジェクトを保存しておいてください。";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "透明な背景";
file.render.transparent.help = "このオプションは2D製作ソフトウェアでメッシュを挿入したい場合、便利です。

現時点では、部分的なオブジェクトの透明度はサポートされていません。";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "グローバル設定を使用";
pressure.useGlobal.help = "デフォルトで、ツールは同じプレッシャー設定を共有します。

このツールに特定のプレッシャーを設定したい場合は、このオプションをチェックしないでください。";

// Pencil pressure
pressure.title = "筆圧";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "このツールはペンシルの筆圧を使用しません。";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "ストロークタイプ、“グラブ”は筆圧設定を無視します。";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "半径";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "強度";

// Customize whether finger and/or stylus can move the Camera
gesture.cameraInteraction = "カメラ:";
// Customize whether finger and/or stylus can sculpt on object
gesture.sculptInteraction = "スカルプト:";
// Both the finger and the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.fingerAndStylus = "指とスタイラス";
// Only the finger can perform a certain action (move camera, sculpt, etc)
gesture.interaction.finger = "指";
// Only the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.stylus = "スタイラス";
// Disable the action
gesture.interaction.none = "なし";
// Allow the action for any inputs
gesture.interaction.any = "すべて";

// long press to pick the color/material under the cursor
gesture.materialPicking = "マテリアルの選択";
gesture.materialPicking.help = "キャンバスを長押しすると、カラー/マテリアルピッカーが表示されます。

現在のブラシのペイントが有効な場合にのみ動作します。";

// Three fingers on screen
gesture.three.title = "3本指";
// Drag 3 fingers horizontally on the canvas to rotate the environment, lights and MatCap
gesture.fingerLighting = "ライティングを回転 (3 本指)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerLighting.help = "指3本でキャンバス上を横方向にドラッグすると、環境、ライト、MatCapを回転できます。";
// Drag 3 fingers vertically to edit the tool radius
gesture.fingerRadius = "ツールの半径を編集 (3 本指)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerRadius.help = "指3本でキャンバスを縦方向にドラッグすると、ツールの半径を編集できます。";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.fingerSmooth = "指は常にスムージングに使用されます";
gesture.fingerSmooth.help = "";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "未認識の筆圧を許可";
gesture.unknownPressure.help = "お使いのペンシルで筆圧が動作しない場合、または指の筆圧が必要な場合、このオプションをチェックしてください。";

// Action when we press an Android pencil button
gesture.pencilAction.android = "ペンシルのボタン";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "ペンシルのダブルタップ";
gesture.pencilAction.ios.help = "Apple Pencil 第2世代にのみ対応。";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "なし";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "追加/減算";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "ワンタップショートカット";
gesture.mask.oneTap.help = "画面を1度タップしてマスクのショートカットを許可します。マスクボタンのショートカットを押す必要がなくなります。

以下のジェスチャを利用できます:
- 背景をタップして、マスクを反転
- マスクしたエリアをタップして、マスクをぼかす
- マスクされていないエリアをタップして、マスクをシャープにする";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress = "長押し (マスク ↔ SelMask)";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress.help = "マスクまたはSelMaskが有効な場合、指で長押しするとこれらのツールを切り替えられます。

指を動かさないで長押しすると、新しいツールがデフォルトのマスクショートカットとして使用されます。";
// Indicator that the tool has been set as the new shortcut
gesture.mask.infoShortcut = "$0 がマスクショートカットとして設定されました。";

// Shortcuts to undo/redo
gesture.history = "ショートカット履歴";
gesture.history.help = "- 取り消し: 2 本指でタップ
- やり直し: 3 本指でタップ
- 取り消し/やり直し: 2 (または3) 本指で長押し (続けて)";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "パームリジェクション";
gesture.palmRejection.confirm = "キャンバスの操作で問題に遭遇した場合は、このオプションが無効になっているか確認してください！";
gesture.palmRejection.help = "接触部分のサイズがこの値より大きい場合、入力を拒否。

すべてのデバイスで利用できるとは限りません。";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "最大サイズのしきい値";

// History, list of undo/redo
history = "履歴";
// First "undo" state
history.root = "ルート";
history.undoConfirm = "これらの操作をすべて取り消してよろしいですか？";
history.undoWarning = "後で編集を加えると、多くの変更内容を喪失する可能性があります。";
// Settings concerning the history stack of undo/redo
history.stack = "スタック";
// Actions to include in the undo/redo stack
history.include = "アクションを含める";
// include lighting editing in the undo/redo
history.includeLights = "ライト";
history.includeLights.help = "このオプションが無効の場合でも、Gizmoを使ったライトの移動はそのまま含まれます。シーン階層で他のオブジェクトに影響するからです。";
// include postProcess editing in the undo/redo
history.includePostProcess = "ポストプロセス";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCap & HDRI";
// Can limit the stack of undo/redo size
history.limitSize = "履歴の上限 (Mb)";
history.limitSize.help = "履歴の最大サイズ (Mb) 。

履歴は次に操作が記録されるとアップデートされます。";
// Limit the number of undo in the history stack
history.limitStack = "スタックの上限";
history.limitStack.help = "アプリが残せる操作数の上限。

履歴は次に操作が記録されるとアップデートされます。";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "取り消しの上限";
history.rangeProtect.help = "履歴をずっとさかのぼると、多くの取り消しを実行する前に確認ダイアログが表示されます。";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "カメラを復元";
history.restoreCamera.help = "このオプションを有効にすると、アクションを取り消し、またはやり直した場合、保存されているカメラのビューポイントを復元します。";
// Undo
history.undo = "取り消す";
// Redo
history.redo = "やり直す";
// Shown during undo
history.state.undo = "取り消し: $0";
// Shown during redo
history.state.redo = "やり直し: $0";
// Shown during undo/redo
history.state.symmetrySplit = "対称で分割";
// Shown during undo/redo
history.state.voxelRemesh = "ボクセルのリメッシュ";
// Shown during undo/redo
history.state.surfaceRemesh = "サーフェスのリメッシュ";
// Shown during undo/redo
history.state.multiresLevel = "解像度の変更";
// Shown during undo/redo
history.state.multiresToDynamic = "マルチレゾからDynTopo";
// Shown during undo/redo (mesh type conversion)
history.state.meshDynamicToStatic = "DynTopoから静的";
// Shown during undo/redo (mesh type conversion)
history.state.meshStaticToDynamic = "静的からDynTopo";

// Interface customization
interface = "インターフェース";

// UI customization: each row of the list will be bigger
interface.expandList = "UI: リストを展開";
// UI customization: each row of the list will be bigger
interface.expandList.help = "リスト管理を簡単にするためのUIオプション。";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "ショートカットを追加 (下)...";

// Interface option (main base color)
interface.colorBase = "カラーベース";
// Interface option (accent widget color)
interface.colorSelect = "カラーウィジェット";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "透明パネル";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "ぼかしの強度";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "カラーパネル";

// Interface color style
interface.preset.title = "カラープリセット";
// Interface color style (original color of Nomad Sculpt)
interface.preset.classic = "クラシック";
// Interface color style
interface.preset.orange = "オレンジ";
// Interface color style (~red)
interface.preset.cardinal = "カーディナル";
// Interface Color style (~pink)
interface.preset.mulberry = "マルベリー";
// Interface color style
interface.preset.brown = "ブラウン";
// Interface color style (~green)
interface.preset.emerald = "エメラルド";
// Interface color style (~blue)
interface.preset.neon = "ネオン";
// Interface color style
interface.preset.violet = "バイオレット";
// Interface color style
interface.preset.grey = "グレイ";
// Interface color style
interface.preset.black = "ブラック";
// Interface color style
interface.preset.white = "ホワイト";

// Reset interface settings
interface.resetAll = "スタイルをリセット";
interface.resetAll.confirm = "インターフェース設定をリセットしますか？";
// Interface option (main base color)
interface.iconSupport = "";
interface.iconSupport.help = "";
// Interface customization
interface.flipTop = "上のバーにミラー";
// Interface customization
interface.flipBottom = "下のバーにミラー";
// Interface customization
interface.flipMiddle = "サイドバーにミラー";
// Interface customization (preview material in the viewport when editing material color)
interface.materialPreview = "マテリアルのカラーのプレビュー";
// Interface customization
interface.materialPreview.help = "素材のカラーを選択すると、この素材のプレビューが現在選択中のオブジェクトに表示されます。";
interface.toolbox.hide = "ツールボックスを隠す";
interface.toolboxHide.help = "ツールボックスを非表示にしたい場合は、このオプションを有効にしてください。";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.maxColumn = "ツールボックスの列の最大値";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "ツールボックスの順序をリセット";
// Scale the interface
interface.scale = "全体的なサイズ調整";
// Spacing between widgets
interface.cursorStep = "垂直方向の間隔";
// Width of the interface panels
interface.panelWidth = "パネルの幅";
// Size of fonts
interface.fontScale = "フォントサイズ";
// Inset
interface.inset.title = "画面の端のオフセット";
interface.inset.title.help = "画面の端のボタン操作に問題がある場合のみ、これらの値を変更することを検討してください。

スライダーが無効の場合、Nomadはデバイスそのものによる安全なエリアの値を使用します。";
interface.inset.left = "左";
interface.inset.right = "右";
interface.inset.bottom = "下";
interface.inset.top = "上";

// (see Glossary for Layer)
layer = "レイヤー";
// (see Glossary for Layer)
layers.lock = "上のレイヤーのディテールを残す";
// (see Glossary for Layer)
layers.lock.yes = "一番上のレイヤーをロックしますか？";
// (see Glossary for Layer)
layers.lock.warning = "スカルプト中、上のレイヤーから来る変形は無視されます。

しかし、これらのレイヤーのディテールはまだ可視状態です。

このオプションは、上のレイヤーに比較的スケールの小さなディテールがある場合のみ動作します。";
// (see Glossary for Layer)
layers.addLayer = "レイヤーを追加";
// (see Glossary for Layer)
layer.factors = "チャンネル要素";
// (see Glossary for Layer)
layer.factor = "要素";
// (see Glossary for Layer)
layer.offset = "オフセット";
// (see Glossary for Layer)
layers.title = "レイヤー";
// (see Glossary for Layer)
layers.title.help = "レイヤーは位置のオフセットとペイントを記録でき、非線形のワークフローに便利です。
例えば、変更内容を取り消すために履歴に頼らなくても、いろいろな表情を試してみたい場合などです。

ペイントのデータには、レイヤーは上から下に順番に並んでいます。つまり、上のレイヤーは下のレイヤーをマスクします。

“DelLayer”ツールを使って、レイヤーの一部を消去することもできます。";
layers.primitive = "レイヤーはプリミティブに利用できません。";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "なし";

light = "ライト";
// Intensity of light
light.intensity = "強度";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "色温度";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "カメラ";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "固定されています";
// The light will move along the camera
light.attachment.camera = "カメラ";
light.attachment.help = "-- 固定
ライトの方向は変化しません。

-- カメラ
ライトの方向はカメラビューによって変化します。";
// Light type (directional, spot, point)
light.type = "タイプ";
// Directional light (synonym: sun light)
light.type.directional = "方向的";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "スポットライト";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "ポイント";
// Cone angle for spot angles
light.spot.angle = "円錐の角度";
// Softness of the spot light
light.spot.softness = "柔らかさ";
// Position of the light
light.position = "位置";
// Enable or disable shadows for a light
light.shadow.cast = "シャドウ";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "ポイントライトは画面空間のシャドウのみをサポートします。";
light.shadow.type = "シャドウのタイプ";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "シャドウマップ";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "スクリーンスペース";
light.shadow.type.screenspace.help = "実験的な機能。今後のリリースで削除される可能性があります。

このオプションは柔らかさのシャドウの機能と使用されるように考えられています。";
// Adjustment to fix artefacts
light.shadow.bias = "バイアス";
// How blurry the shadow is
light.shadow.softness = "柔らかさ";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "コンタクト";
light.contact.help = "“自動”が選択されている場合、最も強いライトのみがコンタクトシャドウを発生します。";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "許容値";
// Activated the light
light.visible = "表示";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "中心に戻す";

// Object's material
material = "マテリアル";
// See glossary
material.pbrRoughnessMetalness.warning = "粗さとメタリックは、PBRシェーディングモードが必要です。";
// See glossary
material.pbrReflectance.warning = "反射率にはPBRシェーディングモードが必要です。";
// See glossary
material.pbrRefraction.warning = "屈折は、PBRシェーディングモードが必要です。";
// See glossary
material.pbrSubsurface.warning = "サブサーフェスにはPBRシェーディングモードが必要です。";
// Value that says how much light will change direction when hitting the surface
material.ior = "屈折率 (IOR)";
// an object-level value that overrides the painting of the mesh
material.paintingOverride = "ペイントを上書き";
// The roughness in the inside is turbidity
material.paintingOverride.help = "有効な粗さが2つあります。1つはサーフェスで、もう1つは内側で動作しています。

しかし、ペイント可能な粗さは1つだけなので、2つのラフネスは同じ値になります。

このスライダーを使用して、サーフェスの粗さを上書きして光沢を増すことができます。";
// Glossiness is simply the opposite of roughness
material.refractionSurfaceGlossiness = "サーフェスの光沢";
material.refractionSurfaceGlossiness.help = "- 0 の場合、サーフェスはペイントされた粗さを使用しています
- 1 の場合、サーフェスは完全にスムーズです";
// Synonym: turbidity
material.refractionInteriorRoughness = "内側の粗さ";
material.refractionInteriorRoughness.help = "- 値が 0 の場合、内側はペイントされた粗さを使用しています
- 値が 1 の場合、内側は完全にザラザラしています";
// Set the roughness of the object with a value of 0
material.paintGlossy = "光沢でペイント";
material.paintGlossy.help = "粗さとメタリックの値を 0 にしてオブジェクトをペイントするので、シャープな屈折が可能です。

これはペイントメニューに進み、カラーとメタリックを無効にして“すべてをペイント”の機能を使用するのと同じです。";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "吸収";
material.absorptionEnable.help = "体積を通過する時に吸収される光をシミュレーションします。

薄い部分は光を多く通すので明るくなります。厚い部分は暗くなります。

エフェクトはオブジェクトの形に大きく影響されます。オブジェクトの厚さの概算のみが使用されます。";
material.absorptionFactor = "要素";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "深さ";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "透過";
material.translucency.help = "透過処理をするにはシャドウを投影するためのライトが必要です。";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "不透明度";
// Fully opaque material
material.type.opaque = "不透明";
// See glossary
material.type.subsurface = "サブサーフェス";
material.type.subsurface.help = "最善の結果を得るには、PBRシェーディングモードに切り替えて、最低1つのディレクショナルライトを、理想的には薄暗い環境で、使用してください。";
// Transparency mode, alpha blending
material.type.blending = "ブレンド";
material.type.blending.help = "不透明度の値を調整してオブジェクトを半透明にします。

オブジェクトの形が複雑な場合、リアルタイムの制限により、あきらかなアーティファクトが見えることがあります。";
// Transparency mode
material.type.additive = "加法";
material.type.additive.help = "不透明度の値を調整してオブジェクトを半透明にします。

この方法は、“ブレンド”に比べてアーティファクトが軽減されますが、オブジェクトはより明るくなります。";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "ディザ合成";
material.type.dithering.help = "ピクセルの一部をランダムに破棄して、オブジェクトを半透明にします。";
// Simulate glass-like material
material.type.refraction = "屈折";
material.type.refraction.help = "このモードはガラスマテリアルを再現するのに使用できます。

リアルタイムの制限のために、自己屈折またはマルチレイヤーの屈折が制限されます。";
material.castShadows = "シャドウを投影";
material.receiveShadows = "シャドウを受け取る";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "常にライトなし";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "カリング反転";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "反射率";
material.reflectance.help = "マテリアルが非メタリックのマテリアルに受け取る反射の量をコントロールします。

大抵の場合、デフォルト値が使用されます (0.5、これは通常の角度で、4% の標準的な反射光に該当します)。";

// Menu name
menu.files = "ファイル";
// Menu name
menu.scene = "シーン";
// Menu name
menu.multires = "マルチレゾ";
// Menu name
menu.voxel = "ボクセル";
// Menu name
menu.dynTopo = "DynTopo";
// Menu name
menu.topology = "デシメイト/UV...";
// Menu name
menu.primitive = "プリミティブ";
// Menu name
menu.render = "レンダリング";
// Menu name
menu.material = "マテリアル";
// Menu name
menu.postProcess = "ポストプロセス";
// Menu name
menu.camera = "カメラ";
// Menu name
menu.background = "背景";
// Menu name
menu.tool = "ツール";
// Menu name
menu.stroke = "ストローク";
// Menu name
menu.paint = "ペイント";
// Menu name
menu.symmetry = "対称";
// Menu name (pencil pressure)
menu.pressure = "筆圧";
// Menu name
menu.gesture = "ジェスチャ";
// Menu name
menu.layers = "レイヤー";
// Menu name
menu.settings = "設定";
// Menu name
menu.interface = "インターフェース";
// Menu name
menu.bindings = "バインド";
// Menu name
menu.history = "履歴";
// Menu name
menu.historySettings = "設定";
// Menu name
menu.about = "情報";
// Menu name
menu.debug = "デバッグ";

// Operation on the object (action)
mesh.action = "操作";
// If the object has holes, the algorithm will close them
mesh.holeClose = "穴を閉じる";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holeDetail = "ディテール";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "分離";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "レイヤー、ペイント、およびマルチレゾリューションは喪失します。";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "解像度";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "強制的に立方体を作成";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "変換";
// Static object means "static topology"
mesh.typeStatic = "メッシュ";
// See glossary
mesh.typeMultiresolution = "マルチレゾリューション";
// Dynamic topology
mesh.typeDynamic = "DynTopo";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "グローバルマテリアル";
paint.useGlobal.help = "このオプションを有効にすると、選択中のマテリアルが他のツールと同じになります。

但し、粗さ、メタリック、およびカラー設定のみが考慮されますので、ご注意ください。";
// The current tool will paint the object if this option is enabled
paint.usePainting = "ストロークペイント";
// Factor/Opacity of paint tool
paint.intensity = "ペイントの強度";
// Apply the paint on the object
paint.paintAll = "すべてをペイント";
paint.paintAll.help = "現在のマテリアルをオブジェクトに適用できます。

マスクの部分と無効なチャンネルはペイントされません。";
// Apply the paint on the object but ignore painting intensity (force full intensity)
paint.paintAllForce = "すべてを強制的にペイント";
paint.strokePainting.title = "ペイント";
// Brush stroke texture
paint.texture.title = "テクスチャ";
paint.texture.title.help = "ブラシストロークを色付けするイメージ。

これはアルファのタイリングと比率の設定を共有しますので、注意してください。";
paint.texture.warningEnable = "テクスチャのプロジェクションを許可するには、ストロークペイントを有効にする必要があります (一番上のチェックボックス)！";
paint.texture.warningIgnored = "使用中のツールはテクスチャを使用できません！";
// Whether the Brush Alpha will be used to module painting
paint.useAlpha = "ストロークのアルファを使用";
paint.useAlpha.help = "ストロークメニューでアルファセットを使用すると、ペイントを調節できます。";
// Whether the Brush Falloff will be used to module painting
paint.useFalloff = "ストロークのフォールオフを使用";
paint.useFalloff.help = "ストロークメニューでフォールオフセットを使用すると、ペイントを調節できます。";

// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "新しい名前";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "新しい値";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "新しいカラー (16進フォーマット)";

// Post process effect
postprocess = "ポストプロセス";
// Quality vs performance
postprocess.quality = "クオリティ";
postprocess.quality.help = "これらのオプションをアクティベートすると、クオリティは向上しますが、パフォーマンスは低下します。";
// More samples means better quality but slower performance
postprocess.maxSamples = "最大サンプル";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "フル解像度";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "最大フレーム数のサンプリング";
postprocess.accumulateCount.help = "レンダリングが停止する前に累積するフレームの最大数。

レンダリングが停止すると、 Nomadは何もしないので、電池寿命を節約します。

多くのレンダリング機能は、フレームの累積が利点になります。特に:
- ソフトシャドウ
- グローバルイルミネーション
- 反射 (SSR)
- アンビエントオクルージョン
- サブサーフェス
- 被写界深度

ソフトシャドウとグローバルイルミネーションは特に多くのフレーム数が必要です。
上記の機能が無効になっている場合、 Nomadはレンダリングを早めに停止できます。";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "レンダーの解像度";
postprocess.renderRatio.warning = "ピクセルアート効果で上書きされます。";
postprocess.renderRatio.help = "このオプションはパフォーマンスに大きく影響します。
x1.25 よりも低い値にしておくことをお勧めします。

このオプションは設定に保存されません。";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "アンチエイリアス (TAA)";
postprocess.taa.help = "カメラを移動中に起きるチラツキを軽減します。";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "反射 (SSR)";
postprocess.ssr.warning = "SSRにはPBRシェーディングモードが必要です。";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "グローバルイルミネーション (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "許容値";
postprocess.ssgi.experimental = "実験的！";
postprocess.ssgi.warning = "SSGIにはPBRシェーディングモードが必要です。";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "アンビエントオクルージョン";
// How far the effect spreads
postprocess.ssao.radius = "サイズ";
// How strong the effect is
postprocess.ssao.factor = "強さ";
// Adjustment to fix artefacts
postprocess.ssao.bias = "曲率のバイアス";
postprocess.ssao.bias.help = "エフェクトの感度はサーフェスの曲率によって変わります。";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "被写界深度";
// The blur factor behind the focused point
postprocess.dof.blurFar = "背景のぼかし";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "前景のぼかし";
postprocess.dof.focusTip = "オブジェクトをタップすると、焦点を変更できます。";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "ブルーム";
// Intensity of the effect
postprocess.bloom.intensity = "強度";
// How far the effect spreads
postprocess.bloom.radius = "半径";
postprocess.bloom.radius.help = "ブルームの範囲。";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "しきい値";
postprocess.bloom.threshold.help = "ピクセルがブルームを拡散しているかどうかを決定するための輝度のしきい値。";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "トーンマッピング";
postprocess.tone.exposure = "露出";
postprocess.tone.contrast = "コントラスト";
postprocess.tone.saturation = "彩度";
// No tonemapping operator is used
postprocess.tone.mapping.none = "なし";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "ニュートラル";
// Color curves
postprocess.curve = "カラーグレーディング";
// Curve for pixel luminance
postprocess.curve.luminance = "メイン";
postprocess.curve.red = "レッド";
postprocess.curve.green = "グリーン";
postprocess.curve.blue = "ブルー";
postprocess.curve.reset = "リセット";
// Reset color grading curves
postprocess.curve.resetAll = "すべてをリセット";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "色収差";
postprocess.chromatic.factor = "強さ";
// Darking on the edges
postprocess.vignette = "ビネット";
// How far the effect spreads
postprocess.vignette.size = "サイズ";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "硬さ";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "シャープ";
postprocess.sharpness.factor = "強さ";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "グレイン";
postprocess.grain.factor = "強さ";
// Accentuate the edges of the model
postprocess.curvature = "曲率";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "キャビティ";
// Color/Strength of convex curvature
postprocess.curvature.bump = "バンプ";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "ピクセルアート";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "フレームのサンプリングを許可";
// Simulate scanline rendering (horizonal line)
postprocess.scanline = "スキャンライン";
postprocess.scanline.factor = "要素";
// Spacing between lines
postprocess.scanline.spacing = "間隔";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "プリミティブ";
primitive.box = "ボックス";
primitive.sphereCube = "球";
primitive.sphereUV = "UV球";
primitive.icosahedron = "二十面体";
primitive.cylinder = "円柱";
primitive.cone = "円錐";
primitive.torus = "トーラス";
primitive.lathe = "レイズ";
primitive.tube = "チューブ";
primitive.plane = "平面";
primitive.triplanar = "Triplanar";
primitive.faceXYZ = "面 XYZ";
primitive.faceXYZ.help = "UV展開されたベースメッシュの提供元: https://texturing.xyz/";
primitive.needValidate = "スカルプトするにはプリミティブを検証する必要があります。";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "編集";
primitive.edit.help = "ビューポイントで3D編集を可能にします。

プリミティブを変更しないでGizmoまたはTransformツールと使用したい場合は、この機能を無効にできます。";

// Primitive configuration
primitive.mainConfig = "パラメータ";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "トポロジー";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "ジオメトリ";

// Validating the primitive (then it can be sculpted)
primitive.validate = "検証";
// Maximum number of faces of the primitives
primitive.maxFaces = "面の最大数";
primitive.maxFaces.help = "プリミティブが所有できる面の最大数。

この上限はプリミティブが検証されていない間のみ有効です。検証後、その制限は無くなります。";
// Synonym: Flat subdivision
primitive.linear = "線分割";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "ポスト分割";

// Radius (of a sphere, torus, etc)
primitive.radius = "半径";
// Size (of cube x dimension)
primitive.size = "サイズ";
primitive.sizeX = "サイズ X";
primitive.sizeY = "サイズ Y";
primitive.sizeZ = "サイズ Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "除算";
primitive.divisionX = "除算 X";
primitive.divisionY = "除算 Y";
primitive.divisionZ = "除算 Z";
// Angle of torus, etc
primitive.angleX = "角度 X";
primitive.angleY = "角度 Y";
primitive.angleZ = "角度 Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "一定の密度";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "球上のプロジェクト";
primitive.projectOnSphere.help = "完全な球形にポイントをスナップします。";

// triplanar
primitive.triplanar.title = "Triplanar";
primitive.triplanar.title.help = "Triplanarとは、3つの平面からのマスクの情報を使用して、ボクセルのグリッドを満たし、多角化します。

徐算、またはサイズスライダーを使って操作する場合、ペイント情報はリセットされます (スムーズはそのままです)。

対称は期待通りに機能しない可能性があるので、無効にしておくことをお勧めします。

“マスク”パネルから“トポロジー接続”のオプションを使用すると、他の平面に影響を与える平面をペイントできます。";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanarSameSize = "同じサイズ (立方体)";
primitive.triplanarPolish = "スムーズ";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanarResetMask = "マスクをリセット";
// One side of a cube (the back plane)
primitive.isolate.back = "戻る";
// One side of a cube (the right plane)
primitive.isolate.right = "右";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "下";
// Plane
primitive.planeSameSize = "同じサイズ (正方形)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "ディスク";
// Box
primitive.boxRegular = "同じサイズ (立方体)";
// Distance to the snapping point
primitive.tubeSnapOffset = "スナップのオフセット";
primitive.tubeSnapOffset.help = "値 1.0 はチューブの半径に等しいです。";
// Radius of the tube (starting end-point of the tube)
primitive.tubeThicknessStart = "半径の始点";
// Radius of the tube (ending end-point of the tube)
primitive.tubeThicknessEnd = "半径の終点";
primitive.tubeTwist = "ツイスト";
primitive.tubeTwistRotate = "回転";
primitive.tubeTwistRadius = "大きさ";
primitive.tubeTwistOffset = "オフセット";
primitive.tubeSnap = "スナップ";
primitive.torusRadiusOuter = "外周半径";
primitive.torusRadiusInner = "内径";
primitive.torusAngle = "アングル";
primitive.torusAngleOffset = "角度のオフセット";
primitive.cylinderHeight = "高さ";
primitive.coneRadius = "半径";
primitive.coneHeight = "高さ";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "穴";
// Make a hole in the primtive to make it hollow
primitive.hasHole = "穴があります";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radiusSync = "同じ半径";
primitive.radiusStart = "半径の始点";
primitive.radiusEnd = "半径の終点";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "読み込む...";

scene.title = "シーン";
scene.title.help = "可視/選択ボタンを使用中、指で押さえたままドラッグすると、他のオブジェクトを簡単に選択できます。

また、可視/選択ボタンを長押しすると、子に影響を与えることもできます。";
// The view will focus on the item when we click on it
scene.focus = "アイテムにフォーカス";
// Icon size in pixel (min/max)
scene.iconSize = "";
// Min size of icon
scene.iconSize.min = "最小";
// Max size of icon
scene.iconSize.max = "最大";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "";
scene.showHierarchy.help = "";
scene.showHierarchyNomadPivot = "";
scene.showHierarchyNomadPivot.help = "";
// The view will focus on the item when we click on it
scene.syncVisible = "";
scene.syncVisible.help = "";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "結合";
// Group the selected object with a new created Empty Node as a parent
scene.group = "グループ";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "ミラー";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "曲線";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "配列";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "放射状";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "";
scene.repeaters.help = "";
// singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "";
// Validate button
scene.validateGroup = "検証";
// Keep instances in the scene
scene.validateGroup.keepInstances = "";
// If we should join children
scene.validateGroup.joinChildren = "子を結合";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "ボクセル結合";
scene.voxelResolution = "解像度";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "減算: オブジェクトを隠す (目のアイコン)";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "交差部分: すべてのオブジェクトは非表示です";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "オブジェクトが選択されていません。オブジェクトを最低1つ選択してください。";
// Need to select one object only
scene.noneButNeedOne = "オブジェクトが選択されていません。オブジェクトを1つ選択してください。";
// Need to select one object only
scene.onlyOneObject = "複数のオブジェクトが選択されています。1つだけ選択してください。";

// General scene display settings
settings.display.title = "表示設定";
// Wireframe (show triangles and quad edges)
settings.wireframe = "ワイヤーフレーム";
// Display UV
settings.debugUV = "UVのデバッグ";
settings.debugUV.help = "このオプションはモデルにUVがある場合のみ適用されます。

背景にUVワイヤーフレームを表示します。

また、モデルに色のついたチェッカーボードのテクスチャも表示します。";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "両面";
settings.twoSided.help = "面は両側から見えます。";
// If we colorize the inverted side of faces
settings.backface.color = "背面のカラー";
// Color of the inverted side of faces
settings.backface.colored = "色つきの背面";
// Outline (contour highlight around the selected object)
settings.outline = "アウトライン";
// Outline (contour highlight around the selected object)
settings.outline.help = "選択中のオブジェクトはアウトライン化されます。";
settings.outline.thickness = "太さ";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "方向キューブ";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "下";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "左";
// Stats (information logs about the scene displayed on screen)
settings.stats = "統計情報";
settings.stats.right = "右";
settings.stats.all = "シーン全体を表示";
// Grid
settings.grid = "グリッド";
// Cursor
settings.cursor.whileSculpting = "スカルプト中、円を表示";
// A small indicator dot
settings.cursor.showDot = "小さなドットを表示";
settings.cursor.showDot.help = "ドットは、カメラの回転軸のポイントとして、またはスカルプト中に表示されます。";
settings.cursor.showRope = "手ぶれ補正ロープを表示";
// Highlight (the object glows when we select it)
settings.highlight.selection = "選択部分をハイライト";
// Highlight settings
settings.highlight = "ハイライト";
settings.highlight.duration = "継続時間";
// Mesh that are not selected will be dark
settings.darkenUnselected = "未選択のオブジェクトを暗く";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "スムーズシェーディング";
// Experimental feature
settings.partialDraw = "部分的な描画";
settings.partialDraw.help = "実験的機能！

複雑にポリメッシュされたパーツの比較的小さな部分をスカルプトする場合、使用できます。

スカルプトの操作をスムーズにしますが、ワイヤーフレームを有効にすることは避けてください！

ブラシストロークを使用中、目に見えるアーティファクトが追加される可能性があります。";
settings.partialDraw.warning = "目に見えるアーティファクトが邪魔な場合は、このオプションをオフにすることをお忘れなく！";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "ペイントを表示";
// Display the light icons in the viewport
settings.lightIcon = "ライトのアイコン";
// Display the camera icons in the viewport
settings.cameraIcon = "カメラのアイコン";
// Show icon on the canvas
settings.icon = "アイコン";
// Show icons on the canvas
settings.icons = "アイコン";
// Tooltip
settings.icons.help = "アイコンを直接選択して編集できるようにキャンバスにアイコンを表示します。";
// Hole filling settings
settings.hole = "穴埋め";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "非多様体を埋める";
settings.hole.nonManifold.help = "非多様体の穴を埋めます。
このオプションは設定で保存されません。";
// Maximum number of vertices (points)
settings.multires.maxVertices = "最大頂点数";
settings.multires.maxVertices.help = "Nomadは分割の前にメモリの確認を行いません。数が多すぎると簡単にクラッシュにつながる可能性があります。";
settings.multires.lowResVertices = "低い解像度のしきい値";
settings.multires.lowResVertices.help = "カメラを動かす際は、メッシュの低い方の解像を表示できます。

メッシュの解像度を高くして表示したい場合は、この値を上げてください。";

// The main rendering mode
shading = "シェーディング";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "ライトあり (PBR)";
shading.pbr.help = "このモードではライト (シャドウを含む) を、HDR環境と一緒に追加できます。

また、メタリックと粗さをペイントすることもできます。こうすることで、マテリアルの見た目をより詳細にコントロールできます。";
// Fast rendering mode for sculpting purpose (do not translate)
shading.matcap = "MatCap";
shading.matcap.help = "MatCapとは、MATerial CAPture（マテリアルキャプチャ）の別名で、ライティングとマテリアル（材質）の2つの情報を1つのイメージに反映することです。";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "ライトなし";
shading.unlit.help = "無地のカラーのシェーディングモード。ライティングなし。";
// Helper rendering mode that display a (do not translate)
shading.id = "ID";
shading.id.help = "ランダムにカラーが割り当てられている各オブジェクトでライトのないレンダリングモード。

シーンに多くのオブジェクトがある場合、最も便利です。";
// Randomize colors
shading.id.randomize = "IDをランダム化";
shading.textures = "テクスチャを使用";
shading.textures.help = "現在、Nomad内でテクスチャの作成および編集はできません。

しかし、テクスチャのあるファイルをNomadに読み込むと、動作します。

-- 対応テクスチャ --
不透明度: ライトあり、MatCap、ライトなし
一般: ライトあり、MatCap
カラー: ライトあり、ライトなし
エミッシブ: ライトあり
粗さ: ライトあり
メタリック: ライトあり";
// Lights
shading.lights = "ライト";
shading.lights.addLight = "ライトを追加";
shading.lights.warning = "ライトにはPBRシェーディングモードが必要です。";
// Environment based lighting (synonym: HDRI)
shading.environment = "環境";
shading.environment.import = "HDRを読み込む";
shading.environment.exposure = "露出";
shading.environment.backgroundBlur = "ぼかし (背景)";
shading.environment.rotation = "回転";
shading.environment.rotation.help = "指3本でビューポートを横方向にドラッグすると、環境を回転できます。";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "カメラに固定";
shading.environment.attachedToCamera.help = "環境をカメラに固定します。

こうすることで、ライティングに一貫性ができ、スカルプトに便利になります。";
shading.matcap.rotation = "回転";
shading.matcap.rotation.help = "指3本でビューポートを横方向にドラッグすると、MatCapを回転できます。";
shading.matcap.global = "グローバルMatCapを使用";
shading.matcap.global.help = "この特定のメッシュに異なるMatCapを使用するには、このオプションをチェックしないでください。";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible.short = "マスク";
shortcut.maskVisible.long = "マスク";
// bottom shortcut buttons (should be SHORT)
shortcut.solo.short = "ソロ";
shortcut.solo.long = "ソロ";
// bottom shortcut buttons (should be SHORT)
shortcut.voxelRemesh.short = "ボクセル";
shortcut.voxelRemesh.long = "ボクセルのリメッシュ";
// bottom shortcut buttons (should be SHORT)
shortcut.wireframe.short = "ワイヤー";
shortcut.wireframe.long = "ワイヤーフレーム";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraReset.short = "リセット";
shortcut.cameraReset.long = "カメラのリセット";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraSnap.short = "スナップ";
shortcut.cameraSnap.long = "カメラのスナップ";
// bottom shortcut buttons (should be SHORT)
shortcut.lockSelection.short = "ロック";
shortcut.lockSelection.long = "選択部分をロック";
shortcut.lockSelection.long.help = "有効な場合、メッシュをタップしても選択部分を変更できません。";
// bottom shortcut buttons (should be SHORT)
shortcut.perspective.short = "遠近";
shortcut.perspective.long = "遠近法";
// bottom shortcut buttons (should be SHORT)
shortcut.grid.short = "グリッド";
shortcut.grid.long = "グリッド";
// bottom shortcut buttons (should be SHORT)
shortcut.uv.short = "UV";
shortcut.uv.long = "UV";

// Memory taken by the scene
stat.ramScene = "シーン";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Vram シーン";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "Vram レンダー";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "Vram テクスチャ";
// Memory taken by the undo/redo history
stat.ramHistory = "履歴";
// Memory taken by other stuffs
stat.ramOther = "その他";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "使用メモリ";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "空きメモリ";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "使用中: $0 MB";
stat.free = "空き: $0 MB";
stat.faces = "面";
stat.triangles = "三角形";
stat.vertices = "頂点";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "四角形";
stat.sceneFaces = "シーンの面";
stat.sceneVertices = "シーンの頂点";

// Brush stroke
stroke = "ストローク";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "ワールドスペースの半径";
// The settings is shared among every tools
stroke.useWorldRadius.help = "この設定はすべてのツールで共有されます。";
// Share the radius value among every tools.
stroke.useShareRadius = "半径を共有";
stroke.useShareRadius.help = "すべてのツールで半径の値を共有します。";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.minSpacing = "ストロークの間隔";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.minSpacing.adjustIntensity = "間隔の強度を調整";
stroke.minSpacingAdjustIntensity.help = "ブラシの強度を調整して、ストロークの間隔に応じて、一貫したデフォーメーションを実行します。";
stroke.minSpacing.help = "ストロークとストロークの間隔、ツールの半径に対して相対的。

値が低いとストロークはスムーズになりますが、パフォーマンスは低下します。";
// Brush stroke smoothing
stroke.lazySmooth = "ストロークのスムージング";
stroke.lazySmooth.help = "ストロークをよりスムーズにするために複数のポインターの位置を平均します。

値が高いほど、ストロークにポインタとのラグが生じますが、最終的には追いつきます。";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "手ぶれ補正ロープ";
stroke.lazyRadius.help = "ストロークが一定の距離でポインターの位置を追いかけます。

滑らかな線を引くのに使用できます。";
// It is not a per-tool settings
stroke.globalSettings = "これはグローバル設定です";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "スナップの半径";
stroke.snapRadius.help = "ポインタが最後に記録したストロークの近くにある場合、ストロークをスナップします。

頻繁に一時停止しながら、長い連続した線を描画したい場合、便利です。";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "ストロークのオフセット";
stroke.sculptOffset.help = "ストロークに一定のオフセットを適用します。

このオプションは、指でストロークをカバーすることがないので、小さな画面で指を使う場合に便利です。";
stroke.accumulate = "ストロークを累積";
stroke.accumulate.help = "このオプションが有効な場合、ストロークごとに追加、または削除できる上限はありません。";
// The tool can use DynTopo
stroke.useDynamicTopology = "ダイナミックトポロジーを許可";
// Only sculpt the part that are linked topologically
stroke.connectedTopology = "トポロジー接続";
stroke.connectedTopology.help = "このオプションは選択中のサーフェスにリンクされた頂点のみをスカルプトします。

これは一般的に“移動”ツールに使用されます。例えば、別のパーツと自己交差する部分だけを移動したい場合などです。";
// Only sculpt the vertex that points toward the camera
stroke.onlyFrontFace = "正面を向いている頂点のみ";
stroke.onlyFrontFace.help = "このオプションは背面を向いている頂点は無視します。

他の側面に影響を与えないで薄いジオメトリの一部をペイントしたい場合、便利です。

スカルプトにも利用できますが、アーティファクトが発生する可能性があります。";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.onlySameSide = "同じ側面の頂点のみ";
stroke.onlySameSide.help = "デフォーメーションの反対方向を指す頂点を無視します。";
// Module the intensity of the sculpting operation by using a falloff curve
stroke.curveFalloff = "フォールオフ";
stroke.onlyLasso = "設定は投げなわツールにのみ有効です。";
// Alpha
stroke.alpha = "アルファ";
// Invert the pixel (black <-> white)
stroke.alphaInvert = "ピクセルを反転";
// Repeat the alpha image (pattern)
stroke.alphaWrap = "タイリング";
// No repeat pattern
stroke.alphaWrap.none = "なし";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alphaWrap.repeat = "繰り返す";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alphaWrap.mirror = "ミラー";
stroke.alphaProject = "方法";
// Project the alpha perpendicularly onto the surface
stroke.alphaProject.surfaceContinuous = "サーフェス";
// Project the alpha onto the surface in the direction of the camera view
stroke.alphaProject.screenFixed = "スクリーンプロジェクト";
stroke.alphaRotation = "回転";
stroke.alphaRotation.lock.help = "";
// Repeat the image
stroke.alphaTiling = "タイリング";
// Scale the image (make it bigger or smaller)
stroke.alphaScale = "サイズ調整";
stroke.alphaScale.help = "最小値では、アルファの四角はツールの円の半径内にあります。";
// Middle-point value at which no deformation occurs
stroke.alphaMidValue = "中間値";
stroke.alphaMidValue.help = "デフォーメーションを起こさない中間値。

(中間値 = 0)
- ブラック: ディスプレイスメントなし
- ホワイト: 正のディスプレイスメント

(中間値 = 0.5)
- ブラック: 負のディスプレイスメント
- ホワイト: 正のディスプレイスメント

(中間値 = 1)
- ブラック: 負のディスプレイスメント
- ホワイト: ディスプレイスメントなし";
// Stroke type
stroke.strokeType = "ストロークのタイプ";
// Sculpt and paint along the brush stroke at regular spacing
stroke.strokeTypeDot = "ドット";
// Sculpt continuously
stroke.strokeTypeDrag = "ドラッグ";
// Lock a region and move it around
stroke.strokeTypeGrab = "グラブ";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.strokeTypeGrabRadius = "グラブ - 動的な半径";
// Lock a region and sculpt it by changing the tool intensity
stroke.strokeTypeGrabIntensity = "グラブ - 動的な強度";

// Symmetry
symmetry = "対称";
symmetry.enable = "オン";
// Display a warning (the feature is only available for mesh object)
symmetry.primitiveWarning = "ブラシのシンメトリーは検証されたプリミティブにのみ利用できます。但し、Triplanarは例外です。";
symmetry.plane.title = "平面";
symmetry.toolIgnore = "現在使用中のツールは対称を無視します。";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "放射状";
symmetry.radialX = "ラジアル X";
symmetry.radialY = "ラジアル Y";
symmetry.radialZ = "ラジアル Z";
// Synonym: Offset
symmetry.offset.title = "オフセット";
symmetry.offsetX = "オフセット X";
symmetry.offsetY = "オフセット Y";
symmetry.offsetZ = "オフセット Z";
// Number of clones
symmetry.count.title = "数";
symmetry.countX = "数 X";
symmetry.countY = "数 Y";
symmetry.countZ = "数 Z";
// method
symmetry.method = "方法:";
symmetry.method.help = "-- ローカル
変換ツール (GizmoやTransformなど) を使用中は、対称面はメッシュに沿って移動します。

-- ワールド
対称面は固定され、移動しません。";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.methodWorld = "ワールド";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.methodLocal = "ローカル";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "オブジェクトを反転";
// Mirror the mesh
symmetry.mirror = "ミラーリング";
symmetry.mirror.help = "トポロジーに影響を与えないで対称を再度適用します。

放射状の対称は無視されます。

トポロジーが対称でないと認識されたため残せない場合は、ミラーリングを強制実行するオプションが提示されます。";
symmetry.mirrorLeftToRight = "左から右";
symmetry.mirrorRightToLeft = "右から左";
symmetry.mirrorFail = "対称を適用できませんでした。

メッシュをミラーリングすることで対称を強制実行しますか？";
symmetry.mirrorUseMasking = "マスクの部分を保護";
symmetry.mirrorUseMasking.help = "マスク部分をそのまま残します。

このオプションは非対称のトポロジー (または、一対の目のような、繋がっていないサーフェス) では無視されます。";
// Reset the symmetry plane position
symmetry.reset = "リセット";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "オブジェクトの中央";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "ワールドの中央";
// Reset the symmetry plane orientation
symmetry.reset.direction = "方向";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "線を表示";
// Display the symmetry plane in 3d
symmetry.showPlane = "平面を表示";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Gizmoで編集";
symmetry.edit.warning = "対称の編集は実験的です。";
symmetry.edit.help = "自由に面対称を設定できます。

この機能はまだ実験段階ですので、使用しないことをお勧めします。";

// Ideally <10 chars
tool.dynTopo = "DynTopo";
// Ideally <10 chars (Symmetry)
tool.symmetry = "対称";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "ミラー";
// Ideally <10 chars
tool.clay = "粘土";
// Ideally <10 chars (Subtract)
tool.clay.sub = "減算";
// Ideally <10 chars
tool.brush = "ブラシ";
// Ideally <10 chars
tool.move = "移動";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "標準";
// Ideally <10 chars
tool.drag = "ドラッグ";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "スムーズ";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "リラックス";
// Ideally <10 chars (Paint mask)
tool.mask = "マスク";
// Ideally <10 chars
tool.mask.unmask = "マスク解除";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "SelMask";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "ぼかし";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "フラット化";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "埋める";
// Ideally <10 chars (Layer brush)
tool.layer = "レイヤー";
// Ideally <10 chars
tool.crease = "クリース";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "トリム";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "分割";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "プロジェクト";
// Ideally <10 chars
tool.inflate = "膨張";
// Ideally <10 chars
tool.pinch = "ピンチ";
// Ideally <10 chars
tool.nudge = "ナッジ";
// Ideally <10 chars
tool.stamp = "スタンプ";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "DelLayer";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.select = "選択";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "Gizmo";
// Ideally <10 chars
tool.gizmo.editPivot = "回転軸";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "スナップ";
// Ideally <10 chars (Snap translation)
tool.gizmo.moveSnap = "スナップ";
// Ideally <10 chars (Local/Relative space)
tool.gizmo.local = "ローカル";
// Ideally <10 chars (World/Absolute space)
tool.gizmo.world = "ワールド";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "変形";
// Ideally <10 chars (Translate the object)
tool.transform.move = "移動";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "回転";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "比率";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "スナップ";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "計測";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "表示";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "レイズ";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "チューブ";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "挿入";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "反転";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "表示";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "投げ縄";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "曲線";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "多角形";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "パス";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "長方形";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "楕円形";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "線";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "閉じています";

// Popup when editing the vertical sliders on the left
tool.slider.radius = "半径 $0";
// Popup when editing the vertical sliders on the left
tool.slider.intensity = "強度 $0 %";

tool.settings = "設定";
tool.settings.none = "このツールには特定の設定がありません。";

// Flatten distance offset
tool.clay.flattenOffset = "フラット化のオフセット";
tool.crease.pinchFactor = "ピンチの強度";

tool.layer.removeInfluence = "レイヤーのデータを使用";
tool.layer.removeInfluence.help = "このオプションはレイヤーが選択されている場合のみ有効です。

レイヤーのデータを使用して、ストローク上のディスプレイスメントを制限します。";
tool.layer.noLayerSelected = "このオプションはレイヤーが選択されている場合のみ利用できます";

tool.flatten.warning = "これらのオプションは実験的で、今後削除される可能性があります！";
tool.flatten.planeLockOrigin = "平面の原点をロック";
tool.flatten.planeLockNormal = "平面の方向をロック";
tool.flatten.planeAverageOrigin = "平面の原点を平均する";
tool.flatten.planeAverageNormal = "平面の方向を平均";
tool.flatten.planeOffset = "平面のオフセット";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "";
tool.syncInstance.message = "";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "ボーダーの頂点を接着";

tool.paint = "ペイント";
// Erase the painting
tool.paint.erase = "消しゴム";
// Only paint the part of the mesh above a certain height
tool.paint.depthFilter = "深度のフィルタリング";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "レイヤーのフィルタリング";
tool.paint.layerFilter.help = "レイヤーのすでにペイントされている部分をペイントし直したい場合のみ、このオプションを使用してください。";

// Clear the painted mask
tool.mask.clear = "消去";
// Invert the painted mask
tool.mask.invert = "反転";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "接続部分を反転";
// Blur the painted mask
tool.mask.blur = "ブラー";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "シャープ";
// The thickness of the extracted mesh (from the painted mask)
tool.mask.thickness = "シェルの厚さ";
// Smooth the border of the extracted mesh (from the painted mask)
tool.mask.polish = "ボーダーのスムージング";
// Extract a new mesh from the painteed mask and carve/emboss the base mesh
tool.mask.engraveEmboss = "浮き出し / 浮き彫り";
// Extract a new mesh from the painted mask
tool.mask.extract = "取り出す";
// Extract two new mesh from the painted mask and from the unmasked area
tool.mask.split = "分割";
// How should we close the topology of the extracted object
tool.mask.closeMask = "閉じるアクション (マスクあり):";
// How should we close the topology of the extracted object
tool.mask.closeUnmask = "閉じるアクション (マスクなし):";
// How should we close the topology of the extracted object
tool.mask.closeAction = "閉じるアクション:";
// Do not close the mesh (leave it open)
tool.mask.closeActionNone = "なし";
// Close the mesh with a hole-filling algorithm
tool.mask.closeActionFill = "埋める";
// Close the mesh by adding a thickness on the surface
tool.mask.closeActionShell = "シェル";
// Close the mesh by using the layer data as a difference thickness
tool.mask.closeActionLayer = "レイヤー";
tool.mask.closeAction.help = "-- なし
単純に部分を取り出し、取り出した部分を開けたままにします。

-- 埋める
穴を埋めて、スムーズにします。
平らな表面にはこのオプションを使用しないでください。

-- シェル
厚さの値を使って、取り出したシェイプを閉じます。

-- レイヤー
レイヤーの差を取り出します (レイヤーのサブメニューのみ)。";

// Transform/Matrix
tool.matrix = "マトリクス";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.apply = "ターゲット";
// Automatic
tool.matrix.apply.auto = "自動";
// Transform the object alone (the children stands still)
tool.matrix.apply.object = "オブジェクト";
// Auto apply the transform on the vertices
tool.matrix.apply.vertex = "頂点";
// Transform the object and its children
tool.matrix.apply.group = "グループ";
tool.matrix.apply.help = "-- 自動
デフォルトで、このオプションは“グループ”オプションと似た動作をします。
メッシュにマスキングされている場合、またはGizmo対称が有効な場合、 “頂点”と同じ動作をします。

-- 頂点
頂点で変換を適用します。未検証のプリミティブでは動作しません。
インスタンスも同様に影響を受けます。

-- オブジェクト
オブジェクトのみを移動します。対称とマスクは無視されます。
編集済みのノードのみが移動し、サブノードはそのまま残ります。

-- グループ
ノードを移動し、対称とマスクは無視されます。階層の残りも同様に変換されます。";
// Operation on the mesh
tool.matrix.action = "操作";
tool.matrix.action.help = "-- 原点を移動
メッシュをワールドの原点に移動します。

-- リセット
メッシュ変換を初期の状況にリセットします。

-- ベイク
マトリクスを頂点に適用して、マトリクスをリセットします。視覚的には、何も変わらないはずです。";
tool.matrix.translation = "平行移動";
tool.matrix.rotation = "回転";
tool.matrix.scale = "比率";
// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "シアー";
tool.matrix.uniformScale = "比率を均一化";
tool.matrix.uniformScale.help = "Nomadは非均等のサイズ調整をオブジェクトの変換としてサポートしませんので、頂点の変換として適用されます。";
tool.matrix.moveToOrigin = "原点を移動";
tool.matrix.resetTransform = "リセット";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "ベイク";

tool.transform.tip = "";

// Size of the gizmo
tool.gizmo.size = "ウィジェットのサイズ";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "数値で入力";
tool.gizmo.allowInput.help = "Gizmoウィジェットの1つをタップすると、数値で入力できます";
// Angle threshold
tool.gizmo.linearRollThreshold = "タンジェント回転のしきい値";
tool.gizmo.linearRollThreshold.help = "線形または円形どちらかの回転方法を選択するための角度のしきい値。

このしきい値より上の値は円形の回転を使用します。

線形の回転 (タンジェントの方向) を優先したい場合は、単純にこの値を90°に設定してください。";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "操作時に隠す";
tool.gizmo.tap = "タップを1回するとカスタム回転軸が移動します。";
tool.gizmo.tap.help = "このオプションはカスタム回転軸モードでのみ有効です (“自動”が無効の場合)。

-- なし
メッシュをタップしても何も起きません。

-- 最初の交点
最初の交点でGizmoを移動します。

-- 中間点
最初の2つの交点を平均した場所でGizmoを移動します。";
tool.gizmo.tapNone = "なし";
tool.gizmo.tapFirstHit = "最初の交点";
tool.gizmo.tapMiddleStab = "中間点";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "固定";

// Fill the object's hole
tool.hole = "穴埋め";
tool.hole.fillHoles = "穴を埋める";
// synonym: Alternative method
tool.hole.bridges = "画面空間のブーリアン";
tool.hole.bridges.help = "このオプションを有効にすると、体積に穴を開けられます。
カットしたスロープも、カットしている形状によりピッタリと追跡します。";
tool.hole.threshold = "しきい値 イプシロン";
tool.hole.threshold.help = "この値を調整することで穴埋めのアルゴリズムに役立つ可能性があります。";
tool.hole.smoothing = "穴のスムージング";

tool.smudge.quality = "クオリティ";
tool.smudge.quality.help = "プロジェクトされたピクセルの解像度を変更します。値が低いほどストロークが速いことを意味します。";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "シェイプ";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "スクエア";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "中央揃え";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "円";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "中央揃え";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "ステップで回転";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "黄金比を表示";

// Topology
topology = "トポロジー";
// Synynom: detail value, density
topology.dynamic.detail = "ディテール";
// See glossary
topology.multires = "マルチレゾリューション";
topology.multires.help = "メッシュの解像度を複数残します。

低い方の解像度で変更を加えた場合、高い方の解像度のディテールは戻した時に再度投影されます。

レイヤーはそれぞれの解像度で利用できます。";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "反転";
topology.multires.reverse.confirm = "ベースの分割を作成できませんでした。

現在のトポロジーはおそらく分割の結果ではありません。";
topology.multires.subdivide = "分割";
topology.multires.subdivide.confirm = "メッシュに頂点が $0M できます。よろしいですか？";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "分割の上限を超えました。$0 をご覧ください";
topology.multires.deleteLower = "低い方を削除";
topology.multires.deleteHigher = "高い方を削除";
topology.multires.keepTriangles = "三角形を残す";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "";
// Synonym: Flat subdivision
topology.multires.linear = "線分割";
topology.multires.linear.help = "スムージングを適用しないでメッシュを単純に分割します。";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "ボクセルをリメッシュ";
topology.voxel.help = "グリッドでメッシュをサンプリングすることでリメッシュします。

オブジェクトが閉じていない (水密でない) 場合、穴埋めアルゴリズムが最初に適用されます。

レイヤーはリメッシュの後、再度プロジェクトされますが、クオリティは下がります。";
topology.voxel.resolution = "解像度";
topology.voxel.remesh = "リメッシュ";
topology.voxel.sharp = "シャープなエッジを残す";
topology.voxel.sharp.help = "このオプションは単純なプリミティブのブーリアンの操作で特に便利です。

端でスナップされたポイントが原因でエリアの一部に歪みが発生します。";
topology.voxel.subLevel = "マルチレゾリューションを構築";
topology.voxel.subLevel.help = "ボクセルのリメッシュの出力からマルチレゾリューションの階層を再構築できます。

また、これは高速で実行でき、メモリの使用も少なくすみます（特にボクセルのディテールの値が高い場合)。
しかし、ボクセルのディテールの値が低く、多くのマルチレゾリューションのレベルがある場合、ディテールを喪失します。";
// Dynamic topology (DynTopo)
topology.surface.remesh = "リメッシュ";
topology.surface.detail = "ディテール";
topology.surface.detail.help = "ボクセルのリメッシュとは異なり、サーフェスのリメッシュではメッシュを閉じる必要がありません。

また、マスクをサポートするので、メッシュ部分をトポロジーの変更から保護できます。

レイヤーは正しくアップデートされます。";
topology.surface.method = "方法";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "一意化";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "分割";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "デシメーション";
topology.surface.method.help = "ダイナミックトポロジーの動作:
- 一意化: ディテールの追加と削除
- 分割: ディテールを追加します
- デシメーション: ディテールを削除します";
topology.surface.useMasking = "マスクの部分を保護";
topology.surface.useMasking.help = "マスクの部分はトポロジーが変更されることから保護します。";
topology.surface.extrapolate = "頂点の外挿";
// DynTopo
topology.dynamic = "ダイナミックトポロジー";
topology.dynamic.activate = "有効";
topology.dynamic.activate.help = "ダイナミックトポロジーを使うと、スカルプトツールはメッシュをローカルにリアルタイムで分割したり、単純化したりできます。

この機能はパフォーマンスに顕著な影響を与えます。

レイヤーは正しくアップデートされます。";
topology.dynamic.method = "ディテールの基となるもの…";
topology.dynamic.method.zoom = "拡大/縮小";
topology.dynamic.method.radius = "半径";
topology.dynamic.method.constant = "一定";
topology.dynamic.method.help = "-- ズーム
ディテールのレベルはサーフェスからどれくらい離れているかによります。

-- 半径
ツールの半径はディテールの量を定義します。

-- 一定
ディテールが固定され、ディテールの値はボクセルスライダーとも共有されます。";
topology.dynamic.quality = "優先する…";
topology.dynamic.quality.help = "“クオリティ”を選択した場合、2つの主な違いは:
- スカルプト操作の前に微調整が適用され、非常に小さいディテールをペイントまたはスカルプトする際に、補完するアーティファクトが少なくなります
- 微調整が増加的に適用されません。非常に小さいディテールをスカルプトする場合、またはすばやくストロークを実行する場合、トポロジーは常に正しく微調整されます

より良いパフォーマンスのために、また、このオプションの使用を計画している場合、“設定”パネルから“部分的な描画”のオプションを有効にすることを検討してください。";
topology.dynamic.quality.speed = "速度";
topology.dynamic.quality.quality = "クオリティ";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "半径に筆圧を使用";
topology.dynamic.usePressure.help = "筆圧をツールの半径に影響させ、ディテールのレベルに影響を与えたい場合、このオプションを使用してください。";
// Decimate
topology.decimate.title = "デシメーション";
topology.decimate.title.help = "ディテールをできるだけ多く残したままポリゴン数を減らします。

この機能は3Dプリント用に書き出したい場合、便利です。
しかし、スカルプトを続けたい場合、不規則な三角形を生成することがあるので、使用を避けることをお勧めします。 

注意：マスク部分はデシメイトされません。 ";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "デシメイト";
topology.decimateTargetFaces = "ターゲットの三角形";
topology.decimatePaintWeight = "ペイントを保持";
topology.decimatePaintWeight.help = "値が高いほどペイントの保持を試みます。

ペイントに固執しない場合は、この値を 0 に設定してください。";
topology.decimateUniform = "面を均一化";
topology.decimateUniform.help = "値が高いほど、同じようなサイズの三角形を出力します。";
topology.decimatePreserveBorders = "";
topology.decimatePreserveBorders.help = "";

// Unwrapping means compute UV (texture coordinates), it allows the object to receive on texture (wrap the texturing on the object)
topology.uv.title = "UV自動展開";
// UV Unwrapping
topology.uvAtlas = "Atlasを展開";
// The operation can be very slow
topology.uvAtlas.warning = "非常に低くすることが可能です。ターゲット <100k 頂点！";
// UV Unwrapping (BFF best left untranslated, stands for Boundary First Flattening)
topology.uvBFF = "Bffを展開";
// Handles are topological holes (synonym: genus, hole)
topology.uvBFF.warning = "メッシュにハンドルがある場合、オーバーラップを持てます！";
// Synonym: Point count? Singularity count ?
topology.uvBFFCones = "円錐の数";
topology.uvBFFCones.help = "値が高いほど、複雑なオブジェクトの歪みを軽減します。

値が高いと計算にかかる時間は長くなります。";
topology.uvDelete = "UVを削除";

// Transfer the vertex painting in the texture
topology.bake = "頂点のペイントをベイク";
topology.bake.help = "頂点のペイントをテクスチャに転送します。

頂点のカラーは処理中にリセットされます。";
topology.bakeResolution = "解像度";

// Reset key-bindings/shortcuts
binding.reset = "バインドをリセット";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.materialPicker = "マテリアルピッカー";
// Edit the tool brush size/radius
binding.editRadius = "ツールの半径";
// Edit the tool brush size/radius
binding.editIntensity = "ツールの強度";
// Snap the camera
binding.viewFront = "正面";
// Snap the camera
binding.viewLeft = "左側面図";
// Snap the camera
binding.viewTop = "上面図";
// Move/Translate the view
binding.panLeft = "左へパン (ビュー)";
// Move/Translate the view
binding.panRight = "右へパン (ビュー)";
// Move/Translate the view
binding.panForward = "前へパン (ビュー)";
// Move/Translate the view
binding.panBackward = "後へパン (ビュー)";
// Move/Translate the view
binding.panUp = "上へパン (ビュー)";
// Move/Translate the view
binding.panDown = "下へパン (ビュー)";
// Snap the view (while rotating)
binding.snapViewOnRotate = "スナップビュー (回転中)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "開く (プロジェクト)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "追加 (プロジェクト)";
// Import an external scene file (replace current scene)
binding.import.open = "開く (読み込む)";
// Import an external scene file (add it to the current scene)
binding.import.add = "追加 (読み込む)";
// Select all the objects in the scene
binding.selectAll = "すべてを選択";
// Rotate environment and the lighting
binding.rotateLighting = "ライティングを回転";

// Privacy policy
privacyPolicy.title = "プライバシーポリシー";
privacyPolicy.reject = "拒否";
// Hexanomad is the company name
privacyPolicy = "HexanomadはNomad Sculptからいかなるデータも収集しません。";

// version trial
version.buyWeb = "ウェブバージョンはデモ目的のみに利用できます";
version.buyFull = "フルバージョンにアップグレード";
version.restorePurchase = "購入を復元";

version.trialHistory = "お試し版: 取り消し/やり直しの上限は4回です";
version.trialLayer = "お試し版: メッシュごとに1 レイヤーのみ";
version.trialOneProject = "お試し版: アクティブなプロジェクトは1件のみです";
version.trialNoImport = "お試し版: 読み込み機能は使用できません";
version.trialNoExport = "お試し版: 書き出し機能は使用できません";

version.fullFeatures = "- 一括購入
- 取り消し/やり直しの上限なし
- 無制限のレイヤー
- 保存 & 読み込み
- 書き出し & 読み込み";
