// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "よろしいですか？";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "はい";
// Answer to a question (Are you sure you want to do that? [yes, no, cancel])
confirm.no = "いいえ";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "OK";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "キャンセル";
// Restart nomad
confirm.restart = "この値を変更した後、Nomadを再起動する必要があります。";

// Experimental feature
experimental = "実験的！";

status.exit = "変更が保存されていません！閉じる前に保存しますか？";
status.exit.yes = "保存";
status.exit.no = "保存しない";

// On single tap (should be short)
ontap = "タップ";

all = "すべて";
error = "エラー";

reset = "リセット";
resetOrder = "順序をリセット";

clipboard = "クリップボード";
clipboard.copy = "コピー";
clipboard.paste = "ペースト";

// memory size
bytes = "バイト";
kB = "kB";
MB = "MB";
GB = "GB";
TB = "TB";

// Noun
instance = "インスタンス";
object = "オブジェクト";

// Same value (usually for axis, e.g: x == y == z)
uniform = "均一";

sync = "同期";

// position
position.top = "上";
position.bottom = "下";
position.left = "左";
position.right = "右";
position.center = "中央揃え";
// direction
direction.up = "上";
direction.down = "下";
direction.left = "左";
direction.right = "右";
// 3D cube
cube.top = "上";
cube.bottom = "下";
cube.left = "左";
cube.right = "右";
cube.front = "正";
cube.back = "背";

// Name of an item (object, tool, etc)
item.name = "名前";
// Add a new item (object, tool, etc)
item.new = "新規";
// Rename an item (object, tool, etc)
item.rename = "名前を変更";
// Add a new item (object, tool, project, etc)
item.add = "追加";
// Update an item image with a new image (synonym: Update)
item.replace = "置換";
// Save an item (object, tool, etc)
item.save = "保存";
item.save.confirm = "保存しますか？";
// Update an item (update camera view point, etc)
item.update = "アップデート";
// Reload last save of an item (object, tool, etc)
item.lastSave = "最後の保存内容";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "最後の保存内容を読み込みますか？";
// Reset an item to its initial value (object, tool, etc)
item.reset = "リセット";
item.reset.confirm = "リセットしますか？";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "インスタンス";
// Uninstance the object, make the object real
item.uninstance = "インスタンスを解除";
// Clone an item (object, tool, etc)
item.clone = "クローン";
// Delete an item (object, tool, etc)
item.delete = "削除";
item.delete.confirm = "削除しますか？";
item.delete.confirm.yes = "はい、削除します";
// When we delete the item but the image is used somewhere
item.delete.used = "使用した画像";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "ノードに";
// Item visibility (object, layer, etc)
item.visible = "可視";
// Show an item (object, layer, etc)
item.show = "表示";
// Hide an item (object, layer, etc)
item.hide = "隠す";
// Select an item (object, layer, etc)
item.select = "選択";
// Unselect an item (object, layer, etc)
item.unselect = "選択解除";
// Merge an item with another one below (layer)
item.mergeDown = "下へ結合";
// The order of an item in a list
item.order = "順序";
// Focus on previous item
item.previous = "前へ";
// Focus on next item
item.next = "次へ";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "ロック";
// No item selected
item.none = "なし";
// Draggable, moveable
item.draggable = "移動可能";

// Search something (text entry to filter item)
search = "検索";

// Three-state toggle button (Auto, Off, On)
toggle.on = "オン";
// Three-state toggle button (Auto, Off, On)
toggle.off = "オフ";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "自動";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "サムネールがありません。ファイルを再処理中...";
loading.reprocess.cancel = "サムネイル生成をスキップしますか？";

access.title = "アクセシビリティ";
access.window = "アシスティブウィンドウ";
access.pinch = "ピンチ";
access.drag = "ドラッグ";
access.rotate = "回転";
access.roll = "ロール";

// Color of an object
material.color = "カラー";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "粗さ";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "光沢";
// Whether the material is a metal or not
material.metalness = "メタリック";
// How much light a surface will reflect
material.specular = "スペキュラ";
// Light that the surface can emit (glow)
material.emissive = "エミッシブ";
// Normal map (synonym: detail, bump)
material.normal = "標準";
// flip y coordinate
material.normal.flipY = "Yを反転";
// Ambient Occlusion (AO)
material.occlusion = "オクルージョン";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "テクスチャ";
// Textures/Image
material.texture = "テクスチャ";
// A warning indicating that the mesh has no UVs
material.warningNoUVs = "UVマップがありません！";
// Texture filtering https://en.wikipedia.org/wiki/Texture_filtering
material.texture.filter = "フィルタリング";
// Nearest Filtering (closest sample)
material.texture.nearest = "ニアレスト";
// Bilinear Filter
material.texture.linear = "リニア";
// Mipmap filtering
material.texture.mipmap = "ミップマップ";
// Triplanar mapping
material.projection = "投影";
material.projection.triplanar = "Triplanar";

// Prefer low power
about.lowPower = "省電力GPU";
// Wintab wacom API
about.wintab = "WinTabを使用";
about.wintab.help = "WinTabが有効な場合、Wacom設定でWindows Inkを無効にすることをお勧めします。

同様に、WinTabが無効な場合は、Wacom設定でWindows Inkを有効にする必要があります。";
// Wacom Multi Touch API
about.touch = "ワコムマルチタッチを使用する";
about.touch.help = "このオプションを有効にすると、ワコムタブレットで複数の指をサポートできます。";
// Prefer low power
about.fullScreen = "全画面表示";
// Minify
about.minify = "UIをMinify";
about.minify.help = "指4本でスクリーンをタップすることもできます（デバイスがサポートする場合)。";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "ターンテーブル";
// Rotation center of the turntable
about.turntable.pivot = "回転の中心";
// Keep current pivot
about.turntable.pivot.keep = "現在の状態を保持";
// Turntable pivot will be at the center of the scene
about.turntable.pivot.scene = "シーン";
// Make the entire scene turn around (speed of the animation)
about.turntable.speed = "速度";
// Speed easing (linear vs non-linaer)
about.turntable.linear = "一定速度";
// Stuffs that I used to make the app
about.credits = "クレジット";
// Link to open source projects that I used for the app
about.credits.openSource = "オープンソース";
// Only translate the &
about.credits.arts = "MatCap & HDRI";
// Change languages of the app
about.languages = "言語";
about.languages.help = "翻訳ファイルは $0 から利用できます";
// Link to the App Website
about.website = "Webサイト";
// Link to the App Forum
about.forum = "フォーラム";
// Link to the App Manual
about.manual = "手動";
// Link to the App Email
about.mail = "サポート";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";
// Link to the App Threads account
about.threads = "Threads";

// The user canceled an operation that was running
alert.aborted = "操作が中止されました！";
// Empty mesh
alert.mirror.empty = "空の出力！";
// Mesh already mirrored
alert.mirror.same = "同じ出力！";
// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "オブジェクトに穴がありません。";
// No operation occured because the mesh is already manifold
alert.manifold.already = "メッシュはすでにマニフォールドです！";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "現在のオブジェクトは不可視です！";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "トリムするものがありません！";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "トリムを中止: オブジェクトは完全にトリムされています。";
// In order to extract something, the mesh needs to have painted mask
alert.extract.none = "取り出すものがありません！";
// In order to split something, the mesh needs to have painted mask
alert.extract.split.none = "分割するものがありません！";
// List of disabled features when View Mode is selected
alert.view.disabled = "表示モードで無効になっている機能:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "プリミティブのウィジェット";
// The object needs to have two parts disconnected
alert.separate.fail = "分割できません: オブジェクトに1つのパーツしかありません！";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "リメッシュしました！";
alert.voxelRemesh.empty = "リメッシュを破棄: 結果のメッシュに面がありません。";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "無効な入力です！";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "オブジェクトは複製されます";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "オブジェクトはインスタンス化されます";
// A pivot refers the gizmo 3D position, this mode means we are moving the pivot
alert.gizmo.editPivot = "回転軸モードを編集してください。";
alert.mask.full = "マスク = 100%!";
// A pivot refers the gizmo 3D position
alert.gizmo.editObject = "オブジェクトモードを編集してください。";
// See Glossary (DynTopo)
alert.dynamic.enable = "アクティブなダイナミックトポロジー";
// See Glossary (DynTopo)
alert.dynamic.disable = "ダイナミックトポロジーを無効にする";
alert.colorPicker = "指をオブジェクトにドラッグして、カラーを選択してください。";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "変換モードを終了するには、タップしてください。";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "シンプルタップで編集対称モードを終了します。";
// Show the painted mask on the mesh
alert.mask.show = "マスクを表示";
// Hide the painted mask on the mesh
alert.mask.hide = "マスクを隠す";
// Selection refers to the objects that are currently selected
alert.selection.lock = "選択部分をロック";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "選択部分をロック解除";
// Hide the objects that are not selected
alert.selection.isolate = "選択部分を分離";
// Show the objects that are hidden
alert.selection.showAll = "すべてを表示";
// Project quick saving
alert.quickSave = "保存中…";
// Painting on the object was hidden but the user did paint the object
alert.forcePainting.fill = "“ペイントを表示”が有効で、[すべてをペイント] が使用されました。";
// Painting on the object was hidden but the user started to paint on the object
alert.forcePainting.tool = "“ペイントを表示”が有効で、オブジェクトがペイントされました。";
// See Glossary (Multiresolution)
alert.multiresLost = "マルチレゾリューションは喪失します！";
// Boolean cut mode will ignore some features
alert.booleanIgnored = "ブーリアンはマスクされたまたは隠されたエリアを無視します!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "ディテールの値が高いので、多くのメモリを必要とする可能性があります！";
// Autosave popup
alert.autoSave.auto = "自動保存... $0s後";
// The selected object doesn't have any layers
alert.needLayer = "使用中のツールはアクティブなレイヤーが必要です。";
// The user decided to hide the painting on the objects
alert.paintingHidden = "ペイントが非表示です!";
// The user decided to hide the masking on the objects
alert.maskingHidden = "マスクが非表示です！";
// The user decided to display hidden faces
alert.hideIgnored = "非表示は無視されています！";
// The selected object doesn't have any layers
alert.noPartialWireframe = "ワイヤーフレームが表示されている場合、部分的な描画は無効です。";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "スクリーンプロジェクタを使用する際、遠近法のfrustumの歪みを避けたい場合は、正投影カメラの使用を検討してください。";
// Trial version has a limited number of undo
alert.state.trial = "お試し版: 取り消しはキャンセルされました";

background = "背景";
// A flat color will be displayed in the background of the scene
background.color = "カラー";
// 2 color with rotation
background.gradient = "カラーグラデーション";
// The environment (HDRI) will be displayed in the background
background.environment = "環境";
background.blur = "ブラー";
background.exposure = "露出";

// Image that the artist uses as a reference
background.reference = "参照";
// Image that the artist uses as a reference
background.imageEnable = "参照イメージ";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "オーバーレイ";
// Opposite of transparency (Alpha)
background.imageAlpha = "不透明度";
background.imageReset = "設定をリセット";
background.imageTransform = "変形";
// X screen coordinate of the image reference
background.imageX = "位置 X";
// Y screen coordinate of the image reference
background.imageY = "位置 Y";
// Rotation of the reference image
background.imageRotation = "回転";
// Scale of the reference image
background.imageScale = "比率";
// Auto adjust the reference when moving the camera
background.lock.image = "カメラロックと同期";
background.lock.image.help = "カメラがスナップキューブでロックされているとき、参照画像はカメラの動きに従います。";
// When exiting camera lock
background.lock.exit = "ロック解除時にリセット：";
background.lock.exit.none = "FOVを調整";
background.lock.exit.none.help = "画像とカメラをそのまま保持。
遠近法の場合、視野のみを調整。";
background.lock.exit.all = "すべてをリセット";
background.lock.exit.all.help = "画像とカメラの位置をリセット。";
background.lock.exit.perspective = "遠近法の場合";
background.lock.exit.perspective.help = "遠近法の場合は、画像とカメラの位置をリセットします。";

// Blend: normal
blend.normal = "標準";
// Blend: darker
blend.darker = "ダーカー";
blend.darker.darken = "暗くする";
blend.darker.multiply = "乗算";
blend.darker.linearBurn = "リニアバーン";
blend.darker.colorBurn = "カラーバーン";
// Blend: lighter
blend.lighter = "ライター";
blend.lighter.lighten = "明るくする";
blend.lighter.screen = "スクリーン";
blend.lighter.linearDodge = "リニアドッジ";
blend.lighter.colorDodge = "カラードッジ";
// Blend: contrast
blend.contrast = "コントラスト";
blend.contrast.hardLight = "ハードライト";
blend.contrast.softLight = "ソフトライト";
blend.contrast.overlay = "オーバーレイ";
blend.contrast.hardMix = "ハードミックス";
blend.contrast.linearLight = "リニアライト";
blend.contrast.vividLight = "ビビッドライト";
blend.contrast.average = "平均";
// Blend: inversion
blend.inversion = "反転";
blend.inversion.exclusion = "除外";
blend.inversion.difference = "差";
// Blend: cancelation
blend.cancelation = "キャンセル";
blend.cancelation.divide = "除算";
blend.cancelation.subtract = "減算";
// Blend: component
blend.component = "コンポーネント";
blend.component.luminosity = "輝度";

// Camera (point of view in 3D)
camera = "カメラ";
cameras = "カメラ";
camera.view = "表示";
// Copy the views
camera.updateView = "ビューポイントをアップデートしますか？";
// Add a new camera
camera.addView = "ビューを追加";
// Focus on the camera
camera.focus = "焦点";
// Add on the camera camera
camera.focusOn = "$0に焦点を当てる";
// Camera projection, Orthographic or Perspective
camera.projection = "投影";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "正投影";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "遠近法";
// camera Vertical Field of View
camera.fov = "垂直画角";
// Camera Field of View hint
camera.focal = "焦点 $0mm (35mm センサー)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "回転";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "ターンテーブル";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "トラックボール";
camera.rotation.trackball.help = "トラックボールを使うと、指2本でカメラを回すことで自由度が増します。";
// Camera interaction mode, 1st person view
camera.firstPerson = "ファーストパーソン";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "速度";
// Camera rotation sensitivity
camera.speed.rotation = "回転";
// Camera translation sensitivity
camera.speed.panning = "平行移動";
// Camera zooming sensitivity
camera.speed.zooming = "ズーム";
// Reset camera position
camera.resetView = "ビューをリセット";
// Align the view (snap to nearest 90° angle)
camera.snapView = "スナップビュー";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "カメラがスナップされています (正投影)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "正投影スナップ";
camera.snapOrthographic.help = "このオプションは画面の隅で方向キューブを使用している場合も有効です。";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "回転軸";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "オブジェクトをダブルタップ";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "背景をダブルタップ";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "切り替える";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "選択内容";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "シーン";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "ダブルタップでアップデート";
camera.doubleTapPivot.help = "オブジェクトの表面をダブルタップすると、回転軸をアップデートします。";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "エアーピボット";
camera.airPivot.help = "オブジェクトのサーフェスの外側でズームしている場合でも、新しい回転軸を使用できます。";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "カメラの使用と同時に";
camera.autoPivot.help = "カメラと動作し始めると回転軸がアップデートされます。";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "フォーカス";
camera.doubleTapFocus.help = "オブジェクトをダブルタップすると、カメラはパンし、選択したポイントにフォーカスします。";
// Disable XY panning when unzomming
camera.centerZoomOut = "倍率を下げる時、ビューを中央にする";
camera.panZoomOut.help = "このオプションを無効にした場合、ピボット位置はそのままになります。";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "複数選択";
// There is 0 nodes/items selected
context.noSelection = "選択されていません";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "プリセット";
// Quick curve x side shift
curve.shift = "シフト";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "スプライン曲線";
curve.bspline = "B-スプライン曲線";
curve.precision = "精度";
// merge or collapse 1 point into another
curve.merge = "結合";
// snap
curve.snap = "スナップ";
curve.snap.offset = "オフセット";
curve.snap.offset.help = "値 100% はチューブの半径に等しいです。";
curve.snap.surface = "サーフェス";
curve.snap.vertex = "頂点";
curve.snap.grid = "グリッド（スナップ時）";
// Regular spaced sampling
curve.uniform = "均一";
curve.uniform.help = "カーブは均等な間隔でサンプリングされ、均一な密度を保証します。

このオプションを無効にすると、カーブに新しい制御点を追加することでエッジループを少し制御できます。";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "対称的な方法で減衰を表示します。

このオプションは視覚的な手がかりのみで、減衰自体には影響しません。";
curve.radius = "半径";
curve.twist = "ツイスト";
curve.spiral = "スパイラル";
curve.spiral.twist = "ねじれ角度";
curve.spiral.scale = "比率";
curve.spiral.offset = "オフセット";
curve.spiral.angle = "角度のオフセット";
curve.pivot = "回転軸";
curve.pivot.self = "曲線";
curve.pivot.children = "子を";

// Set the desired FPS (frame per second, refresh rate)
debug.targetFps = "目標FPS";
debug.targetFps.help = "無効にすると、デフォルト値はディスプレイのリフレッシュレートと同期することを意味します。";

// Warning about UVs (using extra memory)
debug.uvPrimitive.warning = "UV (追加のメモリ) が必要でない場合、このオプションを無効にしてください。";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "UVを標準化";
debug.uvNormalize.help = "Nomadは [0-1] のタイル内のUVを標準化します。";

// Debug option, display an window with some debugging logs
debug.logs = "ログ";
// Model shortcut window
debug.shortcut = "ショートカットウィンドウ";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "ハイトマップ";
// Debug options, graphical stuffs
debug.graphics = "グラフィック";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "ストアのサムネールを作成";

// Open file explorer
file.explore = "エクスプローラー";
// Open file explorer
file.scope = "スコープ";
file.scope.internal = "内部";
file.scope.internal.help = "デフォルトの動作、モバイルと同様。
プロジェクトはメインのNomadフォルダー内にのみ保存されます。";
file.scope.external = "その場所で";
file.scope.external.help = "外部からプロジェクトをインポートする際、保存すると元のファイルが上書きされます。
外部プロジェクトには自動保存はサポートされていません。";
// Empty list: there is no projects
file.project.load = "スタートアップでプロジェクトをリロードする";
// Empty list: there is no projects
file.project.empty = "まだ保存されたプロジェクトがありません！";
// The current opened project has some unsaved changes
file.project.unsaved = "変更内容が保存されていません！";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "未保存の変更内容は喪失します！";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "最後に手動で保存した内容のプレビュー";

file.project = "プロジェクト";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "保存";
// E.g: Save "my_project"?
file.project.save.confirm = "$0を保存しますか？";
// Make a copy
file.project.saveAs = "別名で保存";
// Overwrite another project
file.project.overwrite = "上書き";
// E.g: Overwrite "my_other_project"?
file.project.overwrite.confirm = "$0を上書きしますか？";
// Open a project
file.project.open = "開く";
// E.g: Open "my_project"?
file.project.open.confirm = "$0を開きますか？";
// E.g: Clone "my_project"?
file.project.clone.confirm = "クローン$0？";
// Load another project and add/append all its data to the current scene
file.project.add = "シーンに追加";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "$0をシーンに追加しますか？";
// Reset the scene and create a new project
file.project.new = "新規";
file.project.new.confirm = "新規シーンを作成しますか？";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "$0を削除しますか？";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "$0を削除しますか？

これは現在アクティブなプロジェクトです！";

// Auto save section
file.autoSave = "自動保存";
file.autoSave.confirm = "自動保存をオフにしますか？";
file.autoSave.help = "プロジェクトを一定の間隔で別のファイルに保存します。

自動保存されたファイルの保存先:";
// Interval in minutes in which the auto save popup will appear
file.autoSave.popup = "ポップアップのタイムアウト";
// In minutes
file.autoSave.minutes = "タイマーのポップアップ";
// Delete the current autoSave data
file.autoSave.delete = "自動保存の内容を破棄";
// Open the outdated auto save
file.autoSave.open.manual = "古い手動セーブを開く";
file.autoSave.open.auto = "古い自動セーブを開く";

// color space (linear or srgb), do not translate linear/srgb if there is a doubt
file.colorSpace = "カラースペース";
file.colorSpace.help = "色が正しくないように見える場合は、このオプションを切り替えてみてください。";
file.colorSpace.linear = "リニア";
file.colorSpace.srgb = "sRGB";

// Configure imports option
file.importSettings = "オプションを読み込む";

// Load interface preference settings when opening a scene file
file.import.guiSettings = "GUI設定を残す";
file.import.guiSettings.help = "プロジェクトファイルを開く、または読み込む際、プロジェクトに埋め込まれたGUIに関連するすべての設定は読み込まれます。";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.import.obj.splitByGroup = "OBJをグループで分割";
file.import.obj.splitByGroup.help = "有効にすると、NomadはOBJグループを別々のオブジェクトに分割します。";
// Merge all the object layers at when loading a file (deleting them in the process)
file.import.mergeLayers = "レイヤーを結合";
// Ignore the textures present in the file to load
file.import.skipTextures = "テクスチャをスキップ";
// Do not fiddle with the object topology when loading the file
file.import.keepTopology = "トポロジーを残す";
file.import.keepTopology.help = "Nomadに読み込んだメッシュのトポロジーをいじらせたくない場合は、このオプションを使用してください。

こうすることで、頂点/面の並べ替え、頂点/面の複製の削除、および未使用の頂点の削除を無効にします。";

// Import file section
file.import.title = "読み込む";
file.import.title.help = "対応フォーマット:";
// The user imports a scene file that will replace the current scene
file.import.open = "開く";
file.import.open.confirm = "新しいファイルを読み込みますか？";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "シーンに追加";
file.import.add.confirm = "新しいファイルを読み込みますか？";

// Export scene file
file.export = "書き出す";

// Filter nodes that we want to export
file.select.include = "含める";
file.select.all = "すべて";
file.select.visible = "可視";
file.select.selected = "選択済み";
file.select.unselected = "選択解除";

// Export each node in a separate file
file.export.separate = "オブジェクトごとのファイル";

// Export the current selected objects instead of the entire scene
file.onlySelection = "選択中のオブジェクトのみを含める";
file.onlySelection.help = "シーン全体ではなく、選択部分のみを含めます。";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "四角形を再構築";
file.convertToQuad.help = "三角形を組み合わせて三角形から四角形を再構築します (ファイルで隣接している場合)。";
// ----------------------------------------------
// Whether we include the textures in the exported file
file.export.texture = "テクスチャ";
// Baking means transfering/converting
file.export.texture.help = "このオプションはテクスチャに頂点カラーをベイクしません。";
// ----------------------------------------------
file.export.color0 = "頂点カラー";
file.export.color1 = "PBRペイント";
file.export.color1.help = "粗さ、メタリック、およびマスクペイントを書き出します。これは他のソフトウェアに無視されます。";
// ----------------------------------------------
// Whether we include normals vector in the exported file
file.export.normal = "法線";
file.export.normal.help = "別のソフトウェアでファイルを開きたい場合は、このオプションをチェックしてください。

Nomadは法線を計算し直すので、必ずそれらを無視します。";
// ----------------------------------------------
file.export.tangent = "接線";
file.export.tangent.help = "別のソフトウェアでファイルを開きたい場合は、このオプションをチェックしてください。

モデルにノーマルマップがある場合のみ接線が使用されます。

Nomadは接線を無視し、再計算されます。";
// ----------------------------------------------
file.export.nomad.help = "Nomad Sculpt内部ファイル形式。

この形式は他のソフトウェアでは読み込めません。主に再インポート目的で使用されます。";
// ----------------------------------------------
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "レイヤー";
file.export.gltf.layer.help = "レイヤーをモーフとして書き出します。glTFに公式にサポートされているので、他のソフトウェアでも同様に動作することが期待されます。";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "レイヤーペイント";
file.export.gltf.layerPaint.help = "レイヤーペイントを書き出します。通常、他のソフトウェアには無視されます。";
// ----------------------------------------------
file.export.obj.warning = "レイヤーとその他のペイント (粗さ、メタリック、マスク) は喪失します。";
// Whether we include the vertex color in the exported file
file.export.obj.color = "頂点カラー";
file.export.obj.color.help = "これを読み取れる3Dソフトウェアもありますが、読み取れないソフトウェアもあります。";
file.export.obj.color.help.append = "頂点の後にカラーの情報を追加します。";
file.export.obj.color.help.hexa = "色をエンコードする代替方法です。マスクデータもサポートしています。";
file.export.obj.faceGroup = "フェースグループ";
file.export.obj.object = "オブジェクトを書き込む";
file.export.obj.object.help = "オブジェクトを分離した状態に保ちます。

このオプションを無効にすると、すべてが単一のエンティティとしてエクスポートされます。
Substance Painterの「メッシュID／ポリグループ」機能を使用する場合は、このオプションを無効にする必要があります。";
file.export.obj.archive = "タイプ";
file.export.obj.archive.folder = "フォルダ";
file.export.obj.archive.zip = "Zip";
file.export.obj.archive.help = "一部のアプリ（Google Drive、One Driveなど）はフォルダのインポートをサポートしていないため、代わりにZipを使用できます。";
// ----------------------------------------------
file.export.ply.warning = "レイヤーとその他のペイント (粗さ、メタリック、マスク) は喪失します。";
// ----------------------------------------------
file.export.stl.warning = "レイヤーとその他のペイント (粗さ、メタリック、マスク) は喪失します。";
// Whether we include the vertex color in the exported file
file.export.stl.color = "頂点カラー";
file.export.stl.color.help = "それを読み出せる3Dソフトウェアもありますが、すべてのソフトウェアができるとは限りません。";
// ----------------------------------------------
file.export.usd.skew = "斜めを許可";
file.export.usd.skew.help = "マトリクス変換での斜めを許可。

無効にすると、Nomadは斜めマトリクスを2つの別々のスケーリングと回転変換に分割します。";
// ----------------------------------------------
// Advanced settings
settings.advanced = "高度な機能";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "これらのオプションは設定に保存されていません。";
settings.reset.title = "設定";
settings.reset.title.help = "この操作はアプリの設定をリセットします。

いくつかのリソースは別々に保存されているので、リセットされません。リセットされないものは以下の通りです:
• プロジェクト
• キーバインド
• ツールのプリセット
• HDR 環境
• MatCap
• アルファ
• テクスチャ (ブラシ)
• 参照イメージ

プロジェクトにリンクされているもの、例えば、ライティング、ポスト処理、カメラビューなど、はすべてそのまま残ります。";

// Reset preference settings button
settings.reset = "デフォルトにリセット";
settings.reset.confirm = "環境設定をリセットしますか？";

// Render a screenshot of the scene
file.render = "レンダリング";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "インターフェースを表示";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "レンダーの比率";
file.render.renderRatio.help = "値が 1.0 の場合、Nomadが下の要求されたイメージサイズと同じ解像度でレンダーすることを意味します。

特定の解像度でレンダーできない場合 (メモリ不足でクラッシュするなど)、このオプションを使用してください。";
// Desired size of the exported screenshot
file.render.size = "最終サイズ";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "カスタム";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "スクリーン";
// width of exported screenshot
file.render.width = "幅";
// height of exported screenshot
file.render.height = "高さ";
// export screenshot of the scene
file.render.warn = "書き出しの解像度が高いです ($0x$1)！

デバイスでVRAMが不足し、クラッシュするような場合に備えて、必ずプロジェクトを保存しておいてください。";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "透明な背景";
file.render.transparent.help = "このオプションは2D製作ソフトウェアでメッシュを挿入したい場合、便利です。

現時点では、部分的なオブジェクトの透明度はサポートされていません。";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "グローバル設定を使用";
pressure.useGlobal.help = "デフォルトで、ツールは同じプレッシャー設定を共有します。

このツールに特定のプレッシャーを設定したい場合は、このオプションをチェックしないでください。";

// Pencil pressure
pressure.title = "筆圧";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "このツールはペンシルの筆圧を使用しません。";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "ストロークタイプ、“グラブ”は筆圧設定を無視します。";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "半径";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "強度";
// Average pencil pressure event to get smoother result
pressure.average = "筆圧平滑化";
pressure.average.help = "より滑らかな結果を得るために鉛筆の筆圧イベントを平均化します。";
// Limit pressure to 100%
pressure.limit = "圧力を100%に制限する";
pressure.limit.help = "これはグローバル設定です。

このオプションを使用して、スタイラスの圧力が100%を超えないようにします。";

// list of inputs allowing camera interaction
gesture.camera = "カメラ";
// list of inputs allowing sculpting interaction
gesture.sculpt = "スカルプト";
// Select object
gesture.select = "オブジェクトを選択";
// Finger/Touch input
gesture.finger = "指";
// Stylus/Pencil
gesture.stylus = "スタイラス";
// Mouse/Trackpad
gesture.mouse = "マウス";

gesture.wheel = "マウスホイール";
gesture.wheel.speed3d = "速度 (3D ズーム)";
gesture.wheel.speed2d = "速度 (2D インターフェース)";

// long press to pick the color/material under the cursor
gesture.dropper = "マテリアルの選択";
gesture.dropper.help = "キャンバスを長押しすると、カラー/マテリアルピッカーが表示されます。

現在のブラシのペイントが有効な場合にのみ動作します。";

camera.airStroke = "エアストロークを許可";
camera.airStroke.help = "初期カーソルがメッシュを外れていても、造形ストロークを開始できる。 

このオプションは、造形が有効でカメラが無効になっている入力にのみアクティブです。";

// Three fingers on screen
gesture.three.title = "3本指";
gesture.three.light = "ライティングを回転";
gesture.three.light.help = "環境、ライト、MatCapを回転できます。";
gesture.three.radius = "ツールの半径";
gesture.three.intensity = "ツールの強度";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.finger.smooth = "指は常にスムージングに使用されます";
gesture.finger.smooth.help = "このオプションは、彫刻ツールがアクティブな場合にのみ有効です。";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "未認識の筆圧を許可";
gesture.unknownPressure.help = "お使いのペンシルで筆圧が動作しない場合、または指の筆圧が必要な場合、このオプションをチェックしてください。";

// Action when we press an Android pencil button
gesture.pencilAction.android = "ペンシルのボタン";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "ペンシルのダブルタップ";
gesture.pencilAction.ios.help = "Apple Pencil 第2世代にのみ対応。";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "なし";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "追加/減算";

// Idle long press with pencil, mouse, finger, etc
gesture.longPress = "長押し";


// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "ワンタップショートカット";
gesture.mask.oneTap.help = "画面を1度タップしてマスクのショートカットを許可します。マスクボタンのショートカットを押す必要がなくなります。

以下のジェスチャを利用できます:
• 背景をタップして、マスクを反転
• マスクしたエリアをタップして、マスクをぼかす
• マスクされていないエリアをタップして、マスクをシャープにする";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.holdStroke = "ストローク";
gesture.mask.holdStroke.help = "長押しすると、マスクとSelMaskの間を切り替え、新しいストロークが始まります。

ストロークの終了時には、以前のツールが再び選択されます。";
gesture.mask.holdIdle = "ツール";
gesture.mask.holdIdle.help = "移動せずに長押ししてから離すと、マスクとSelMaskを切り替えます。";

gesture.smooth.holdSelect.help = "長押しすると、選択ツールに切り替わり、ストローク選択が続く間有効になります。";

// Shortcut customization, choose the action that the shortcut will performan (select tool, etc)
gesture.shortcut = "ショートカット";

// Shortcuts to undo/redo
gesture.history = "ショートカット履歴";
gesture.history.help = "• 取り消し: 2 本指でタップ
• やり直し: 3 本指でタップ";
gesture.history.hold = "長押し";
gesture.history.hold.help = "2 (または3) 本指で長押し (続けて)。";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "パームリジェクション";
gesture.palmRejection.confirm = "キャンバスの操作で問題に遭遇した場合は、このオプションが無効になっているか確認してください！";
gesture.palmRejection.help = "接触部分のサイズがこの値より大きい場合、入力を拒否。

すべてのデバイスで利用できるとは限りません。";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "最大サイズのしきい値";

// Smoothing strategy
extract.polish.all = "すべて";
extract.polish.sharp = "鋭い境界";
extract.polish.border = "境界のみ";
// Smooth the border in a way that it matches completely with its dual
extract.polish.syncBorder = "境界の同期";
// topology of extracted mesh
extract.edgeLoop = "エッジループ（側面）";
extract.edgeLoop.auto = "自動エッジループ";
extract.edgeLoop.division = "除算";
// The thickness of the extracted mesh (from the painted mask)
extract.thickness = "太さ";
// Carve the mask into the surface
extract.carve = "浮き出し";
// Extract a new mesh from the painted mask
extract = "取り出す";
// Preview extract
extract.preview = "のプレビュー";
// Extract two new mesh from the painted mask and from the unmasked area
extract.split = "分割";
// How should we close the topology of the extracted object
extract.action = "閉じるアクション:";
extract.action.help = "• なし
単純に部分を取り出し、取り出した部分を開けたままにします。

• 埋める
穴を埋めて、スムーズにします。
平らな表面にはこのオプションを使用しないでください。

• シェル
厚さの値を使って、取り出したシェイプを閉じます。

• レイヤー
レイヤーの差を取り出します (レイヤーのサブメニューのみ)。";
// Do not close the mesh (leave it open)
extract.action.none = "なし";
// Close the mesh with a hole-filling algorithm
extract.action.fill = "埋める";
// Close the mesh by adding a thickness on the surface
extract.action.shell = "シェル";
// Close the mesh by using the layer data as a difference thickness
extract.action.layer = "レイヤー";

// uv part of revolution surface
genus.main = "メイン";
genus.hole = "穴";
genus.bottom = "下";
genus.top = "上";

// History, list of undo/redo
history = "履歴";
// First "undo" state
history.root = "ルート";
history.undoConfirm = "これらの操作をすべて取り消してよろしいですか？";
history.undoWarning = "後で編集を加えると、多くの変更内容を喪失する可能性があります。";
// Settings concerning the history stack of undo/redo
history.stack = "スタック";
// Actions to include in the undo/redo stack
history.include = "アクションを含める";
// include lighting editing in the undo/redo
history.includeLights = "ライト";
history.includeLights.help = "このオプションが無効の場合でも、Gizmoを使ったライトの移動はそのまま含まれます。シーン階層で他のオブジェクトに影響するからです。";
// include postProcess editing in the undo/redo
history.includePostProcess = "ポストプロセス";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCap & HDRI";
// Can limit the stack of undo/redo size
history.limitSize = "履歴の上限";
history.limitSize.help = "履歴の最大サイズ。

履歴は次に操作が記録されるとアップデートされます。";
// Limit the number of undo in the history stack
history.limitStack = "スタックの上限";
history.limitStack.help = "アプリが残せる操作数の上限。

履歴は次に操作が記録されるとアップデートされます。";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "取り消しの上限";
history.rangeProtect.help = "履歴をずっとさかのぼると、多くの取り消しを実行する前に確認ダイアログが表示されます。";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "カメラを復元";
history.restoreCamera.help = "このオプションを有効にすると、アクションを取り消し、またはやり直した場合、保存されているカメラのビューポイントを復元します。";
// Undo
history.undo = "取り消す";
// Redo
history.redo = "やり直す";
// Shown during undo
history.state.undo = "取り消し: $0";
// Shown during redo
history.state.redo = "やり直し: $0";
// Shown during undo/redo
history.state.voxelRemesh = "ボクセルのリメッシュ";
// Shown during undo/redo
history.state.surfaceRemesh = "サーフェスのリメッシュ";
// Shown during undo/redo
history.state.multiresLevel = "解像度の変更";

// Debugging/Inspect object material (view channel separately color, roughness, normal, uv, etc)
inspect = "インスペクタ";
// Inspector but SHORT
inspect.short = "検査";
// Display the material channel on the background
inspect.onBackground = "背景上";
// Display the material channel on the mesh
inspect.onMesh = "On Mesh";
// Show UV seams
inspect.seams = "シーム";

// Interface customization
interface = "インターフェース";

// Resize window (should be short)
interface.resize = "サイズ変更";

// UI customization: one item row will stands on one line (synonym: Inlined)
interface.compact = "UI：コンパクト";

// UI customization: each row of the list will be bigger
interface.expandList = "UI: リストを展開";
// UI customization: each row of the list will be bigger
interface.expandList.help = "リスト管理を簡単にするためのUIオプション。";

// Add shortcuts buttons to the bottom of the screen
interface.shortcut.bottom = "ショートカットを追加 (下)...";
// Floating window
interface.shortcut.float = "ショートカットを追加 (ウィンドウ)...";

// Interface option (main base color)
interface.colorBase = "カラーベース";
// Interface option (accent widget color)
interface.colorSelect = "カラーウィジェット";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "透明パネル";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "ぼかしの強度";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "カラーパネル";

// Interface color style
interface.preset.title = "プリセット";

// Reset interface settings
interface.resetAll = "スタイルをリセット";
interface.resetAll.confirm = "インターフェース設定をリセットしますか？";
// Help popup when hovering
interface.hoverHelp = "ホバー時のヘルプポップアップ";
// Do not use windows native dialog
interface.customDialog = "Nomad ダイアログを使用";
interface.customDialog.help = "ネイティブダイアログの代わりにNomad独自のテキストダイアログを表示します。";
// Interface option (main base color)
interface.iconSupport = "ハイコントラストボタン";
interface.iconSupport.help = "有効の時にボタンがより目立つようにする代替スタイル。

自動に設定すると、Nomadは有効/無効のUIカラーコントラストが低い時にこのモードを使用します。";
// Interface customization
interface.flipTop = "上のバーにミラー";
// Interface customization
interface.flipMiddle = "サイドバーにミラー";
// Interface customization
interface.flipBottom = "下のバーにミラー";
// list of tools
interface.toolbox = "ツールボックス";
// hide toolbox by default
interface.toolbox.hide = "隠れた";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.columns = "列数";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.rows = "行";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "順序をリセット";
// Colored text and icon
interface.toolbox.color = "カラー";
// Top bar
interface.top.title = "トップバー";
interface.top.responsive = "レスポンシブ";
interface.top.responsive.help = "このオプションは主に小さい画面に関連します。";
interface.top.responsive.multiline = "複数行対応";
interface.top.responsive.scroll = "スクロール";
interface.top.alt = "代替の順序";
interface.top.alt.help = "トップメニューの代替順序アイコン。

メッシュ編集に関するメニューは主にシーンメニューの反対側に配置されており、シーン編集に役立ちます。";
// Scale the interface
interface.scale = "全体的なサイズ調整";
// Spacing between widgets
interface.cursorStep = "垂直方向の間隔";
// Width of the interface panels
interface.panelWidth = "パネルの幅";
// Size of fonts
interface.fontScale = "フォントサイズ";
// Inset
interface.inset.title = "画面の端のオフセット";
interface.inset.title.help = "画面の端のボタン操作に問題がある場合のみ、これらの値を変更することを検討してください。

スライダーが無効の場合、Nomadはデバイスそのものによる安全なエリアの値を使用します。";

// (see Glossary for Layer)
layer = "レイヤー";
layers.syncTransform = "トランスフォームを同期";
layers.syncTransform.help = "If enabled, all the unselected layers will be adjusted depending on the transform rotation, scale and skew.

Disable this option if the other layers are meant to be used without the new transform that you are applying.

When set on auto, only the visible layers will be adjusted.";
// (see Glossary for Layer)
layers.lock = "上のレイヤーのディテールを残す";
// (see Glossary for Layer)
layers.lock.yes = "一番上のレイヤーをロックしますか？";
// (see Glossary for Layer)
layers.lock.warning = "スカルプト中、上のレイヤーから来る変形は無視されます。

しかし、これらのレイヤーのディテールはまだ可視状態です。

このオプションは、上のレイヤーに比較的スケールの小さなディテールがある場合のみ動作します。";
// (see Glossary for Layer)
layers.addLayer = "レイヤーを追加";
// (see Glossary for Layer)
layer.factors = "チャンネル要素";
// (see Glossary for Layer)
layer.factor = "要素";
// (see Glossary for Layer)
layer.offset = "オフセット";
// Layer blend mode
layer.blendMode = "ブレンド";
// (see Glossary for Layer)
layer.base = "ベース";
layer.base.nothing = "取り出すものがありません！";
layer.base.background = "背景材料";
layer.base.background.help = "有効になっている場合、背景材料と異なる材料値のみが抽出されます。";
// (see Glossary for Layer)
layers = "レイヤー";
layers.title = "レイヤー";
// (see Glossary for Layer)
layers.title.help = "レイヤーは位置のオフセットとペイントを記録でき、非線形のワークフローに便利です。
例えば、変更内容を取り消すために履歴に頼らなくても、いろいろな表情を試してみたい場合などです。

ペイントのデータには、レイヤーは上から下に順番に並んでいます。つまり、上のレイヤーは下のレイヤーをマスクします。

“DelLayer”ツールを使って、レイヤーの一部を消去することもできます。";
layers.primitive = "レイヤーはプリミティブに利用できません。";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "なし";

light = "ライト";
lights = "ライト";
// Intensity of light
light.intensity = "強度";
// Color of light
light.color = "カラー";
// Kelvin (the temperature unit)
light.kelvin = "ケルビン";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "色温度";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "カメラ";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "固定されています";
// The light will move along the camera
light.attachment.camera = "カメラ";
light.attachment.help = "• 固定
ライトの方向は変化しません。

• カメラ
ライトの方向はカメラビューによって変化します。";
// Light type (directional, spot, point)
light.type = "タイプ";
// Directional light (synonym: sun light)
light.type.directional = "方向的";
light.type.sun = "太陽";
// Directional light (synonym: sun light)
light.type.environment = "環境";
light.type.hdri = "HDRI";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "スポットライト";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "ポイント";
// For directional light (angle jitter)
light.angle = "アングル";
// For point/spot light (offset jitter)
light.size = "サイズ";
// Cone angle for spot angles
light.spot.angle = "円錐の角度";
// Softness of the spot light
light.spot.softness = "柔らかさ";
// Position of the light
light.position = "位置";
// Enable or disable shadows for a light
light.shadow.cast = "シャドウ";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "ポイントライトは画面空間のシャドウのみをサポートします。";
light.shadow.type = "シャドウのタイプ";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "シャドウマップ";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "スクリーンスペース";
light.shadow.type.screenspace.help = "実験的な機能。今後のリリースで削除される可能性があります。

このオプションは柔らかさのシャドウの機能と使用されるように考えられています。";
// Adjustment to fix artefacts
light.shadow.bias = "バイアス";
// How blurry the shadow is
light.shadow.softness = "柔らかさ";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "コンタクト";
light.contact.help = "“自動”が選択されている場合、最も強いライトのみがコンタクトシャドウを発生します。";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "許容値";
// Activated the light
light.visible = "表示";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "中心に戻す";

// Object's material
material = "マテリアル";
// See glossary
material.pbrRoughnessMetalness.warning = "粗さとメタリックは、PBRシェーディングモードが必要です。";
// See glossary
material.pbrReflectance.warning = "反射率にはPBRシェーディングモードが必要です。";
// See glossary
material.pbrRefraction.warning = "屈折は、PBRシェーディングモードが必要です。";
// See glossary
material.pbrSubsurface.warning = "サブサーフェスにはPBRシェーディングモードが必要です。";
// Value that says how much light will change direction when hitting the surface
material.ior = "屈折率 (IOR)";
// an object-level value that overrides the roughness interior/surface of the mesh
material.paintingOverride = "ペイントを上書き";
// The roughness in the inside is turbidity
material.paintingOverride.help = "有効な粗さが2つあります。1つはサーフェスで、もう1つは内側で動作しています。

しかし、ペイント可能な粗さは1つだけなので、2つのラフネスは同じ値になります。";
// Glossiness is simply the opposite of roughness
material.refraction.surface = "サーフェス";
// Synonym: turbidity
material.refraction.interior = "内側";
// Set the roughness of the object with a value of 0
material.paintGlossy = "光沢でペイント";
material.paintGlossy.help = "粗さとメタリックの値を 0 にしてオブジェクトをペイントするので、シャープな屈折が可能です。

これはペイントメニューに進み、カラーとを無効に“すべてをペイント”の機能を使用するのと同じです。";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "吸収";
material.absorptionEnable.help = "体積を通過する時に吸収される光をシミュレーションします。

薄い部分は光を多く通すので明るくなります。厚い部分は暗くなります。

エフェクトはオブジェクトの形に大きく影響されます。オブジェクトの厚さの概算のみが使用されます。";
material.absorptionFactor = "要素";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "深さ";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "透過";
material.translucency.help = "透過処理をするにはシャドウを投影するためのライトが必要です。";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "不透明度";
// Fully opaque material
material.type.opaque = "不透明";
material.type.opaque.help = "これはデフォルトのマテリアルタイプです。

ペイントされた頂点アルファ、オパシティテクスチャ、またはカラーチャネルのアルファチャンネルは、ディザリングを通じて考慮されます。

メインの不透明度スライダーのみ無視されます。";
// Fully opaque material
material.type.shadowCatcher = "シャドウキャッチャー";
material.type.shadowCatcher.help = "光によって投射された影を除いて、オブジェクトを完全に透明にします。

このモードは通常、プレーンジオメトリで使用されます。";
material.type.shadowCatcher.warning = "シーンにはシャドウ付きのライトがありません。シャドウキャスターは無効になります。 

シャドウキャッチャーが完全にメタリックである場合、SSR（反射）ポストプロセスが有効であれば、シャドウキャッチャーはシーンを反射できます。";
// See glossary
material.type.subsurface = "サブサーフェス";
material.type.subsurface.help = "最善の結果を得るには、PBRシェーディングモードに切り替えて、最低1つのディレクショナルライトを、理想的には薄暗い環境で、使用してください。";
// Transparency mode, alpha blendingd
material.type.blending = "ブレンド";
material.type.blending.help = "不透明度の値を調整してオブジェクトを半透明にします。

オブジェクトの形が複雑な場合、リアルタイムの制限により、あきらかなアーティファクトが見えることがあります。";
// Transparency mode
material.type.additive = "加法";
material.type.additive.help = "不透明度の値を調整してオブジェクトを半透明にします。

この方法は、“ブレンド”に比べてアーティファクトが軽減されますが、オブジェクトはより明るくなります。";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "ディザ合成";
material.type.dithering.help = "ピクセルの一部をランダムに破棄して、オブジェクトを半透明にします。";
// Simulate glass-like material
material.type.refraction = "屈折";
material.type.refraction.help = "このモードはガラスマテリアルを再現するのに使用できます。

リアルタイムの制限のために、自己屈折またはマルチレイヤーの屈折が制限されます。";
material.castShadows = "シャドウを投影";
material.receiveShadows = "シャドウを受け取る";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "常にライトなし";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "カリング反転";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "反射率";
material.reflectance.help = "マテリアルが非メタリックのマテリアルに受け取る反射の量をコントロールします。

大抵の場合、デフォルト値が使用されます (これは通常の角度で、4% の標準的な反射光に該当します)。";
// Material preview in the viewport
material.preview = "マテリアルのカラーのプレビュー";
material.preview.help = "When you modify a material, a preview will be displayed in the viewport on the selected object.

The preview is shown while you interact with the color, roughness, metalness, opacity and intensity sliders.";
// Menu names
menu.files = "ファイル";
menu.scene = "シーン";
menu.multires = "マルチレゾ";
menu.voxel = "ボクセル";
menu.dynamic = "DynTopo";
menu.topology = "その他";
menu.primitive = "プリミティブ";
menu.render = "レンダリング";
menu.material = "マテリアル";
menu.postprocess = "ポストプロセス";
menu.camera = "カメラ";
menu.background = "背景";
menu.tool = "ツール";
menu.stroke = "ストローク";
menu.alpha = "アルファ";
menu.filter = "フィルタ";
menu.falloff = "フォールオフ";
menu.paint = "ペイント";
menu.symmetry = "対称";
menu.operation = "操作";
menu.pressure = "筆圧";
menu.gesture = "ジェスチャ";
menu.layers = "レイヤー";
menu.settings = "設定";
menu.interface = "インターフェース";
menu.bindings = "バインド";
menu.shortcuts = "ショートカット";
menu.history = "履歴";
menu.historySettings = "設定";
menu.about = "情報";
menu.debug = "デバッグ";

// Operation on the object (action)
mesh.holes = "穴";
// If the object has holes, the algorithm will close them
mesh.holes.close = "穴を閉じる";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holes.detail = "ディテール";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "分離";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "レイヤー、ペイント、およびマルチレゾリューションは喪失します。";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "解像度";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "強制的に立方体を作成";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "変換";
// Static object means "static topology"
mesh.static = "メッシュ";
// See glossary
mesh.multires = "マルチレゾリューション";
// Dynamic topology
mesh.dynamic = "DynTopo";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "グローバルマテリアル";
paint.useGlobal.help = "このオプションを有効にすると、選択中のマテリアルが他のツールと同じになります。

但し、粗さ、メタリック、およびカラー設定のみが考慮されますので、ご注意ください。";
// The current tool will paint the object if this option is enabled
paint.usePainting = "ストロークペイント";
// If true save the textures data into
paint.preset.embed = "テクスチャを埋め込む";
paint.preset.embed.help = "The textures can be found in the Nomad textures/ folder.
The material presets can be found in the Nomad materials/ folder.

When this option is off, the material preset only reference the texture inside the textures/ folder.

You can enable this option to make a copy of the textures inside the material preset.
It can be useful if you want to share a textured preset without providing the associated textures.";
paint.preset.embed.apply = "Apply to all materials";
// Factor/Opacity of paint tool
paint.intensity = "ペイントの強度";
// Apply the paint on the object
paint.paintAll = "すべてをペイント";
paint.paintAll.help = "現在のマテリアルをオブジェクトに適用できます。";
paint.paintAll.help.mask = "マスクされた領域は影響を受けません。";
paint.paintAll.help.hide = "非表示の領域は影響を受けません。";
paint.paintAll.help.opacity = "上記のツール塗装要因を使用してください。";
paint.paintAll.help.layer = "未塗装のレイヤーの領域は影響を受けません。";
paint.strokePainting.title = "ペイント";
// Brush stroke texture
paint.texture.warningEnable = "テクスチャのプロジェクションを許可するには、ストロークペイントを有効にする必要があります (一番上のチェックボックス)！";
paint.texture.warningIgnored = "使用中のツールはテクスチャを使用できません！";
// use stencil mode
paint.stencil = "ステンシル";
// Inherit stroke falloff option for the painting
paint.tool.help = "ツールのアルファ、フォールオフ、ランダマイザを使用して塗装ストロークの強度を調整します。

これらのオプションは塗りつぶし機能には適用されませんが、三平面バリアントではアルファが考慮されます。";
// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "新しい名前";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "新しい値";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "新しいカラー (16進フォーマット)";

// Post process effect
postprocess = "ポストプロセス";
// Denoise
postprocess.denoise = "ノイズ除去";
postprocess.denoise.help = "すべてのフレームが蓄積された後、ノイズ除去処理を適用します。";
postprocess.denoise.warning = "これは高コストな処理です。画像がノイズ出ている場合にのみこの効果を有効にしてください。";
// Quality vs performance
postprocess.quality = "クオリティ";
postprocess.quality.help = "これらのオプションをアクティベートすると、クオリティは向上しますが、パフォーマンスは低下します。";
// More samples means better quality but slower performance
postprocess.maxSamples = "最大サンプル";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "フル解像度";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "最大フレーム数のサンプリング";
postprocess.accumulateCount.help = "レンダリングが停止する前に累積するフレームの最大数。

レンダリングが停止すると、 Nomadは何もしないので、電池寿命を節約します。

多くのレンダリング機能は、フレームの累積が利点になります。特に:
• ソフトシャドウ
• グローバルイルミネーション
• 反射 (SSR)
• アンビエントオクルージョン
• サブサーフェス
• 被写界深度

ソフトシャドウとグローバルイルミネーションは特に多くのフレーム数が必要です。
上記の機能が無効になっている場合、 Nomadはレンダリングを早めに停止できます。";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "レンダーの解像度";
postprocess.renderRatio.warning = "ピクセルアート効果で上書きされます。";
postprocess.renderRatio.help = "このオプションはパフォーマンスに大きく影響します。
x1.25 よりも低い値にしておくことをお勧めします。

このオプションは設定に保存されません。";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "アンチエイリアス (TAA)";
postprocess.taa.help = "カメラを移動中に起きるチラツキを軽減します。";
// Ditherhing pixel
postprocess.dithering = "ディザ合成";
postprocess.dithering.help = "バンディングアーティファクトを減らすためにピクセルをディザリングします。";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "反射 (SSR)";
postprocess.ssr.warning = "SSRにはPBRシェーディングモードが必要です。";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "グローバルイルミネーション (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "許容値";
postprocess.ssgi.warning = "SSGIにはPBRシェーディングモードが必要です。";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "アンビエントオクルージョン";
// How far the effect spreads
postprocess.ssao.radius = "サイズ";
// How strong the effect is
postprocess.ssao.factor = "強さ";
// Adjustment to fix artefacts
postprocess.ssao.bias = "曲率のバイアス";
postprocess.ssao.bias.help = "エフェクトの感度はサーフェスの曲率によって変わります。";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "被写界深度";
// The blur factor behind the focused point
postprocess.dof.blurFar = "背景のぼかし";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "前景のぼかし";
postprocess.dof.focusTip = "オブジェクトをタップすると、焦点を変更できます。";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "ブルーム";
// Intensity of the effect
postprocess.bloom.intensity = "強度";
// How far the effect spreads
postprocess.bloom.radius = "半径";
postprocess.bloom.radius.help = "ブルームの範囲。";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "しきい値";
postprocess.bloom.threshold.help = "ピクセルがブルームを拡散しているかどうかを決定するための輝度のしきい値。";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "トーンマッピング";
postprocess.tone.exposure = "露出";
postprocess.tone.contrast = "コントラスト";
postprocess.tone.saturation = "彩度";
postprocess.tone.hue = "色調";
// No tonemapping operator is used
postprocess.tone.mapping.none = "なし";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "ニュートラル";
// Color curves
postprocess.curve = "カラーグレーディング";
// Curve for pixel luminance
postprocess.curve.luminance = "メイン";
postprocess.curve.red = "レッド";
postprocess.curve.green = "グリーン";
postprocess.curve.blue = "ブルー";
// Reset color grading curves
postprocess.curve.resetAll = "すべてをリセット";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "色収差";
postprocess.chromatic.factor = "強さ";
// Darking on the edges
postprocess.vignette = "ビネット";
// How far the effect spreads
postprocess.vignette.size = "サイズ";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "硬さ";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "シャープ";
postprocess.sharpness.factor = "強さ";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "グレイン";
postprocess.grain.factor = "強さ";
// Accentuate the edges of the model
postprocess.curvature = "曲率";
// main strength of curvatre
postprocess.curvature.factor = "要素";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "キャビティ";
// Color/Strength of convex curvature
postprocess.curvature.bump = "バンプ";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "ピクセルアート";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "フレームのサンプリングを許可";
// Simulate scanline rendering (horizontal line)
postprocess.scanline = "スキャンライン";
postprocess.scanline.factor = "要素";
// Spacing between lines
postprocess.scanline.spacing = "間隔";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "プリミティブ";
primitive.box = "ボックス";
primitive.sphereCube = "クアッドスフィア";
primitive.sphereUV = "UV球";
primitive.icosahedron = "二十面体";
primitive.cylinder = "円柱";
primitive.cone = "円錐";
primitive.torus = "トーラス";
primitive.lathe = "レイズ";
primitive.tube = "チューブ";
primitive.plane = "平面";
primitive.triplanar = "Triplanar";
primitive.needValidate = "プリミティブを検証する必要があります!";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "編集";
primitive.edit.help = "ビューポイントで3D編集を可能にします。

プリミティブを変更しないでGizmoまたはTransformツールと使用したい場合は、この機能を無効にできます。";

// Primitive configuration
primitive.mainConfig = "パラメータ";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "トポロジー";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "ジオメトリ";

// Validating the primitive (then it can be sculpted)
primitive.validate = "検証";
// Maximum number of faces of the primitives
primitive.maxFaces = "面の最大数";
primitive.maxFaces.help = "プリミティブが所有できる面の最大数。

この上限はプリミティブが検証されていない間のみ有効です。検証後、その制限は無くなります。";
// Synonym: Flat subdivision
primitive.linear = "線分割";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "ポスト分割";

// Radius (of a sphere, torus, etc)
primitive.radius = "半径";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radius.sync = "同じ半径";
primitive.radius.start = "半径の始点";
primitive.radius.end = "半径の終点";
// Size (of cube x dimension)
primitive.size = "サイズ";
primitive.sizeX = "サイズ X";
primitive.sizeY = "サイズ Y";
primitive.sizeZ = "サイズ Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "除算";
primitive.divisionX = "除算 X";
primitive.divisionY = "除算 Y";
primitive.divisionZ = "除算 Z";
// Angle of torus, etc
primitive.angleX = "角度 X";
primitive.angleY = "角度 Y";
primitive.angleZ = "角度 Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "一定の密度";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "球上のプロジェクト";
primitive.projectOnSphere.help = "完全な球形にポイントをスナップします。";

// triplanar
primitive.triplanar.title = "Triplanar";
primitive.triplanar.title.help = "Triplanarとは、3つの平面からのマスクの情報を使用して、ボクセルのグリッドを満たし、多角化します。

徐算、またはサイズスライダーを使って操作する場合、ペイント情報はリセットされます (スムーズはそのままです)。

対称は期待通りに機能しない可能性があるので、無効にしておくことをお勧めします。

“マスク”パネルから“トポロジー接続”のオプションを使用すると、他の平面に影響を与える平面をペイントできます。";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanar.sameSize = "同じサイズ (立方体)";
primitive.triplanar.polish = "スムーズ";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanar.resetMask = "マスクをリセット";
// One side of a cube (the back plane)
primitive.isolate.back = "戻る";
// One side of a cube (the right plane)
primitive.isolate.right = "右";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "下";
// Plane
primitive.planeSameSize = "同じサイズ (正方形)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "ディスク";
// Box
primitive.boxRegular = "同じサイズ (立方体)";
// Torus
primitive.torus.radiusOuter = "外周半径";
primitive.torus.radiusInner = "内径";
primitive.torus.angle = "アングル";
primitive.torus.angleOffset = "角度のオフセット";
// Cylinder
primitive.cylinder.height = "高さ";
// Cone
primitive.cone.radius = "半径";
primitive.cone.height = "高さ";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "穴";
// Make a hole in the primitive to make it hollow
primitive.hasHole = "穴があります";
// Curve profile (synonym: profile, curve)
primitive.profile = "プロファイル";
primitive.profile.viewport = "ビューポートに表示";
// If the revolution surface has caps (E.g: cylinder)
primitive.cap = "キャップ";

// Singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "リピーター";
// All the new items will be inserted inside the bound rather than outside
repeater.array.fitInside = "内側にフィット";
// The object will follow the curve
repeater.curve.align = "アライン";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "読み込む...";
// iOS Photos gallery
resource.import.ios.photos = "写真";
// iOS Files App
resource.import.ios.files = "ファイル";

scene.title = "シーン";
scene.title.help = "可視/選択ボタンを使用中、指で押さえたままドラッグすると、他のオブジェクトを簡単に選択できます。

また、可視/選択ボタンを長押しすると、子に影響を与えることもできます。";
// The view will focus on the item when we click on it
scene.focus = "UI: アイテムにダブルタップでフォーカス";
// Add new object on gizmo position
scene.addOnGizmo = "On gizmo";
scene.addOnGizmo.help = "ノードをギズモの位置に移動します（ギズモツールが選択されている場合）";
// Select the gizmo tool after adding a new object
scene.addSelectGizmo = "ギズモを選択";
scene.addSelectGizmo.help = "新しいノードを追加する時にギズモツールを選択します";
// Icon size in pixel (min/max)
scene.iconSize = "アイコンサイズ";
// Min size of icon
scene.iconSize.min = "最小";
// Max size of icon
scene.iconSize.max = "最大";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "階層ライン";
scene.showHierarchy.help = "ビューポートで親とその子供の間にラインを表示します。";
scene.showHierarchyNomadPivot = "Nomadピボットを使用";
scene.showHierarchyNomadPivot.help = "Nomadピボットは、TransformとGizmoツールによって使用されるピボットです。

このオプションが無効になっている場合、自然なベースピボットを使用します。
場合によっては、このベースピボットはオブジェクトの中心から遠く離れていることがあります！";
// The view will focus on the item when we click on it
scene.syncVisible = "可視性を同期";
scene.syncVisible.help = "有効にすると、表示（目）アイコンを使用すると選択された項目に影響します。";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "結合";
// Group the selected object with a new created Empty Node as a parent
scene.group = "グループ";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "親を解除";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "ミラー";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "曲線";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "配列";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "放射状";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "リピーター";
scene.repeaters.help = "シーン階層でそれより下にある任意のジオメトリのインスタンスを作成するリピーターノード。";
// Validate button
scene.validateGroup = "検証";
// Keep instances in the scene
scene.validateGroup.keepInstances = "インスタンスを保持";
// If we should join children
scene.validateGroup.joinChildren = "子を結合";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "ボクセル結合";
scene.voxelResolution = "解像度";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "減算: オブジェクトを隠す";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "交差部分: すべてのオブジェクトは非表示です";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "オブジェクトが選択されていません。オブジェクトを最低1つ選択してください。";
// Need to select one object only
scene.noneButNeedOne = "オブジェクトが選択されていません。オブジェクトを1つ選択してください。";
// Need to select one object only
scene.onlyOneObject = "複数のオブジェクトが選択されています。1つだけ選択してください。";
// Boolean operation
scene.boolean = "ブーリアン";
scene.boolean.help = "ブール演算を行ってオブジェクトをマージ、減算、または交差させます。

一部のオブジェクトがマニフォールドでないまたは非防水の場合、操作が失敗する可能性があります。

ブール演算が失敗した場合は、問題のオブジェクトに対してボクセルリメッシャーを常に使用して、それが防水マニフォールドであることを保証できます。";
// Weld intersection
scene.boolean.mergeIntersection = "交差部の溶接";

// General scene display settings
settings.display.title = "表示設定";
// Wireframe (show triangles and quad edges)
settings.wireframe = "ワイヤーフレーム";
// Display the material texture
settings.debugChannel = "テクスチャを表示";
// Display the material texture in the background
settings.debugChannel.onBackground = "背景に表示";
// Display the material texture on the mesh
settings.debugChannel.onMesh = "On Mesh";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "両面";
settings.twoSided.help = "面は両側から見えます。";
// If we colorize the inverted side of faces
settings.backface.color = "背面のカラー";
// Color of the inverted side of faces
settings.backface.colored = "色つきの背面";
// Outline (contour highlight around the selected object)
settings.outline = "アウトライン";
// Outline (contour highlight around the selected object)
settings.outline.help = "選択中のオブジェクトはアウトライン化されます。";
settings.outline.thickness = "太さ";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "方向キューブ";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "下";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "左";
// Flip the camera (rotate 180° to see the other side)
settings.snapCube.flip = "180°回転";
settings.snapCube.flip.help = "ビューが既にスナップされている場合はビューを反転します。";
// Alignment (can be auto/on/off)
settings.snapCube.align = "アライメントを制限";
settings.snapCube.align.help = "ビューを世界軸に揃えます。有効にすると、スナッピングビューは6つだけ可能です。

オートでは、カメラがオービットモードにある場合のみ制限が行われます。";
// Stats (information logs about the scene displayed on screen)
settings.stats = "統計情報";
settings.stats.right = "右";
settings.stats.all = "シーン全体を表示";
// Handles are controls that you interact with in the viewport in order to edit something
settings.handle = "ハンドル";
settings.handles = "ハンドル";
// Shape draw thing
settings.shape = "シェイプ";
settings.shape.color = "ポリゴンの色";
// Grid
settings.grid = "グリッド";
settings.grid.snapDivision = "スナップ分割しきい値";
settings.grid.snapDivision.help = "しきい値はグリッドまでの距離と比較されます。";
// Cursor
settings.cursor.title = "カーソル";
// sculpting circle
settings.cursor.circle = "円";
// A small indicator dot
settings.cursor.showDot = "小さなドットを表示";
settings.cursor.showDot.help = "ドットは、カメラの回転軸のポイントとして、またはスカルプト中に表示されます。";
settings.cursor.showRope = "手ぶれ補正ロープを表示";
// indicator
settings.indicator.title = "インジケーター";
settings.indicator.title.help = "ビジュアルインジケーターを表示します（チュートリアル、画面キャプチャなど）。";
settings.indicator.size = "サイズ";
// Highlight (the object glows when we select it)
settings.highlight.selection = "選択部分をハイライト";
// Highlight settings
settings.highlight = "ハイライト";
settings.highlight.duration = "継続時間";
// Mesh that are not selected will be dark
settings.darkenUnselected = "未選択のオブジェクトを暗く";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "スムーズシェーディング";
// Experimental feature
settings.partialDraw = "部分的な描画";
settings.partialDraw.help = "実験的機能！

複雑にポリメッシュされたパーツの比較的小さな部分をスカルプトする場合、使用できます。

スカルプトの操作をスムーズにしますが、ワイヤーフレームを有効にすることは避けてください！

ブラシストロークを使用中、目に見えるアーティファクトが追加される可能性があります。";
settings.partialDraw.warning = "目に見えるアーティファクトが邪魔な場合は、このオプションをオフにすることをお忘れなく！";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "ペイントを表示";
// Show and use the masking on the mesh
settings.showMasking = "マスクを表示";
// Disable this option to force show the hidden faces
settings.showDiscard = "非表示を使用";
// Show icon on the canvas
settings.icon = "アイコン";
// Show icons on the canvas
settings.icons = "アイコン";
// Tooltip
settings.icons.help = "アイコンを直接選択して編集できるようにキャンバスにアイコンを表示します。";
// Hole filling settings
settings.hole = "穴埋め";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "非多様体を埋める";
settings.hole.nonManifold.help = "非多様体の穴を埋めます。
このオプションは設定で保存されません。";
// Maximum number of vertices (points)
settings.multires.maxVertices = "最大頂点数";
settings.multires.maxVertices.help = "Nomadは分割の前にメモリの確認を行いません。数が多すぎると簡単にクラッシュにつながる可能性があります。";
settings.multires.lowResVertices = "低い解像度のしきい値";
settings.multires.lowResVertices.help = "カメラを動かす際は、メッシュの低い方の解像を表示できます。

メッシュの解像度を高くして表示したい場合は、この値を上げてください。";

// The main rendering mode
shading = "シェーディング";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "ライトあり (PBR)";
shading.pbr.help = "このモードではライト (シャドウを含む) を、HDR環境と一緒に追加できます。

また、メタリックと粗さをペイントすることもできます。こうすることで、マテリアルの見た目をより詳細にコントロールできます。";
// Fast rendering mode for sculpting purpose
shading.matcap = "MatCap";
shading.matcap.help = "MatCapとは、MATerial CAPture（マテリアルキャプチャ）の別名で、ライティングとマテリアル（材質）の2つの情報を1つのイメージに反映することです。";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "ライトなし";
shading.unlit.help = "無地のカラーのシェーディングモード。ライティングなし。";
// Helper rendering mode that display solid colors
shading.object = "オブジェクト ID";
shading.object.help = "ランダムにカラーが割り当てられている各オブジェクトでライトのないレンダリングモード。

シーンに多くのオブジェクトがある場合、最も便利です。";
// Helper rendering mode that display solid colors
shading.instance = "インスタンス ID";
shading.instance.help = "オブジェクトIDと同じですが、インスタンスは同じ色を持ちます。";
// Helper rendering mode that display solid colors
shading.material = "マテリアルID";
shading.material.help = "マテリアルインスタンスごとに単色を表示します。";
// Randomize colors
shading.id.randomize = "IDをランダム化";
shading.textures = "テクスチャを使用";
shading.textures.help = "現在、Nomad内でテクスチャの作成および編集はできません。

しかし、テクスチャのあるファイルをNomadに読み込むと、動作します。

• 対応テクスチャ
不透明度: ライトあり、MatCap、ライトなし
一般: ライトあり、MatCap
カラー: ライトあり、ライトなし
エミッシブ: ライトあり
粗さ: ライトあり
メタリック: ライトあり";
// Lights
shading.lights = "ライト";
shading.lights.addLight = "ライトを追加";
shading.lights.warning = "ライトにはPBRシェーディングモードが必要です。";
// Environment based lighting (synonym: HDRI)
shading.environment = "環境";
shading.environment.import = "HDRを読み込む";
shading.environment.exposure = "露出";
shading.environment.backgroundBlur = "ぼかし (背景)";
shading.environment.rotation = "回転";
shading.environment.rotation.help = "指3本でビューポートを横方向にドラッグすると、環境を回転できます。";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "カメラに固定";
shading.environment.attachedToCamera.help = "環境をカメラに固定します。

こうすることで、ライティングに一貫性ができ、スカルプトに便利になります。";
shading.matcap.rotation = "回転";
shading.matcap.rotation.help = "指3本でビューポートを横方向にドラッグすると、MatCapを回転できます。";
shading.matcap.global = "グローバルMatCapを使用";
shading.matcap.global.help = "この特定のメッシュに異なるMatCapを使用するには、このオプションをチェックしないでください。";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible = "マスク";
shortcut.solo = "ソロ";
shortcut.xray = "X線";
shortcut.voxelRemesh = "ボクセル";
shortcut.wireframe = "ワイヤー";
shortcut.cameraReset = "リセット";
shortcut.cameraSnap = "スナップ";
shortcut.lockSelection = "ロック";
shortcut.lockSelection.help = "有効な場合、メッシュをタップしても選択部分を変更できません。";
shortcut.grid = "グリッド";

// Memory taken by the scene
stat.ramScene = "シーン";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Vram シーン";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "Vram レンダー";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "Vram テクスチャ";
// Memory taken by the undo/redo history
stat.ramHistory = "履歴";
// Memory taken by other stuffs
stat.ramOther = "その他";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "使用メモリ";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "空きメモリ";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "使用中: $0";
stat.free = "空き: $0";
stat.faces = "面";
stat.triangles = "三角形";
stat.vertices = "頂点";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "四角形";
stat.vertex = "頂点";
stat.scene.face = "シーンの面";
stat.scene.vertex = "シーンの頂点";

// Brush stroke
stroke = "ストローク";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "ワールドスペースの半径";
// The settings is shared among every tools
stroke.useWorldRadius.help = "この設定はすべてのツールで共有されます。";
// Share the radius value among every tools.
stroke.useShareRadius = "半径を共有";
stroke.useShareRadius.help = "すべてのツールで半径の値を共有します。";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.spacing = "ストロークの間隔";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.spacing.adjust = "間隔の強度を調整";
stroke.minSpacingAdjustIntensity.help = "ブラシの強度を調整して、ストロークの間隔に応じて、一貫したデフォーメーションを実行します。";
stroke.minSpacing.help = "ストロークとストロークの間隔、ツールの半径に対して相対的。

値が低いとストロークはスムーズになりますが、パフォーマンスは低下します。";
// Brush stroke smoothing
stroke.lazySmooth = "ストロークのスムージング";
stroke.lazySmooth.help = "ストロークをよりスムーズにするために複数のポインターの位置を平均します。

値が高いほど、ストロークにポインタとのラグが生じますが、最終的には追いつきます。";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "手ぶれ補正ロープ";
stroke.lazyRadius.help = "ストロークが一定の距離でポインターの位置を追いかけます。

滑らかな線を引くのに使用できます。";
// It is not a per-tool settings
stroke.globalSettings = "これはグローバル設定です";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "スナップの半径";
stroke.snapRadius.help = "ポインタが最後に記録したストロークの近くにある場合、ストロークをスナップします。

頻繁に一時停止しながら、長い連続した線を描画したい場合、便利です。";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "ストロークのオフセット";
stroke.sculptOffset.help = "ストロークに一定のオフセットを適用します。

このオプションは、指でストロークをカバーすることがないので、小さな画面で指を使う場合に便利です。";
stroke.accumulate = "ストロークを累積";
stroke.accumulate.help = "このオプションが有効な場合、ストロークごとに追加、または削除できる上限はありません。";
// The tool can use DynTopo
stroke.useDynamic = "ダイナミックトポロジーを許可";
// Only sculpt the part that are linked topologically
stroke.connect = "トポロジー接続";
stroke.connect.help = "このオプションは選択中のサーフェスにリンクされた頂点のみをスカルプトします。

これは一般的に“移動”ツールに使用されます。例えば、別のパーツと自己交差する部分だけを移動したい場合などです。";
stroke.connect.short = "接続";
// sculpt on hide or mask
stroke.protect = "保護エリア";
stroke.protect.hide.help = "自動に設定すると、隠れた面のワイヤーフレームが表示されている場合、それらの面は編集されます（ワイヤーフレームメニュー参照）。";
// Only sculpt the vertex that points toward the camera
stroke.culling = "正面を向いている頂点のみ";
stroke.culling.help = "このオプションは背面を向いている頂点は無視します。

他の側面に影響を与えないで薄いジオメトリの一部をペイントしたい場合、便利です。

スカルプトにも利用できますが、アーティファクトが発生する可能性があります。";
// Infinite depth, move everything under the circle, disregarding depth
stroke.silhouette = "シルエット";
stroke.silhouette.view = "表示";
stroke.silhouette.snapped = "スナップされている場合";
stroke.silhouette.closest = "最も近い";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.sameSide = "同じ側面の頂点のみ";
stroke.sameSide.help = "デフォーメーションの反対方向を指す頂点を無視します。";
// determine normal direction
stroke.normal.direction = "方向";
stroke.normal.direction.help = "通常の変形が有効になっている場合のみ関連があります。
Nomadが変形の符号（押すまたは引く）を決定する方法を制御します。";
stroke.normal.direction.normal = "標準3D";
stroke.normal.direction.normal.help = "ポインターのXY位置と投影された表面の標準を比較します。";
stroke.normal.direction.screen = "XY";
stroke.normal.direction.screen.help = "ポインターの画面上のXY位置を使用して押すか引くかを決定します。";
stroke.normal.direction.auto = "自動";
stroke.normal.direction.auto.help = "投影面の標準角度に基づいて自動的に方法を選択します。";
stroke.normal.direction.auto.threshold = "しきい値";
stroke.normal.direction.auto.threshold.help = "使用する方法を決定するために、表面の標準に対して比較される角度制限。";
// small tip/warning
stroke.onlyLasso = "設定は投げなわツールにのみ有効です。";

// Here sampling refers to the app gathering information under the mouse
stroke.area = "エリアサンプリング";
stroke.area.help = "一部のブラシやストロークオプションは、機能するために表面に垂直な平面が必要です。
この平均平面の計算方法を、ツール半径の比率としてサンプリングエリアを設定することによって制御できます。

100％で、選択円の内側のすべての点が考慮されます。
0％では、最も近い頂点または三角形のみが考慮されます。";
// Sampling radius size (percent)
stroke.area.normal.radius = "ノーマル半径";
// Sampling radius size (percent)
stroke.area.point.radius = "ポジション半径";
// Sampling averaging
stroke.area.normal.average = "ノーマル平均";
// Sampling averaging
stroke.area.point.average = "ポジション平均";
// Keep sharp edges
stroke.normalFilter = "ノーマルフィルター";
stroke.normalFilter.help = "
深度のフィルタリング";

// Only paint the part of the mesh above a certain height
stroke.depth.enable = "深度マスキング";
stroke.depth.enable.help = "計算された平面の上または下にある特定の距離以上の点を除外します（エリアサンプリング）。

例として、凹凸やくぼみにペイントする場合に使用できます。";
stroke.depth.offset = "高さのオフセット";
stroke.depth.falloff = "深度フォールオフ";
stroke.depth.max = "上部エリア";
stroke.depth.min = "下部エリア";

// Invert the pixel (black <-> white)
stroke.alpha.invert = "ピクセルを反転";
// Repeat the alpha image (pattern)
stroke.alpha.wrap = "タイリング";
// No repeat pattern
stroke.alpha.wrap.none = "なし";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alpha.wrap.repeat = "繰り返す";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alpha.wrap.mirror = "ミラー";
// Tight fit when using tiling
stroke.alpha.fit = "内側にフィット";
stroke.alpha.fit.help = "This option is only relevant if the alpha and brushes textures are non square.

When enabled, each images will tile independently with no spacing.
You can disable this option if you want to keep the alpha and other images synchronized, in case their ratio are not the same.";
// Alpha rotation
stroke.alpha.rotation = "回転";
stroke.alpha.rotation.lock.help = "アルファの向きを固定します。

回転が解除されると、向きはリアルタイムでストロークの方向に追従します。";
// Repeat the image
stroke.alpha.tiling = "タイリング";
// Scale the image (make it bigger or smaller)
stroke.alpha.scale = "サイズ調整";
stroke.alpha.scale.help = "最小値では、アルファの四角はツールの円の半径内にあります。";
// Middle-point value at which no deformation occurs
stroke.alpha.midValue = "中間値";
stroke.alpha.midValue.help = "デフォーメーションを起こさない中間値。

(中間値 = 0)
• ブラック: ディスプレイスメントなし
• ホワイト: 正のディスプレイスメント

(中間値 = 0.5)
• ブラック: 負のディスプレイスメント
• ホワイト: 正のディスプレイスメント

(中間値 = 1)
• ブラック: 負のディスプレイスメント
• ホワイト: ディスプレイスメントなし";
// Synonymous: Scatter/Jitter/Randomize
stroke.jitter = "ランダム化";
// Sculpt and paint along the brush stroke at regular spacing
stroke.type.dot = "ドット";
// Sculpt and paint along with alpha spaced by brush radius
stroke.type.roll = "ロール";
// Sculpt and paint with alpha projected on screen stencil
stroke.type.tile = "タイル";
// Sculpt and paint with alpha projected on 3 axis
stroke.type.triplanar = "Triplanar";
// Sculpt continuously
stroke.type.drag = "ドラッグ";
// Lock a region and move it around
stroke.type.grab = "グラブ";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.type.grabRadius = "グラブ • 動的な半径";
// Lock a region and sculpt it by changing the tool intensity
stroke.type.grabIntensity = "グラブ • 動的な強度";

stroke.falloffProject = "影響";
stroke.falloffProject.help = "• スフィア（3d）
影響は頂点からブラシの中心までの距離を計算することによって算出されます。

• サークル（2d）
頂点はまずエリア平面上に投影され、その後ブラシの中心までの距離を計算します。
これはアルファのサンプリング方法と似ています。";
stroke.falloffProject.sphere = "球";
stroke.falloffProject.circle = "円";
stroke.falloffProject.cylinder = "円柱";

// Symmetry
symmetry = "対称";
symmetry.enable = "オン";
symmetry.primitiveWarning = "ブラシのシンメトリーは検証されたプリミティブにのみ利用できます。但し、Triplanarは例外です。";
symmetry.plane.title = "平面";
symmetry.toolIgnore = "現在使用中のツールは対称を無視します。";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "放射状";
symmetry.radialX = "ラジアル X";
symmetry.radialY = "ラジアル Y";
symmetry.radialZ = "ラジアル Z";
// A warning indicating that we limit the number of repetitions ($0 is a number)
symmetry.limited = "繰り返しの数は$0に限定されています！";
// Synonym: Offset
symmetry.offset.title = "オフセット";
symmetry.offsetX = "オフセット X";
symmetry.offsetY = "オフセット Y";
symmetry.offsetZ = "オフセット Z";
// Number of clones
symmetry.count.title = "数";
symmetry.countX = "数 X";
symmetry.countY = "数 Y";
symmetry.countZ = "数 Z";
// method
symmetry.method = "方法:";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.method.world = "ワールド";
symmetry.method.world.help = "対称面は固定され、移動しません。";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.method.local = "ローカル";
symmetry.method.local.help = "変換ツール (GizmoやTransformなど) を使用中は、対称面はメッシュに沿って移動します。";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "オブジェクトを反転";
// Cut half of the mesh
symmetry.cut = "カット";
// after mirroring, separate into multiple output (synonym: split, separate)
symmetry.split = "分割";
// Reapply the mesh mirror, does not impact the topology
symmetry.mirror = "ミラー";
symmetry.mirror.help = "トポロジーに影響を与えないで対称を再度適用します。

放射状の対称は無視されます。

トポロジーが対称でないと認識されたため残せない場合は、ミラーリングを強制実行するオプションが提示されます。";
// indicate that applying the mirror will keep the mesh topology
symmetry.mirror.keepTopology = "トポロジーを保持";
symmetry.mirrorFail = "対称を適用できませんでした。

メッシュをミラーリングすることで対称を強制実行しますか？";
symmetry.mirrorUseMasking = "マスクの部分を保護";
symmetry.mirrorUseMasking.help = "マスク部分をそのまま残します。

このオプションは非対称のトポロジー (または、一対の目のような、繋がっていないサーフェス) では無視されます。";
// Reset the symmetry plane position
symmetry.reset = "リセット";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "オブジェクトの中央";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "ワールドの中央";
// Reset the symmetry plane orientation
symmetry.reset.direction = "方向";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "線を表示";
// Display the symmetry plane in 3D
symmetry.showPlane = "平面を表示";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Gizmoで編集";
symmetry.edit.warning = "対称の編集は実験的です。";
symmetry.edit.help = "自由に面対称を設定できます。

この機能はまだ実験段階ですので、使用しないことをお勧めします。";

// Ideally short strings
tool.dynamic = "DynTopo";
// Ideally short strings (Symmetry)
tool.symmetry = "対称";
// Ideally short strings (Mirror primitive)
tool.mirror = "ミラー";
// Ideally short strings
tool.clay = "粘土";
// Ideally short strings (Subtract)
tool.clay.sub = "減算";
// Ideally short strings
tool.brush = "ブラシ";
// Ideally short strings
tool.move = "移動";
// Ideally short strings (Normal vector, perpendicular to surface)
tool.move.normal = "標準";
// Ideally short strings
tool.drag = "ドラッグ";
// Ideally short strings (Smooth the surface by erasing the details)
tool.smooth = "スムーズ";
// Ideally short strings (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "リラックス";
// Ideally short strings (Paint mask)
tool.mask = "マスク";
// Ideally short strings
tool.mask.unmask = "マスク解除";
// Ideally short strings (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "SelMask";
// Ideally short strings (Smudge the paint of the object)
tool.smudge = "ぼかし";
// Ideally short strings (Flatten the surface)
tool.flatten = "フラット化";
// Ideally short strings (Flatten the surface, more strongly than Flatten)
tool.planar = "プラナー";
// Ideally short strings (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "埋める";
// Ideally short strings (Layer brush)
tool.layer = "レイヤー";
// Ideally short strings
tool.crease = "クリース";
// Ideally short strings (Cut part of the mesh cleanly)
tool.trim = "トリム";
// Ideally short strings (Cut part of the mesh cleanly into two separate meshes)
tool.split = "分割";
// Ideally short strings (Project part of the object onto a curve)
tool.project = "プロジェクト";
// Ideally short strings
tool.inflate = "膨張";
// Ideally short strings
tool.pinch = "ピンチ";
// Ideally short strings
tool.nudge = "ナッジ";
// Ideally short strings
tool.stamp = "スタンプ";
// Ideally short strings (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "DelLayer";
// Ideally short strings (Select multiple objects with a lasso tool)
tool.select = "選択";
// Ideally short strings (Rotate, Translate and Scale the object)
tool.gizmo = "Gizmo";
// Ideally short strings
tool.gizmo.editPivot = "回転軸";
// Ideally short strings (Snap angle)
tool.gizmo.rotateSnap = "スナップ";
// Ideally short strings (Snap translation)
tool.gizmo.moveSnap = "スナップ";
// Ideally short strings (Local/Relative space)
tool.gizmo.local = "ローカル";
// Ideally short strings (Align/Snap the gizmo to world axis)
tool.gizmo.align = "アライン";
// Ideally short strings (Pin the gizmo, so that it stays in place when switching between objects)
tool.gizmo.pin = "ピン";
// Ideally short strings (Rotate, Translate and Scale the object)
tool.transform = "変形";
// Ideally short strings (Translate the object)
tool.transform.move = "移動";
// Ideally short strings (Rotate the object)
tool.transform.rotate = "回転";
// Ideally short strings (Scale the object)
tool.transform.scale = "比率";
// Ideally short strings (Snap the object on another object surface)
tool.transform.snap = "スナップ";
// Ideally short strings (Measure distance between 2 points)
tool.measure = "計測";
// Ideally short strings (Lattice, deformer)
tool.lattice = "ラティス";
// If an option is shared among the tools
tool.all = "すべて";
// Ideally short strings (Quad Remesher)
tool.remesh = "クワッドリメッシャー";
tool.remesh.guides = "ガイド";
tool.remesh.density = "密度";
tool.remesh.same = "Same";
tool.remesh.half = "Half";
// Ideally short strings (FaceGroup)
tool.faceGroup = "フェースグループ";
tool.faceGroup.autoPick = "自動選択";
tool.faceGroup.flush = "未使用を削除";
tool.faceGroup.skip = "以下に基づいて小さいグループをスキップします：";
tool.faceGroup.skipFace = "面の数";
tool.faceGroup.skipFace.help = "面の数がこの閾値以下であれば新しいグループを作成しません。";
tool.faceGroup.skipArea = "表面積";
tool.faceGroup.skipArea.help = "新しいグループの表面積がこの閾値以下であれば新しいグループを作成しません。

閾値はオブジェクトの全体の表面積の割合として与えられます。";
// Ideally short strings (Hide)
tool.hide = "隠す";
// Ideally short strings (View tool, do nothing in particular)
tool.view = "表示";
// Ideally short strings (Revolving surface along a line)
tool.lathe = "レイズ";
// Ideally short strings (Revolving surface along a curve)
tool.tube = "チューブ";
// Ideally short strings (Insert object into the scene)
tool.insert = "挿入";
// Ideally short strings (Flip/Invert/Negate the shape)
tool.shape.flip = "反転";
// Ideally short strings (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "表示";
// Ideally short strings (Lasso selection)
tool.shape.lasso = "投げ縄";
// Ideally short strings (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "曲線";
// Ideally short strings (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "多角形";
// Ideally short strings (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "パス";
// Ideally short strings (Rectangular selection)
tool.shape.rectangle = "長方形";
// Ideally short strings (Ellipse selection)
tool.shape.ellipse = "楕円形";
// Ideally short strings (Line selection, split the screen in half)
tool.shape.line = "線";
// Ideally short strings (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "閉じています";

// Radius of the tool (size)
tool.radius = "半径";
// Intensity of the tool (force)
tool.intensity = "強度";

tool.settings = "設定";
tool.settings.none = "このツールには特定の設定がありません。";

tool.crease.pinchFactor = "ピンチの強度";
tool.crease.offsetFactor = "オフセット係数";

tool.layer.removeInfluence = "レイヤーのデータを使用";
tool.layer.removeInfluence.help = "このオプションはレイヤーが選択されている場合のみ有効です。

レイヤーのデータを使用して、ストローク上のディスプレイスメントを制限します。";
tool.layer.noLayerSelected = "このオプションはレイヤーが選択されている場合のみ利用できます";

tool.flatten.planeLockOrigin = "平面の原点をロック";
tool.flatten.planeLockNormal = "平面の方向をロック";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "同期";
tool.syncInstance.message = "新しいオブジェクトは他のすべてのインスタンスに追加されます！";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "ボーダーの頂点を接着";
tool.smooth.screen = "画面の平滑化";
tool.smooth.screen.help = "高ポリで独立したトポロジーの平滑化を行う場合、このオプションを使用してください。";
tool.smooth.screen.samples = "画面サンプル";
tool.smooth.taubin = "ボリュームを保持";
tool.smooth.taubin.shrink = "収縮";
tool.smooth.taubin.inflate = "膨張";
tool.smooth.stable = "安定したスムージング";
tool.smooth.stable.help = "スムージングがトポロジーに依存しないように試みます。

このモードは、トポロジー密度の変化が大きく、スムージング強度の値が高い場合に最適です。";

tool.paint = "ペイント";
// Erase the painting
tool.paint.erase = "消しゴム";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "レイヤーのフィルタリング";
tool.paint.layerFilter.help = "レイヤーのすでにペイントされている部分をペイントし直したい場合のみ、このオプションを使用してください。";

// Clear the painted mask
tool.mask.clear = "消去";
tool.mask.clearAll = "全てクリア";
// Invert the painted mask
tool.mask.invert = "反転";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "接続部分を反転";
// Blur the painted mask
tool.mask.blur = "ブラー";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "シャープ";
// Transform/Matrix
tool.matrix = "マトリクス";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.target = "ターゲット";
// Automatic
tool.matrix.target.auto = "自動";
tool.matrix.target.auto.help = "デフォルトで、このオプションは“グループ”オプションと似た動作をします。
メッシュにマスキングされている場合、または対称が有効な場合、 “頂点”と同じ動作をします。";
// Auto apply the transform on the vertices
tool.matrix.target.vertex = "頂点";
tool.matrix.target.vertex.help = "頂点で変換を適用します。未検証のプリミティブでは動作しません。
インスタンスも同様に影響を受けます。";
// Transform the object alone (the children stands still)
tool.matrix.target.object = "オブジェクト";
tool.matrix.target.object.help = "オブジェクトのみを移動します。対称とマスクは無視されます。
編集済みのノードのみが移動し、サブノードはそのまま残ります。";
// Transform the object and its children
tool.matrix.target.group = "グループ";
tool.matrix.target.group.help = "ノードを移動し、対称とマスクは無視されます。
階層の残りも同様に変換されます。";
// Operation on the mesh
tool.matrix.action = "操作";
tool.matrix.action.origin = "原点を移動";
tool.matrix.action.origin.help = "メッシュをワールドの原点に移動します。";
tool.matrix.action.bake = "ベイク";
tool.matrix.action.bake.help = "マトリクスを頂点に適用して、マトリクスをリセットします。視覚的には、何も変わらないはずです。";
tool.matrix.action.reset = "リセット";
tool.matrix.action.reset.help = "メッシュ変換を初期の状況にリセットします。";

// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "シアー";
tool.matrix.translation = "平行移動";
tool.matrix.rotation = "回転";
tool.matrix.scale = "比率";
tool.matrix.uniformScale = "比率を均一化";

tool.transform.tip = "第二指でシングルタップしてモードを切り替えます";

// Size of the gizmo
tool.gizmo.size = "ウィジェットのサイズ";
// If true, there is less spacing between gizmo handlers (rotate, scale, etc)
tool.gizmo.compact = "コンパクト";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "数値で入力";
tool.gizmo.allowInput.help = "Gizmoウィジェットの1つをタップすると、数値で入力できます";
// Angle threshold
tool.gizmo.linearRollThreshold = "タンジェント回転のしきい値";
tool.gizmo.linearRollThreshold.help = "線形または円形どちらかの回転方法を選択するための角度のしきい値。

このしきい値より上の値は円形の回転を使用します。

線形の回転 (タンジェントの方向) を優先したい場合は、単純にこの値を90°に設定してください。";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "操作時に隠す";
tool.gizmo.tap = "シングルタップ";
tool.gizmo.tap.help = "このオプションはカスタム回転軸モードでのみ有効です (“自動”が無効の場合)。";
tool.gizmo.tap.none = "なし";
tool.gizmo.tap.none.help = "メッシュをタップしても何も起きません。";
tool.gizmo.tap.normal = "標準";
tool.gizmo.tap.normal.help = "Move the gizmo on the first intersection and align it according to the surface normal.";
tool.gizmo.tap.first = "最初の交点";
tool.gizmo.tap.first.help = "最初の交点でGizmoを移動します。";
tool.gizmo.tap.medial = "中間点";
tool.gizmo.tap.medial.help = "最初の2つの交点を平均した場所でGizmoを移動します。";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "固定";
tool.lathe.axisOnly = "軸のみ";
tool.lathe.stable = "安定";
tool.lathe.axis = "軸";

// Fill the object's hole
tool.hole = "穴埋め";
tool.hole.fillHoles = "穴を埋める";
// synonym: Alternative method
tool.hole.method.fill = "埋める";
tool.hole.method.legacy = "レガシー";
tool.hole.method.boolean = "ブーリアン";
tool.hole.bridges = "画面空間のブーリアン";
tool.hole.bridges.help = "このオプションを有効にすると、体積に穴を開けられます。
カットしたスロープも、カットしている形状によりピッタリと追跡します。";
tool.hole.threshold = "しきい値 イプシロン";
tool.hole.threshold.help = "この値を調整することで穴埋めのアルゴリズムに役立つ可能性があります。";
tool.hole.smoothing = "穴のスムージング";

tool.smudge.quality = "クオリティ";
tool.smudge.quality.help = "プロジェクトされたピクセルの解像度を変更します。値が低いほどストロークが速いことを意味します。";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "シェイプ";
// Auto-validate the drawn shape
tool.shape.autoValidate = "自動検証";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "スクエア";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "中央揃え";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "円";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "中央揃え";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "ステップで回転";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "黃金比";
// volume of a mesh
tool.measure.volume = "メッシュのボリューム";
// Surface of a mesh
tool.measure.surface = "サーフェス";

// Always display the camera shortcut buttons on the viewport
tool.view.stickyCamera = "カメラショートカット（常時）";

// Topology
topology = "トポロジー";
// Synynom: detail value, density
topology.dynamic.detail = "ディテール";
// See glossary
topology.multires = "マルチレゾリューション";
topology.multires.help = "メッシュの解像度を複数残します。

低い方の解像度で変更を加えた場合、高い方の解像度のディテールは戻した時に再度投影されます。

レイヤーはそれぞれの解像度で利用できます。";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "反転";
topology.multires.reverse.confirm = "ベースの分割を作成できませんでした。

現在のトポロジーはおそらく分割の結果ではありません。";
topology.multires.subdivide = "分割";
topology.multires.subdivide.confirm = "メッシュに頂点が $0M できます。よろしいですか？";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "分割の上限を超えました。$0 をご覧ください";
topology.multires.deleteLower = "低い方を削除";
topology.multires.deleteHigher = "高い方を削除";
topology.multires.keepTriangles = "三角形を残す";
topology.multires.lock = "ロック (LV0)";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "マルチレスレベル →";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "Multires level ←";
// Synonym: Flat subdivision
topology.multires.linear = "線分割";
topology.multires.linear.help = "スムージングを適用しないでメッシュを単純に分割します。";
// Only show the lowest resolution wireframe
topology.multires.minWireframe = "レベル0のみ";
// Create a new object by recomputing a new topology
topology.remesh = "リメッシュ";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "ボクセルをリメッシュ";
topology.voxel.help = "グリッドでメッシュをサンプリングすることでリメッシュします。

オブジェクトが閉じていない (水密でない) 場合、穴埋めアルゴリズムが最初に適用されます。

レイヤーはリメッシュの後、再度プロジェクトされますが、クオリティは下がります。";
topology.voxel.resolution = "解像度";
topology.voxel.sharp = "シャープなエッジを残す";
topology.voxel.sharp.help = "このオプションは単純なプリミティブのブーリアンの操作で特に便利です。

端でスナップされたポイントが原因でエリアの一部に歪みが発生します。";
topology.voxel.subLevel = "マルチレゾリューションを構築";
topology.voxel.subLevel.help = "ボクセルのリメッシュの出力からマルチレゾリューションの階層を再構築できます。

また、これは高速で実行でき、メモリの使用も少なくすみます（特にボクセルのディテールの値が高い場合)。
しかし、ボクセルのディテールの値が低く、多くのマルチレゾリューションのレベルがある場合、ディテールを喪失します。";
// Dynamic topology (DynTopo)
topology.surface.remesh = "リメッシュ";
topology.surface.detail = "ディテール";
topology.surface.detail.help = "ボクセルのリメッシュとは異なり、サーフェスのリメッシュではメッシュを閉じる必要がありません。

また、マスクをサポートするので、メッシュ部分をトポロジーの変更から保護できます。

レイヤーは正しくアップデートされます。";
topology.surface.method = "方法";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "一意化";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "分割";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "デシメーション";
topology.surface.method.help = "ダイナミックトポロジーの動作:
• 一意化: ディテールの追加と削除
• 分割: ディテールを追加します
• デシメーション: ディテールを削除します";
topology.surface.useMasking = "マスクの部分を保護";
topology.surface.useMasking.help = "マスクの部分はトポロジーが変更されることから保護します。";
topology.surface.extrapolate = "頂点の外挿";
// DynTopo
topology.dynamic = "ダイナミックトポロジー";
topology.dynamic.global = "グローバルオン/オフ";
topology.dynamic.activate = "有効";
topology.dynamic.activate.help = "ダイナミックトポロジーを使うと、スカルプトツールはメッシュをローカルにリアルタイムで分割したり、単純化したりできます。

この機能はパフォーマンスに顕著な影響を与えます。

レイヤーは正しくアップデートされます。";
topology.dynamic.method = "ディテールの基となるもの…";
topology.dynamic.method.screen = "スクリーン";
topology.dynamic.method.radius = "半径";
topology.dynamic.method.constant = "一定";
topology.dynamic.method.help = "• ズーム
ディテールのレベルはサーフェスからどれくらい離れているかによります。

• 半径
ツールの半径はディテールの量を定義します。

• 一定
ディテールが固定され、ディテールの値はボクセルスライダーとも共有されます。";
topology.dynamic.quality = "優先する…";
topology.dynamic.quality.help = "“クオリティ”を選択した場合、2つの主な違いは:
• スカルプト操作の前に微調整が適用され、非常に小さいディテールをペイントまたはスカルプトする際に、補完するアーティファクトが少なくなります
• 微調整が増加的に適用されません。非常に小さいディテールをスカルプトする場合、またはすばやくストロークを実行する場合、トポロジーは常に正しく微調整されます";
topology.dynamic.quality.speed = "速度";
topology.dynamic.quality.quality = "クオリティ";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "半径に筆圧を使用";
topology.dynamic.usePressure.help = "筆圧をツールの半径に影響させ、ディテールのレベルに影響を与えたい場合、このオプションを使用してください。";
topology.dynamic.useFalloff = "ストロークのフォールオフを使用";
// Decimate
topology.decimate.title = "デシメーション";
topology.decimate.title.help = "ディテールをできるだけ多く残したままポリゴン数を減らします。

この機能は3Dプリント用に書き出したい場合、便利です。
しかし、スカルプトを続けたい場合、不規則な三角形を生成することがあるので、使用を避けることをお勧めします。 

注意：マスク部分はデシメイトされません。 ";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "デシメイト";
topology.decimatePaintWeight = "ペイントを保持";
topology.decimatePaintWeight.help = "値が高いほどペイントの保持を試みます。

ペイントに固執しない場合は、この値を 0 に設定してください。";
topology.decimateUniform = "面を均一化";
topology.decimateUniform.help = "値が高いほど、同じようなサイズの三角形を出力します。";
topology.decimatePreserveBorders = "境界を保持する";
topology.decimatePreserveBorders.help = "メッシュの境界を減少させないでください。";
// Target a certain number of triangles, faces and vertices
topology.target.triangles = "ターゲットの三角形";
topology.target.faces = "ターゲット面";
topology.target.quads = "ターゲットクワッド";
topology.target.points = "ターゲットポイント";
// Quad remesher
topology.qremesh = "クワッドリメッシュ";
topology.qremesh.angle = "クリース角度";
topology.qremesh.border = "境界を保持する";
topology.qremesh.onlyQuad = "クワッドのみ";
topology.qremesh.hole = "最大穴埋め";
topology.qremesh.hole.help = "
UV展開";

// Unwrapping means compute UV (texture coordinates), with uvs you can appliy (wrap) a texture onto the model
topology.uv.title = "UV 展開";
// UV Unwrap but as a Verb
topology.uv.unwrap = "展開";
// The operation can be very slow
topology.uv.atlas.warning = "非常に低くすることが可能です。ターゲット <100k 頂点！";
// Handles are topological holes (synonym: genus, hole)
topology.uv.bff.warning = "メッシュにハンドルがある場合、オーバーラップを持てます！";
// Solo patch
topology.uv.bff.seamless = "シームレスパッチ";
topology.uv.bff.seamless.help = "このオプションは重要な歪みを導入する可能性があります。

通常、フェイスグループが慎重に設定されている場合に使用できます。";
// Synonym: Point count? Singularity count ?
topology.uv.bff.cones = "円錐の数";
topology.uv.bff.help = "値が高いほど、複雑なオブジェクトの歪みを軽減します。

値が高いと計算にかかる時間は長くなります。";
topology.uv.delete = "UVを削除";

// Transfer the vertex painting in the texture, bake means "create texture (from mesh data)"
topology.bake.title = "ベイク";
// Bake here means "create texture (from mesh data)"
topology.bake.title.help = "テクスチャベイクは、シーン内の他の可視オブジェクトを投影してテクスチャを作成します。

ベイクの典型的なワークフローは以下の通りです：
• 細かいディテールとペインティングが施されたメッシュがあります
• それをクローンします
• 減少させます（`ペインティングを保持する`を0に設定！）
• UVアンラップします
• ベイクします！

これで、以前のオブジェクトのペイントやディテールのほとんどを保持した低解像度のメッシュが得られるはずです。

操作後、頂点カラーは新しい無効なレイヤーに移動されるので、色付きテクスチャに対して乗算されるのではなく無視されます。

ベイクに使用するオブジェクトを選ぶためのロジックは以下の通りです:
- 選択されたすべてのオブジェクトと、シーンメニューで最も強調表示されているメインの選択オブジェクトがベイクされます
- 1つのオブジェクトだけが選択されている場合、Nomadはすべての表示されているオブジェクトを考慮します
- すべてのオブジェクトが隠されている場合（例えば、<b>Solo</b>を使用して）、シーン全体が考慮されます";
// Bake here means "create texture (from mesh data)"
topology.bake.self = "自分自身から";
// Bake here means "create texture (from another mesh data)"
topology.bake.other = "高解像度から";
topology.bake.resolution = "解像度";
// Cage is a specific term, synonyom: "Bake offset"
topology.bake.offset = "レイオフセット";
topology.bake.radius = "ケージ半径";
// Bake opacity (from mask data)
topology.bake.opacityFromMask = "マスク -> 不透明度";
topology.bake.backup = "バックアップ";

// project a high resolution mesh details onto another
topology.reproject.title = "リプロジェクト";
topology.reproject.title.help = "最も近い可視オブジェクトから、彫刻されたディテール、ペインティング、レイヤーをプロジェクトします。

これは通常、クリーンなトポロジーを持つ高解像度メッシュにも使用されます。";
// tweaking value
topology.reproject.rayBias = "レイバイアス";
topology.reproject.rayBias.help = "リプロジェクションには2つの方法が使用されます：
• 最も近い：表面上の最も近い点
• レイ：法線方向を通る交点

バイアス値が高いほど、最も近い表面ではなくレイ交点を優先します。";
topology.reproject.normalOffset = "ノーマルオフセット";
topology.reproject.shpereCast = "スフィアキャストフォールバック";
topology.reproject.shpereCast.help = "通常のレイリプロジェクションが失敗した場合、Nomadは最近接表面交差にフォールバックします。";
// number of iteration the algorithm will take
topology.reproject.iterations = "反復回数";
topology.reproject.relax = "リラックス";
topology.reproject.relax.help = "メッシュがローポリの場合、リラックスを優先すべきです。";
topology.reproject.layers.help = "他のレイヤーを選択したメッシュに転送します。";

topology.manifold = "多様体";
topology.nonManifold = "非多様体";
topology.manifold.clean = "クリーン";
topology.manifold.collapse = "小さな面を削除";
topology.manifold.title = "フォース・マニフォールド";
topology.manifold.title.help = "非マニフォールドエッジのクリーンアップを試みます。

2つ以上の面が共通しているエッジをサポートしていない外部ソフトウェアに役立つ場合があります。";

// Reset key-bindings/shortcuts
binding.reset = "バインドをリセット";
// Add node in a sync mode (synchronize instance)
binding.addSync = "同期";
binding.addSync.help = "デフォルトでは、シーンメニューで設定された同期値を使用します。";
// Add node in a sync mode (synchronize instance)
binding.float.position = "位置";
binding.float.position.keep = "前回を保持";
binding.float.position.cursor = "カーソル上";
// Binding option
binding.context.toggle = "コンテキストの切り替え";
// quick sidebar tool shortcuts
binding.quicks = "クイックショートカット";
// quick regular tool shortcuts
binding.tools = "ツールショートカット";
// When the key is tapped once, the value will be toggled
binding.toggle = "前のツールに切り替える";
binding.toggle.help = "同じバインディングを使って最後のツールに戻ります。";
// Control if hold+release reverts the tool
binding.revert = "保持して戻す";
binding.revert.help = "保持したキーを放すと、前のツールに戻るかどうかを選択します。";
// sticky keys
binding.sticky = "固定キー";
binding.sticky.off = "押す";
binding.sticky.off.help = "キーを押し続けてツールを使用し、離して前のツールに戻ります。";
binding.sticky.on = "切り替える";
binding.sticky.on.help = "一度押してツールを切り替えます。";
binding.sticky.quick = "クイックプレス";
binding.sticky.quick.help = "一時的に使用するには押し続け、クイックプレスで切り替えます。";
// The binding force camera movement
binding.forceCamera = "カメラを強制する";
binding.forceCamera.help = "別のバインディングとの競合がある場合にカメラのインタラクションを強制します。

通常、同じバインディングがツールのショートカットキーや追加/減算に割り当てられているときに発生する可能性があります。";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickMaterial = "マテリアルピッカー";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickFaceGroup = "フェースグループを選択";
// Edit the tool brush size/radius
binding.editRadius = "ツールの半径";
// Inverse direction zooming
binding.invertZoomY = "ズームYを反転";
// Edit the tool brush size/radius
binding.editIntensity = "ツールの強度";
// Controller dead zone
binding.joystick = "ジョイスティック";
binding.controller.deadZone = "スティックのデッドゾーン";
binding.controller.deadZone.help = "コントローラースティックが触れられていない場合でもカメラが動く場合、この値を上げてください。";
// Snap the camera
binding.view.front = "フロントビュー";
binding.view.left = "左ビュー";
binding.view.top = "トップビュー";
// Move/Translate the view
binding.pan.left = "左にパン";
binding.pan.right = "右へパン";
binding.pan.forward = "前へパン";
binding.pan.backward = "後へパン";
binding.pan.up = "上へパン";
binding.pan.down = "下へパン";
// Snap the view (while rotating)
binding.snapViewOnRotate = "スナップビュー (回転中)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "開く (プロジェクト)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "追加 (プロジェクト)";
// Select all the objects in the scene
binding.selectAll = "すべてを選択";
// Rotate environment and the lighting
binding.rotateLighting = "ライティングを回転";
// The Camera pivot is the point around which the camera rotates
binding.updatePivot = "回転軸";

quadremesh.adaptQuadCount = "アダプティブ・クワッド数";
quadremesh.curvatureAdaptivness = "アダプティブサイズ";
quadremesh.curvatureAdaptivness.help = "100%では、オブジェクトの曲率に応じてクワッドのサイズが変わり、高曲率部分ではより小さいクワッドになります。
0%では、クワッドのサイズは均一になります。";
quadremesh.useVertexColors = "ペイントを保持";
quadremesh.autoDetectHardEdges = "ハードエッジの自動検出";
quadremesh.autoDetectHardEdges.short = "ハードエッジ";
quadremesh.reprojectVertex = "頂点の再投影";
quadremesh.reprojectVertex.short = "頂点の再投影";
quadremesh.reprojectVertex.label = "有効にすると、Nomadは前のメッシュ上の位置を再投影します。

メッシュにレイヤーがある場合、再投影は常に使用されます。";

// Privacy policy
privacyPolicy.title = "プライバシーポリシー";
privacyPolicy.reject = "拒否";
// Hexanomad is the company name
privacyPolicy = "HexanomadはNomad Sculptからいかなるデータも収集しません。";

sonar.disconnect = "ソナーペンの切断";
sonar.connect = "ソナーペンの接続";
sonar.connect.confirm = "ソナーペンを接続しますか？";
sonar.connect.confirm.warning = "ソナーペンはマイク（オーディオループバック）を使用してペンの圧力を検出します。";

// Color disc mode
widget.color.disc = "ディスク";
widget.color.ring = "リング";
widget.color.square = "スクエア";

nomad.mainFolder = "Nomadメインフォルダ";
nomad.mainFolder.help = "ファイルをNomadメインフォルダに追加した場合、変更を適用するにはNomadを再起動してください。

サブフォルダに誤ったタイプのファイルがある場合は、can_be_deleted/ に移動されることがあります。

例えば、プロジェクトフォルダは3Dファイルのみを受け入れ、アルファやマットキャップは画像のみを受け入れます。";
nomad.mainFolder.warning = "ファイルはそのままにしておきます。
コピー、削除、移動はしません。";
nomad.mainFolder.error = "はいを選択すると、Nomadは閉じて、簡単に再起動できます。";

license.title = "ライセンス";
license.retry = "再試行";
license.key = "ライセンスキー";
license.activate = "ライセンスを有効化";
// ----------------------------------------------
license.newest = "新しいバージョンが利用可能です！";
license.encrypt.error = "暗号化できませんでした！";
// ----------------------------------------------
license.grace = "オフライン - 残りの猶予期間:";
license.grace.hours = "時間";
license.grace.days = "日";
// ----------------------------------------------
license.portal.title = "既存のユーザー";
license.portal.label = "ライセンスポータル";
// ----------------------------------------------
license.checkout.title = "新しいユーザー";
license.checkout.label = "Nomadを購入";
// ----------------------------------------------
license.device.error = "デバイスIDを取得できませんでした。";
license.device.mismatch = "デバイスIDが一致しません！";
// ----------------------------------------------
license.error429 = "リクエストが多すぎます（待ってください）。";
// ----------------------------------------------
license.validate.error404 = "ライセンスキーが見つかりませんでした。";
license.validate.error422 = "処理できないエンティティ。";
// ----------------------------------------------
license.activate.error403 = "最大数のデバイスに達しました！
ライセンスポータルで他のデバイスのアクティベーションを解除できます。";
license.activate.error404 = "ライセンスキーが見つかりませんでした。";
license.activate.error422 = "処理できないエンティティ。";
// ----------------------------------------------
// version
version.update = "アップデート可能！";
version.restore = "購入の復元";
version.buyWeb = "ウェブバージョンはデモ目的のみに利用できます";
version.buyFull = "フルバージョンにアップグレード";
// ----------------------------------------------
// QuadRemesh
version.qr.unlock = "ロック解除 (購入、復元、トライアル)";
version.qr.desktop = "デスクトップでは、QuadRemesher は Hexanomad によって配布されますが、Hexanomad は販売やライセンスを扱っていません。
すべてのライセンス管理は Exoside によって行われます。";
version.qr.buy = "購入";
version.qr.promo = "
Quad Remesherは四角形を主体とするメッシュを出力するアルゴリズムです。
四角形の分布はオブジェクトの自然な曲率に沿って試みます。

アルゴリズムは局所的な曲率に応じて四角形のサイズを適応させることもできます。

以下のガイドを使用してトポロジーを誘導することもできます：

• フェースグループ $0（より良い結果のために、その境界をスムーズにしてください！）

• 平面X/Y/Z対称性 $1

• カーブガイド $2

• 密度ペインティング $3

Quad Remesherは https://exoside.com/ によって開発されました。";
// ----------------------------------------------
version.trialLayer = "お試し版: メッシュごとに1 レイヤーのみ";
version.trialNoExport = "お試し版: 書き出し機能は使用できません";
// ----------------------------------------------
version.fullFeatures = "• 一括購入
• 取り消し/やり直しの上限なし
• 無制限のレイヤー
• 書き出し & 読み込み";
// ----------------------------------------------
version.demo.purpose = "このバージョンはデモ用として特別に開発されたものです。";
version.demo.disable = "このデモでは機能が有効になっていません。";
// ----------------------------------------------
version.demo = "デモテスト";
version.demo.sculpt = "スカルプト";
version.demo.sculpt.help = "すべてのブラシが利用可能ですが、保存やエクスポートはできません。

このモードは主にブラシを試すか、圧力サポートをテストするために設計されています。

他の機能も制限される場合があります（履歴、レイヤー）。";
version.demo.file = "インポート＆エクスポート";
version.demo.file.help = "モデルのインポートとエクスポートは可能ですが、スカルプトブラシは無効です。

このモードは、モバイルメモリ制約で大きな.nomプロジェクトを開けないモバイルユーザーにとって特に便利です。";
// ----------------------------------------------
// app store main page
store.name = "Nomad Sculpt";
store.headline = "3Dで彫刻し、ペイントし、作成する";
store.tag = "sculpt, 3d, nomad, paint, modeling, 彫刻, ペイント, モデリング";
// ----------------------------------------------
store.description.sculpt = "• 彫刻ツール
クレイ、フラット化、スムーズ化、マスクなどのブラシで作品を形作ります。
ハードサーフェス用途には、ラッソ、長方形などの形状を使ったトリムブーリアンカッティングツールも使用できます。";
// ----------------------------------------------
store.description.stroke = "• ストロークのカスタマイズ
フォールオフ、アルファ、タイリング、ペンシル圧力などのストロークパラメーターをカスタマイズできます。
ツールのプリセットを保存して読み込むこともできます。";
// ----------------------------------------------
store.description.paint = "• ペイントツール
頂点ペインティングで色、粗さ、メタルネスを扱います。
マテリアルプリセットも簡単に管理できます。";
// ----------------------------------------------
store.description.layer = "• レイヤー
彫刻およびペイント操作を個別のレイヤーで記録し、作成プロセス中に簡単に反復できます。
彫刻およびペイントの変更が記録されます。";
// ----------------------------------------------
store.description.multires = "• マルチレゾリューションスカルプティング
柔軟なワークフローのためにメッシュの複数の解像度間を行き来します。";
// ----------------------------------------------
store.description.voxel = "• ボクセルリメッシュ
メッシュをすばやくリメッシュして、一様の詳細レベルを取得します。
作成プロセスの始めに大まかな形をすばやくスケッチするために使用できます。";
// ----------------------------------------------
store.description.dynamic = "• ダイナミックトポロジー
ブラシの下でメッシュを局所的に精製して、自動的な詳細レベルを得ます。
レイヤーもそのまま保持でき、自動的に更新されます！";
// ----------------------------------------------
store.description.topology = "• デシメート
できるだけ多くの詳細を保持しつつ、ポリゴン数を減らします。";
// ----------------------------------------------
store.description.group = "• フェイスグループ
フェイスグループツールを使用して、メッシュをサブグループに分割します。";
// ----------------------------------------------
store.description.unwrap = "• 自動UVアンラップ
自動UVアンラッパーは、アンラッピングプロセスを制御するためにフェイスグループを使用できます。";
// ----------------------------------------------
store.description.baking = "• ベーキング
頂点データ（色、粗さ、メタルネス、小規模な詳細）をテクスチャに転送します。
また、テクスチャデータを頂点データやレイヤーに転送することも可能です。";
// ----------------------------------------------
store.description.primitive = "• プリミティブ形状
円筒、トーラス、チューブ、旋盤などのプリミティブを使用して、新しい形状をすぐに始めることができます。";
// ----------------------------------------------
store.description.rendering = "• PBRレンダリング
デフォルトで美しいPBRレンダリングを提供します。光と影があります。
彫刻の目的でより標準的なシェーディングにしたい場合は、いつでもMatCapに切り替えることができます。";
// ----------------------------------------------
store.description.postprocess = "• ポストプロセス
スクリーンスペースリフレクション、奥行きの深さ、アンビエントオクルージョン、トーンマッピングなど";
// ----------------------------------------------
store.description.files = "• エクスポートとインポート
サポートされるフォーマットには、glTF、OBJ、STL、PLYファイルが含まれます。";
// ----------------------------------------------
store.description.interface = "• インターフェース
モバイルエクスペリエンス用に設計された使いやすいインターフェース。
カスタマイズも可能です！";
// ----------------------------------------------
store.description.remesher = "• クアッドリメッシャー（アプリ内購入のみ）
オブジェクトをメッシュ曲率に沿ったクアッド主体のメッシュで自動的にリメッシュします。
ガイド、フェイスグループ、密度ペインティングがサポートされています。";
// ----------------------------------------------