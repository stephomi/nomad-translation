// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "Confirm?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Yes";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "Ok";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Cancel";

// Name of an item (object, tool, etc)
item.name = "Name";
// Add a new item (object, tool, etc)
item.new = "New";
// Rename an item (object, tool, etc)
item.rename = "Rename";
// Add a new item (object, tool, project, etc)
item.add = "Add";
// Save an item (object, tool, etc)
item.save = "Save";
item.save.confirm = "Confirm save?";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Last save";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "Load last save?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Reset";
item.reset.confirm = "Confirm reset?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "Instance";
// Uninstance the object, make the object real
item.uninstance = "Un-instance";
// Clone an item (object, tool, etc)
item.clone = "Clone";
// Delete an item (object, tool, etc)
item.delete = "Delete";
item.delete.confirm = "Confirm deletion?";
item.delete.confirm.yes = "Yes, delete";
// When we delete the item but the image is used somewhere
item.delete.imageUsed = "Used by the following tools:";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "To Node";
// Item visibility (object, layer, etc)
item.visible = "Visible";
// Show an item (object, layer, etc)
item.show = "Show";
// Hide an item (object, layer, etc)
item.hide = "Hide";
// Select an item (object, layer, etc)
item.select = "Select";
// Unselect an item (object, layer, etc)
item.unselect = "Unselect";
// Merge an item with another one below (layer)
item.mergeDown = "Merge down";
// The order of an item in a list
item.order = "Order";
// Focus on previous item
item.previous = "Previous";
// Focus on next item
item.next = "Next";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "Lock";

// Three-state toggle button (Auto, Off, On)
toggle.on = "On";
// Three-state toggle button (Auto, Off, On)
toggle.off = "Off";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "Auto";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Missing thumbnails, reprocessing files... ($0/$1)

$2";
loading.reprocess.cancel = "Skip thumbnails generation?";

// Color of an object
material.color = "Color";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "Roughness";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "Glossiness";
// Whether the material is a metal or not
material.metalness = "Metalness";
// How much light a surface will reflect
material.specular = "Specular";
// Light that the surface can emit (glow)
material.emissive = "Emissive";
// Normal map (synonym: detail, bump)
material.normal = "Normal";
// Ambient Occlusion (AO)
material.occlusion = "Occlusion";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "Textures";

// Minify
about.minify = "Minify UI";
about.minify.help = "You can also tap your screen with 4 fingers, if your device supports it.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Turntable";
// Make the entire scene turn around (speed of the animation)
about.turntableSpeed = "Turntable Speed";
// Stuffs that I used to make the app
about.credits = "Credits";
// Link to open source projects that I used for the app
about.credits.openSource = "Open-Source";
// Only translate the &
about.credits.arts = "MatCaps & HDRIs";
// Change languages of the app
about.languages = "Languages";
about.languages.help = "Translation files available at $0";
// Link to the App Website
about.website = "Website";
// Link to the App Forum
about.forum = "Forum";
// Link to the App Manual
about.manual = "Manual";
// Link to the App Email
about.mail = "Support";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";

// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "The object has no holes!";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "The current object is invisible!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Nothing to trim.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Abort trim: the object is fully trimmed.";
// In order to extract something, the mesh needs to have painted mask
alert.mask.noExtract = "Nothing to extract!";
// In order to split something, the mesh needs to have painted mask
alert.mask.noSplit = "Nothing to split!";
// List of disabled features when View Mode is selected
alert.view.disabled = "Features disabled in View Mode:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Primitive widgets";
// The object needs to have two parts disconnected
alert.separate.fail = "Could not separate: the object has only one part!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "Remeshed!";
alert.voxelRemesh.empty = "Abort remesh: result mesh has no faces.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "Invalid input!";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "The object will be duplicated";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "The object will be instanced";
// A pivot refers the gizmo 3d position
alert.gizmo.usePivot = "Use custom pivot.";
// A pivot refers the gizmo 3d position
alert.gizmo.useAuto = "Use automatic pivot.";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Edit pivot mode.";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "Edit object mode.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Dynamic topology ON";
// See Glossary (DynTopo)
alert.dynamic.disable = "Dynamic topology OFF";
alert.colorPicker = "Drag your finger on the object to pick a color.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Simple tap to exit transform mode.";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "Simple tap to exit edit symmetry mode.";
alert.view.reset = "Reset view";
// Snap the view to the nearest aligned 90° angle
alert.view.snap = "Snap view";
// Show the painted mask on the mesh
alert.mask.show = "Show mask";
// Hide the painted mask on the mesh
alert.mask.hide = "Hide mask";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Lock selection";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Unlock selection";
// Hide the objects that are not selected
alert.selection.isolate = "Isolate selection";
// Show the objects that are hidden
alert.selection.showAll = "Show all";
// Project quick saving
alert.quickSave = "Saving...";
// Painting on the object was hidden but the user did paint the object
alert.forceShowPainting.fill = "Show painting activated, [Paint all] was used.";
// Painting on the object was hidden but the user started to paint on the object
alert.forceShowPainting.tool = "Show painting activated, the object was painted.";
// See Glossary (Multiresolution)
alert.multiresLost = "Multiresolution will be lost!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "The detail value is high and might require lot of memory!";
// Autosave popup
alert.autoSave.auto = "Autosave in... $0s";
// The selected object doesn't have any layers
alert.needLayer = "The current tool requires an active layer.";
// The user decides to hide the painting on the objects
alert.paintingHidden = "Painting hidden: show it again in Settings panel.";
// The selected object doesn't have any layers
alert.noPartialWireframe = "Partial drawing is disabled when wireframe is displayed.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Consider using orthographic camera if you want to avoid perspective frustum distortion when using screen projector.";
// Trial version has a limited number of undo
alert.state.trial = "Trial version: undo canceled";

background = "Background";
// A flat color will be displayed in the background of the scene
background.color = "Color";
// The environment (HDRI) will be displayed in the background
background.environment = "Environment";
background.blur = "Blur";
background.exposure = "Exposure";

// Image that the artist uses as a reference
background.imageEnable = "Reference image";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Overlay";
// Opposite of transparency (Alpha)
background.imageAlpha = "Opacity";
background.imageReset = "Reset settings";
background.imageTransform = "Transform";
// X screen coordinate of the image reference
background.imageX = "Position X";
// Y screen coordinate of the image reference
background.imageY = "Position Y";
// Rotation of the reference image
background.imageRotation = "Rotation";
// Scale of the reference image
background.imageScale = "Scale";

// Camera (point of view in 3d)
camera = "Camera";
// Copy the views
camera.updateView = "Update view point?";
// Add a new camera
camera.addView = "Add View";
// Focus on the camera
camera.focus = "Focus";
// Add on the camera camera
camera.focusOn = "Focus on $0";
// Camera projection, Orthographic or Perspective
camera.projection = "Projection";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Orthographic";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Perspective";
// camera Vertical Field of View
camera.fov = "Vertical Fov";
// Camera Field of View hint
camera.focal = "focal $0mm (35mm sensor)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Rotation";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "Turntable";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Trackball";
camera.rotation.trackball.help = "Trackball gives more degree of freedom you can also roll the camera with 2 fingers.";
// Camera interaction mode, 1st person view
camera.firstPerson = "First Person";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Speed";
// Camera rotation sensitivity
camera.speed.rotation = "Rotation";
// Camera panning sensitivity
camera.speed.panning = "Panning";
// Camera zooming sensitivity
camera.speed.zooming = "Zooming";
// Reset camera position
camera.resetView = "Reset view";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Snap view";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "Camera is snapped (orthographic)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "Orthographic snap";
camera.snapOrthographic.help = "This option also works when using the Snap Cube in the corner.";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Update pivot...";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Double tap on object";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Double tap on background";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "Toggle";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "Selection";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "Scene";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "When double tapping";
camera.doubleTapPivot.help = "Update the rotation pivot when double tapping on the object surface.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "Allow air pivot";
camera.airPivot.help = "Allow new pivot even when zooming outside the object surface.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "When camera starts moving";
camera.autoPivot.help = "Update the pivot when you start interacting with the camera.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Focus";
camera.doubleTapFocus.help = "When double tapping on the object, the camera will pan and focus on the picked point.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "Multiselection";
// There is 0 nodes/items selected
context.noSelection = "No selection";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "Preset";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "Spline";

// Debug option, the newly created primitives will contains texture coordinates (UVs)
debug.uvPrimitive = "Keep primitive UVs";
debug.uvPrimitive.warning = "Disable this option if you don't need UVs (extra memory).";
debug.uvPrimitive.help = "For now, only Box and Sphere are supported.

Other types will be supported in the future.";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "Normalize UVs";
debug.uvNormalize.help = "Nomad will normalise the UVs inside the [0-1] tile.";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "Add BFF UVs";
debug.uvBFF.help = "Add an alternative unwrapping method (boundary first flattening).

Note that BFF will produce overlaps if your mesh topology is different than a disk or a sphere.";
// Debug option, display an window with some debugging logs
debug.logs = "Logs";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Heightmap";
// Debug options, graphical stuffs
debug.graphics = "Graphics";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Make store thumbnails";

// Empty list: there is no projects
file.project.empty = "You have no saved project yet!";
// The current opened project has some unsaved changes
file.project.unsaved = "Unsaved changes!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "You will lose unsaved changes!";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Preview of the last manual save";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "Trial version: You won't be able to re-open the current project!";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "Trial version: you can only re-open your current project!";

file.project = "Project";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Save";
// E.g: Save "my_project"?
file.project.save.confirm = "Save $0?";
// Save to another project (either new one or overriding existing one)
file.project.saveAs = "Save As";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "Overwrite $0?";
// Open a project
file.project.open = "Open";
// E.g: Open "my_project"?
file.project.open.confirm = "Open $0?";
// Load another project and add/append all its data to the current scene
file.project.add = "Add to scene";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "Add $0 to the scene?";
// Reset the scene and create a new project
file.project.new = "New";
file.project.new.confirm = "Create new scene?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "Delete $0?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "Delete $0?

This is the current active project!";

// Auto save section
file.project.autoSave = "Auto Save";
file.project.autoSave.confirm = "Disable Auto Save?";
file.project.autoSave.help = "Save your project in a separate file at regular interval.
The autoSave file can be found in:

$0";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "Popup timeout";
// In minutes
file.project.autoSave.minutes = "Timer popup";
// Delete the current autoSave data
file.project.autoSave.delete = "Discard Auto Save";

// Load interface preference settings when opening a scene file
file.load.guiSettings = "Keep gui settings";
file.load.guiSettings.help = "When opening or importing a project file, all the gui-related settings embedded in the project will be loaded.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.load.objSplitByGroup = "Split OBJ by groups";
file.load.objSplitByGroup.help = "When enabled, Nomad will split the OBJ groups into separate objects.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.load.mergeLayers = "Merge Layers";
// Ignore the textures present in the file to load
file.load.skipTextures = "Skip textures";
// Do not fiddle with the object topology when loading the file
file.load.keepTopology = "Keep topology";
file.load.keepTopology.help = "Use this option if you don't want Nomad to fiddle with the topology of imported mesh.

It will disable vertex/face reordering, removal of vertex/face duplicates and removal of unused vertices.";
// If the object has more vertices than this value, then we won't attemp to reverse (multiresolution) the object
file.load.reverseVertices = "Reverse threshold";
file.load.reverseVertices.help = "In order to use less memory, Nomad doesn't save the lower resolution of a mesh.

However it will rebuild the lower resolution if the number of vertices is lower than this threshold.";


// Configure imports option
file.importSettings = "Import options";

// Import file section
file.import.title = "Import";
file.import.title.help = "Supported format:
- Wavefront (.obj)
- glTF 2.0 (.glb .gltf)
- STL (.stl)";
// The user imports a scene file that will replace the current scene
file.import.open = "Open";
file.import.open.confirm = "Import new file?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Add to scene";
file.import.add.confirm = "Import new file?";

// Export scene file
file.export.title = "Export";
file.export.title.help = "If possible favor glTF export as it supports more features than other formats.";

// Export the current selected objects instead of the entire scene
file.onlySelection = "Only include selected objects";
file.onlySelection.help = "Only include the selection, instead of the entire scene.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Reconstruct quad";
file.convertToQuad.help = "Reconstruct quads from triangles by pairing triangle (if they are adjacent in the files).";

// Whether we include the textures in the exported file
file.export.texture = "Export textures";
// Baking means transfering/converting 
file.export.texture.help = "This option doesn't bake vertex colors into textures.";
// Whether we include normals vector in the exported file
file.export.normal = "Export normals";
file.export.normal.help = "Check this option if you want to open the file in another softwares.

Nomad always ignore the normals as it will recompute them.";

file.export.gltf = "Export glTF 2.0";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Export layers";
file.export.gltf.layer.help = "Export layers as morphs. Officially supported by glTF so it should work on other softwares as well.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Export layer paint";
file.export.gltf.layerPaint.help = "Export layer painting. It is usually ignored by other softwares.";
// Whether the exported layer will use the non-standard Nomad encoding (smaller size)
file.export.gltf.layerNomad = "Nomad layer encoding";
file.export.gltf.layerNomad.help = "Can make the file smaller by writing paint layer in 8-bit instead of 16-bit.

This encoding only works in Nomad as it will use absolute painting.
Other softwares will have incorrect result as glTF requires relative encoding.";
// Whether we include the vertex color in the exported file
file.export.gltf.color0 = "Export vertex colors";
file.export.gltf.color0.help = "Export vertex colors. Officially supported by glTF so it should work on other softwares as well.";
// Whether we include the vertex roughness and vertex metalness in the exported file
file.export.gltf.color1 = "Export pbr paint";
file.export.gltf.color1.help = "Export roughness, metalness and mask painting. This will be ignored by other softwares.";

file.export.obj = "Export OBJ";
file.export.obj.warning = "Layers and extra painting (roughness metalness and mask) will be lost.";
// Whether we include the vertex color in the exported file
file.export.obj.colorAppend = "Export vertex colors";
file.export.obj.colorAppend.help = "Append color information after vertices.

Some 3d softwares will be able to read it but not all of them.";

file.export.stl = "Export STL";
file.export.stl.warning = "Layers and extra painting (roughness metalness and mask) will be lost.";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Export vertex colors";
file.export.stl.color.help = "Some 3d softwares will be able to read it but not all of them.";
file.export.stl.ascii = "By default the format is binary.

You can choose to export to text format (ASCII) but the file will be bigger.";

// Advanced settings
settings.advanced = "Advanced";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "These options are not saved in the settings.";
settings.reset.title = "Settings";
settings.reset.title.help = "It will reset the app preference settings.

Some resources are saved separately and will NOT be resetted, it includes:
- Projects
- Key Bindings
- Tools Presets
- HDRs Environments
- MatCaps
- Alphas
- Textures (brush)
- Reference Images

Note that everything linked to the project will be kept intact, such as lighting, Post Process, camera views, etc";

// Reset preference settings button
settings.reset = "Reset to default";
settings.reset.confirm = "Reset preference settings?";

// Render a screenshot of the scene
file.render = "Render";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Show interface";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Render ratio";
file.render.renderRatio.help = "A value of 1.0 means that Nomad will render at the same resolution as the requested image size below.

Use this option if you cannot render at certain resolution (crashes because of lack of memory).";
// Desired size of the exported screenshot
file.render.size = "Final size";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Custom";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "screen";
// width of exported screenshot
file.render.width = "Width";
// height of exported screenshot
file.render.height = "Height";
// export screenshot of the scene
file.render.export = "Export png";
file.render.warn = "The export resolution is high ($0x$1)!

Make sure to save your project in case your device runs out of VRAM and crashes.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Transparent background";
file.render.transparent.help = "This option can be useful if you want to insert the mesh in a 2d creation software.

Partial object transparency is not supported for now.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Use global settings";
pressure.useGlobal.help = "By default, the tools share the same pressure settings.

Uncheck this option if you want specific pressure settings for this tool.";

// Pencil pressure
pressure.title = "Pressure";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "This tool doesn't use pencil pressure.";
// The tool can support pressure but its selected stroke type will ignore it 
pressure.noGrab = "Grab stroke type will ignore pressure settings.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Radius";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Intensity";

// Customize whether finger and/or stylus can move the Camera
gesture.cameraInteraction = "Camera:";
// Customize whether finger and/or stylus can sculpt on object
gesture.sculptInteraction = "Sculpt:";
// Both the finger and the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.fingerAndStylus = "Finger and Stylus";
// Only the finger can perform a certain action (move camera, sculpt, etc)
gesture.interaction.finger = "Finger";
// Only the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.stylus = "Stylus";
// Disable the action
gesture.interaction.none = "None";
// Allow the action for any inputs
gesture.interaction.any = "Any";

// long press to pick the color/material under the cursor
gesture.materialPicking = "Material picking";
gesture.materialPicking.help = "The color/material picker can be triggered by long-pressing on the canvas.

Note that it only work if the current brush has painting enabled."

// Three fingers on screen
gesture.three.title = "Three fingers";
// Drag 3 fingers horizontally on the canvas to rotate the environment, lights and MatCap
gesture.fingerLighting = "Rotate lighting (3 fingers)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerLighting.help = "Drag 3 fingers horizontally on the canvas to rotate the environment, lights and MatCap.";
// Drag 3 fingers vertically to edit the tool radius
gesture.fingerRadius = "Edit tool radius (3 fingers)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerRadius.help = "Drag 3 fingers vertically on the canvas to edit the tool radius.";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.fingerSmooth = "Finger always smooths";
gesture.fingerSmooth.help = "This option is only active if a sculpting tool is active.";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Allow unrecognized pressure";
gesture.unknownPressure.help = "Check this option if the pressure doesn't work with your pencil or if you need pressure finger.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Pencil button";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Pencil double tap";
gesture.pencilAction.ios.help = "Only active for Apple Pencil 2nd gen.";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "None";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Add/Sub";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "One tap shortcuts";
gesture.mask.oneTap.help = "Allow the Mask shortcut by tapping the screen once, without having to hold the mask button shortcut.

It will allow the following gesture:
- tap on the background to invert the mask
- tap on a masked area to blur the mask
- tap on an unmasked area to sharpen the mask";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress = "Long press (Mask ↔ SelMask)";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress.help = "When Mask or SelMask is active, long press finger to toggle between those tools.

If you long press without moving the finger, the new tool will be used as the default mask shortcut.";
// Indicator that the tool has been set as the new shortcut
gesture.mask.infoShortcut = "$0 set as mask shortcut.";

// Shortcuts to undo/redo
gesture.history = "History shortcuts";
gesture.history.help = "- Undo: tap with 2 fingers
- Redo: tap with 3 fingers
- Undo/Redo: hold 2/3 fingers down (continuous)";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Palm rejection";
gesture.palmRejection.confirm = "Make sure to disable this option if you have trouble interacting with the canvas!";
gesture.palmRejection.help = "Reject input if the contact area size larger than this value.

Might not work on every device.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Max size threshold";

// History, list of undo/redo
history = "History";
// First "undo" state
history.root = "Root";
history.undoConfirm = "Do you confirm undoing all these operations?";
history.undoWarning = "If you make an edit afterwards you might lose lot of changes.";
// Settings concerning the history stack of undo/redo
history.stack = "Stack";
// Actions to include in the undo/redo stack
history.include = "Include actions";
// include lighting editing in the undo/redo
history.includeLights = "Lights";
history.includeLights.help = "If this option is disabled, moving the lights with the Gizmo will still be included, as it can impact other objects in the scene hierarchy.";
// include postProcess editing in the undo/redo
history.includePostProcess = "PostProcess";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCaps & HDRIs";
// Can limit the stack of undo/redo size
history.limitSize = "History limit (Mb)";
history.limitSize.help = "Maximum size (in Mb) of the history.

The history will be updated on the next recorded operation.";
// Limit the number of undo in the history stack
history.limitStack = "Stack limit";
history.limitStack.help = "Maximum number of operation the application can keep.

The history will be updated on the next recorded operation.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Maximum undoable";
history.rangeProtect.help = "If you go far in the history, it will prompt a confirm dialog before undoing many operations.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Restore camera";
history.restoreCamera.help = "Enable this option to restore the saved camera viewpoint when you undo/redo an action.";
// Undo
history.undo = "Undo";
// Redo
history.redo = "Redo";
// Shown during undo
history.state.undo = "Undo: $0";
// Shown during redo
history.state.redo = "Redo: $0";
// Shown during undo/redo
history.state.symmetrySplit = "Symmetry Split";
// Shown during undo/redo
history.state.voxelRemesh = "Voxel remesh";
// Shown during undo/redo
history.state.surfaceRemesh = "Surface remesh";
// Shown during undo/redo
history.state.multiresLevel = "Resolution change";
// Shown during undo/redo
history.state.multiresToDynamic = "Multires to DynTopo";
// Shown during undo/redo (mesh type conversion)
history.state.meshDynamicToStatic = "DynTopo to Static";
// Shown during undo/redo (mesh type conversion)
history.state.meshStaticToDynamic = "Static to DynTopo";

// Interface customization
interface = "Interface";

// UI customization: each row of the list will be bigger
interface.expandList = "UI: Expand list";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Just an UI option for easier list management.";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "Add shortcuts (bottom)...";

// Interface option (main base color)
interface.colorBase = "Color base";
// Interface option (accent widget color)
interface.colorSelect = "Color widget";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Transparent panel";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Blur strength";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Color panel";

// Interface color style
interface.preset.title = "Color presets";
// Interface color style
interface.preset.legacy = "Legacy";
// Interface color style
interface.preset.orange = "Orange";
// Interface color style (~red)
interface.preset.cardinal = "Cardinal";
// Interface Color style (~pink)
interface.preset.mulberry = "Mulberry";
// Interface color style
interface.preset.brown = "Brown";
// Interface color style (~green)
interface.preset.emerald = "Emerald";
// Interface color style (~blue)
interface.preset.neon = "Neon";
// Interface color style
interface.preset.violet = "Violet";
// Interface color style
interface.preset.grey = "Grey";
// Interface color style
interface.preset.black = "Black";
// Interface color style
interface.preset.white = "White";

// Reset interface settings
interface.resetAll = "Reset style";
interface.resetAll.confirm = "Reset interface settings?";
// Interface option (main base color)
interface.iconSupport = "High-contrast button";
interface.iconSupport.help = "An alternative style for buttons that makes them more visible when they are enabled.

If set on Auto, Nomad will use this mode when the UI color contrast between enabled/disabled is low.";
// Interface customization
interface.flipTop = "Mirror top bar";
// Interface customization
interface.flipBottom = "Mirror bottom bar";
// Interface customization
interface.flipMiddle = "Mirror side bars";
// Interface customization (preview material in the viewport when editing material color)
interface.materialPreview = "Material color preview";
// Interface customization
interface.materialPreview.help = "When you select a color for a material, a preview of this material is displayed on the currently selected object.";
interface.toolbox.hide = "Hide toolbox";
interface.toolboxHide.help = "Enable this option if you want to hide the toolbox.";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.maxColumn = "Max column toolbox";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Reset toolbox order";
// Mirror the curve in the tool falloff
interface.curveToolSymmetric = "Symmetrical tool falloff";
interface.curveToolSymmetric.help = "The widget can be found in the Tool panel under the falloff option.";
// Scale the interface
interface.scale = "Overall scale";
// Spacing between widgets
interface.cursorStep = "Vertical spacing";
// Width of the interface panels
interface.panelWidth = "Panel width";
// Size of fonts
interface.fontScale = "Font scale";
// Inset
interface.inset.title = "Edge offsets";
interface.inset.title.help = "You can change these values only if you have issues interacting with the buttons on the screen edges.

If the slider is disabled, Nomad will use the safe area values returned by the device itself.";
interface.inset.left = "Left";
interface.inset.right = "Right";
interface.inset.bottom = "Bottom";
interface.inset.top = "Top";

// (see Glossary for Layer)
layer = "Layer";
// (see Glossary for Layer)
layers.lock = "Keep top layers details";
// (see Glossary for Layer)
layers.lock.yes = "Lock the top layers?";
// (see Glossary for Layer)
layers.lock.warning = "During sculpting, the deformation coming from the top layers will be ignored.

However the details of these layers will still be visible.

This option only works if the top layers have relatively small scale details.";
// (see Glossary for Layer)
layers.addLayer = "Add layer";
// (see Glossary for Layer)
layer.factors = "Channel factors";
// (see Glossary for Layer)
layer.factor = "Factor";
// (see Glossary for Layer)
layer.offset = "Offset";
// (see Glossary for Layer)
layers.title = "Layers";
// (see Glossary for Layer)
layers.title.help = "Layers can record position offsets and painting, it can be useful for non-linear workflow.
For example by experimenting different facial expression without relying on the history stack to undo the changes.

For painting data, layers are sorted in a top-down fashion; so layers on top will mask the lower ones.

You can erase part of the layer (and thus, the layer influence) by using the 'DelLayer' tool.";
layers.primitive = "Layers are unavailable for primitives.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "None";

light = "Light";
// Intensity of light
light.intensity = "Intensity";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "Temperature";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Attachment";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Fixed";
// The light will move along the camera
light.attachment.camera = "Camera";
light.attachment.help = "-- Fixed
Light orientation won't change.

-- Camera
Light orientation depends on the camera view.";
// Light type (directional, spot, point)
light.type = "Type";
// Directional light (synonym: sun light)
light.type.directional = "Directional";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Spot";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Point";
// Cone angle for spot angles
light.spot.angle = "Cone angle";
// Softness of the spot light
light.spot.softness = "Softness";
// Position of the light
light.position = "Position";
// Enable or disable shadows for a light
light.shadow.cast = "Shadow";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "Point light only supports screenspace shadows.";
light.shadow.type = "Shadow type";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "Shadow map";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "Screenspace";
light.shadow.type.screenspace.help = "Experimental feature, it might be removed in a future release.

This option is meant to be used with the softness shadow feature.";
// Adjustment to fix artefacts
light.shadow.bias = "Bias";
// How blurry the shadow is
light.shadow.softness = "Softness";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "Contact";
light.contact.help = "If auto is selected, only the most dominant light will have contact shadow.";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "Tolerance";
// Activated the light
light.visible = "Show";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Recenter";

// Object's material
material = "Material";
// See glossary
material.pbrRoughnessMetalness.warning = "Roughness and Metalness requires PBR shading mode.";
// See glossary
material.pbrReflectance.warning = "Reflectance requires PBR shading mode.";
// See glossary
material.pbrRefraction.warning = "Refraction requires PBR shading mode.";
// See glossary
material.pbrSubsurface.warning = "Subsurface requires PBR shading mode.";
// Value that says how much light will change direction when hitting the surface
material.ior = "Index of Refraction";
// an object-level value that overrides the painting of the mesh
material.paintingOverride = "Override painting";
// The roughness in the inside is turbidity
material.paintingOverride.help = "There is two roughness at play, the one that drives the surface and the one in the inside.

However there is only one paintable roughness, so the two roughness have the same values.

You can use this slider to override the surface roughness to make more glossy.";
// Glossiness is simply the opposite of roughness
material.refractionSurfaceGlossiness = "Surface glossiness";
material.refractionSurfaceGlossiness.help = "- at 0, the surface is using the painted roughness
- at 1, the surface is completely smooth";
// Synonym: turbidity
material.refractionInteriorRoughness = "Interior roughness";
material.refractionInteriorRoughness.help = "- at 0, the interior is using the painted roughness
- at 1, the interior is completely rough";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Paint glossy";
material.paintGlossy.help = "It will paint the object with a roughness and metalness of 0, thus allowing sharp refraction.

This is the same as going in the painting menu and using the paint all feature with color and metalness disabled.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Absorption";
material.absorptionEnable.help = "Simulate the light being absorbed when it travels through the volume.

Thin parts will bright as it lets more light pass through, while thick areas will be darker.

The effect heavily depends on the object shape, only an approximation of the object thickness is used.";
material.absorptionFactor = "Factor";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "Depth";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "Translucency";
material.translucency.help = "You need to have a light that casts shadows in order to see translucency.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Opacity";
// Fully opaque material
material.type.opaque = "Opaque";
// See glossary
material.type.subsurface = "Subsurface";
material.type.subsurface.help = "To get the best result, you can switch to PBR shading mode and use at least one directional light, ideally with a dim environment.";
// Transparency mode, alpha blending
material.type.blending = "Blending";
material.type.blending.help = "Make the object semi-transparent by tweaking the opacity value.

Note that because of real-time constraints, you can have noticeable visual artifacts if your object has a complex shape.";
// Transparency mode
material.type.additive = "Additive";
material.type.additive.help = "Make the object semi-transparent by tweaking the opacity value.

This method tends to have less artifacts than the Blending method, but the object will be brighter.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Dithering";
material.type.dithering.help = "Make the object semi-transparent by discarding some pixels in a random fashion.";
// Simulate glass-like material
material.type.refraction = "Refraction";
material.type.refraction.help = "This mode can be used to simulate glass material.

Because of real time constraints, self-refraction or multi-layered refraction is limited.";
material.castShadows = "Cast shadows";
material.receiveShadows = "Receive shadows";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Always unlit";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Inverse culling";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Reflectance";
material.reflectance.help = "Control the amount of reflection the material will receive for non-metallic materials.

Most of the time, the default value should be used (0.5, which corresponds to the standard 4% reflected light at normal angle).";

// Menu name
menu.files = "Files";
// Menu name
menu.scene = "Scene";
// Menu name
menu.multires = "Multires";
// Menu name
menu.voxel = "Voxel";
// Menu name
menu.dynTopo = "DynTopo";
// Menu name
menu.topology = "Deci/UV...";
// Menu name
menu.primitive = "Primitive";
// Menu name
menu.render = "Render";
// Menu name
menu.material = "Material";
// Menu name
menu.postProcess = "PostProcess";
// Menu name
menu.camera = "Camera";
// Menu name
menu.background = "Background";
// Menu name
menu.tool = "Tool";
// Menu name
menu.stroke = "Stroke";
// Menu name
menu.paint = "Paint";
// Menu name
menu.symmetry = "Symmetry";
// Menu name (pencil pressure)
menu.pressure = "Pressure";
// Menu name
menu.gesture = "Gesture";
// Menu name
menu.layers = "Layers";
// Menu name
menu.settings = "Settings";
// Menu name
menu.interface = "Interface";
// Menu name
menu.bindings = "Bindings";
// Menu name
menu.history = "History";
// Menu name
menu.historySettings = "Settings";
// Menu name
menu.about = "About";
// Menu name
menu.debug = "Debug";

// Operation on the object (action)
mesh.action = "Operation";
// If the object has holes, the algorithm will close them
mesh.holeClose = "Close holes";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holeDetail = "Detail";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Separate";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "Layers, painting and multiresolution will be lost.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Resolution";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Force cubic";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Convert";
// Static object means "static topology"
mesh.typeStatic = "Mesh";
// See glossary
mesh.typeMultiresolution = "Multiresolution";
// Dynamic topology 
mesh.typeDynamic = "DynTopo";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Global material";
paint.useGlobal.help = "If this option is enabled, the selected material will be the same as the other tools.

Note that it only takes into account roughness, metalness and color settings.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Stroke painting";
// Factor/Opacity of paint tool
paint.intensity = "Paint intensity";
// Apply the paint on the object
paint.paintAll = "Paint all";
paint.paintAll.help = "Apply the current material to the object.

Masked area and disabled channels won't be painted.";
// Apply the paint on the object but ignore painting intensity (force full intensity)
paint.paintAllForce = "Force paint all";
paint.strokePainting.title = "Painting";
// Brush stroke texture
paint.texture.title = "Texture";
paint.texture.title.help = "An image that will color your brush stroke.

Note that it will share the alpha's tiling and scale settings.";
paint.texture.warningEnable = "Stroke painting needs to be enabled to allow texture projection (checkbox on top)!";
paint.texture.warningIgnored = "The current tool cannot use textures!";
// Whether the Brush Alpha will be used to module painting
paint.useAlpha = "Use stroke alpha";
paint.useAlpha.help = "Using the alpha set in the stroke menu to modulate the painting.";
// Whether the Brush Falloff will be used to module painting
paint.useFalloff = "Use stroke falloff";
paint.useFalloff.help = "Using the falloff set in the stroke menu to modulate the painting.";

// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "New name";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "New value";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "New color (hex format)";

// Post process effect
postprocess = "Post Process";
// Quality vs performance
postprocess.quality = "Quality";
postprocess.quality.help = "Activate these options to improve the quality to the detriment of performance.";
// More samples means better quality but slower performance
postprocess.maxSamples = "Max samples";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Full Resolution";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "Max frame sampling";
postprocess.accumulateCount.help = "Maximum number of frames to accumulate before the rendering stops.

When the rendering stops, Nomad won't do anything, thus saving battery life.

Many rendering features benefit from frame accumulation, notably:
- Soft Shadows
- Global Illumination
- Reflection (SSR)
- Ambient Occlusion
- Subsurface
- Depth Of Field

High frame counts are mostly necessary for Soft Shadows and Global Illumination.
Nomad can stop the rendering sooner if the features mentioned aboved are disabled.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Render resolution";
postprocess.renderRatio.warning = "Overriden by the Pixel Art effect.";
postprocess.renderRatio.help = "This option impacts the performance a lot.
It's advised to keep a value lower than x1.25.

This option is not saved in the settings.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "Anti-aliasing (TAA)";
postprocess.taa.help = "Reduces flickering when you are moving the camera.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "Reflection (SSR)";
postprocess.ssr.warning = "SSR requires PBR shading mode.";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "Global Illumination (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "Tolerance";
postprocess.ssgi.experimental = "Experimental!";
postprocess.ssgi.warning = "SSGI requires PBR shading mode.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "Ambient Occlusion";
// How far the effect spreads
postprocess.ssao.radius = "Size";
// How strong the effect is
postprocess.ssao.factor = "Strength";
// Adjustment to fix artefacts
postprocess.ssao.bias = "Curvature bias";
postprocess.ssao.bias.help = "How sensitive the effect is depending on the surface curvature.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "Depth Of Field";
// The blur factor behind the focused point 
postprocess.dof.blurFar = "Far blur";
// The blur factor in front of the focused point 
postprocess.dof.blurNear = "Near blur";
postprocess.dof.focusTip = "Tap an object to change the focus point.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "Bloom";
// Intensity of the effect
postprocess.bloom.intensity = "Intensity";
// How far the effect spreads
postprocess.bloom.radius = "Radius";
postprocess.bloom.radius.help = "How widespread the bloom is.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "Threshold";
postprocess.bloom.threshold.help = "Luminosity threshold to decide if a pixel will emit bloom or not.
If the value is at 0, everything will receive bloom.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "Tone Mapping";
postprocess.tone.exposure = "Exposure";
postprocess.tone.contrast = "Contrast";
postprocess.tone.saturation = "Saturation";
// No tonemapping operator is used
postprocess.tone.mapping.none = "None";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "Neutral";
// Color curves
postprocess.curve = "Color Grading";
// Curve for pixel luminance
postprocess.curve.luminance = "Main";
postprocess.curve.red = "Red";
postprocess.curve.green = "Green";
postprocess.curve.blue = "Blue";
postprocess.curve.reset = "Reset";
// Reset color grading curves
postprocess.curve.resetAll = "Reset All";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "Chromatic Aberration";
postprocess.chromatic.factor = "Strength";
// Darking on the edges
postprocess.vignette = "Vignette";
// How far the effect spreads
postprocess.vignette.size = "Size";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "Hardness";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "Sharpness";
postprocess.sharpness.factor = "Strength";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "Grain";
postprocess.grain.factor = "Strength";
// Accentuate the edges of the model
postprocess.curvature = "Curvature";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "Cavity";
// Color/Strength of convex curvature
postprocess.curvature.bump = "Bump";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "Pixel Art";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "Allow frame sampling";
// Simulate scanline rendering (horizonal line)
postprocess.scanline = "Scanline";
postprocess.scanline.factor = "Factor";
// Spacing between lines
postprocess.scanline.spacing = "Spacing";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Primitive";
primitive.box = "Box";
primitive.sphereCube = "Sphere";
primitive.sphereUV = "UV Sphere";
primitive.icosahedron = "Icosahedron";
primitive.cylinder = "Cylinder";
primitive.cone = "Cone";
primitive.torus = "Torus";
primitive.lathe = "Lathe";
primitive.tube = "Tube";
primitive.plane = "Plane";
primitive.triplanar = "Triplanar";
primitive.faceXYZ = "Face XYZ";
primitive.faceXYZ.help = "UV-unwrapped base mesh provided by https://texturing.xyz/";
primitive.needValidate = "Primitives should be validated in order to be sculpted.";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Edit";
primitive.edit.help = "Allow 3d editing in the viewport.

You can disable this feature if you want to interact with the Gizmo or the Transform tool without modifying the primitive.";

// Primitive configuration
primitive.mainConfig = "Parameter";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Topology";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Geometry";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Validate";
// Maximum number of faces of the primitives
primitive.maxFaces = "Max faces";
primitive.maxFaces.help = "The maximum number of faces a primitive can have.

This limit is only active while the primitive is not validated, afterwards the safeguard is gone.";
// Synonym: Flat subdivision
primitive.linear = "Linear subdivision";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Post subdivision";

// Radius (of a sphere, torus, etc)
primitive.radius = "Radius";
// Size (of cube x dimension)
primitive.size = "Size";
primitive.sizeX = "Size X";
primitive.sizeY = "Size Y";
primitive.sizeZ = "Size Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "Division";
primitive.divisionX = "Division X";
primitive.divisionY = "Division Y";
primitive.divisionZ = "Division Z";
// Angle of torus, etc
primitive.angleX = "Angle X";
primitive.angleY = "Angle Y";
primitive.angleZ = "Angle Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Constant density";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Project on sphere";
primitive.projectOnSphere.help = "Snaps the points on a perfect sphere.";

// triplanar
primitive.triplanar.title = "Triplanar";
primitive.triplanar.title.help = "Triplanar is using the mask information from 3 planes to fill a voxel grid that is then polygonized.

If you interact with the division or size sliders, the painting information will reset (smoothness is ok).

You should probably disable symmetry as it might not function as you would expect.

You can use the 'Topologically connected' option in the mask panel to paint a plane impacting the other planes.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanarSameSize = "Same size (cube)";
primitive.triplanarPolish = "Smoothness";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanarResetMask = "Reset mask";
// One side of a cube (the back plane)
primitive.isolate.back = "Back";
// One side of a cube (the right plane)
primitive.isolate.right = "Right";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Bottom";
// Plane
primitive.planeSameSize = "Same size (square)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "Disk";
// Box
primitive.boxRegular = "Same size (cube)";
// Distance to the snapping point
primitive.tubeSnapOffset = "Snap offset";
primitive.tubeSnapOffset.help = "A value of 1.0 is equal to the tube's radius.";
// Radius of the tube (starting end-point of the tube)
primitive.tubeThicknessStart = "Radius start";
// Radius of the tube (ending end-point of the tube)
primitive.tubeThicknessEnd = "Radius end";
primitive.tubeTwist = "Twist";
primitive.tubeTwistRotate = "Rotation";
primitive.tubeTwistRadius = "Magnitude";
primitive.tubeTwistOffset = "Offset";
primitive.tubeSnap = "Snap";
primitive.torusRadiusOuter = "Outer radius";
primitive.torusRadiusInner = "Inner radius";
primitive.torusAngle = "Angle";
primitive.torusAngleOffset = "Angle offset";
primitive.cylinderHeight = "Height";
primitive.coneRadius = "Radius";
primitive.coneHeight = "Height";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Hole";
// Make a hole in the primtive to make it hollow
primitive.hasHole = "Has hole";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radiusSync = "Same radius";
primitive.radiusStart = "Radius start";
primitive.radiusEnd = "Radius end";
curve.spline = "Spline";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Import...";

scene.title = "Scene";
scene.title.help = "When using the visible/select buttons, hold and drag your finger to select other objects easily.

You can also long press the visible/select buttons to affect the children as well.";
// The view will focus on the item when we click on it
scene.focus = "Focus on item";
// Icon size in pixel (min/max)
scene.iconSize = "Icon size";
// Min size of icon
scene.iconSize.min = "Min";
// Max size of icon
scene.iconSize.max = "Max";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "Hierarchy lines";
scene.showHierarchy.help = "Display a line between parent and its children in the viewport.";
scene.showHierarchyNomadPivot = "Use Nomad pivot";
scene.showHierarchyNomadPivot.help = "The Nomad pivot is the pivot used by the Transform and Gizmo tools.

If this option is disabled, it will use the natural base pivot.
In some case this base pivot can be far away from the object center itself!";
// The view will focus on the item when we click on it
scene.syncVisible = "Sync visibility";
scene.syncVisible.help = "When enabled, using the visible (eye) icon will impact all the selected items.";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "Join";
// Group the selected object with a new created Empty Node as a parent
scene.group = "Group";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "Mirror";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "Curve";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "Array";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "Radial";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "Repeaters";
scene.repeaters.help = "Repeater nodes that make instances of any geometries below it in the scene hierarchy.";
// Validate button
scene.validateGroup = "Validate";
// If we should join children
scene.validateGroup.joinChildren = "Join children";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Voxel merge";
scene.voxelResolution = "Resolution";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Subtraction: Hide object (eye icon)";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Intersection: All objects hidden";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "No selected object, please select at least one object.";
// Need to select one object only
scene.noneButNeedOne = "No selected object, please select one object.";
// Need to select one object only
scene.onlyOneObject = "Multiple objects are selected, please select only one object.";

// General scene display settings
settings.display.title = "Display settings";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Wireframe";
// Display UV
settings.debugUV = "Debug UV";
settings.debugUV.help = "This option is only relevant if the model has UVs.

It will display the UV wireframe in the background.

It will also display a colored checkerboard texture on the model.";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Two sided";
settings.twoSided.help = "Faces will be visible from both sides.";
// If we colorize the inverted side of faces
settings.backface.color = "Backface color";
// Color of the inverted side of faces
settings.backface.colored = "Colored backface";
// Outline (contour highlight around the selected object)
settings.outline = "Outline";
// Outline (contour highlight around the selected object)
settings.outline.help = "Selected objects will be outlined.";
settings.outline.thickness = "Thickness";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Snap cube";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "Bottom";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "Left";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Stats";
settings.stats.right = "Right";
settings.stats.all = "Show full scene";
// Grid
settings.grid = "Grid";
// Cursor
settings.cursor.whileSculpting = "Show circle while sculpting";
// A small indicator dot
settings.cursor.showDot = "Show small dot";
settings.cursor.showDot.help = "The dot can appear as the camera pivot point or when you are sculpting.";
settings.cursor.showRope = "Show rope stabilizer";
// Highlight (the object glows when we select it)
settings.highlight.selection = "Highlight selection";
// Highlight settings
settings.highlight = "Highlight";
settings.highlight.duration = "Duration";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Darken unselected objects";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Smooth shading";
// Experimental feature
settings.partialDraw = "Partial drawing";
settings.partialDraw.help = "Experimental feature!

Use it if you are sculpting a relatively small part of a high poly mesh.

It should make the sculpting smoother, but you should not enable wireframe!

Also it might add visual artefacts during the brush strokes";
settings.partialDraw.warning = "Do not forget to turn off this option if the visual artefacts are too bothersome!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Show painting";
// Display the light icons in the viewport
settings.lightIcon = "Light icons";
// Display the camera icons in the viewport
settings.cameraIcon = "Camera icons";
// Show icon on the canvas
settings.icon = "Icon";
// Show icons on the canvas
settings.icons = "Icons";
// Tooltip
settings.icons.help = "Display an icon on the canvas so that you can select and edit them directly.";
// Hole filling settings
settings.hole = "Hole-filling";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Fill non-manifold";
settings.hole.nonManifold.help = "Try to fill non manifold hole.
This option is not saved in the settings.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Max vertices count";
settings.multires.maxVertices.help = "Nomad doesn't perform memory check before subdivision, high poly count can easily lead to crashes.";
settings.multires.lowResVertices = "Low resolution threshold";
settings.multires.lowResVertices.help = "A lower resolution of the mesh can be displayed when you move the camera.

You can increase this value if you want to display a higher resolution of the mesh.";

// The main rendering mode
shading = "Shading";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "Lit (PBR)";
shading.pbr.help = "In this mode you can add lights (with shadows), along with an HDR environment.

You can also paint metalness and roughness, thus allowing a finer control on the look of your material.";
// Fast rendering mode for sculpting purpose (do not translate) 
shading.matcap = "MatCap";
shading.matcap.help = "Stands for MATerial CAPture, a MatCap takes care of both the lighting and material information in a single image.

This is a fast rendering mode, mostly suited for raw sculpting.";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "Unlit";
shading.unlit.help = "Solid color shading mode, without lighting.";
// Helper rendering mode that display a (do not translate)
shading.id = "ID";
shading.id.help = "Unlit rendering mode with each objects having a random color assigned.

This is mostly useful when you have many objects in your scene.";
// Randomize colors
shading.id.randomize = "Randomize id";
shading.textures = "Use textures";
shading.textures.help = "At the moment, you cannot create nor edit textures inside Nomad.

But if you import a file with textures in it, it should work.

-- Supported textures --
Opacity: Lit, MatCap, Unlit
Normal: Lit, MatCap
Color: Lit, Unlit
Emissive: Lit
Roughness: Lit
Metalness: Lit";
// Lights
shading.lights = "Lights";
shading.lights.addLight = "Add light";
shading.lights.warning = "Lights requires PBR shading mode.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Environment";
shading.environment.import = "Import HDR";
shading.environment.exposure = "Exposure";
shading.environment.backgroundBlur = "Blur (background)";
shading.environment.rotation = "Rotation";
shading.environment.rotation.help = "You can rotate the environment by dragging 3 fingers horizontally on the viewport.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "Attached to camera";
shading.environment.attachedToCamera.help = "Attach the environment to the camera.

It will force the lighting to be consistent, which can be useful for sculpting purposes.";
shading.matcap.rotation = "Rotation";
shading.matcap.rotation.help = "You can rotate the MatCap by dragging 3 fingers horizontally on the viewport.";
shading.matcap.global = "Use global MatCap";
shading.matcap.global.help = "Uncheck this option to use a different MatCap for this particular mesh.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible.short = "Mask";
shortcut.maskVisible.long = "Mask";
// bottom shortcut buttons (should be SHORT)
shortcut.solo.short = "Solo";
shortcut.solo.long = "Solo";
// bottom shortcut buttons (should be SHORT)
shortcut.voxelRemesh.short = "Voxel";
shortcut.voxelRemesh.long = "Voxel remesh";
// bottom shortcut buttons (should be SHORT)
shortcut.wireframe.short = "Wire";
shortcut.wireframe.long = "Wireframe";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraReset.short = "Reset";
shortcut.cameraReset.long = "Camera reset";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraSnap.short = "Snap";
shortcut.cameraSnap.long = "Camera snap";
// bottom shortcut buttons (should be SHORT)
shortcut.lockSelection.short = "Lock";
shortcut.lockSelection.long = "Lock selection";
shortcut.lockSelection.long.help = "When enabled, you cannot change the selection by tapping on a mesh.";
// bottom shortcut buttons (should be SHORT)
shortcut.perspective.short = "Persp";
shortcut.perspective.long = "Perspective";
// bottom shortcut buttons (should be SHORT)
shortcut.grid.short = "Grid";
shortcut.grid.long = "Grid";
// bottom shortcut buttons (should be SHORT)
shortcut.uv.short = "uv";
shortcut.uv.long = "uv";

// Memory taken by the scene
stat.ramScene = "Scene";
// Vram = Video RAM (Video Memory, the memory of the graphic card) 
stat.vramScene = "Vram Scene";
// Vram = Video RAM (Video Memory, the memory of the graphic card) 
stat.vramRender = "Vram Render";
// Vram = Video RAM (Video Memory, the memory of the graphic card) 
stat.vramTextures = "Vram Textures";
// Memory taken by the undo/redo history
stat.ramHistory = "History";
// Memory taken by other stuffs
stat.ramOther = "Other";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "Used Memory";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "Free Memory";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "Used: $0 MB";
stat.free = "Free: $0 MB";
stat.faces = "Faces";
stat.triangles = "Triangles";
stat.vertices = "Vertices";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Quads";
stat.sceneFaces = "Scene faces";
stat.sceneVertices = "Scene vertices";

// Brush stroke
stroke = "Stroke";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "World-space radius";
// The settings is shared among every tools
stroke.useWorldRadius.help = "This is shared among every tools.";
// Share the radius value among every tools.
stroke.useShareRadius = "Share radius";
stroke.useShareRadius.help = "Share the radius value among every tools.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.minSpacing = "Stroke spacing";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.minSpacing.adjustIntensity = "Adjust spacing intensity";
stroke.minSpacingAdjustIntensity.help = "Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.";
stroke.minSpacing.help = "Spacing between each stroke, relative to the tool radius.

Lower value will allow smoother stroke but performance will degrade.";
// Brush stroke smoothing
stroke.lazySmooth = "Stroke smoothing";
stroke.lazySmooth.help = "Average multiple pointer position to get a smoother stroke.

With high values, the stroke will lag behind the pointer but will eventually catch up.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Lazy rope stabilizer";
stroke.lazyRadius.help = "Strokes will lag behind the pointer position according to a certain distance.

This can be used to draw smooth lines.";
// It is not a per-tool settings
stroke.globalSettings = "This is a global setting";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Snap radius";
stroke.snapRadius.help = "Snap the stroke if the pointer lies close to the last recorded stroke.

This can be useful when drawing long continuous lines, while doing frequent pauses.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Stroke offset";
stroke.sculptOffset.help = "Apply a constant offset on the stroke.

This option is there to help for small screen when using fingers, so that your finger doesn't cover the stroke.";
stroke.accumulate = "Accumulate stroke";
stroke.accumulate.help = "If this option is enabled, there is no limit to how much matter you can add/remove per stroke.";
// The tool can use DynTopo
stroke.useDynamicTopology = "Allow dynamic topology";
// Only sculpt the part that are linked topologically
stroke.connectedTopology = "Connected topology";
stroke.connectedTopology.help = "This option will only sculpt the vertices that are linked to the picked surface.

This is typically used for the Move tool, for example if you want to exclusively move a part that self-intersect with another part.";
// Only sculpt the vertex that points toward the camera
stroke.onlyFrontFace = "Front-facing vertex only";
stroke.onlyFrontFace.help = "This option will ignore back facing vertices.

It can be useful if you want to paint part of a thin geometry without impacting the other side.

It also works for sculpting but you might experience some artefacts.";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.onlySameSide = "Same-side vertex only";
stroke.onlySameSide.help = "Ignore vertices that points in the opposite direction of the deformation.";
// Module the intensity of the sculpting operation by using a falloff curve
stroke.curveFalloff = "Falloff";
stroke.onlyLasso = "Settings only active for the lasso tool.";
// Alpha
stroke.alpha = "Alpha";
// Invert the pixel (black <-> white)
stroke.alphaInvert = "Invert pixels";
// Repeat the alpha image (pattern)
stroke.alphaWrap = "Tiling";
// No repeat pattern
stroke.alphaWrap.none = "None";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alphaWrap.repeat = "Repeat";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alphaWrap.mirror = "Mirror";
stroke.alphaProject = "Method";
// Project the alpha perpendicularly onto the surface 
stroke.alphaProject.surfaceContinuous = "Surface";
// Project the alpha onto the surface in the direction of the camera view
stroke.alphaProject.screenFixed = "Screen project";
stroke.alphaRotation = "Rotation";
// Repeat the image
stroke.alphaTiling = "Tiling";
// Scale the image (make it bigger or smaller)
stroke.alphaScale = "Scaling";
stroke.alphaScale.help = "At minimum value, the alpha square is inside the tool circle radius.";
// Middle-point value at which no deformation occurs
stroke.alphaMidValue = "Mid value";
stroke.alphaMidValue.help = "Middle-point value at which no deformation occurs.

(Mid value = 0)
- Black: no displacement
- White: positive displacement

(Mid value = 0.5)
- Black: negative displacement
- White: positive displacement

(Mid value = 1)
- Black: negative displacement
- White: no displacement";
// Stroke type
stroke.strokeType = "Stroke type";
// Sculpt and paint along the brush stroke at regular spacing
stroke.strokeTypeDot = "Dot";
// Sculpt continuously
stroke.strokeTypeDrag = "Drag";
// Lock a region and move it around
stroke.strokeTypeGrab = "Grab";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.strokeTypeGrabRadius = "Grab - dynamic radius";
// Lock a region and sculpt it by changing the tool intensity
stroke.strokeTypeGrabIntensity = "Grab - dynamic intensity";

// Symmetry
symmetry = "Symmetry";
symmetry.enable = "Enabled";
// Display a warning (the feature is only available for mesh object)
symmetry.primitiveWarning = "Brush symmetry is only available for primitives that are validated, with the exception of the Triplanar.";
symmetry.plane.title = "Planes";
symmetry.toolIgnore = "The current tool ignores symmetry.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Radial";
symmetry.radialX = "Radial X";
symmetry.radialY = "Radial Y";
symmetry.radialZ = "Radial Z";
// Synonym: Offset
symmetry.offset.title = "Offset";
symmetry.offsetX = "Offset X";
symmetry.offsetY = "Offset Y";
symmetry.offsetZ = "Offset Z";
// Number of clones
symmetry.count.title = "Count";
symmetry.countX = "Count X";
symmetry.countY = "Count Y";
symmetry.countZ = "Count Z";
// method
symmetry.method = "Method:";
symmetry.method.help = "-- Local
The symmetry plane will move along the mesh when you use one of the transform tools (Gizmo or Transform).

-- World
The symmetry plane is fixed and will not move.";
// Local means: in the coordinate of the scene 
symmetry.methodWorld = "World";
// Local means: in the coordinate of the object (internal) 
symmetry.methodLocal = "Local";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Flip object";
// Mirror the mesh
symmetry.mirror = "Mirroring";
symmetry.mirror.help = "Try to re-apply the symmetry without impacting the topology.

Radial symmetry will be ignored.

If the topology can't be kept because it is not considered symmetrical, you'll get the option to enforce the mirroring.";
symmetry.mirrorLeftToRight = "Left to Right";
symmetry.mirrorRightToLeft = "Right to Left";
symmetry.mirrorFail = "Failed to apply symmetry.

Do you want to enforce symmetry by mirroring the mesh?";
symmetry.mirrorUseMasking = "Protect masked area";
symmetry.mirrorUseMasking.help = "Keep masked area intact.

This option will be ignored with non-symmetric topology (or disconnected surface, like a pair of eyes).";
// Reset the symmetry plane position
symmetry.reset = "Reset";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Object center";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "World center";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Orientation";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Show line";
// Display the symmetry plane in 3d
symmetry.showPlane = "Show plane";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Gizmo edit";
symmetry.edit.warning = "Symmetry edit is experimental.";
symmetry.edit.help = "You can freely set the symmetry plane.

This feature is a bit experimental and you should probably never use it.";

// Ideally <10 chars
tool.dynTopo = "DynTopo";
// Ideally <10 chars (Symmetry)
tool.symmetry = "Sym";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "Mirror";
// Ideally <10 chars
tool.clay = "Clay";
// Ideally <10 chars (Subtract)
tool.clay.sub = "Sub";
// Ideally <10 chars
tool.brush = "Brush";
// Ideally <10 chars
tool.move = "Move";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "Normal";
// Ideally <10 chars
tool.drag = "Drag";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "Smooth";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Relax";
// Ideally <10 chars (Paint mask)
tool.mask = "Mask";
// Ideally <10 chars
tool.mask.unmask = "Unmask";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "SelMask";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "Smudge";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "Flatten";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Fill";
// Ideally <10 chars (Layer brush)
tool.layer = "Layer";
// Ideally <10 chars
tool.crease = "Crease";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "Trim";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Split";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "Project";
// Ideally <10 chars
tool.inflate = "Inflate";
// Ideally <10 chars
tool.pinch = "Pinch";
// Ideally <10 chars
tool.nudge = "Nudge";
// Ideally <10 chars
tool.stamp = "Stamp";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "DelLayer";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.select = "Select";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "Gizmo";
// Ideally <10 chars (Automatic pivot)
tool.gizmo.auto = "Auto";
// Ideally <10 chars (Custom pivot)
tool.gizmo.custom = "Custom";
// Ideally <10 chars
tool.gizmo.editPivot = "Pivot";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "Snap";
// Ideally <10 chars (Snap translation)
tool.gizmo.moveSnap = "Snap";
// Ideally <10 chars (Local space)
tool.gizmo.local = "Local";
// Ideally <10 chars (Local space)
tool.gizmo.world = "World";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "Transform";
// Ideally <10 chars (Translate the object)
tool.transform.move = "Move";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "Rotate";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "Scale";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "Snap";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "Measure";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "View";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "Lathe";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "Tube";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "Insert";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "Flip";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "View";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "Lasso";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Curve";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Polygon";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Path";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "Rect";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "Ellipse";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "Line";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Closed";

// Popup when editing the vertical sliders on the left
tool.slider.radius = "Radius $0";
// Popup when editing the vertical sliders on the left
tool.slider.intensity = "Intensity $0 %";

tool.settings = "Settings";
tool.settings.none = "This tool doesn't have any specific settings.";

// Flatten distance offset
tool.clay.flattenOffset = "Flatten offset";
tool.crease.pinchFactor = "Pinch force";

tool.layer.removeInfluence = "Use layer data";
tool.layer.removeInfluence.help = "This option is only active when there is a layer selected.

It will use the layer data to limit the displacement over strokes.";
tool.layer.noLayerSelected = "This option is only available if a layer is selected";

tool.flatten.warning = "These options are experimental and could be removed in the future!";
tool.flatten.planeLockOrigin = "Lock plane origin";
tool.flatten.planeLockNormal = "Lock plane direction";
tool.flatten.planeAverageOrigin = "Average plane origin";
tool.flatten.planeAverageNormal = "Average plane direction";
tool.flatten.planeOffset = "Plane offset";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "Sync";
tool.syncInstance.message = "The new object will be added on all other instances!";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Sticky vertex on border";

tool.paint = "Paint";
// Erase the painting
tool.paint.erase = "Erase";
// Only paint the part of the mesh above a certain height
tool.paint.depthFilter = "Depth filtering";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Layer filtering";
tool.paint.layerFilter.help = "Use this option if you only want to repaint the already painted area of a layer.";

// Clear the painted mask
tool.mask.clear = "Clear";
// Invert the painted mask
tool.mask.invert = "Invert";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Invert mask (connected)";
// Blur the painted mask
tool.mask.blur = "Blur";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Sharpen";
// The thickness of the extracted mesh (from the painted mask)
tool.mask.thickness = "Shell thickness";
// Smooth the border of the extracted mesh (from the painted mask)
tool.mask.polish = "Border smoothness";
// Extract a new mesh from the painteed mask and carve/emboss the base mesh
tool.mask.engraveEmboss = "Engrave / Emboss";
// Extract a new mesh from the painted mask
tool.mask.extract = "Extract";
// Extract two new mesh from the painted mask and from the unmasked area
tool.mask.split = "Split";
// How should we close the topology of the extracted object
tool.mask.closeMask = "Closing action (masked):";
// How should we close the topology of the extracted object
tool.mask.closeUnmask = "Closing action (unmasked):";
// How should we close the topology of the extracted object
tool.mask.closeAction = "Closing action:";
// Do not close the mesh (leave it open)
tool.mask.closeActionNone = "None";
// Close the mesh with a hole-filling algorithm
tool.mask.closeActionFill = "Fill";
// Close the mesh by adding a thickness on the surface
tool.mask.closeActionShell = "Shell";
// Close the mesh by using the layer data as a difference thickness
tool.mask.closeActionLayer = "Layer";
tool.mask.closeAction.help = "-- None
Simply extract the part and let the extracted part opened.

-- Fill
Hole is filled and smoothed.
Do not use this option for flat surface.

-- Shell
Close the extracted shape by using the thickness value.

-- Layer
Extract the layer difference (layer sub-menu only).";

// Transform/Matrix
tool.matrix = "Matrix";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.apply = "Target";
// Automatic
tool.matrix.apply.auto = "Auto";
// Transform the object alone (the children stands still)
tool.matrix.apply.object = "Object";
// Auto apply the transform on the vertices
tool.matrix.apply.vertex = "Vertex";
// Transform the object and its children
tool.matrix.apply.group = "Group";
tool.matrix.apply.help = "-- Auto
By default, this will work similarly to the Group option.
If the mesh has masking, or if gizmo symmetry is enabled, it will work the same as Vertex.

-- Vertex
Try to apply the transform on the vertices, it won't work on unvalidated primitives.
Instances will be impacted as well.

-- Object
Move the object only, ignoring symmetry and masking.
Only the edited node will move, the children will stand still.

-- Group
Move the node, ignoring symmetry and masking. The rest of the hierarchy will be transformed as well.";
// Operation on the mesh
tool.matrix.action = "Operation";
tool.matrix.action.help = "-- Move origin
Move the mesh to the world origin.

-- Reset
Reset the mesh transform to identity.

-- Bake
Apply the matrix to the vertex and reset the matrix. Visually, nothing should change.";
tool.matrix.translation = "Translation";
tool.matrix.rotation = "Rotation";
tool.matrix.scale = "Scale";
tool.matrix.uniformScale = "Uniform scale";
tool.matrix.uniformScale.help = "Nomad cannot support non-uniform scale as object transform, so it will be applied as a vertex transformation.";
tool.matrix.moveToOrigin = "Move origin";
tool.matrix.resetTransform = "Reset";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "Bake";

tool.transform.tip = "Single tap with second finger to switch mode";

// Size of the gizmo
tool.gizmo.size = "Widget size";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "Numerical input";
tool.gizmo.allowInput.help = "Allow numerical input when tapping one of the gizmo widget";
// Angle threshold
tool.gizmo.linearRollThreshold = "Tangent roll threshold";
tool.gizmo.linearRollThreshold.help = "Angle threshold to choose between linear or circular roll method.

Value above this threshold will use the circular roll.

If you prefer the linear roll (direction of the tangent), simply set this value to 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Hide on interaction";
tool.gizmo.tap = "Move custom pivot on single-tap";
tool.gizmo.tap.help = "This option is only effective in custom pivot mode (Auto disabled).

-- None
Nothing happen when tapping on the mesh.

-- First hit
Move the gizmo on the first intersection.

-- Middle stab
Move the gizmo on the average of the first two intersections.";
tool.gizmo.tapNone = "None";
tool.gizmo.tapFirstHit = "First hit";
tool.gizmo.tapMiddleStab = "Middle stab";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "Fixed";

// Fill the object's hole
tool.hole = "Hole filling";
tool.hole.fillHoles = "Fill holes";
// synonym: Alternative method
tool.hole.bridges = "Screen-space boolean";
tool.hole.bridges.help = "If this option is enabled, you can punch holes in the volume.
The cut slope will also follow more closely the cutting shape.";
tool.hole.threshold = "Threshold epsilon";
tool.hole.threshold.help = "Tweaking this value might help with the hole filling algorithm.";
tool.hole.smoothing = "Hole smoothing";

tool.smudge.quality = "Quality";
tool.smudge.quality.help = "It changes the resolution of the projected pixels, lower values means faster strokes.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Shape";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Square";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Centered";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Circle";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Centered";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Rotate step";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Show golden ratio";

// Topology
topology = "Topology";
// Synynom: detail value, density
topology.dynamic.detail = "Detail";
// See glossary
topology.multires = "Multiresolution";
topology.multires.help = "Keep multiple resolution of a mesh.

If you make changes in a lower resolution, details from the higher resolutions will be reprojected when you switch back.

Layers are available on every resolution.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "Reverse";
topology.multires.reverse.confirm = "Could not create base subdivision.

The current topology is probably not a result from a subdivision.";
topology.multires.subdivide = "Subdivide";
topology.multires.subdivide.confirm = "The mesh will have $0M vertices, are you sure?";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "Subdivide limit exceeded, see $0";
topology.multires.deleteLower = "Delete lower";
topology.multires.deleteHigher = "Delete higher";
topology.multires.keepTriangles = "Keep triangles";
// Synonym: Flat subdivision
topology.multires.linear = "Linear subdivision";
topology.multires.linear.help = "Simply subdivide the mesh without applying any smoothing";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Voxel remeshing";
topology.voxel.help = "Remeshing by sampling the mesh on a grid.

If the object is not closed (watertight), an hole-filling algorithm will be applied first.

Layers are reprojected after remeshing but the quality will degrade.";
topology.voxel.resolution = "Resolution";
topology.voxel.remesh = "Remesh";
topology.voxel.sharp = "Keep sharp edges";
topology.voxel.sharp.help = "This option is mostly useful for simple primitive boolean operation.

It will introduce distortion in some area due to the points being snapped on the edges.";
topology.voxel.subLevel = "Build multiresolution";
topology.voxel.subLevel.help = "You can rebuild a multiresolution hierarchy from the voxel remesher output.

It will also run faster and use less memory, especially if the voxel detail value is high.
However if the voxel detail value is low and you are asking for lot of multires level, you'll lose details.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Remesh";
topology.surface.detail = "Detail";
topology.surface.detail.help = "Unlike voxel remeshing, surface remeshing doesn't require the mesh to be closed.

It can also support masking so that you can protect some part of the mesh from topology changes.

Layers are updated correctly.";
topology.surface.method = "Method";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Uniformisation";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Subdivision";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Decimation";
topology.surface.method.help = "Behavior of dynamic topology:
- Uniformisation: add and remove detail
- Subdivision: add detail
- Decimation: remove detail";
topology.surface.useMasking = "Protect masked area";
topology.surface.useMasking.help = "The masked areas will protect the topology from beging changed.";
topology.surface.extrapolate = "Vertex extrapolation";
// DynTopo
topology.dynamic = "Dynamic topology";
topology.dynamic.activate = "Enabled";
topology.dynamic.activate.help = "With dynamic topology, sculpting tools can subdivide or simplify the mesh locally in real time.

This feature can have a noticeable impact on performance.

Layers are updated correctly.";
topology.dynamic.method = "Detail based on...";
topology.dynamic.method.zoom = "Zoom";
topology.dynamic.method.radius = "Radius";
topology.dynamic.method.constant = "Constant";
topology.dynamic.method.help = "-- Zoom
The level of detail is based on how far you are from the surface.

-- Radius
The tool radius defines the amount of detail.

-- Constant
The detail is fixed, the detail value is shared with the voxel slider as well.";
topology.dynamic.quality = "Prefer...";
topology.dynamic.quality.help = "If you choose Quality, the 2 main differences are:
- refinement is applied before the sculpting operator, you will get less interpolating artefact when painting or sculpting very small details
- refinement is not applied incrementally, if you sculpt very small details or do quick strokes, the topology will always be correctly refined

For better performance, and if you plan on using this option, you might consider enabling the 'partial drawing' option in the Settings panel.";
topology.dynamic.quality.speed = "Speed";
topology.dynamic.quality.quality = "Quality";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Use pressure on radius";
topology.dynamic.usePressure.help = "Use this option if you want the pen pressure impact on tool radius to impact the level of detail.";
// Decimate
topology.decimate.title = "Decimation";
topology.decimate.title.help = "Reduce the number of polygons by trying to keep as many details as possible.

This feature can be useful if you want to export for 3d printing.
However you should probably not use it if you want to continue sculpting on it, as it can produce uneven triangles.

Note that the masked area won't be decimated.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Decimate";
topology.decimateTargetFaces = "Target triangles";
topology.decimatePaintWeight = "Preserve painting";
topology.decimatePaintWeight.help = "Higher value will try to preserve painting.

Set this value to 0 if you don't care about the painting.";
topology.decimateUniform = "Uniform faces";
topology.decimateUniform.help = "Higher value will output triangles with similar size.";
// topology.decimatePreserveBorders = "Preserve borders";
// topology.decimatePreserveBorders.help = "Do not decimate the border of the mesh.";

// Unwrapping means compute UV (texture coordinates), it allows the object to receive on texture (wrap the texturing on the object)
topology.uv.title = "UV Auto-Unwrap";
// UV Unwrapping
topology.uvAtlas = "Unwrap Atlas";
// The operation can be very slow
topology.uvAtlas.warning = "Can be very slow, target <100k vertices!";
// UV Unwrapping (BFF best left untranslated, stands for Boundary First Flattening)
topology.uvBFF = "Unwrap Bff";
// Handles are topological holes (synonym: genus, hole)
topology.uvBFF.warning = "Can have overlaps if the mesh has handles!";
// Synonym: Point count? Singularity count ?
topology.uvBFFCones = "Cone count";
topology.uvBFFCones.help = "Higher value will reduce distortion for complex objects.

Higher value will means longer compute time.";
topology.uvDelete = "Delete UVs";

// Transfer the vertex painting in the texture
topology.bake = "Bake Vertex painting";
topology.bake.help = "Transfer the vertex painting to a texture.

Vertex color are resetted in the process.";
topology.bakeResolution = "Resolution";

// Reset key-bindings/shortcuts
binding.reset = "Reset bindings";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.materialPicker = "Material Picker";
// Edit the tool brush size/radius
binding.editRadius = "Tool Radius";
// Edit the tool brush size/radius
binding.editIntensity = "Tool Intensity";
// Snap the camera
binding.viewFront = "Front View";
// Snap the camera
binding.viewLeft = "Left View";
// Snap the camera
binding.viewTop = "Top View";
// Move/Translate the view
binding.panLeft = "Pan Left (View)";
// Move/Translate the view
binding.panRight = "Pan Right (View)";
// Move/Translate the view
binding.panForward = "Pan Forward (View)";
// Move/Translate the view
binding.panBackward = "Pan Backward (View)";
// Move/Translate the view
binding.panUp = "Pan Upward (View)";
// Move/Translate the view
binding.panDown = "Pan Downward (View)";
// Snap the view (while rotating)
binding.snapViewOnRotate = "Snap view (while rotating)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "Open (project)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "Add (project)";
// Import an external scene file (replace current scene)
binding.import.open = "Open (import)";
// Import an external scene file (add it to the current scene)
binding.import.add = "Add (import)";
// Select all the objects in the scene
binding.selectAll = "Select All";
// Rotate environment and the lighting
binding.rotateLighting = "Rotate lighting";

// Privacy policy
privacyPolicy.title = "Privacy Policy";
privacyPolicy.reject = "Reject";
// Hexanomad is the company name
privacyPolicy = "Hexanomad does not collect any data from Nomad Sculpt.";

// version trial
version.buyWeb = "Web version is only a demo";
version.buyFull = "Upgrade to full version";
version.restorePurchase = "Restore purchase";

version.trialHistory = "Trial version: 4 undo/redo possible";
version.trialLayer = "Trial version: 1 layer per object";
version.trialOneProject = "Trial version: 1 active project only";
version.trialNoImport = "Trial version: No import";
version.trialNoExport = "Trial version: No export";

version.fullFeatures = "- One time purchase
- Unlimited undo/redo
- Unlimited layers
- Save & Load
- Export & import";
