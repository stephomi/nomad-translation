// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "Confirm?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Yes";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "Ok";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Cancel";

// Experimental feature
experimental = "Experimental!";

// On single tap (should be short)
ontap = "On tap";

clipboard = "Clipboard";
clipboard.copy = "Copy";
clipboard.paste = "Paste";

// memory size
bytes = "bytes";
kB = "kB";
MB = "MB";
GB = "GB";
TB = "TB";

// Noun
instance = "Instance";

// Same value (usually for axis, e.g: x == y == z)
uniform = "Uniform";

sync = "Sync";

// position
position.top = "Top";
position.bottom = "Bottom";
position.left = "Left";
position.right = "Right";
position.center = "Center";
// direction
direction.up = "Up";
direction.down = "Down";
direction.left = "Left";
direction.right = "Right";
// 3d cube
cube.top = "Top";
cube.bottom = "Bottom";
cube.left = "Left";
cube.right = "Right";
cube.front = "Front";
cube.back = "Back";

// Name of an item (object, tool, etc)
item.name = "Name";
// Add a new item (object, tool, etc)
item.new = "New";
// Rename an item (object, tool, etc)
item.rename = "Rename";
// Add a new item (object, tool, project, etc)
item.add = "Add";
// Update an item image with a new image (synonym: Update)
item.replace = "Replace";
// Save an item (object, tool, etc)
item.save = "Save";
item.save.confirm = "Confirm save?";
// Update an item (update camera view point, etc)
item.update = "Update";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Last save";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "Load last save?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Reset";
item.reset.confirm = "Confirm reset?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "Instance";
// Uninstance the object, make the object real
item.uninstance = "Un-instance";
// Clone an item (object, tool, etc)
item.clone = "Clone";
// Delete an item (object, tool, etc)
item.delete = "Delete";
item.delete.confirm = "Confirm deletion?";
item.delete.confirm.yes = "Yes, delete";
// When we delete the item but the image is used somewhere
item.delete.used = "Image used";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "To Node";
// Item visibility (object, layer, etc)
item.visible = "Visible";
// Show an item (object, layer, etc)
item.show = "Show";
// Hide an item (object, layer, etc)
item.hide = "Hide";
// Select an item (object, layer, etc)
item.select = "Select";
// Unselect an item (object, layer, etc)
item.unselect = "Unselect";
// Merge an item with another one below (layer)
item.mergeDown = "Merge down";
// The order of an item in a list
item.order = "Order";
// Focus on previous item
item.previous = "Previous";
// Focus on next item
item.next = "Next";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "Lock";
// No item selected
item.none = "None";

// Search something (text entry to filter item)
search = "Search";

// Three-state toggle button (Auto, Off, On)
toggle.on = "On";
// Three-state toggle button (Auto, Off, On)
toggle.off = "Off";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "Auto";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Missing thumbnails, reprocessing files...";
loading.reprocess.cancel = "Skip thumbnails generation?";

access.title = "Accessibility";
access.window = "Assistive window";
access.pinch = "Pinch";
access.drag = "Drag";
access.rotate = "Rotate";
access.roll = "Roll";

// Color of an object
material.color = "Color";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "Roughness";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "Glossiness";
// Whether the material is a metal or not
material.metalness = "Metalness";
// How much light a surface will reflect
material.specular = "Specular";
// Light that the surface can emit (glow)
material.emissive = "Emissive";
// Normal map (synonym: detail, bump)
material.normal = "Normal";
// flip y coordinate
material.normal.flipY = "FlipY";
// Ambient Occlusion (AO)
material.occlusion = "Occlusion";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "Textures";
// Textures/Image
material.texture = "Texture";
// A warning indicating that the mesh has no UVs
material.warningNoUVs = "No UVs!";
// Texture filtering https://en.wikipedia.org/wiki/Texture_filtering
material.texture.filter = "Filtering";
// Nearest Filtering (closest sample)
material.texture.nearest = "Nearest";
// Bilinear Filter
material.texture.linear = "Linear";
// Mipmap filtering
material.texture.mipmap = "Mipmap";
// Triplanar mapping
material.projection = "Projection";
material.projection.triplanar = "Triplanar";

// Minify
about.minify = "Minify UI";
about.minify.help = "You can also tap your screen with 4 fingers, if your device supports it.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Turntable";
// Rotation center of the turntable
about.turntable.pivot = "Rotation center";
// Keep current pivot
about.turntable.pivot.keep = "Keep current";
// Turntable pivot will be at the center of the scene
about.turntable.pivot.scene = "Scene";
// Make the entire scene turn around (speed of the animation)
about.turntable.speed = "Speed";
// Stuffs that I used to make the app
about.credits = "Credits";
// Link to open source projects that I used for the app
about.credits.openSource = "Open-Source";
// Only translate the &
about.credits.arts = "MatCaps & HDRIs";
// Change languages of the app
about.languages = "Languages";
about.languages.help = "Translation files available at $0";
// Link to the App Website
about.website = "Website";
// Link to the App Forum
about.forum = "Forum";
// Link to the App Manual
about.manual = "Manual";
// Link to the App Email
about.mail = "Support";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";
// Link to the App Threads account
about.threads = "Threads";

// The user canceled an operation that was running
alert.aborted = "Operation aborted!";
// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "The object has no holes!";
// No operation occured because the mesh is already manifold
alert.manifold.already = "The mesh is already manifold!";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "The current object is invisible!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Nothing to trim.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Abort trim: the object is fully trimmed.";
// In order to extract something, the mesh needs to have painted mask
alert.extract.none = "Nothing to extract!";
// In order to split something, the mesh needs to have painted mask
alert.extract.split.none = "Nothing to split!";
// List of disabled features when View Mode is selected
alert.view.disabled = "Features disabled in View Mode:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Primitive widgets";
// The object needs to have two parts disconnected
alert.separate.fail = "Could not separate: the object has only one part!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "Remeshed!";
alert.voxelRemesh.empty = "Abort remesh: result mesh has no faces.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "Invalid input!";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "The object will be duplicated";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "The object will be instanced";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Edit pivot mode.";
alert.mask.full = "Mask = 100%!";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "Edit object mode.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Dynamic topology ON";
// See Glossary (DynTopo)
alert.dynamic.disable = "Dynamic topology OFF";
alert.colorPicker = "Drag on the object to pick a color.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Simple tap to exit transform mode.";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "Simple tap to exit edit symmetry mode.";
// Show the painted mask on the mesh
alert.mask.show = "Show mask";
// Hide the painted mask on the mesh
alert.mask.hide = "Hide mask";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Lock selection";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Unlock selection";
// Hide the objects that are not selected
alert.selection.isolate = "Isolate selection";
// Show the objects that are hidden
alert.selection.showAll = "Show all";
// Project quick saving
alert.quickSave = "Saving...";
// Painting on the object was hidden but the user did paint the object
alert.forcePainting.fill = "Show painting activated, [Paint all] was used.";
// Painting on the object was hidden but the user started to paint on the object
alert.forcePainting.tool = "Show painting activated, the object was painted.";
// See Glossary (Multiresolution)
alert.multiresLost = "Multiresolution will be lost!";
// Boolean cut mode will ignore some features
alert.booleanIgnored = "Boolean will ignore masked or hidden area!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "The detail value is high and might require lot of memory!";
// Autosave popup
alert.autoSave.auto = "Autosave in... $0s";
// The selected object doesn't have any layers
alert.needLayer = "The current tool requires an active layer.";
// The user decided to hide the painting on the objects
alert.paintingHidden = "Painting is hidden!";
// The user decided to hide the masking on the objects
alert.maskingHidden = "Mask is hidden!";
// The user decided to display hidden faces
alert.hideIgnored = "Hide is ignored!";
// The selected object doesn't have any layers
alert.noPartialWireframe = "Partial drawing is disabled when wireframe is displayed.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Consider using orthographic camera if you want to avoid perspective frustum distortion when using screen projector.";
// Trial version has a limited number of undo
alert.state.trial = "Trial version: undo canceled";

background = "Background";
// A flat color will be displayed in the background of the scene
background.color = "Color";
// 2 color with rotation
background.gradient = "Gradient";
// The environment (HDRI) will be displayed in the background
background.environment = "Environment";
background.blur = "Blur";
background.exposure = "Exposure";

// Image that the artist uses as a reference
background.imageEnable = "Reference image";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Overlay";
// Opposite of transparency (Alpha)
background.imageAlpha = "Opacity";
background.imageReset = "Reset settings";
background.imageTransform = "Transform";
// X screen coordinate of the image reference
background.imageX = "Position X";
// Y screen coordinate of the image reference
background.imageY = "Position Y";
// Rotation of the reference image
background.imageRotation = "Rotation";
// Scale of the reference image
background.imageScale = "Scale";

// Blend: normal
blend.normal = "Normal";
// Blend: darker
blend.darker = "Darker";
blend.darker.darken = "Darken";
blend.darker.multiply = "Multiply";
blend.darker.linearBurn = "Linear Burn";
blend.darker.colorBurn = "Color Burn";
// Blend: lighter
blend.lighter = "Lighter";
blend.lighter.lighten = "Lighten";
blend.lighter.screen = "Screen";
blend.lighter.linearDodge = "Linear Dodge";
blend.lighter.colorDodge = "Color Dodge";
// Blend: contrast
blend.contrast = "Contrast";
blend.contrast.hardLight = "Hard Light";
blend.contrast.softLight = "Soft Light";
blend.contrast.overlay = "Overlay";
blend.contrast.hardMix = "Hard Mix";
blend.contrast.linearLight = "Linear Light";
blend.contrast.vividLight = "Vivid Light";
blend.contrast.average = "Average";
// Blend: inversion
blend.inversion = "Inversion";
blend.inversion.exclusion = "Exclusion";
blend.inversion.difference = "Difference";
// Blend: cancelation
blend.cancelation = "Cancelation";
blend.cancelation.divide = "Divide";
blend.cancelation.subtract = "Subtract";
// Blend: component
blend.component = "Component";
blend.component.luminosity = "Luminosity";

// Camera (point of view in 3d)
camera = "Camera";
cameras = "Cameras";
camera.view = "View";
// Copy the views
camera.updateView = "Update view point?";
// Add a new camera
camera.addView = "Add View";
// Focus on the camera
camera.focus = "Focus";
// Add on the camera camera
camera.focusOn = "Focus on $0";
// Camera projection, Orthographic or Perspective
camera.projection = "Projection";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Orthographic";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Perspective";
// camera Vertical Field of View
camera.fov = "Vertical Fov";
// Camera Field of View hint
camera.focal = "focal $0mm (35mm sensor)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Rotation";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "Turntable";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Trackball";
camera.rotation.trackball.help = "Trackball gives more degree of freedom you can also roll the camera with 2 fingers.";
// Camera interaction mode, 1st person view
camera.firstPerson = "First Person";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Speed";
// Camera rotation sensitivity
camera.speed.rotation = "Rotation";
// Camera translation sensitivity
camera.speed.panning = "Translation";
// Camera zooming sensitivity
camera.speed.zooming = "Zooming";
// Reset camera position
camera.resetView = "Reset view";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Snap view";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "Camera is snapped (orthographic)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "Orthographic snap";
camera.snapOrthographic.help = "This option also works when using the Snap Cube in the corner.";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Update pivot...";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Double tap on object";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Double tap on background";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "Toggle";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "Selection";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "Scene";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "When double tapping";
camera.doubleTapPivot.help = "Update the rotation pivot when double tapping on the object surface.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "Allow air pivot";
camera.airPivot.help = "Allow new pivot even when zooming outside the object surface.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "When camera starts moving";
camera.autoPivot.help = "Update the pivot when you start interacting with the camera.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Focus";
camera.doubleTapFocus.help = "When double tapping on the object, the camera will pan and focus on the picked point.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "Multiselection";
// There is 0 nodes/items selected
context.noSelection = "No selection";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "Preset";
// Quick curve x side shift
curve.shift = "Shift";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "Spline";
curve.bspline = "B-spline";
curve.precision = "Accuracy";
// snap
curve.snap = "Snap";
curve.snap.offset = "Offset";
curve.snap.offset.help = "A value of 100% is equal to the tube's radius.";
curve.snap.surface = "Surface";
curve.snap.vertex = "Vertex";
curve.snap.grid = "Grid (if snapped)";
// Regular spaced sampling
curve.uniform = "Uniform";
curve.uniform.help = "The curve will be sampled at regular spacing, to ensure uniform density.

You can disable this option to control a bit the edge loops by adding new control points on the curve.";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "Display the falloff in a symmetric way.

This option is only a visual cue, it doesn't impact the falloff itself";
curve.radius = "Radius";
curve.twist = "Twist";
curve.spiral = "Spiral";
curve.spiral.twist = "Twist angle";
curve.spiral.scale = "Scale";
curve.spiral.offset = "Offset";
curve.spiral.angle = "Angle offset";
curve.pivot = "Pivot";
curve.pivot.self = "Self";
curve.pivot.children = "Children";

// Set the desired FPS (frame per second, refresh rate)
debug.targetFPS = "Target FPS";
debug.targetFPS.help = "When disabled, the default value means it will sync with the display's refresh rate.";

// Warning about UVs (using extra memory)
debug.uvPrimitive.warning = "Disable this option if you don't need UVs.

Meshes with UVs will use more memory.";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "Normalize UVs";
debug.uvNormalize.help = "Nomad will normalise the UVs inside the [0-1] tile.";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "Add BFF UVs";
debug.uvBFF.help = "Add an alternative unwrapping method (boundary first flattening).

Note that BFF will produce overlaps if your mesh topology is different than a disk or a sphere.";

// Debug option, display an window with some debugging logs
debug.logs = "Logs";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Heightmap";
// Debug options, graphical stuffs
debug.graphics = "Graphics";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Make store thumbnails";

// Empty list: there is no projects
file.project.empty = "You have no saved project yet!";
// The current opened project has some unsaved changes
file.project.unsaved = "Unsaved changes!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "You will lose unsaved changes!";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Preview of the last manual save";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "Trial version: You won't be able to re-open the current project!";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "Trial version: you can only re-open your current project!";

file.project = "Project";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Save";
// E.g: Save "my_project"?
file.project.save.confirm = "Save $0?";
// Overwrite another project
file.project.saveAs = "Save As";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "Overwrite $0?";
// Open a project
file.project.open = "Open";
// E.g: Open "my_project"?
file.project.open.confirm = "Open $0?";
// Load another project and add/append all its data to the current scene
file.project.add = "Add to scene";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "Add $0 to the scene?";
// Reset the scene and create a new project
file.project.new = "New";
file.project.new.confirm = "Create new scene?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "Delete $0?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "Delete $0?

This is the current active project!";

// Auto save section
file.project.autoSave = "Auto Save";
file.project.autoSave.confirm = "Disable Auto Save?";
file.project.autoSave.help = "Save your project in a separate file at regular interval.

The autoSave file can be found at:";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "Popup timeout";
// In minutes
file.project.autoSave.minutes = "Timer popup";
// Delete the current autoSave data
file.project.autoSave.delete = "Discard Auto Save";

// color space (linear or srgb), do not translate linear/srgb if there is a doubt
file.colorSpace = "Color Space";
file.colorSpace.help = "Try to toggle this option if the colors seem incorrect.";
file.colorSpace.linear = "Linear";
file.colorSpace.srgb = "sRGB";

// Configure imports option
file.importSettings = "Import options";

// Load interface preference settings when opening a scene file
file.import.guiSettings = "Keep gui settings";
file.import.guiSettings.help = "When opening or importing a project file, all the gui-related settings embedded in the project will be loaded.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.import.obj.splitByGroup = "Split OBJ by groups";
file.import.obj.splitByGroup.help = "When enabled, Nomad will split the OBJ groups into separate objects.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.import.mergeLayers = "Merge Layers";
// Ignore the textures present in the file to load
file.import.skipTextures = "Skip textures";
// Do not fiddle with the object topology when loading the file
file.import.keepTopology = "Keep topology";
file.import.keepTopology.help = "Use this option if you don't want Nomad to fiddle with the topology of imported mesh.

It will disable vertex/face reordering, removal of vertex/face duplicates and removal of unused vertices.";

// Import file section
file.import.title = "Import";
file.import.title.help = "Supported format:";
// The user imports a scene file that will replace the current scene
file.import.open = "Open";
file.import.open.confirm = "Import new file?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Add to scene";
file.import.add.confirm = "Import new file?";

// Export scene file
file.export.title = "Export";

file.select.include = "Include";
file.select.all = "All";
file.select.visible = "Visible";
file.select.selected = "Selected";
file.select.unselected = "Unselected";

// Export the current selected objects instead of the entire scene
file.onlySelection = "Only include selected objects";
file.onlySelection.help = "Only include the selection, instead of the entire scene.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Reconstruct quad";
file.convertToQuad.help = "Reconstruct quads from triangles by pairing triangle (if they are adjacent in the files).";
// ----------------------------------------------
// Whether we include the textures in the exported file
file.export.texture = "Textures";
// Baking means transfering/converting
file.export.texture.help = "This option doesn't bake vertex colors into textures.

It only include textures if the object has textures on its material.";
// ----------------------------------------------
file.export.color0 = "Vertex colors";
file.export.color1 = "PBR paint";
file.export.color1.help = "Export roughness, metalness and mask painting. This will be ignored by other softwares.";
// ----------------------------------------------
// Whether we include normals vector in the exported file
file.export.normal = "Normals";
file.export.normal.help = "Check this option if you want to open the file in another softwares.

Nomad always ignore the normals as it will recompute them.";
// ----------------------------------------------
file.export.tangent = "Tangents";
file.export.tangent.help = "Check this option if you want to open the file in another softwares.

Tangents are only used if the model has a normal map.

Nomad always ignore the tangents as it will recompute them.";
// ----------------------------------------------
file.export.nomad = "Export Nomad";
file.export.nomad.help = "Nomad Sculpt internal file format.

This format won't load on other softwares, this is mostly for re-import purposes.";
// ----------------------------------------------
file.export.gltf = "Export glTF 2.0";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Layers";
file.export.gltf.layer.help = "Export layers as morphs. Officially supported by glTF so it should work on other softwares as well.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Layer painting";
file.export.gltf.layerPaint.help = "Export layer painting. It is usually ignored by other softwares.";
// ----------------------------------------------
file.export.obj = "Export OBJ";
file.export.obj.warning = "Layers and extra painting (roughness metalness and mask) will be lost.";
// Whether we include the vertex color in the exported file
file.export.obj.color = "Vertex colors";
file.export.obj.color.help = "Some 3d softwares will be able to read it but not all of them.";
file.export.obj.color.help.append = "Append color information after vertices.";
file.export.obj.color.help.hexa = "An alternative way to encode color. It also supports mask data.";
file.export.obj.faceGroup = "Face Group";
file.export.obj.object = "Write Objects";
file.export.obj.object.help = "Keep objects separated.

Disabling this option will export everything as a single entity.
You need to disable this option if you want to use the Substance Painter 'Mesh ID / Polygroup' feature.";
file.export.obj.archive = "Type";
file.export.obj.archive.folder = "Folder";
file.export.obj.archive.zip = "Zip";
file.export.obj.archive.help = "Some apps (Google Drive, One Drive, etc) don't support folder import, so you can use Zip instead.";
// ----------------------------------------------
file.export.stl = "Export STL";
file.export.stl.warning = "Layers and extra painting (roughness, metalness, etc) will be lost.";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Vertex colors";
file.export.stl.color.help = "Some 3d softwares will be able to read it but not all of them.";
// ----------------------------------------------
file.export.ply = "Export PLY";
file.export.ply.warning = "Layers and extra painting (roughness, metalness, etc) will be lost.";
// ----------------------------------------------
file.export.fbx = "Export FBX";
// ----------------------------------------------
// Advanced settings
settings.advanced = "Advanced";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "These options are not saved in the settings.";
settings.reset.title = "Settings";
settings.reset.title.help = "It will reset the app preference settings.

Some resources are saved separately and will NOT be resetted, it includes:
• Projects
• Key Bindings
• Tools Presets
• HDRs Environments
• MatCaps
• Alphas
• Textures (brush)
• Reference Images

Note that everything linked to the project will be kept intact, such as lighting, Post Process, camera views, etc";

// Reset preference settings button
settings.reset = "Reset to default";
settings.reset.confirm = "Reset preference settings?";

// Render a screenshot of the scene
file.render = "Render";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Show interface";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Render ratio";
file.render.renderRatio.help = "A value of 1.0 means that Nomad will render at the same resolution as the requested image size below.

Use this option if you cannot render at certain resolution (crashes because of lack of memory).";
// Desired size of the exported screenshot
file.render.size = "Final size";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Custom";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "Screen";
// width of exported screenshot
file.render.width = "Width";
// height of exported screenshot
file.render.height = "Height";
// export screenshot of the scene
file.render.export = "Export png";
file.render.warn = "The export resolution is high ($0x$1)!

Make sure to save your project in case your device runs out of VRAM and crashes.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Transparent background";
file.render.transparent.help = "This option can be useful if you want to insert the mesh in a 2d creation software.

Partial object transparency is not supported for now.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Use global settings";
pressure.useGlobal.help = "By default, the tools share the same pressure settings.

Uncheck this option if you want specific pressure settings for this tool.";

// Pencil pressure
pressure.title = "Pressure";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "This tool doesn't use pencil pressure.";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "Grab stroke type will ignore pressure settings.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Radius";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Intensity";
// Average pencil pressure event to get smoother result
pressure.average = "Pressure smoothing";
pressure.average.help = "Average the pencil pressure events for smoother results.";

// list of inputs allowing camera interaction
gesture.camera = "Camera";
// list of inputs allowing sculpting interaction
gesture.sculpt = "Sculpt";
// Select object
gesture.select = "Select object";
// Finger/Touch input
gesture.finger = "Finger";
// Stylus/Pencil
gesture.stylus = "Stylus";
// Mouse/Trackpad
gesture.mouse = "Mouse";

// long press to pick the color/material under the cursor
gesture.dropper = "Material picking";
gesture.dropper.help = "The color/material picker can be triggered by long-pressing on the canvas.

Note that it only work if the current brush has painting enabled.";

// Three fingers on screen
gesture.three.title = "Three fingers";
gesture.three.light = "Rotate lighting";
gesture.three.light.help = "Rotate the environment, lights and MatCap.";
gesture.three.radius = "Tool Radius";
gesture.three.intensity = "Tool Intensity";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.finger.smooth = "Finger always smooths";
gesture.finger.smooth.help = "This option is only active if a sculpting tool is active.";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Allow unrecognized pressure";
gesture.unknownPressure.help = "Check this option if the pressure doesn't work with your pencil or if you need pressure finger.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Pencil button";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Pencil double tap";
gesture.pencilAction.ios.help = "Only active for Apple Pencil 2nd gen.";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "None";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Add/Sub";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "One tap shortcuts";
gesture.mask.oneTap.help = "Allow the Mask shortcut by tapping the screen once, without having to hold the mask button shortcut.

It will allow the following gesture:
• tap on the background to invert the mask
• tap on a masked area to blur the mask
• tap on an unmasked area to sharpen the mask";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.holdStroke = "Stroke";
gesture.mask.holdStroke.help = "Long press will toggle between Mask and SelMask and start a new stroke.

At the end of the stroke, the previous tool is selected back.";
gesture.mask.holdIdle = "Tool";
gesture.mask.holdIdle.help = "Long press and release without moving to switch between Mask and SelMask.";

// Shortcut customization, choose the action that the shortcut will performan (select tool, etc)
gesture.shortcut = "Shortcut";

// Shortcuts to undo/redo
gesture.history = "History shortcuts";
gesture.history.help = "• Undo: tap with 2 fingers
• Redo: tap with 3 fingers";
gesture.history.hold = "Long press";
gesture.history.hold.help = "Hold 2/3 fingers down.";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Palm rejection";
gesture.palmRejection.confirm = "Make sure to disable this option if you have trouble interacting with the canvas!";
gesture.palmRejection.help = "Reject input if the contact area size larger than this value.

Might not work on every device.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Max size threshold";

// Smoothing strategy
extract.polish.all = "All";
extract.polish.sharp = "Sharp border";
extract.polish.border = "Borders only";
// Smooth the border in a way that it matches completely with its dual
extract.polish.syncBorder = "Sync border";
// topology of extracted mesh
extract.edgeLoop = "Edge loop (side)";
extract.edgeLoop.auto = "Auto edge loop";
extract.edgeLoop.division = "Division";
// The thickness of the extracted mesh (from the painted mask)
extract.thickness = "Thickness";
// Carve the mask into the surface
extract.carve = "Carve";
// Extract a new mesh from the painted mask
extract = "Extract";
// Preview extract
extract.preview = "Preview";
// Extract two new mesh from the painted mask and from the unmasked area
extract.split = "Split";
// How should we close the topology of the extracted object
extract.action = "Closing action";
extract.action.help = "• None
Simply extract the part and let the extracted part opened.

• Fill
Hole is filled and smoothed.
Do not use this option for flat surface.

• Shell
Close the extracted shape by using the thickness value.

• Layer
Extract the layer difference (layer sub-menu only).";
// Do not close the mesh (leave it open)
extract.action.none = "None";
// Close the mesh with a hole-filling algorithm
extract.action.fill = "Fill";
// Close the mesh by adding a thickness on the surface
extract.action.shell = "Shell";
// Close the mesh by using the layer data as a difference thickness
extract.action.layer = "Layer";

// uv part of revolution surface
genus.main = "Main";
genus.hole = "Hole";
genus.bottom = "Bottom";
genus.top = "Top";

// History, list of undo/redo
history = "History";
// First "undo" state
history.root = "Root";
history.undoConfirm = "Do you confirm undoing all these operations?";
history.undoWarning = "If you make an edit afterwards you might lose lot of changes.";
// Settings concerning the history stack of undo/redo
history.stack = "Stack";
// Actions to include in the undo/redo stack
history.include = "Include actions";
// include lighting editing in the undo/redo
history.includeLights = "Lights";
history.includeLights.help = "If this option is disabled, moving the lights with the Gizmo will still be included, as it can impact other objects in the scene hierarchy.";
// include postProcess editing in the undo/redo
history.includePostProcess = "PostProcess";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCaps & HDRIs";
// Can limit the stack of undo/redo size
history.limitSize = "History limit";
history.limitSize.help = "Maximum size of the history.

The history will be updated on the next recorded operation.";
// Limit the number of undo in the history stack
history.limitStack = "Stack limit";
history.limitStack.help = "Maximum number of operation the application can keep.

The history will be updated on the next recorded operation.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Maximum undoable";
history.rangeProtect.help = "If you go far in the history, it will prompt a confirm dialog before undoing many operations.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Restore camera";
history.restoreCamera.help = "Enable this option to restore the saved camera viewpoint when you undo/redo an action.";
// Undo
history.undo = "Undo";
// Redo
history.redo = "Redo";
// Shown during undo
history.state.undo = "Undo: $0";
// Shown during redo
history.state.redo = "Redo: $0";
// Shown during undo/redo
history.state.symmetrySplit = "Symmetry Split";
// Shown during undo/redo
history.state.voxelRemesh = "Voxel remesh";
// Shown during undo/redo
history.state.surfaceRemesh = "Surface remesh";
// Shown during undo/redo
history.state.multiresLevel = "Resolution change";

// Debugging/Inspect object material (view channel separately color, roughness, normal, uv, etc)
inspect = "Inspector";
// Inspector but SHORT
inspect.short = "Inspect";
// Display the material channel on the background
inspect.onBackground = "On Background";
// Display the material channel on the mesh
inspect.onMesh = "On Mesh";
// Show UV seams
inspect.seams = "Seams";

// Interface customization
interface = "Interface";

// UI customization: one item row will stands on one line (synonym: Inlined)
interface.compact = "UI: Compact";

// UI customization: each row of the list will be bigger
interface.expandList = "UI: Expand list";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Just an UI option for easier list management.";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "Add shortcuts (bottom)...";

// Interface option (main base color)
interface.colorBase = "Color base";
// Interface option (accent widget color)
interface.colorSelect = "Color widget";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Transparent panel";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Blur strength";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Color panel";

// Interface color style
interface.preset.title = "Presets";

// Reset interface settings
interface.resetAll = "Reset style";
interface.resetAll.confirm = "Reset interface settings?";
// help popup when hovering
interface.hoverHelp = "Help popup on hover";
// Interface option (main base color)
interface.iconSupport = "High-contrast button";
interface.iconSupport.help = "An alternative style for buttons that makes them more visible when they are enabled.

If set on Auto, Nomad will use this mode when the UI color contrast between enabled/disabled is low.";
// Interface customization
interface.flipTop = "Mirror top bar";
// Interface customization
interface.flipBottom = "Mirror bottom bar";
// Interface customization
interface.flipMiddle = "Mirror side bars";
// list of tools
interface.toolbox = "Toolbox";
// hide toolbox by default
interface.toolbox.hide = "Hidden";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.columns = "Columns";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.rows = "Rows";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Reset order";
// Colored text and icon
interface.toolbox.color = "Colored";
// Scale the interface
interface.scale = "Overall scale";
// Spacing between widgets
interface.cursorStep = "Vertical spacing";
// Width of the interface panels
interface.panelWidth = "Panel width";
// Size of fonts
interface.fontScale = "Font scale";
// Inset
interface.inset.title = "Edge offsets";
interface.inset.title.help = "You can change these values only if you have issues interacting with the buttons on the screen edges.

If the slider is disabled, Nomad will use the safe area values returned by the device itself.";

// (see Glossary for Layer)
layer = "Layer";
layers.syncTransform = "Sync transform";
layers.syncTransform.help = "If enabled, all the unselected layers will be adjusted depending on the transform rotation, scale and skew.

Disable this option if the other layers are meant to be used without the new transform that you are applying.

When set on auto, only the visible layers will be adjusted.";
// (see Glossary for Layer)
layers.lock = "Keep top layers details";
// (see Glossary for Layer)
layers.lock.yes = "Lock the top layers?";
// (see Glossary for Layer)
layers.lock.warning = "During sculpting, the deformation coming from the top layers will be ignored.

However the details of these layers will still be visible.

This option only works if the top layers have relatively small scale details.";
// (see Glossary for Layer)
layers.addLayer = "Add layer";
// (see Glossary for Layer)
layer.factors = "Channel factors";
// (see Glossary for Layer)
layer.factor = "Factor";
// (see Glossary for Layer)
layer.offset = "Offset";
// Layer blend mode
layer.blendMode = "Blend Mode";
// (see Glossary for Layer)
layer.base = "Base";
layer.base.nothing = "Nothing to extract!";
layer.base.background = "Background material";
layer.base.background.help = "If active, only the material values that differs from the background material will be extracted.";
// (see Glossary for Layer)
layers.title = "Layers";
// (see Glossary for Layer)
layers.title.help = "Layers can record position offsets and painting, it can be useful for non-linear workflow.
For example by experimenting different facial expression without relying on the history stack to undo the changes.

For painting data, layers are sorted in a top-down fashion; so layers on top will mask the lower ones.

You can erase part of the layer by using the `DelLayer` tool.";
layers.primitive = "Layers are unavailable for primitives.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "None";

light = "Light";
lights = "Lights";
// Intensity of light
light.intensity = "Intensity";
// Color of light
light.color = "Color";
// Kelvin (the temperature unit)
light.kelvin = "Kelvin";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "Temperature";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Attachment";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Fixed";
// The light will move along the camera
light.attachment.camera = "Camera";
light.attachment.help = "• Fixed
Light orientation won't change.

• Camera
Light orientation depends on the camera view.";
// Light type (directional, spot, point)
light.type = "Type";
// Directional light (synonym: sun light)
light.type.directional = "Directional";
light.type.sun = "Sun";
// Directional light (synonym: sun light)
light.type.environment = "Environment";
light.type.hdri = "HDRI";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Spot";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Point";
// For directional light (angle jitter)
light.angle = "Angle";
// For point/spot light (offset jitter)
light.size = "Size";
// Cone angle for spot angles
light.spot.angle = "Cone angle";
// Softness of the spot light
light.spot.softness = "Softness";
// Position of the light
light.position = "Position";
// Enable or disable shadows for a light
light.shadow.cast = "Shadow";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "Point light only supports screenspace shadows.";
light.shadow.type = "Shadow type";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "Shadow map";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "Screenspace";
light.shadow.type.screenspace.help = "Experimental feature, it might be removed in a future release.

This option is meant to be used with the softness shadow feature.";
// Adjustment to fix artefacts
light.shadow.bias = "Bias";
// How blurry the shadow is
light.shadow.softness = "Softness";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "Contact";
light.contact.help = "If auto is selected, only the most dominant light will have contact shadow.";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "Tolerance";
// Activated the light
light.visible = "Show";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Recenter";

// Object's material
material = "Material";
// See glossary
material.pbrRoughnessMetalness.warning = "Roughness and Metalness requires PBR shading mode.";
// See glossary
material.pbrReflectance.warning = "Reflectance requires PBR shading mode.";
// See glossary
material.pbrRefraction.warning = "Refraction requires PBR shading mode.";
// See glossary
material.pbrSubsurface.warning = "Subsurface requires PBR shading mode.";
// Value that says how much light will change direction when hitting the surface
material.ior = "Index of Refraction";
// an object-level value that overrides the roughness interior/surface of the mesh
material.paintingOverride = "Override roughness";
// The roughness in the inside is turbidity
material.paintingOverride.help = "There are two roughness at play, the one that drives the surface and the one in the inside.

However there is only one paintable roughness, so the two roughness have the same values.";
// Glossiness is simply the opposite of roughness
material.refraction.surface = "Surface";
// Synonym: turbidity
material.refraction.interior = "Interior";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Paint glossy";
material.paintGlossy.help = "It will paint the object with a roughness and metalness of 0, thus allowing sharp refraction.

This is the same as going in the painting menu and using the paint all feature with color disabled.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Absorption";
material.absorptionEnable.help = "Simulate the light being absorbed when it travels through the volume.

Thin parts will bright as it lets more light pass through, while thick areas will be darker.

The effect heavily depends on the object shape, only an approximation of the object thickness is used.";
material.absorptionFactor = "Factor";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "Depth";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "Translucency";
material.translucency.help = "You need to have a light that casts shadows in order to see translucency.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Opacity";
// Fully opaque material
material.type.opaque = "Opaque";
// See glossary
material.type.subsurface = "Subsurface";
material.type.subsurface.help = "To get the best result, you can switch to PBR shading mode and use at least one directional light, ideally with a dim environment.";
// Transparency mode, alpha blending
material.type.blending = "Blending";
material.type.blending.help = "Make the object semi-transparent by tweaking the opacity value.

Note that because of real-time constraints, you can have noticeable visual artifacts if your object has a complex shape.";
// Transparency mode
material.type.additive = "Additive";
material.type.additive.help = "Make the object semi-transparent by tweaking the opacity value.

This method tends to have less artifacts than the Blending method, but the object will be brighter.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Dithering";
material.type.dithering.help = "Make the object semi-transparent by discarding some pixels in a random fashion.";
// Simulate glass-like material
material.type.refraction = "Refraction";
material.type.refraction.help = "This mode can be used to simulate glass material.

Because of real time constraints, self-refraction or multi-layered refraction is limited.";
material.castShadows = "Cast shadows";
material.receiveShadows = "Receive shadows";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Always unlit";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Inverse culling";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Reflectance";
material.reflectance.help = "Control the amount of reflection the material will receive for non-metallic materials.

Most of the time, the default value should be used (which corresponds to the standard 4% reflected light at normal angle).";
// Material preview in the viewport
material.preview = "Material viewport preview";
material.preview.help = "When you modify a material, a preview will be displayed in the viewport on the selected object.

The preview is shown while you interact with the color, roughness, metalness, opacity and intensity sliders.";
// Menu name
menu.files = "Files";
// Menu name
menu.scene = "Scene";
// Menu name
menu.multires = "Multires";
// Menu name
menu.voxel = "Voxel";
// Menu name
menu.dynamic = "DynTopo";
// Menu name (Synonym: Misc, Other)
menu.topology = "Misc";
// Menu name
menu.primitive = "Primitive";
// Menu name
menu.render = "Render";
// Menu name
menu.material = "Material";
// Menu name
menu.postprocess = "PostProcess";
// Menu name
menu.camera = "Camera";
// Menu name
menu.background = "Background";
// Menu name
menu.tool = "Tool";
// Menu name
menu.stroke = "Stroke";
// Menu name
menu.alpha = "Alpha";
// Menu name
menu.filter = "Filter";
// Menu name
menu.falloff = "Falloff";
// Menu name
menu.paint = "Paint";
// Menu name
menu.symmetry = "Symmetry";
// Menu name
menu.operation = "Operation";
// Menu name (pencil pressure)
menu.pressure = "Pressure";
// Menu name
menu.gesture = "Gesture";
// Menu name
menu.layers = "Layers";
// Menu name
menu.settings = "Settings";
// Menu name
menu.interface = "Interface";
// Menu name
menu.bindings = "Bindings";
// Menu name
menu.history = "History";
// Menu name
menu.historySettings = "Settings";
// Menu name
menu.about = "About";
// Menu name
menu.debug = "Debug";

// Operation on the object (action)
mesh.holes = "Holes";
// If the object has holes, the algorithm will close them
mesh.holes.close = "Close holes";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holes.detail = "Detail";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Separate";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "Layers, painting and multiresolution will be lost.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Resolution";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Force cubic";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Convert";
// Static object means "static topology"
mesh.static = "Mesh";
// See glossary
mesh.multires = "Multires";
// Dynamic topology
mesh.dynamic = "DynTopo";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Global material";
paint.useGlobal.help = "If this option is enabled, the selected material will be the same as the other tools.

Note that it only takes into account roughness, metalness and color settings.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Stroke painting";
// If true save the textures data into
paint.preset.embed = "Embed textures";
paint.preset.embed.help = "The textures can be found in the Nomad textures/ folder.
The material presets can be found in the Nomad materials/ folder.

When this option is off, the material preset only reference the texture inside the textures/ folder.

You can enable this option to make a copy of the textures inside the material preset.
It can be useful if you want to share a textured preset without providing the associated textures.";
paint.preset.embed.apply = "Apply to all materials";
// Factor/Opacity of paint tool
paint.intensity = "Paint intensity";
// Apply the paint on the object
paint.paintAll = "Paint all";
paint.paintAll.help = "Apply the current material to the object.";
paint.paintAll.help.mask = "Masked area won't be affected.";
paint.paintAll.help.hide = "Hidden area won't be affected.";
paint.paintAll.help.opacity = "Use the tool painting factor above.";
paint.paintAll.help.layer = "Unpainted area of a layer won't be affected.";
paint.strokePainting.title = "Painting";
// Brush stroke texture
paint.texture.warningEnable = "Stroke painting needs to be enabled to allow texture projection (checkbox on top)!";
paint.texture.warningIgnored = "The current tool cannot use textures!";
// use stencil mode
paint.stencil = "Stencil";
// Inherit stroke falloff option for the painting
paint.tool.help = "Use the tool alpha, falloff and randomizer to modulate the painting stroke intensity.

These options are igored for the paint all feature, but the alpha is taken into account for the triplanar variant.";
// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "New name";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "New value";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "New color (hex format)";

// Post process effect
postprocess = "Post Process";
// Quality vs performance
postprocess.quality = "Quality";
postprocess.quality.help = "Activate these options to improve the quality to the detriment of performance.";
// More samples means better quality but slower performance
postprocess.maxSamples = "Max samples";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Full Resolution";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "Max frame sampling";
postprocess.accumulateCount.help = "Maximum number of frames to accumulate before the rendering stops.

When the rendering stops, Nomad won't do anything, thus saving battery life.

Many rendering features benefit from frame accumulation, notably:
• Soft Shadows
• Global Illumination
• Reflection (SSR)
• Ambient Occlusion
• Subsurface
• Depth Of Field

High frame counts are mostly necessary for Soft Shadows and Global Illumination.
Nomad can stop the rendering sooner if the features mentioned aboved are disabled.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Render resolution";
postprocess.renderRatio.warning = "Overriden by the Pixel Art effect.";
postprocess.renderRatio.help = "This option impacts the performance a lot.
It's advised to keep a value lower than x1.25.

This option is not saved in the settings.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "Anti-aliasing (TAA)";
postprocess.taa.help = "Reduces flickering when you are moving the camera.";
// Ditherhing pixel
postprocess.dithering = "Dithering";
postprocess.dithering.help = "Dither pixels to reduce banding artefacts.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "Reflection (SSR)";
postprocess.ssr.warning = "SSR requires PBR shading mode.";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "Global Illumination (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "Tolerance";
postprocess.ssgi.warning = "SSGI requires PBR shading mode.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "Ambient Occlusion";
// How far the effect spreads
postprocess.ssao.radius = "Size";
// How strong the effect is
postprocess.ssao.factor = "Strength";
// Adjustment to fix artefacts
postprocess.ssao.bias = "Curvature bias";
postprocess.ssao.bias.help = "How sensitive the effect is depending on the surface curvature.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "Depth Of Field";
// The blur factor behind the focused point
postprocess.dof.blurFar = "Far blur";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "Near blur";
postprocess.dof.focusTip = "Tap an object to change the focus point.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "Bloom";
// Intensity of the effect
postprocess.bloom.intensity = "Intensity";
// How far the effect spreads
postprocess.bloom.radius = "Radius";
postprocess.bloom.radius.help = "How widespread the bloom is.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "Threshold";
postprocess.bloom.threshold.help = "Luminosity threshold to decide if a pixel will emit bloom or not.
If the value is at 0, everything will receive bloom.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "Tone Mapping";
postprocess.tone.exposure = "Exposure";
postprocess.tone.contrast = "Contrast";
postprocess.tone.saturation = "Saturation";
postprocess.tone.hue = "Hue";
// No tonemapping operator is used
postprocess.tone.mapping.none = "None";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "Neutral";
// Color curves
postprocess.curve = "Color Grading";
// Curve for pixel luminance
postprocess.curve.luminance = "Main";
postprocess.curve.red = "Red";
postprocess.curve.green = "Green";
postprocess.curve.blue = "Blue";
// Reset color grading curves
postprocess.curve.resetAll = "Reset All";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "Chromatic Aberration";
postprocess.chromatic.factor = "Strength";
// Darking on the edges
postprocess.vignette = "Vignette";
// How far the effect spreads
postprocess.vignette.size = "Size";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "Hardness";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "Sharpness";
postprocess.sharpness.factor = "Strength";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "Grain";
postprocess.grain.factor = "Strength";
// Accentuate the edges of the model
postprocess.curvature = "Curvature";
// main strength of curvatre
postprocess.curvature.factor = "Factor";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "Cavity";
// Color/Strength of convex curvature
postprocess.curvature.bump = "Bump";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "Pixel Art";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "Allow frame sampling";
// Simulate scanline rendering (horizontal line)
postprocess.scanline = "Scanline";
postprocess.scanline.factor = "Factor";
// Spacing between lines
postprocess.scanline.spacing = "Spacing";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Primitive";
primitive.box = "Box";
primitive.sphereCube = "Sphere";
primitive.sphereUV = "UV Sphere";
primitive.icosahedron = "Icosahedron";
primitive.cylinder = "Cylinder";
primitive.cone = "Cone";
primitive.torus = "Torus";
primitive.lathe = "Lathe";
primitive.tube = "Tube";
primitive.plane = "Plane";
primitive.triplanar = "Triplanar";
primitive.faceXYZ = "Face XYZ";
primitive.faceXYZ.help = "UV-unwrapped base mesh provided by https://texturing.xyz/";
primitive.needValidate = "Primitive should be validated!";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Edit";
primitive.edit.help = "Allow 3d editing in the viewport.

You can disable this feature if you want to interact with the Gizmo or the Transform tool without modifying the primitive.";

// Primitive configuration
primitive.mainConfig = "Parameter";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Topology";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Geometry";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Validate";
// Maximum number of faces of the primitives
primitive.maxFaces = "Max faces";
primitive.maxFaces.help = "The maximum number of faces a primitive can have.

This limit is only active while the primitive is not validated, afterwards the safeguard is gone.";
// Synonym: Flat subdivision
primitive.linear = "Linear subdivision";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Post subdivision";

// Radius (of a sphere, torus, etc)
primitive.radius = "Radius";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radius.sync = "Same radius";
primitive.radius.start = "Radius start";
primitive.radius.end = "Radius end";
// Size (of cube x dimension)
primitive.size = "Size";
primitive.sizeX = "Size X";
primitive.sizeY = "Size Y";
primitive.sizeZ = "Size Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "Division";
primitive.divisionX = "Division X";
primitive.divisionY = "Division Y";
primitive.divisionZ = "Division Z";
// Angle of torus, etc
primitive.angleX = "Angle X";
primitive.angleY = "Angle Y";
primitive.angleZ = "Angle Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Constant density";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Project on sphere";
primitive.projectOnSphere.help = "Snaps the points on a perfect sphere.";

// triplanar
primitive.triplanar.title = "Triplanar";
primitive.triplanar.title.help = "Triplanar is using the mask information from 3 planes to fill a voxel grid that is then polygonized.

If you interact with the division or size sliders, the painting information will reset (smoothness is ok).

You should probably disable symmetry as it might not function as you would expect.

You can use the `Topologically connected option in the mask panel to paint a plane impacting the other planes.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanar.sameSize = "Same size (cube)";
primitive.triplanar.polish = "Smoothness";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanar.resetMask = "Reset mask";
// One side of a cube (the back plane)
primitive.isolate.back = "Back";
// One side of a cube (the right plane)
primitive.isolate.right = "Right";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Bottom";
// Plane
primitive.planeSameSize = "Same size (square)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "Disk";
// Box
primitive.boxRegular = "Same size (cube)";
// Torus
primitive.torus.radiusOuter = "Outer radius";
primitive.torus.radiusInner = "Inner radius";
primitive.torus.angle = "Angle";
primitive.torus.angleOffset = "Angle offset";
// Cylinder
primitive.cylinder.height = "Height";
// Cone
primitive.cone.radius = "Radius";
primitive.cone.height = "Height";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Hole";
// Make a hole in the primitive to make it hollow
primitive.hasHole = "Has hole";
// Curve profile (synonym: profile, curve)
primitive.profile = "Profile";
primitive.profile.viewport = "Show in viewport";
// If the revolution surface has caps (E.g: cylinder)
primitive.cap = "Cap";

// Singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "Repeater";
// All the new items will be inserted inside the bound rather than outside
repeater.array.fitInside = "Fit inside";
// The object will follow the curve
repeater.curve.align = "Align";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Import...";
// iOS Photos gallery
resource.import.ios.photos = "Photos";
// iOS Files App
resource.import.ios.files = "Files";

scene.title = "Scene";
scene.title.help = "When using the visible/select buttons, hold and drag your finger to select other objects easily.

You can also long press the visible/select buttons to affect the children as well.";
// The view will focus on the item when we click on it
scene.focus = "UI: Focus on item on double tap";
// Add new object on gizmo position
scene.addOnGizmo = "On gizmo";
scene.addOnGizmo.help = "Move the node on the gizmo position (if the gizmo tool is selected)";
// Select the gizmo tool after adding a new object
scene.addSelectGizmo = "Select gizmo";
scene.addSelectGizmo.help = "Select the gizmo tool when adding a new node";
// Icon size in pixel (min/max)
scene.iconSize = "Icon size";
// Min size of icon
scene.iconSize.min = "Min";
// Max size of icon
scene.iconSize.max = "Max";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "Hierarchy lines";
scene.showHierarchy.help = "Display a line between parent and its children in the viewport.";
scene.showHierarchyNomadPivot = "Use Nomad pivot";
scene.showHierarchyNomadPivot.help = "The Nomad pivot is the pivot used by the Transform and Gizmo tools.

If this option is disabled, it will use the natural base pivot.
In some case this base pivot can be far away from the object center itself!";
// The view will focus on the item when we click on it
scene.syncVisible = "Sync visibility";
scene.syncVisible.help = "When enabled, using the visible (eye) icon will impact all the selected items.";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "Join";
// Group the selected object with a new created Empty Node as a parent
scene.group = "Group";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "Unparent";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "Mirror";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "Curve";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "Array";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "Radial";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "Repeaters";
scene.repeaters.help = "Repeater nodes that make instances of any geometries below it in the scene hierarchy.";
// Validate button
scene.validateGroup = "Validate";
// Keep instances in the scene
scene.validateGroup.keepInstances = "Keep instances";
// If we should join children
scene.validateGroup.joinChildren = "Join children";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Voxel merge";
scene.voxelResolution = "Resolution";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Subtraction: Hidden objects";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Intersection: All objects hidden";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "No selected object, please select at least one object.";
// Need to select one object only
scene.noneButNeedOne = "No selected object, please select one object.";
// Need to select one object only
scene.onlyOneObject = "Multiple objects are selected, please select only one object.";
// Boolean operation
scene.boolean = "Boolean";
scene.boolean.help = "Merge, subtract or intersect objects by performing a boolean operation.

The operation can fail if some objects are not manifold or not watertight.

If the boolean fails, you can always use the voxel remesher on the problematic object to ensure it's a watertight manifold.";
// Weld intersection
scene.boolean.mergeIntersection = "Weld intersection";

// General scene display settings
settings.display.title = "Display settings";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Wireframe";
// Display the material texture
settings.debugChannel = "Show Texture";
// Display the material texture in the background
settings.debugChannel.onBackground = "In Background";
// Display the material texture on the mesh
settings.debugChannel.onMesh = "On Mesh";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Two sided";
settings.twoSided.help = "Faces will be visible from both sides.";
// If we colorize the inverted side of faces
settings.backface.color = "Backface color";
// Color of the inverted side of faces
settings.backface.colored = "Colored backface";
// Outline (contour highlight around the selected object)
settings.outline = "Outline";
// Outline (contour highlight around the selected object)
settings.outline.help = "Selected objects will be outlined.";
settings.outline.thickness = "Thickness";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Snap cube";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "Bottom";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "Left";
// Flip the camera (rotate 180° to see the other side)
settings.snapCube.flip = "Flip 180°";
settings.snapCube.flip.help = "Flip the view if the view is already snapped.";
// Alignment (can be auto/on/off)
settings.snapCube.align = "Restrict alignment";
settings.snapCube.align.help = "Align the views to the world axis. If enabled, only 6 snapping views are possible.

On Auto, the restriction will happen only if the camera is in Orbit mode.";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Stats";
settings.stats.right = "Right";
settings.stats.all = "Show full scene";
// Grid
settings.grid = "Grid";
// Cursor
settings.cursor.title = "Cursor";
settings.cursor.whileSculpting = "Show circle while sculpting";
// A small indicator dot
settings.cursor.showDot = "Show small dot";
settings.cursor.showDot.help = "The dot can appear as the camera pivot point or when you are sculpting.";
settings.cursor.showRope = "Show rope stabilizer";
// indicator
settings.indicator.title = "Indicator";
settings.indicator.title.help = "Display a visual indicator (tutorials, screen capture, etc).";
settings.indicator.size = "Size";
// Highlight (the object glows when we select it)
settings.highlight.selection = "Highlight selection";
// Highlight settings
settings.highlight = "Highlight";
settings.highlight.duration = "Duration";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Darken unselected objects";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Smooth shading";
// Experimental feature
settings.partialDraw = "Partial drawing";
settings.partialDraw.help = "Experimental feature!

Use it if you are sculpting a relatively small part of a high poly mesh.

It should make the sculpting smoother, but you should not enable wireframe!

Also it might add visual artefacts during the brush strokes";
settings.partialDraw.warning = "Do not forget to turn off this option if the visual artefacts are too bothersome!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Show paint";
// Show and use the masking on the mesh
settings.showMasking = "Show mask";
// Disable this option to force show the hidden faces
settings.showDiscard = "Use Hide";
// Display the light icons in the viewport
settings.lightIcon = "Light icons";
// Display the camera icons in the viewport
settings.cameraIcon = "Camera icons";
// Show icon on the canvas
settings.icon = "Icon";
// Show icons on the canvas
settings.icons = "Icons";
// Tooltip
settings.icons.help = "Display an icon on the canvas so that you can select and edit them directly.";
// Hole filling settings
settings.hole = "Hole-filling";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Fill non-manifold";
settings.hole.nonManifold.help = "Try to fill non manifold hole.
This option is not saved in the settings.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Max vertices count";
settings.multires.maxVertices.help = "Nomad doesn't perform memory check before subdivision, high poly count can easily lead to crashes.";
settings.multires.lowResVertices = "Low resolution threshold";
settings.multires.lowResVertices.help = "A lower resolution of the mesh can be displayed when you move the camera.

You can increase this value if you want to display a higher resolution of the mesh.";

// The main rendering mode
shading = "Shading";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "Lit (PBR)";
shading.pbr.help = "In this mode you can add lights (with shadows), along with an HDR environment.

You can also paint metalness and roughness, thus allowing a finer control on the look of your material.";
// Fast rendering mode for sculpting purpose (do not translate)
shading.matcap = "MatCap";
shading.matcap.help = "Stands for MATerial CAPture, a MatCap takes care of both the lighting and material information in a single image.

This is a fast rendering mode, mostly suited for raw sculpting.";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "Unlit";
shading.unlit.help = "Solid color shading mode, without lighting.";
// Helper rendering mode that display a (do not translate)
shading.object = "Object ID";
shading.object.help = "Unlit rendering mode with each objects having a random color assigned.

This is mostly useful when you have many objects in your scene.";
// Helper rendering mode that display a (do not translate)
shading.instance = "Instance ID";
shading.instance.help = "Same as Object ID, but instances will have the same color.";
// Randomize colors
shading.id.randomize = "Randomize id";
shading.textures = "Use textures";
shading.textures.help = "At the moment, you cannot create nor edit textures inside Nomad.

But if you import a file with textures in it, it should work.

• Supported textures
Opacity: Lit, MatCap, Unlit
Normal: Lit, MatCap
Color: Lit, Unlit
Emissive: Lit
Roughness: Lit
Metalness: Lit";
// Lights
shading.lights = "Lights";
shading.lights.addLight = "Add light";
shading.lights.warning = "Lights requires PBR shading mode.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Environment";
shading.environment.import = "Import HDR";
shading.environment.exposure = "Exposure";
shading.environment.backgroundBlur = "Blur (background)";
shading.environment.rotation = "Rotation";
shading.environment.rotation.help = "You can rotate the environment by dragging 3 fingers horizontally on the viewport.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "Attached to camera";
shading.environment.attachedToCamera.help = "Attach the environment to the camera.

It will force the lighting to be consistent, which can be useful for sculpting purposes.";
shading.matcap.rotation = "Rotation";
shading.matcap.rotation.help = "You can rotate the MatCap by dragging 3 fingers horizontally on the viewport.";
shading.matcap.global = "Use global MatCap";
shading.matcap.global.help = "Uncheck this option to use a different MatCap for this particular mesh.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible = "Mask";
shortcut.maskVisible.short = "Mask";
// bottom shortcut buttons (should be SHORT)
shortcut.solo = "Solo";
shortcut.solo.short = "Solo";
// bottom shortcut buttons (should be SHORT)
shortcut.xray = "X-Ray";
shortcut.xray.short = "X-Ray";
// bottom shortcut buttons (should be SHORT)
shortcut.voxelRemesh = "Voxel remesh";
shortcut.voxelRemesh.short = "Voxel";
// bottom shortcut buttons (should be SHORT)
shortcut.wireframe = "Wireframe";
shortcut.wireframe.short = "Wire";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraReset = "Camera reset";
shortcut.cameraReset.short = "Reset";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraSnap = "Camera snap";
shortcut.cameraSnap.short = "Snap";
// bottom shortcut buttons (should be SHORT)
shortcut.lockSelection = "Lock selection";
shortcut.lockSelection.short = "Lock";
shortcut.lockSelection.help = "When enabled, you cannot change the selection by tapping on a mesh.";
// bottom shortcut buttons (should be SHORT)
shortcut.perspective = "Perspective";
shortcut.perspective.short = "Persp";
// bottom shortcut buttons (should be SHORT)
shortcut.grid = "Grid";
shortcut.grid.short = "Grid";

// Memory taken by the scene
stat.ramScene = "Scene";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Vram Scene";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "Vram Render";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "Vram Textures";
// Memory taken by the undo/redo history
stat.ramHistory = "History";
// Memory taken by other stuffs
stat.ramOther = "Other";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "Used Memory";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "Free Memory";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "Used: $0";
stat.free = "Free: $0";
stat.faces = "Faces";
stat.triangles = "Triangles";
stat.vertices = "Vertices";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Quads";
stat.vertex = "Vertex";
stat.scene.face = "Scene faces";
stat.scene.vertex = "Scene vertices";

// Brush stroke
stroke = "Stroke";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "World-space radius";
// The settings is shared among every tools
stroke.useWorldRadius.help = "This is shared among every tools.";
// Share the radius value among every tools.
stroke.useShareRadius = "Share radius";
stroke.useShareRadius.help = "Share the radius value among every tools.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.spacing = "Stroke spacing";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.spacing.adjust = "Adjust spacing intensity";
stroke.minSpacingAdjustIntensity.help = "Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.";
stroke.minSpacing.help = "Spacing between each stroke, relative to the tool radius.

Lower value will allow smoother stroke but performance will degrade.";
// Brush stroke smoothing
stroke.lazySmooth = "Stroke smoothing";
stroke.lazySmooth.help = "Average multiple pointer position to get a smoother stroke.

With high values, the stroke will lag behind the pointer but will eventually catch up.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Lazy rope stabilizer";
stroke.lazyRadius.help = "Strokes will lag behind the pointer position according to a certain distance.

This can be used to draw smooth lines.";
// It is not a per-tool settings
stroke.globalSettings = "This is a global setting";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Snap radius";
stroke.snapRadius.help = "Snap the stroke if the pointer lies close to the last recorded stroke.

This can be useful when drawing long continuous lines, while doing frequent pauses.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Stroke offset";
stroke.sculptOffset.help = "Apply a constant offset on the stroke.

This option is there to help for small screen when using fingers, so that your finger doesn't cover the stroke.";
stroke.accumulate = "Accumulate stroke";
stroke.accumulate.help = "If this option is enabled, there is no limit to how much matter you can add/remove per stroke.";
// The tool can use DynTopo
stroke.useDynamic = "Allow dynamic topology";
// Only sculpt the part that are linked topologically
stroke.connect = "Connected topology";
stroke.connect.help = "This option will only sculpt the vertices that are linked to the picked surface.

This is typically used for the Move tool, for example if you want to exclusively move a part that self-intersects with another part.";
stroke.connect.short = "Connected";
// sculpt on hide or mask
stroke.protect = "Protect area";
stroke.protect.hide.help = "When set on auto, hidden faces will be edited if the wireframe on hidden faces is visible (see wireframe menu).";
// Only sculpt the vertex that points toward the camera
stroke.culling = "Front-facing vertex only";
stroke.culling.help = "This option will ignore back facing vertices.

It can be useful if you want to paint part of a thin geometry without impacting the other side.

It also works for sculpting but you might experience some artefacts.";
// Infinite depth, move everything under the circle, disregarding depth
stroke.silhouette = "Silhouette";
stroke.silhouette.view = "View";
stroke.silhouette.snapped = "If snapped";
stroke.silhouette.closest = "Closest";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.sameSide = "Same-side vertex only";
stroke.sameSide.help = "Ignore vertices that points in the opposite direction of the deformation.";
stroke.onlyLasso = "Settings only active for the lasso tool.";

// Here sampling refers to the app gathering information under the mouse
stroke.area = "Area sampling";
stroke.area.help = "Some brushes or stroke options require a plane normal to the surface in order to work.
You can control how to compute this average plane by setting the sampling area as a ratio of the tool radius.

At 100%, every points inside the selection circle is taken into account.
At 0%, only the nearest vertex or triangle is taken into account.";
// Sampling radius size (percent)
stroke.area.normal.radius = "Normal radius";
// Sampling radius size (percent)
stroke.area.point.radius = "Position radius";
// Sampling averaging
stroke.area.normal.average = "Normal averaging";
// Sampling averaging
stroke.area.point.average = "Position averaging";
// Keep sharp edges
stroke.keepSharp = "Keep sharp edges";
stroke.keepSharp.help = "Exclude points whose normals differ too much from the surface normal.

It will change how the plane area is computed (Area sampling).

This option can be useful for flatten-based tool, or if you want to color a planar surface without spilling.";

// Only paint the part of the mesh above a certain height
stroke.depthFilter = "Depth masking";
stroke.depthFilter.help = "Exclude points that are above or below a certain distance of the computed plane (Area sampling).

As an example, it can be used to paint bumps or cavities.";
stroke.depthFilter.max = "Top area";
stroke.depthFilter.min = "Bottom area";
stroke.depthFilter.offset = "Height offset";

// Invert the pixel (black <-> white)
stroke.alpha.invert = "Invert pixels";
// Repeat the alpha image (pattern)
stroke.alpha.wrap = "Tiling";
// No repeat pattern
stroke.alpha.wrap.none = "None";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alpha.wrap.repeat = "Repeat";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alpha.wrap.mirror = "Mirror";
// Tight fit when using tiling
stroke.alpha.fit = "Tight fit (non square images)";
stroke.alpha.fit.help = "This option is only relevant if the alpha and brushes textures are non square.

When enabled, each images will tile independently with no spacing.
You can disable this option if you want to keep the alpha and other images synchronized, in case their ratio are not the same.";
// Alpha rotation
stroke.alpha.rotation = "Rotation";
stroke.alpha.rotation.lock.help = "Lock the alpha orientation.

If the rotation is unlocked, the orientation will follow the stroke direction in real-time.";
// Repeat the image
stroke.alpha.tiling = "Tiling";
// Scale the image (make it bigger or smaller)
stroke.alpha.scale = "Scaling";
stroke.alpha.scale.help = "At minimum value, the alpha square is inside the tool circle radius.";
// Middle-point value at which no deformation occurs
stroke.alpha.midValue = "Mid value";
stroke.alpha.midValue.help = "Middle-point value at which no deformation occurs.

(Mid value = 0)
• Black: no displacement
• White: positive displacement

(Mid value = 0.5)
• Black: negative displacement
• White: positive displacement

(Mid value = 1)
• Black: negative displacement
• White: no displacement";
// Synonymous: Scatter/Jitter/Randomize
stroke.jitter = "Randomize";
// Sculpt and paint along the brush stroke at regular spacing
stroke.type.dot = "Dot";
// Sculpt and paint along with alpha spaced by brush radius
stroke.type.roll = "Roll";
// Sculpt and paint with alpha projected on screen stencil
stroke.type.tile = "Tile";
// Sculpt and paint with alpha projected on 3 axis
stroke.type.triplanar = "Triplanar";
// Sculpt continuously
stroke.type.drag = "Drag";
// Lock a region and move it around
stroke.type.grab = "Grab";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.type.grabRadius = "Lock + radius";
// Lock a region and sculpt it by changing the tool intensity
stroke.type.grabIntensity = "Lock + intensity";

stroke.falloffProject = "Influence";
stroke.falloffProject.help = "• Sphere (3d)
Influence is computed by taking the distance from the vertex to the brush's center.

• Circle (2d)
The vertex is first projected on the area plane, before taking its distance to the brush's center.
This is similar to how alphas are sampled.";
stroke.falloffProject.sphere = "Sphere";
stroke.falloffProject.circle = "Circle";

// Symmetry
symmetry = "Symmetry";
symmetry.enable = "Enabled";
symmetry.primitiveWarning = "Brush symmetry is only available for primitives that are validated, with the exception of the Triplanar.";
symmetry.plane.title = "Planes";
symmetry.toolIgnore = "The current tool ignores symmetry.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Radial";
symmetry.radialX = "Radial X";
symmetry.radialY = "Radial Y";
symmetry.radialZ = "Radial Z";
// A warning indicating that we limit the number of repetitions ($0 is a number)
symmetry.limited = "Number of repeats limited to $0!";
// Synonym: Offset
symmetry.offset.title = "Offset";
symmetry.offsetX = "Offset X";
symmetry.offsetY = "Offset Y";
symmetry.offsetZ = "Offset Z";
// Number of clones
symmetry.count.title = "Count";
symmetry.countX = "Count X";
symmetry.countY = "Count Y";
symmetry.countZ = "Count Z";
// method
symmetry.method = "Method:";
symmetry.method.help = "• Local
The symmetry plane will move along the mesh when you use one of the transform tools (Gizmo or Transform).

• World
The symmetry plane is fixed and will not move.";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.method.world = "World";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.method.local = "Local";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Flip object";
// Mirror the mesh
symmetry.mirror = "Mirroring";
symmetry.mirror.help = "Try to re-apply the symmetry without impacting the topology.

Radial symmetry will be ignored.

If the topology can't be kept because it is not considered symmetrical, you'll get the option to enforce the mirroring.";
symmetry.mirrorFail = "Failed to detect symmetry.

Do you want to enforce symmetry by mirroring the mesh?";
symmetry.mirrorUseMasking = "Protect masked area";
symmetry.mirrorUseMasking.help = "Keep masked area intact.

This option will be ignored with non-symmetric topology (or disconnected surface, like a pair of eyes).";
symmetry.apply = "Mirror
(keep topology)";
symmetry.splitMirror = "Split & Mirror
(new topology)";
// Reset the symmetry plane position
symmetry.reset = "Reset";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Object center";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "World center";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Orientation";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Show line";
// Display the symmetry plane in 3d
symmetry.showPlane = "Show plane";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Gizmo edit";
symmetry.edit.warning = "Symmetry edit is experimental.";
symmetry.edit.help = "You can freely set the symmetry plane.

This feature is a bit experimental and you should probably never use it.";

// Ideally <10 chars
tool.dynamic = "DynTopo";
// Ideally <10 chars (Symmetry)
tool.symmetry = "Sym";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "Mirror";
// Ideally <10 chars
tool.clay = "Clay";
// Ideally <10 chars (Subtract)
tool.clay.sub = "Sub";
// Ideally <10 chars
tool.brush = "Brush";
// Ideally <10 chars
tool.move = "Move";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "Normal";
// Ideally <10 chars
tool.drag = "Drag";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "Smooth";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Relax";
// Ideally <10 chars (Paint mask)
tool.mask = "Mask";
// Ideally <10 chars
tool.mask.unmask = "Unmask";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "SelMask";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "Smudge";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "Flatten";
// Ideally <10 chars (Flatten the surface, more strongly than Flatten)
tool.planar = "Planar";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Fill";
// Ideally <10 chars (Layer brush)
tool.layer = "Layer";
// Ideally <10 chars
tool.crease = "Crease";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "Trim";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Split";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "Project";
// Ideally <10 chars
tool.inflate = "Inflate";
// Ideally <10 chars
tool.pinch = "Pinch";
// Ideally <10 chars
tool.nudge = "Nudge";
// Ideally <10 chars
tool.stamp = "Stamp";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "DelLayer";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.select = "Select";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "Gizmo";
// Ideally <10 chars
tool.gizmo.editPivot = "Pivot";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "Snap";
// Ideally <10 chars (Snap translation)
tool.gizmo.moveSnap = "Snap";
// Ideally <10 chars (Local/Relative space)
tool.gizmo.local = "Local";
// Ideally <10 chars (Align/Snap the gizmo to world axis)
tool.gizmo.align = "Align";
// Ideally <10 chars (Pin the gizmo, so that it stays in place when switching between objects)
tool.gizmo.pin = "Pin";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "Transform";
// Ideally <10 chars (Translate the object)
tool.transform.move = "Move";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "Rotate";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "Scale";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "Snap";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "Measure";
// Ideally <10 chars (Lattice, deformer)
tool.lattice = "Lattice";
// If an option is shared among the tools
tool.all = "All tools";
// Ideally <10 chars (Quad Remesher)
tool.remesh = "Quad Remesher";
tool.remesh.guides = "Guides";
tool.remesh.density = "Density";
tool.remesh.same = "Same";
tool.remesh.half = "Half";
// Ideally <10 chars (FaceGroup)
tool.faceGroup = "Face Group";
tool.faceGroup.autoPick = "Auto-pick";
tool.faceGroup.flush = "Remove unused";
tool.faceGroup.skip = "Skip small groups based on:";
tool.faceGroup.skipFace = "Face count";
tool.faceGroup.skipFace.help = "Do not create a new group if the number of face is inferior or equal to this threshold.";
tool.faceGroup.skipArea = "Surface area";
tool.faceGroup.skipArea.help = "Do not create a new group if the surface area of the new group is inferor to this threshold.

The threshold is given as percentage of the total area of the object.";
// Ideally <10 chars (Hide)
tool.hide = "Hide";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "View";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "Lathe";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "Tube";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "Insert";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "Flip";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "View";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "Lasso";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Curve";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Polygon";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Path";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "Rect";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "Ellipse";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "Line";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Closed";

// Radius of the tool (size)
tool.radius = "Radius";
// Intensity of the tool (force)
tool.intensity = "Intensity";

tool.settings = "Settings";
tool.settings.none = "This tool doesn't have any specific settings.";

tool.crease.pinchFactor = "Pinch factor";
tool.crease.offsetFactor = "Offset factor";

tool.layer.removeInfluence = "Use layer data";
tool.layer.removeInfluence.help = "This option is only active when there is a layer selected.

It will use the layer data to limit the displacement over strokes.";
tool.layer.noLayerSelected = "This option is only available if a layer is selected";

tool.flatten.planeLockOrigin = "Lock plane origin";
tool.flatten.planeLockNormal = "Lock plane direction";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "Sync";
tool.syncInstance.message = "The new object will be added on all other instances!";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Sticky vertex on border";
tool.smooth.screen = "Screen smoothing";
tool.smooth.screen.help = "Use this option to get topology independent smoothing, even at high poly.";
tool.smooth.screen.samples = "Screen samples";
tool.smooth.stable = "Stable smoothing";
tool.smooth.stable.help = "Tries to make the smoothing topology independent.

This mode works best with varying topology density and with high smoothing intensity value.";

tool.paint = "Paint";
// Erase the painting
tool.paint.erase = "Erase";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Layer filtering";
tool.paint.layerFilter.help = "Use this option if you only want to repaint the already painted area of a layer.";

// Clear the painted mask
tool.mask.clear = "Clear";
tool.mask.clearAll = "Clear all";
// Invert the painted mask
tool.mask.invert = "Invert";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Invert mask (connected)";
// Blur the painted mask
tool.mask.blur = "Blur";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Sharpen";
// Transform/Matrix
tool.matrix = "Matrix";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.target = "Target";
// Automatic
tool.matrix.target.auto = "Auto";
tool.matrix.target.auto.help = "By default, this will work similarly to the Group option.
If the mesh has masking, or if symmetry is enabled, it will work the same as Vertex.";
// Auto apply the transform on the vertices
tool.matrix.target.vertex = "Vertex";
tool.matrix.target.vertex.help = "Try to apply the transform on the vertices, it won't work on unvalidated primitives.
Instances will be impacted as well.";
// Transform the object alone (the children stands still)
tool.matrix.target.object = "Object";
tool.matrix.target.object.help = "Move the object only, ignoring symmetry and masking.
Only the edited node will move, the children will stand still.";
// Transform the object and its children
tool.matrix.target.group = "Group";
tool.matrix.target.group.help = "Move the node, ignoring symmetry and masking.
The rest of the hierarchy will be transformed as well.";
// Operation on the mesh
tool.matrix.action = "Operation";
tool.matrix.action.help = "• Move origin
Move the mesh to the world origin.

• Reset
Reset the mesh transform to identity.

• Bake
Apply the matrix to the vertex and reset the matrix. Visually, nothing should change.";
tool.matrix.translation = "Translation";
tool.matrix.rotation = "Rotation";
tool.matrix.scale = "Scale";
// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "Skew";
tool.matrix.uniformScale = "Uniform scale";
tool.matrix.moveToOrigin = "Move origin";
tool.matrix.resetTransform = "Reset";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "Bake";

tool.transform.tip = "Single tap with second finger to switch mode";

// Size of the gizmo
tool.gizmo.size = "Widget size";
// If true, there is less spacing between gizmo handlers (rotate, scale, etc)
tool.gizmo.compact = "Compact";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "Numerical input";
tool.gizmo.allowInput.help = "Allow numerical input when tapping one of the gizmo widget";
// Angle threshold
tool.gizmo.linearRollThreshold = "Tangent roll threshold";
tool.gizmo.linearRollThreshold.help = "Angle threshold to choose between linear or circular roll method.

Value above this threshold will use the circular roll.

If you prefer the linear roll (direction of the tangent), simply set this value to 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Hide on interaction";
tool.gizmo.tap = "On tap";
tool.gizmo.tap.help = "This option controls how to move the pivot when tapping once on the mesh surface.";
tool.gizmo.tap.none = "None";
tool.gizmo.tap.none.help = "Nothing happen when tapping on the mesh.";
tool.gizmo.tap.normal = "Normal";
tool.gizmo.tap.normal.help = "Move the gizmo on the first intersection and align it according to the surface normal.";
tool.gizmo.tap.first = "First";
tool.gizmo.tap.first.help = "Move the gizmo on the first intersection.";
tool.gizmo.tap.medial = "Medial";
tool.gizmo.tap.medial.help = "Move the gizmo on the middle of the first two intersections.";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "Fixed";
tool.lathe.axisOnly = "Axis only";
tool.lathe.stable = "Stable";
tool.lathe.axis = "Axis";

// Fill the object's hole
tool.hole = "Hole filling";
tool.hole.fillHoles = "Fill holes";
// synonym: Alternative method
tool.hole.method.fill = "Fill";
tool.hole.method.legacy = "Legacy";
tool.hole.method.boolean = "Boolean";
tool.hole.bridges = "Screen-space boolean";
tool.hole.bridges.help = "If this option is enabled, you can punch holes in the volume.
The cut slope will also follow more closely the cutting shape.";
tool.hole.threshold = "Threshold epsilon";
tool.hole.threshold.help = "Tweaking this value might help with the hole filling algorithm.";
tool.hole.smoothing = "Hole smoothing";

tool.smudge.quality = "Quality";
tool.smudge.quality.help = "It changes the resolution of the projected pixels, lower values means faster strokes.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Shape";
// Auto-validate the drawn shape
tool.shape.autoValidate = "Auto-validate";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Square";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Centered";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Circle";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Centered";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Rotate step";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Golden ratio";
// volume of a mesh
tool.measure.volume = "Volume";
// Surface of a mesh
tool.measure.surface = "Surface";

// Always display the camera shortcut buttons on the viewport
tool.view.stickyCamera = "Camera shortcut (always)";

// Topology
topology = "Topology";
// Synynom: detail value, density
topology.dynamic.detail = "Detail";
// See glossary
topology.multires = "Multiresolution";
topology.multires.help = "Keep multiple resolution of a mesh.

If you make changes in a lower resolution, details from the higher resolutions will be reprojected when you switch back.

Layers are available on every resolution.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "Reverse";
topology.multires.reverse.confirm = "Could not create base subdivision.

The current topology is probably not a result from a subdivision.";
topology.multires.subdivide = "Subdivide";
topology.multires.subdivide.confirm = "The mesh will have $0M vertices, are you sure?";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "Subdivide limit exceeded, see $0";
topology.multires.deleteLower = "Delete lower";
topology.multires.deleteHigher = "Delete higher";
topology.multires.keepTriangles = "Keep triangles";
topology.multires.lock = "Lock (LV0)";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "Multires level →";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "Multires level ←";
// Synonym: Flat subdivision
topology.multires.linear = "Linear subdivision";
topology.multires.linear.help = "Simply subdivide the mesh without applying any smoothing";
// Only show the lowest resolution wireframe
topology.multires.minWireframe = "Level 0 only";
// Create a new object by recomputing a new topology
topology.remesh = "Remesh";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Voxel remeshing";
topology.voxel.help = "Remeshing by sampling the mesh on a grid.

If the object is not closed (watertight), an hole-filling algorithm will be applied first.

Layers are reprojected after remeshing but the quality will degrade.";
topology.voxel.resolution = "Resolution";
topology.voxel.sharp = "Keep sharp edges";
topology.voxel.sharp.help = "This option is mostly useful for simple primitive boolean operation.

It will introduce distortion in some area due to the points being snapped on the edges.";
topology.voxel.subLevel = "Build multiresolution";
topology.voxel.subLevel.help = "You can rebuild a multiresolution hierarchy from the voxel remesher output.

It will also run faster and use less memory, especially if the voxel detail value is high.
However if the voxel detail value is low and you are asking for lot of multires level, you'll lose details.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Remesh";
topology.surface.detail = "Detail";
topology.surface.detail.help = "Unlike voxel remeshing, surface remeshing doesn't require the mesh to be closed.

It can also support masking so that you can protect some part of the mesh from topology changes.

Layers are updated correctly.";
topology.surface.method = "Method";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Uniformisation";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Subdivision";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Decimation";
topology.surface.method.help = "Behavior of dynamic topology:
• Uniformisation: add and remove detail
• Subdivision: add detail
• Decimation: remove detail";
topology.surface.useMasking = "Protect masked area";
topology.surface.useMasking.help = "The masked areas will protect the topology from being changed.";
topology.surface.extrapolate = "Vertex extrapolation";
// DynTopo
topology.dynamic = "Dynamic topology";
topology.dynamic.activate = "Enabled";
topology.dynamic.activate.help = "With dynamic topology, sculpting tools can subdivide or simplify the mesh locally in real time.

This feature can have a noticeable impact on performance.

Layers are updated correctly.";
topology.dynamic.method = "Detail based on...";
topology.dynamic.method.screen = "Screen";
topology.dynamic.method.radius = "Radius";
topology.dynamic.method.constant = "Constant";
topology.dynamic.method.help = "• Zoom
The level of detail is based on how far you are from the surface.

• Radius
The tool radius defines the amount of detail.

• Constant
The detail is fixed, the detail value is shared with the voxel slider as well.";
topology.dynamic.quality = "Prefer...";
topology.dynamic.quality.help = "If you choose Quality, the 2 main differences are:
• refinement is applied before the sculpting operator, you will get less interpolating artefact when painting or sculpting very small details
• refinement is not applied incrementally, if you sculpt very small details or do quick strokes, the topology will always be correctly refined";
topology.dynamic.quality.speed = "Speed";
topology.dynamic.quality.quality = "Quality";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Use pressure on radius";
topology.dynamic.usePressure.help = "Use this option if you want the pen pressure on tool radius to impact the level of detail.";
topology.dynamic.useFalloff = "Use stroke falloff";
// Decimate
topology.decimate.title = "Decimation";
topology.decimate.title.help = "Reduce the number of polygons by trying to keep as many details as possible.

This feature can be useful if you want to export for 3d printing.
However you should probably not use it if you want to continue sculpting on it, as it can produce uneven triangles.

Note that the masked area won't be decimated.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Decimate";
topology.decimatePaintWeight = "Preserve painting";
topology.decimatePaintWeight.help = "Higher value will try to preserve painting.

Set this value to 0 if you don't care about the painting.";
topology.decimateUniform = "Uniform faces";
topology.decimateUniform.help = "Higher value will output triangles with similar size.";
topology.decimatePreserveBorders = "Preserve borders";
topology.decimatePreserveBorders.help = "Do not decimate the border of the mesh.";
// Target a certain number of triangles, faces and vertices
topology.target.triangles = "Target triangles";
topology.target.faces = "Target faces";
topology.target.quads = "Target quads";
topology.target.points = "Target points";
// Quad remesher
topology.qremesh = "Quad Remesh";
topology.qremesh.angle = "Crease angle";
topology.qremesh.border = "Preserve borders";
topology.qremesh.onlyQuad = "Quads only";
topology.qremesh.hole = "Max fill hole";
topology.qremesh.hole.help = "The algorithm can sometimes produce unwanted holes.

If a hole has fewer vertices than this value, then it will be filled.";

// Unwrapping means compute UV (texture coordinates), with uvs you can appliy (wrap) a texture onto the model
topology.uv.title = "UV Unwrap";
// UV Unwrap but as a Verb
topology.uv.unwrap = "Unwrap";
// The operation can be very slow
topology.uv.atlas.warning = "Can be very slow, target <100k vertices!";
// Handles are topological holes (synonym: genus, hole)
topology.uv.bff.warning = "Can have overlaps if the mesh has handles!";
// Solo patch
topology.uv.bff.seamless = "Seamless patches";
topology.uv.bff.seamless.help = "This option can introduce important distortion.

Typically, it can be used when face groups are carefully set up.";
// Synonym: Point count? Singularity count ?
topology.uv.bff.cones = "Cone count";
topology.uv.bff.help = "Higher value will reduce distortion for complex objects.

Higher value will means longer compute time.";
topology.uv.delete = "Delete UVs";

// Transfer the vertex painting in the texture, bake means "create texture (from mesh data)"
topology.bake.title = "Bake";
// Bake here means "create texture (from mesh data)"
topology.bake.title.help = "Texture baking will create textures by projecting other visible objects in the scene.

Here is the typical workflow for baking:
• You have a mesh with fine details and painting
• Clone it
• Decimate it (set `Preserve painting` to 0!)
• UV unwrap it
• Bake it!

Nomad will take every visible mesh in the scene into account.
You can also use the Solo mode to quickly hide most of the other meshes.
If there is no other visible objects, then it will take the entire scene into account.

You should now have a low-resolution mesh that retains most of the paint and details of your previous object.

After the operation, vertex colors will be moved in a new disabled layer, so that it gets ignored instead of being multiplied against the colored texture.";
// Bake here means "create texture (from mesh data)"
topology.bake.self = "From itself";
// Bake here means "create texture (from another mesh data)"
topology.bake.other = "From high-res";
topology.bake.resolution = "Resolution";
// Cage is a specific term, synonyom: "Bake offset"
topology.bake.offset = "Ray offset";
topology.bake.radius = "Cage radius";
// Bake opacity (from mask data)
topology.bake.opacityFromMask = "Mask -> Opacity";
topology.bake.backup = "Backup";

// project a high resolution mesh details onto another
topology.reproject.title = "Reproject";
topology.reproject.title.help = "Project sculpted details, painting and layers from the nearest visible objects.

This is mostly meant to be used on a high-resolution mesh as well, typically with a clean topology.";
// tweaking value
topology.reproject.rayBias = "Ray bias";
topology.reproject.rayBias.help = "Two methods are used for reprojection:
• nearest: the closest point on the surface
• ray: intersection point through the normal direction

Higher bias values will favor ray intersection instead of nearest surface.";
topology.reproject.normalOffset = "Normal offset";
topology.reproject.shpereCast = "Sphere cast fallback";
topology.reproject.shpereCast.help = "If normal ray reprojection fails, Nomad will fallback to nearest surface intersection.";
// number of iteration the algorithm will take
topology.reproject.iterations = "Iterations";
topology.reproject.relax = "Relax";
topology.reproject.relax.help = "Relax should be prefered when the mesh is low poly.";
topology.reproject.layers.help = "Transfer other layers onto the selected mesh.";

topology.manifold = "Manifold";
topology.nonManifold = "Non-manifold";
topology.manifold.clean = "Clean";
topology.manifold.collapse = "Delete small faces";
topology.manifold.title = "Force Manifold";
topology.manifold.title.help = "Tries to clean non manifold edge.

It can be useful for external softwares that don't support edges that have more than 2 faces in common.";

// Reset key-bindings/shortcuts
binding.reset = "Reset bindings";
// Binding option
binding.context.toggle = "Toggle context";
binding.toggleTool = "Toggle tool shortcuts";
binding.toggleTool.help = "When using one of the tool shortcuts, the previous tool will be selected if the current shortcut tool is active.";
// When the key is tap once, the value will be toggled
binding.tapToggle = "Toggle shortcut on key tap";
// The binding force camera movement
binding.forceCamera = "Force camera";
binding.forceCamera.help = "Force camera interaction in case there is a conflict with another binding.

It can typically happens if the same binding is assigned to a tool shortcut or Add/Sub.";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickMaterial = "Pick Material";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickFaceGroup = "Pick Face Group";
// Edit the tool brush size/radius
binding.editRadius = "Tool Radius";
// Edit the tool brush size/radius
binding.editIntensity = "Tool Intensity";
// Snap the camera
binding.view.front = "Front View";
binding.view.left = "Left View";
binding.view.top = "Top View";
// Move/Translate the view
binding.pan.left = "Pan Left";
binding.pan.right = "Pan Right";
binding.pan.forward = "Pan Forward";
binding.pan.backward = "Pan Backward";
binding.pan.up = "Pan Upward";
binding.pan.down = "Pan Downward";
// Snap the view (while rotating)
binding.snapViewOnRotate = "Snap view (while rotating)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "Open (project)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "Add (project)";
// Select all the objects in the scene
binding.selectAll = "Select All";
// Rotate environment and the lighting
binding.rotateLighting = "Rotate lighting";
// The Camera pivot is the point around which the camera rotates
binding.updatePivot = "Update pivot...";

quadremesh.adaptQuadCount = "Adaptive Quad Count";
quadremesh.curvatureAdaptivness = "Adaptive Size";
quadremesh.curvatureAdaptivness.help = "At 100%, quads size will vary depending on the object curvature, allowing smaller quad on high curvature.
At 0%, quads size will be uniform.";
quadremesh.autoDetectHardEdges = "Auto-Detect Hard Edges";
quadremesh.useVertexColors = "Preserve painting";

// Privacy policy
privacyPolicy.title = "Privacy Policy";
privacyPolicy.reject = "Reject";
// Hexanomad is the company name
privacyPolicy = "Hexanomad does not collect any data from Nomad Sculpt.";

sonar.disconnect = "Disconnect SonarPen";
sonar.connect = "Connect SonarPen";
sonar.connect.confirm = "Connect SonarPen?";
sonar.connect.confirm.warning = "Sonar Pen will use the microphone (audio loopback) to detect the pressure of the pen.";

// Color disc mode
widget.color.disc = "Disc";
widget.color.ring = "Ring";
widget.color.square = "Square";

nomad.mainFolder = "Nomad main folder";
nomad.mainFolder.warning = "Files are left untouched.
They are not copied, deleted or moved.";
nomad.mainFolder.error = "After you select yes, Nomad will close and you can simply relaunch it.";

// version trial
version.restore = "Restore purchase";
version.buyWeb = "Web version is only a demo";
version.buyFull = "Upgrade to full version";
version.buyQR = "Purchase";
version.buyQR.promo = "
The Quad Remesher is an an algorithm that outputs quad dominant mesh.
The quad distribution will try to follow the natural curvature of the object.

The algorithm can also adapt the quads size depending on the local curvature.

You can also guide the resulting topology with:

• Face Group $0 (make sure to smooth their borders for better result!)

• Planar X/Y/Z symmetry $1

• Curve guides $2

• Density painting $3

The Quad Remesher is developed by https://exoside.com/.";

version.trialHistory = "Trial version: 4 undo/redo possible";
version.trialLayer = "Trial version: 1 layer per object";
version.trialOneProject = "Trial version: 1 active project only";
version.trialNoImport = "Trial version: No import";
version.trialNoExport = "Trial version: No export";

version.fullFeatures = "• One time purchase
• Unlimited undo/redo
• Unlimited layers
• Save & Load
• Export & import";

version.demo.purpose = "This version has been created specifically for demonstration purposes.";
version.demo.disable = "Feature not enabled for demo.";

// app store main page
store.name = "Nomad Sculpt";
store.headline = "Sculpt, paint and create in 3D";
store.tag = "sculpt, 3d, nomad, paint, modeling";
// ----------------------------------------------
store.description.sculpt = "• Sculpting tools
Clay, flatten, smooth, mask and many other brushes will let you shape your creation.
You can also use the trim boolean cutting tool with lasso, rectangle and other shapes, for hardsurface purposes.";
// ----------------------------------------------
store.description.stroke = "• Stroke customization
Falloff, alphas, tilings, pencil pressure and other stroke parameters can be customized.
You can save and load your tools preset as well.";
// ----------------------------------------------
store.description.paint = "• Painting tools
Vertex painting with color, roughness and metalness.
You can easily manage all your material presets as well.";
// ----------------------------------------------
store.description.layer = "• Layers
Record your sculpting and painting operations in separate layers for easier iteration during the creation process.
Both the sculpting and painting changes are recorded.";
// ----------------------------------------------
store.description.multires = "• Multiresolution sculpting
Go back and forth between multiple resolution of your mesh for a flexible workflow.";
// ----------------------------------------------
store.description.voxel = "• Voxel remeshing
Remesh quickly your mesh to get a uniform level of detail.
It can be used to quickly sketch a rough shape at the beginning of the creation process.";
// ----------------------------------------------
store.description.dynamic = "• Dynamic topology
Refine locally your mesh under your brush to get an automatic level of detail.
You can even keep your layers, as they will be automatically updated!";
// ----------------------------------------------
store.description.topology = "• Decimate
Reduce the number of polygons by keeping as many details as possible.";
// ----------------------------------------------
store.description.group = "• Face Group
Segment your mesh into subgroups with the face group tool.";
// ----------------------------------------------
store.description.unwrap = "• Automatic UV unwrap
The automatic UV unwrapper can use face groups to control the unwrapping process.";
// ----------------------------------------------
store.description.baking = "• Baking
You can transfer vertex data such as color, roughness, metalness and small scaled detail in to textures.
You can also do the opposite, transfering textures data into vertex data or layers.";
// ----------------------------------------------
store.description.primitive = "• Primitive shape
Cylinder, torus, tube, lathe and other primitives can be used to quickly start new shapes from scratch.";
// ----------------------------------------------
store.description.rendering = "• PBR rendering
Beautiful PBR rendering by default, with lighting and shadows.
You can always switch to matcap for a more standard shading for sculpting purposes.";
// ----------------------------------------------
store.description.postprocess = "• Post processing
Screen Space Reflection, Depth of Field, Ambient Occlusion, Tone mapping, etc";
// ----------------------------------------------
store.description.files = "• Export and Import
Supported formats include glTF, OBJ, STL or PLY files.";
// ----------------------------------------------
store.description.interface = "• Interface
Easy-to-use interface, designed for mobile experience.
Customization is possible as well!";
// ----------------------------------------------
store.description.remesher = "• Quad Remesher (separate in-app purchase only)
Remesh your object automatically with a quad dominant mesh that follows the mesh curvatures.
It supports guides, face groups and density painting.";
// ----------------------------------------------