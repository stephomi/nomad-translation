// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "Confirm?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Yes";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "Ok";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Cancel";

// Name of an item (object, tool, etc)
item.name = "Name";
// Rename an item (object, tool, etc)
item.rename = "Rename";
// Add a new item (object, tool, project, etc)
item.add = "Add";
// Save an item (object, tool, etc)
item.save = "Save";
item.save.confirm = "Confirm save?";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Last save";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "Load last save?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Reset";
item.reset.confirm = "Confirm reset?";
// Clone an item (object, tool, etc)
item.clone = "Clone";
// Delete an item (object, tool, etc)
item.delete = "Delete";
item.delete.confirm = "Confirm deletion?";
item.delete.confirm.yes = "Yes, delete";
// Item visibility (object, layer, etc)
item.visible = "Visible";
// Show an item (object, layer, etc)
item.show = "Show";
// Hide an item (object, layer, etc)
item.hide = "Hide";
// Select an item (object, layer, etc)
item.select = "Select";
// Unselect an item (object, layer, etc)
item.unselect = "Unselect";
// Merge an item with another one below (layer)
item.mergeDown = "Merge down";
// The order of an item in a list
item.order = "Order";

// Three-state toggle button (Auto, Off, On)
toggle.on = "On";
// Three-state toggle button (Auto, Off, On)
toggle.off = "Off";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "Auto";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "No selected object, please select at least one object.";
// Need to select one object only
scene.noneButNeedOne = "No selected object, please select one object.";
// Need to select one object only
scene.onlyOneObject = "Multiple objects are selected, please select only one object."


// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Missing thumbnails, reprocessing files... ($0/$1)

$2";

// Dolor of an object
material.color = "Color";
// Defines how blurry or sharp the reflection on a material is
material.roughness = "Roughness";
// Whether the material is a metal or not
material.metalness = "Metalness";

// Minify
about.minify = "Minify UI";
about.minify.help = "You can also tap your screen with 4 fingers, if your device supports it.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Turntable";
// Make the entire scene turn around (speed of the animation)
about.turntableSpeed = "Turntable Speed";
// Stuffs that I used to make the app
about.credits = "Credits";
// Link to open source projects that I used for the app
about.credits.openSource = "Open-Source";
// Only translate the &
about.credits.arts = "MatCaps & HDRIs";
// Change languages of the app
about.languages = "Languages";
about.languages.help = "Translation files available at $0";
// Link to the App Website
about.website = "Website";
// Link to the App Forum
about.forum = "Forum";
// Link to the App Manual
about.manual = "Manual";
// Link to the App Email
about.mail = "Support";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";

// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "The object has no holes!";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "The current object is invisible!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Nothing to trim.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Abort trim: the object is fully trimmed.";
// In order to extract something, the mesh needs to have painted mask
alert.mask.noExtract = "Nothing to extract!";
// In order to split something, the mesh needs to have painted mask
alert.mask.noSplit = "Nothing to split!";
// List of disabled features when View Mode is selected
alert.view.disabled = "Features disabled in View Mode:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Primitive widgets";
// The object needs to have two parts disconnected
alert.separate.fail = "Could not separate: the object has only one part!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "Remeshed!";
alert.voxelRemesh.empty = "Abort remesh: result mesh has no faces.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "Invalid input!";
alert.matrix.clone = "The object will be duplicated";
// A pivot refers the gizmo 3d position
alert.gizmo.usePivot = "Use custom pivot.";
// A pivot refers the gizmo 3d position
alert.gizmo.useAuto = "Use automatic pivot.";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Edit pivot mode.";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "Edit object mode.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Active dynamic topology";
// See Glossary (DynTopo)
alert.dynamic.disable = "Disable dynamic topology";
alert.colorPicker = "Drag your finger on the object to pick a color.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Simple tap to exit transform mode.";
alert.view.reset = "Reset view";
// Snap the view to the nearest aligned 90° angle
alert.view.snap = "Snap view";
// Show the painted mask on the mesh
alert.mask.show = "Show mask";
// Hide the painted mask on the mesh
alert.mask.hide = "Hide mask";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Lock selection";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Unlock selection";
// Hide the objects that are not selected
alert.selection.isolate = "Isolate selection";
// Show the objects that are hidden
alert.selection.showAll = "Show all";
// Project quick saving
alert.quickSave = "Saving...";
// Painting on the object was hidden but the user did paint the object
alert.forceShowPainting.fill = "Show painting activated, [Paint all] was used.";
// Painting on the object was hidden but the user started to paint on the object
alert.forceShowPainting.tool = "Show painting activated, the object was painted.";
// See Glossary (Multiresolution)
alert.multiresLost = "Multiresolution will be lost!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "The detail value is high and might require lot of memory!";
// Autosave popup
alert.autoSave.auto = "Autosave in... $0s";
// The selected object doesn't have any layers
alert.needLayer = "The current tool requires an active layer.";
// The user decides to hide the painting on the objects
alert.paintingHidden = "Painting hidden: show it again in Settings panel.";
// The selected object doesn't have any layers
alert.noPartialWireframe = "Partial drawing is disabled when wireframe is displayed.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Consider using orthographic camera if you want to avoid perspective frustum distortion when using screen projector.";
// Trial version has a limited number of undo
alert.state.trial = "Trial version: undo canceled";

background = "Background";
// A flat color will be displayed in the background of the scene
background.color = "Color";
// The environment (HDRI) will be displayed in the background
background.environment = "Environment";
background.blur = "Blur";
background.exposure = "Exposure";

// Image that the artist uses as a reference
background.imageEnable = "Reference image";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Overlay";
// Opposite of transparency (Alpha)
background.imageAlpha = "Opacity";
background.imageReset = "Reset settings";
background.imageTransform = "Transform";
// X screen coordinate of the image reference
background.imageX = "Position X";
// Y screen coordinate of the image reference
background.imageY = "Position Y";
// Rotation of the reference image
background.imageRotation = "Rotation";
// Scale of the reference image
background.imageScale = "Scale";

// Camera (point of view in 3d)
camera = "Camera";
// Copy the views
camera.updateView = "Update view point?";
camera.addView = "Add View";
camera.focusOn = "Focus on";
// Camera projection, Orthographic or Perspective
camera.projection = "Projection";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Orthographic";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Perspective";
// camera Vertical Field of View
camera.fov = "Vertical Fov";
// Camera Field of View hint
camera.focal = "focal $0mm (35mm sensor)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Rotation";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "Turntable";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Trackball";
camera.rotation.trackball.help = "Trackball gives more degree of freedom you can also roll the camera with 2 fingers.";
// Camera interaction mode, 1st person view
camera.firstPerson = "First Person";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Speed";
// Camera rotation sensitivity
camera.speed.rotation = "Rotation";
// Camera panning sensitivity
camera.speed.panning = "Panning";
// Camera zooming sensitivity
camera.speed.zooming = "Zooming";
// Reset camera position
camera.resetView = "Reset view";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Snap view";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Pivot";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Double tap on object";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Double tap on background";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "Update on double tap";
camera.doubleTapPivot.help = "Update the rotation pivot when double tapping on the object surface.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "Air pivot";
camera.airPivot.help = "Allow new pivot even when zooming outside the object surface.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "On camera gesture start";
camera.autoPivot.help = "Update the pivot when you start interacting with the camera.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Focus";
camera.doubleTapFocus.help = "When double tapping on the object, the camera will pan and focus on the picked point.";
// Move the camera so that it focus on selected objects
camera.doubleTapFocusSelection = "Focus on selection";
camera.doubleTapFocusSelection.help = "When double taping on background focus on the selected object instead of the whole scene.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "Multiselection";

// Curve widget, Preset lets the user chooses between predefined curves
curve.preset = "Preset";
// Curve widget, Custom lets the user edits the curve directly
curve.custom = "Custom";

// Debug option, the newly created primitives will contains texture coordinates (UVs)
debug.uvPrimitive = "Keep primitive UVs";
debug.uvPrimitive.warning = "Disable this option if you don't need UVs (extra memory).";
debug.uvPrimitive.help = "For now, only Box and Sphere are supported.

Other types will be supported in the future.";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "Normalize UVs";
debug.uvNormalize.help = "Nomad will normalise the UVs inside the [0-1] tile.";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "Add BFF UVs";
debug.uvBFF.help = "Add an alternative unwrapping method (boundary first flattening).

Note that BFF will produce overlaps if your mesh topology is different than a disk or a sphere.";
// Debug option, display an window with some debugging logs
debug.logs = "Logs";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Heightmap";
// Debug options, graphical stuffs
debug.graphics = "Graphics";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Make store thumbnails";

// Empty list: there is no projects
file.project.empty = "You have no saved project yet!";
// The current opened project has some unsaved changes
file.project.unsaved = "Unsaved changes!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "You will lose unsaved changes!";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Preview of the last manual save";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "Trial version: You won't be able to re-open the current project!";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "Trial version: you can only re-open your current project!";

file.project = "Project";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Save";
// E.g: Save "my_project"?
file.project.save.confirm = "Save $0?";
// Save to another project (either new one or overriding existing one)
file.project.saveAs = "Save As";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "Overwrite $0?";
// Open a project
file.project.open = "Open";
// E.g: Open "my_project"?
file.project.open.confirm = "Open $0?";
// Load another project and add/append all its data to the current scene
file.project.add = "Add to scene";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "Add $0 to the scene?";
// Reset the scene and create a new project
file.project.new = "New";
file.project.new.confirm = "Create new scene?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "Delete $0?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "Delete $0?

This is the current active project!";

// Auto save section
file.project.autoSave = "Project Auto Save";
file.project.autoSave.confirm = "Disable Auto Save?";
file.project.autoSave.help = "Save your project in a separate file at regular interval.
The autoSave file can be found in:

$0";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "Popup timeout";
// In minutes
file.project.autoSave.minutes = "Timer popup";
// Delete the current autoSave data
file.project.autoSave.delete = "Discard Auto Save";

// Load interface preference settings when opening a scene file
file.load.guiSettings = "Keep gui settings";
file.load.guiSettings.help = "When opening or importing a project file, all the gui-related settings embedded in the project will be loaded.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.load.objSplitByGroup = "Split OBJ by groups";
file.load.objSplitByGroup.help = "When enabled, Nomad will split the OBJ groups into separate objects.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.load.mergeLayers = "Merge Layers";
// Ignore the textures present in the file to load
file.load.skipTextures = "Skip textures";
// Do not fiddle with the object topology when loading the file
file.load.keepTopology = "Keep topology";
file.load.keepTopology.help = "Use this option if you don't want Nomad to fiddle with the topology of imported mesh.

It will disable vertex/face reordering, removal of vertex/face duplicates and removal of unused vertices.";
// If the object has more vertices than this value, then we won't attemp to reverse (multiresolution) the object
file.load.reverseVertices = "Reverse threshold";
file.load.reverseVertices.help = "In order to use less memory, Nomad doesn't save the lower resolution of a mesh.

However it will rebuild the lower resolution if the number of vertices is lower than this threshold.";


// Configure imports option
file.importSettings = "Import options";

// Import file section
file.import.title = "Import";
file.import.title.help = "Supported format:
- Wavefront (.obj)
- glTF 2.0 (.glb .gltf)
- STL (.stl)";
// The user imports a scene file that will replace the current scene
file.importOpen = "Open";
file.importOpen.confirm = "Import new file?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Add to scene";
file.import.add.confirm = "Import new file?";

// Export scene file
file.export.title = "Export";
file.export.title.help = "If possible favor glTF export as it supports more features than other formats.";

// Export the current selected mesh instead of the entire scene
file.exportSelection = "Export selection only";
file.exportSelection.help = "Export the current selected object instead of the entire scene.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Reconstruct quad";
file.convertToQuad.help = "Reconstruct quads from triangles by pairing triangle (if they are adjacent in the files).";

// Whether we include the textures in the exported file
file.export.texture = "Export textures";
// Baking means transfering/converting 
file.export.texture.help = "This option doesn't bake vertex colors into textures.";
// Whether we include normals vector in the exported file
file.export.normal = "Export normals";
file.export.normal.help = "Check this option if you want to open the file in another softwares.

Nomad always ignore the normals as it will recompute them.";

file.export.gltf = "Export glTF 2.0";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Export layers";
file.export.gltf.layer.help = "Export layers as morphs. Officially supported by glTF so it should work on other softwares as well.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Export layer paint";
file.export.gltf.layerPaint.help = "Export layer painting. It is usually ignored by other softwares.";
// Whether the exported layer will use the non-standard Nomad encoding (smaller size)
file.export.gltf.layerNomad = "Nomad layer encoding";
file.export.gltf.layerNomad.help = "Can make the file smaller by writing paint layer in 8-bit instead of 16-bit.

This encoding only works in Nomad as it will use absolute painting.
Other softwares will have incorrect result as glTF requires relative encoding.";
// Whether we include the vertex color in the exported file
file.export.gltf.color0 = "Export vertex colors";
file.export.gltf.color0.help = "Export vertex colors. Officially supported by glTF so it should work on other softwares as well.";
// Whether we include the vertex roughness and vertex metalness in the exported file
file.export.gltf.color1 = "Export pbr paint";
file.export.gltf.color1.help = "Export roughness, metalness and mask painting. This will be ignored by other softwares.";

file.export.obj = "Export OBJ";
file.export.obj.warning = "Layers and extra painting (roughness metalness and mask) will be lost.";
// Whether we include the vertex color in the exported file
file.export.obj.colorAppend = "Export vertex colors";
file.export.obj.colorAppend.help = "Append color information after vertices.

Some 3d softwares will be able to read it but not all of them.";

file.export.stl = "Export STL";
file.export.stl.warning = "Layers and extra painting (roughness metalness and mask) will be lost.";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Export vertex colors";
file.export.stl.color.help = "Some 3d softwares will be able to read it but not all of them.";
file.export.stl.ascii = "By default the format is binary.

You can choose to export to text format (ASCII) but the file will be bigger.";

// Advanced settings
settings.advanced = "Advanced";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "These options are not saved in the settings.";
settings.reset.title = "Settings";
settings.reset.title.help = "It will reset the app preference settings.

Some resources are saved separately and will NOT be resetted, it includes:
- Projects
- Tools Presets
- HDRs Environments
- MatCaps
- Alphas
- Textures (brush)
- Reference Images

Note that everything linked to the project will be kept intact, such as lighting, Post Process, camera views, etc";

// Reset preference settings button
settings.reset = "Reset to default";
settings.reset.confirm = "Reset preference settings?";

// Render a screenshot of the scene
file.render = "Render";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Show interface";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Render ratio";
file.render.renderRatio.help = "A value of 1.0 means that Nomad will render at the same resolution as the requested image size below.

Use this option if you cannot render at certain resolution (crashes because of lack of memory).";
// Desired size of the exported screenshot
file.render.size = "Final size";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Custom";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "screen";
// width of exported screenshot
file.render.width = "Width";
// height of exported screenshot
file.render.height = "Height";
// export screenshot of the scene
file.render.export = "Export png";
file.render.warn = "The export resolution is high ($0x$1)!

Make sure to save your project in case your device runs out of VRAM and crashes.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Transparent background";
file.render.transparent.help = "This option can be useful if you want to insert the mesh in a 2d creation software.

Partial object transparency is not supported for now.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Use global settings";
pressure.useGlobal.help = "By default, the tools share the same pressure settings.

Uncheck this option if you want specific pressure settings for this tool.";

// Pencil pressure
pressure.title = "Pressure";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "This tool doesn't use pencil pressure.";
// The tool can support pressure but its selected stroke type will ignore it 
pressure.noGrab = "Grab stroke type will ignore pressure settings.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Radius";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Intensity";

// Gesture section (how we handle stylus, finger)
gesture.title = "Gesture";
// Saved in global preference file, it's not linked to a certain tool or project
gesture.title.help = "These options are always global.";

// Customize whether finger and/or stylus can move the Camera
gesture.cameraInteraction = "Camera:";
// Customize whether finger and/or stylus can sculpt on object
gesture.sculptInteraction = "Sculpt:";
// Both the finger and the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.fingerAndStylus = "Finger and Stylus";
// Only the finger can perform a certain action (move camera, sculpt, etc)
gesture.interaction.finger = "Finger";
// Only the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.stylus = "Stylus";

// Three fingers on screen
gesture.three.title = "Three fingers";
// Drag 3 fingers horizontally on the canvas to rotate the environment, lights and MatCap
gesture.fingerLighting = "Rotate lighting (3 fingers)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerLighting.help = "Drag 3 fingers horizontally on the canvas to rotate the environment, lights and MatCap.";
// Drag 3 fingers vertically to edit the tool radius
gesture.fingerRadius = "Edit tool radius (3 fingers)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerRadius.help = "Drag 3 fingers vertically on the canvas to edit the tool radius.";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.fingerSmooth = "Finger always smooths";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Allow unrecognized pressure";
gesture.unknownPressure.help = "Check this option if the pressure doesn't work with your pencil or if you need pressure finger.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Pencil button";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Pencil double tap";
gesture.pencilAction.ios.help = "Only active for Apple Pencil 2nd gen.";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "None";
// Pencil button (or iOS pencil double tap) action: Smooth tool
gesture.pencilAction.smooth = "Smooth";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Add/Sub";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "One tap shortcuts";
gesture.mask.oneTap.help = "Allow the Mask shortcut by tapping the screen once, without having to hold the mask button shortcut.

It will allow the following gesture:
- tap on the background to invert the mask
- tap on a masked area to blur the mask
- tap on an unmasked area to sharpen the mask";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.holdToggle = "Hold to toggle (Mask ↔ SelMask)";

// Shortcuts to undo/redo
gesture.history = "History shortcuts";
gesture.history.help = "- Undo: tap with 2 fingers
- Redo: tap with 3 fingers
- Undo/Redo: hold 2/3 fingers down (continuous)";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Palm rejection";
gesture.palmRejection.confirm = "Make sure to disable this option if you have trouble interacting with the canvas!";
gesture.palmRejection.help = "Reject input if the contact area size larger than this value.

Might not work on every device.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Max size threshold";

// History, list of undo/redo
history = "History";
// First "undo" state
history.root = "Root";
history.undoConfirm = "Do you confirm undoing all these operations?";
history.undoWarning = "If you make an edit afterwards you might lose lot of changes.";
// Settings concerning the history stack of undo/redo
history.stack = "Stack";
// Can limit the stack of undo/redo size
history.limitSize = "History limit (Mb)";
history.limitSize.help = "Maximum size (in Mb) of the history.

The history will be updated on the next recorded operation.";
// Limit the number of undo in the history stack
history.limitStack = "Stack limit";
history.limitStack.help = "Maximum number of operation the application can keep.

The history will be updated on the next recorded operation.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Maximum undoable";
history.rangeProtect.help = "If you go far in the history, it will prompt a confirm dialog before undoing many operations.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Restore camera";
history.restoreCamera.help = "Enable this option to restore the saved camera viewpoint when you undo/redo an action.";
// Shown during undo
history.state.undo = "Undo: $0";
// Shown during redo
history.state.redo = "Redo: $0";
// Shown during undo/redo
history.state.symmetrySplit = "Symmetry Split";
// Shown during undo/redo
history.state.voxelRemesh = "Voxel remesh";
// Shown during undo/redo
history.state.surfaceRemesh = "Surface remesh";
// Shown during undo/redo
history.state.multiresLevel = "Resolution change";
// Shown during undo/redo
history.state.multiresToDynamic = "Multires to DynTopo";
// Shown during undo/redo (mesh type conversion)
history.state.meshDynamicToStatic = "DynTopo to Static";
// Shown during undo/redo (mesh type conversion)
history.state.meshStaticToDynamic = "Static to DynTopo";

// Interface customization
interface = "Interface";

// UI customization: each row of the list will be bigger
interface.expandList = "UI: Expand list";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Just an UI option for easier list management.";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "Add shortcuts (bottom)...";

// Interface option (main base color)
interface.colorBase = "Color base";
// Interface option (accent widget color)
interface.colorSelect = "Color widget";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Transparent panel";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Blur strength";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Color panel";

// Interface color preset style
interface.preset.title = "Color presets";
// Interface color preset style
interface.preset.blurRed = "Red";
// Interface color preset style
interface.preset.blurBlue = "Blue";
// Interface color preset style
interface.preset.blurGreen = "Green";
// Interface color preset style
interface.preset.blurYellow = "Yellow";
// Interface color preset style
interface.preset.blackWhite = "Black & White";
// Interface color preset style
interface.preset.whiteBlack = "White & Black";
// Interface color preset style
interface.preset.lividOrange = "Livid & Orange";
// Interface color preset style
interface.preset.cardboard = "Cardboard";
// Interface color preset style
interface.preset.default = "Default";

// Reset interface settings
interface.resetAll = "Reset style";
interface.resetAll.confirm = "Reset interface settings?";
// Interface customization
interface.flipTop = "Mirror top bar";
// Interface customization
interface.flipBottom = "Mirror bottom bar";
// Interface customization
interface.flipMiddle = "Mirror side bars";
// Interface customization (preview material in the viewport when editing material color)
interface.materialPreview = "Material color preview";
// Interface customization
interface.materialPreview.help = "When you select a color for a material, a preview of this material is displayed on the currently selected object.";
interface.toolbox.hide = "Hide toolbox";
interface.toolboxHide.help = "Enable this option if you want to hide the toolbox.";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.maxColumn = "Max column toolbox";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Reset toolbox order";
// Mirror the curve in the tool falloff
interface.curveToolSymmetric = "Symmetrical tool falloff";
interface.curveToolSymmetric.help = "The widget can be found in the Tool panel under the falloff option.";
// Scale the interface
interface.scale = "Overall scale";
// Spacing between widgets
interface.cursorStep = "Vertical spacing";
// Width of the interface panels
interface.panelWidth = "Panel width";
// Size of fonts
interface.fontScale = "Font scale";

// (see Glossary for Layer)
layer = "Layer";
// (see Glossary for Layer)
layers.addLayer = "Add layer";
// (see Glossary for Layer)
layer.factors = "Channel factors";
// (see Glossary for Layer)
layer.factor = "Factor";
// (see Glossary for Layer)
layer.offset = "Offset";
// (see Glossary for Layer)
layers.title = "Layers";
// (see Glossary for Layer)
layers.title.help = "Layers can record position offsets and painting, it can be useful for non-linear workflow.
For example by experimenting different facial expression without relying on the history stack to undo the changes.

For painting data, layers are sorted in a top-down fashion; so layers on top will mask the lower ones.

You can erase part of the layer (and thus, the layer influence) by using the 'DelLayer' tool.";
layers.primitive = "Layers are unavailable for primitives.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "None";

light = "Light";
// Intesity of light
light.intensity = "Intensity";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Attachment";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Fixed";
// The light will move along the camera
light.attachment.camera = "Camera";
light.attachment.help = "-- Fixed
Light orientation won't change.

-- Camera
Light orientation depends on the camera view.";
// Light type (directional, spot, point)
light.type = "Type";
// Directional light (synonym: sun light)
light.type.directional = "Directional";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Spot";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Point";
// Cone angle for spot angles
light.spotAngle = "Cone angle";
// Softness of the spot light
light.spotSoftness = "Softness";
// Position of the light
light.position = "Position";
// Enable or disable shadows for a light
light.shadowCast = "Shadow";
light.shadowType = "Shadow type";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadowType.shadowMap = "Shadow map";
// Shadows computed with only the information visible on screen
light.shadowType.screenspace = "Screenspace";
light.shadowType.screenspace.help = "Experimental feature, it might be removed in a future release.

This option is meant to be used with the softness shadow feature.";
// Adjustment to fix artefacts
light.shadowBias = "Bias";
// How blurry the shadow is
light.shadowSoftness = "Softness";
// Contact shadows are small scale shadows (synonym: cavity shadows... maybe)
light.contactShadow = "Contact";
light.contactShadow.help = "If auto is selected, only the most dominant light will have contact shadow.";
// Activated the light
light.visible = "Show";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Recenter";

// Object's material
material = "Material";
// See glossary
material.pbrRoughnessMetalness.warning = "Roughness and Metalness requires PBR shading mode.";
// See glossary
material.pbrReflectance.warning = "Reflectance requires PBR shading mode.";
// See glossary
material.pbrRefraction.warning = "Refraction requires PBR shading mode.";
// See glossary
material.pbrSubsurface.warning = "Subsurface requires PBR shading mode.";
// Value that says how much light will change direction when hitting the surface
material.ior = "Index of Refraction";
// an object-level value that overrides the painting of the mesh
material.paintingOverride = "Override painting";
// The roughness in the inside is turbidity
material.paintingOverride.help = "There is two roughness at play, the one that drives the surface and the one in the inside.

However there is only one paintable roughness, so the two roughness have the same values.

You can use this slider to override the surface roughness to make more glossy.";
// Glossiness is simply the opposite of roughness
material.refractionSurfaceGlossiness = "Surface glossiness";
material.refractionSurfaceGlossiness.help = "- at 0, the surface is using the painted roughness
- at 1, the surface is completely smooth";
// Synonym: turbidity
material.refractionInteriorRoughness = "Interior roughness";
material.refractionInteriorRoughness.help = "- at 0, the interior is using the painted roughness
- at 1, the interior is completely rough";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Paint glossy";
material.paintGlossy.help = "It will paint the object with a roughness and metalness of 0, thus allowing sharp refraction.

This is the same as going in the painting menu and using the paint all feature with color and metalness disabled.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Absorption";
material.absorptionEnable.help = "Simulate the light being absorbed when it travels through the volume.

Thin parts will bright as it lets more light pass through, while thick areas will be darker.

The effect heavily depends on the object shape, only an approximation of the object thickness is used.";
material.absorptionFactor = "Factor";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "Depth";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "Translucency";
material.translucency.help = "You need to have a light that casts shadows in order to see translucency.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Opacity";
// Fully opaque material
material.type.opaque = "Opaque";
// See glossary
material.type.subsurface = "Subsurface";
material.type.subsurface.help = "To get the best result, you can switch to PBR shading mode and use at least one directional light, ideally with a dim environment.";
// Transparency mode, alpha blending
material.type.blending = "Blending";
material.type.blending.help = "Make the object semi-transparent by tweaking the opacity value.

Note that because of real-time constraints, you can have noticeable visual artifacts if your object has a complex shape.";
// Transparency mode
material.type.additive = "Additive";
material.type.additive.help = "Make the object semi-transparent by tweaking the opacity value.

This method tends to have less artifacts than the Blending method, but the object will be brighter.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Dithering";
material.type.dithering.help = "Make the object semi-transparent by discarding some pixels in a random fashion.";
// Simulate glass-like material
material.type.refraction = "Refraction";
material.type.refraction.help = "This mode can be used to simulate glass material.

Because of real time constraints, self-refraction or multi-layered refraction is limited.";
material.castShadows = "Cast shadows";
material.receiveShadows = "Receive shadows";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Always unlit";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Inverse culling";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Reflectance";
material.reflectance.help = "Control the amount of reflection the material will receive for non-metallic materials.

Most of the time, the default value should be used (0.5, which corresponds to the standard 4% reflected light at normal angle).";

// Menu name
menu.files = "Files";
// Menu name
menu.scene = "Scene";
// Menu name
menu.multires = "Multires";
// Menu name
menu.voxel = "Voxel";
// Menu name
menu.dynTopo = "DynTopo";
// Menu name
menu.topology = "Deci/UV...";
// Menu name
menu.primitive = "Primitive";
// Menu name
menu.render = "Render";
// Menu name
menu.material = "Material";
// Menu name
menu.postProcess = "PostProcess";
// Menu name
menu.camera = "Camera";
// Menu name
menu.background = "Background";
// Menu name
menu.tool = "Tool";
// Menu name
menu.stroke = "Stroke";
// Menu name
menu.paint = "Paint";
// Menu name
menu.symmetry = "Symmetry";
// Menu name
menu.pressure = "Pressure";
// Menu name
menu.layers = "Layers";
// Menu name
menu.settings = "Settings";
// Menu name
menu.interface = "Interface";
// Menu name
menu.history = "History";
// Menu name
menu.historySettings = "Settings";
// Menu name
menu.about = "About";
// Menu name
menu.debug = "Debug";

// Operation on the object (action)
mesh.action = "Operation";
// If the object has holes, the algorithm will close them
mesh.holeClose = "Close holes";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holeDetail = "Detail";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Separate";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "Layers, painting and multiresolution will be lost.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Resolution";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Force cubic";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Convert";
// Static object means "static topology"
mesh.typeStatic = "Static";
// See glossary
mesh.typeMultiresolution = "Multiresolution";
// Dynamic topology 
mesh.typeDynamic = "DynTopo";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Global material";
paint.useGlobal.help = "If this option is enabled, the selected material will be the same as the other tools.

Note that it only takes into account roughness, metalness and color settings.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Stroke painting";
// Factor/Opacity of paint tool
paint.intensity = "Paint intensity";
// Apply the paint on the object
paint.paintAll = "Paint all";
paint.paintAll.help = "Apply the current material to the object.

Masked area and disabled channels won't be painted.";
// Apply the paint on the object but ignore painting intensity (force full intensity)
paint.paintAllForce = "Force paint all";
paint.strokePainting.title = "Painting";
paint.layerWarning = "Channel masking will be ignored if you try to apply it on a layer.";
// Brush stroke texture
paint.texture.title = "Texture";
paint.texture.title.help = "An image that will color your brush stroke.

Note that it will share the alpha's tiling and scale settings.";
paint.texture.warningEnable = "Stroke painting needs to be enabled to allow texture projection (checkbox on top)!";
paint.texture.warningIgnored = "The current tool cannot use textures!";
// Whether the Brush Alpha will be used to module painting
paint.useAlpha = "Use stroke alpha";
paint.useAlpha.help = "Using the alpha set in the stroke menu to modulate the painting.";
// Whether the Brush Falloff will be used to module painting
paint.useFalloff = "Use stroke falloff";
paint.useFalloff.help = "Using the falloff set in the stroke menu to modulate the painting.";

// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "New name";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "New value";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "New color (hex format)";

// Post process effect
postprocess.mainEnable = "Post Process";
// Quality vs performance
postprocess.quality = "Quality";
postprocess.quality.help = "Activate these options to improve the quality to the detriment of performance.

It will improve:
- Reflection
- Subsurface
- Ambient Occlusion
- Depth Of Field";
// More samples means better quality but slower performance
postprocess.maxSamples = "Max samples";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Full Resolution";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "Max frame sampling";
postprocess.accumulateCount.help = "Maximum number of frames to accumulates before the rendering stops.

When the rendering stops, Nomad won't do anything, thus saving battery life.

Many rendering features benefits from frame accumulation, notably:
- Soft Shadows
- Reflection
- Subsurface
- Ambient Occlusion
- Depth Of Field

High frame count are only necessary for Soft Shadows.
Depending on features enabled, Nomad can stops the rendering sooner.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Render resolution";
postprocess.renderRatio.warning = "Overriden by the Pixel Art effect.";
postprocess.renderRatio.help = "This option impacts the performance a lot.
It's advised to keep a value lower than x1.25.

This option is not saved in the settings.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taaEnable = "Anti-aliasing (TAA)";
postprocess.taaEnable.help = "Reduces flickering when you are moving the camera.";
// Screen-space reflection (no need to translate "SSR")
postprocess.ssrEnable = "Reflection (SSR)";
postprocess.ssrEnable.warning = "SSR requires PBR shading mode.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssaoEnable = "Ambient Occlusion";
// How far the effect spreads
postprocess.ssaoRadius = "Size";
// How strong the effect is
postprocess.ssaoFactor = "Strength";
// Adjustment to fix artefacts
postprocess.ssaoBias = "Curvature bias";
postprocess.ssaoBias.help = "How sensitive the effect is depending on the surface curvature.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dofEnable = "Depth Of Field";
// The blur factor behind the focused point 
postprocess.dofBlurFar = "Far blur";
// The blur factor in front of the focused point 
postprocess.dofBlurNear = "Near blur";
postprocess.dofFocusTip = "Tap an object to change the focus point.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloomEnable = "Bloom";
// Intensity of the effect
postprocess.bloomIntensity = "Intensity";
// How far the effect spreads
postprocess.bloomRadius = "Radius";
postprocess.bloomRadius.help = "How widespread the bloom is.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloomThreshold = "Threshold";
postprocess.bloomThreshold.help = "Luminosity threshold to decide if a pixel will emit bloom or not.
If the value is at 0, everything will receive bloom.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.toneEnable = "Tone Mapping";
postprocess.toneExposure = "Exposure";
postprocess.toneContrast = "Contrast";
postprocess.toneSaturation = "Saturation";
// No tonemapping operator is used
postprocess.toneMappingNone = "None";
// Color curves
postprocess.curveEnable = "Color Grading";
// Curve for pixel luminance
postprocess.curve.luminance = "Main";
postprocess.curve.red = "Red";
postprocess.curve.green = "Green";
postprocess.curve.blue = "Blue";
postprocess.curveReset = "Reset";
// Reset color grading curves
postprocess.curveResetAll = "Reset All";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromaticEnable = "Chromatic Aberration";
postprocess.chromaticFactor = "Strength";
// Darking on the edges
postprocess.vignetteEnable = "Vignette";
// How far the effect spreads
postprocess.vignetteSize = "Size";
// How sharp the edge of the effect is
postprocess.vignetteHardness = "Hardness";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpnessEnable = "Sharpness";
postprocess.sharpnessFactor = "Strength";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grainEnable = "Grain";
postprocess.grainFactor = "Strength";
// Accentuate the edges of the model
postprocess.curvatureEnable = "Curvature";
// Color/Strength of concave curvature
postprocess.curvatureCavity = "Cavity";
// Color/Strength of convex curvature
postprocess.curvatureBump = "Bump";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArtEnable = "Pixel Art";
// Simulate scanline rendering (horizonal line)
postprocess.scanlineEnable = "Scanline";
postprocess.scanlineFactor = "Factor";
// Spacing between lines
postprocess.scanlineSpacing = "Spacing";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Primitive";
primitive.box = "Box";
primitive.sphereCube = "Sphere";
primitive.sphereUV = "UV Sphere";
primitive.icosahedron = "Icosahedron";
primitive.cylinder = "Cylinder";
primitive.cone = "Cone";
primitive.torus = "Torus";
primitive.lathe = "Lathe";
primitive.tube = "Tube";
primitive.plane = "Plane";
primitive.triplanar = "Triplanar";
primitive.faceXYZ = "Face XYZ";
primitive.faceXYZ.help = "UV-unwrapped base mesh provided by https://texturing.xyz/";
primitive.needValidate = "Primitives should be validated in order to be sculpted.";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Edit";
primitive.edit.help = "Allow 3d editing in the viewport.

You can disable this feature if you want to interact with the Gizmo or the Transform tool without modifying the primitive.";

// Primitive configuration
primitive.mainConfig = "Parameter";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Topology";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Geometry";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Validate";
// Maximum number of faces of the primitives
primitive.maxFaces = "Max faces";
primitive.maxFaces.help = "The maximum number of faces a primitive can have.

This limit is only active while the primitive is not validated, afterwards the safeguard is gone.";
// Synonym: Flat subdivision
primitive.linear = "Linear subdivision";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Post subdivision";

// Radius (of a sphere, torus, etc)
primitive.radius = "Radius";
// Size (of cube x dimension)
primitive.size = "Size";
primitive.sizeX = "Size X";
primitive.sizeY = "Size Y";
primitive.sizeZ = "Size Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "Division";
primitive.divisionX = "Division X";
primitive.divisionY = "Division Y";
primitive.divisionZ = "Division Z";
// Angle of torus, etc
primitive.angleX = "Angle X";
primitive.angleY = "Angle Y";
primitive.angleZ = "Angle Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Constant density";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Project on sphere";
primitive.projectOnSphere.help = "Snaps the points on a perfect sphere.";

// triplanar
primitive.triplanar.title = "Triplanar";
primitive.triplanar.title.help = "Triplanar is using the mask information from 3 planes to fill a voxel grid that is then polygonized.

If you interact with the division or size sliders, the painting information will reset (smoothness is ok).

You should probably disable symmetry as it might not function as you would expect.

You can use the 'Topologically connected' option in the mask panel to paint a plane impacting the other planes.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanarSameSize = "Same size (cube)";
primitive.triplanarPolish = "Smoothness";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanarResetMask = "Reset mask";
// One side of a cube (the back plane)
primitive.isolate.back = "Back";
// One side of a cube (the right plane)
primitive.isolate.right = "Right";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Bottom";
// Plane
primitive.planeSameSize = "Same size (square)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "Disk";
// Box
primitive.boxRegular = "Same size (cube)";
// Distance to the snapping point
primitive.tubeSnapOffset = "Snap offset";
primitive.tubeSnapOffset.help = "A value of 1.0 is equal to the tube's radius.";
// Radius of the tube (starting end-point of the tube)
primitive.tubeThicknessStart = "Radius start";
// Radius of the tube (ending end-point of the tube)
primitive.tubeThicknessEnd = "Radius end";
primitive.tubeTwist = "Twist";
primitive.tubeTwistRotate = "Rotation";
primitive.tubeTwistRadius = "Magnitude";
primitive.tubeTwistOffset = "Offset";
primitive.tubeSnap = "Snap";
primitive.torusRadiusOuter = "Outer radius";
primitive.torusRadiusInner = "Inner radius";
primitive.torusAngle = "Angle";
primitive.torusAngleOffset = "Angle offset";
primitive.cylinderHeight = "Height";
primitive.coneRadius = "Radius";
primitive.coneHeight = "Height";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Hole";
// Make a hole in the primtive to make it hollow
primitive.hasHole = "Has hole";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radiusSync = "Same radius";
primitive.radiusStart = "Radius start";
primitive.radiusEnd = "Radius end";
// Smooth curve https://en.wikipedia.org/wiki/Spline_(mathematics)
primitive.spline = "Spline";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Import...";

scene.title = "Scene";
scene.title.help = "When using the selection checkbox, hold and drag your finger to select other objects easily.";
// Merge 2 objects without modifying the geometry or the topology
scene.mergeSimple = "Simple merge";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Voxel merge";
scene.voxelResolution = "Resolution";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Subtraction: Hide object (eye icon)";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Intersection: All objects hidden";

// General scene display settings
settings.display.title = "Display settings";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Wireframe";
// Display UV
settings.debugUV = "Debug UV";
settings.debugUV.help = "This option is only relevant if the model has UVs.

It will display the UV wireframe in the background.

It will also display a colored checkerboard texture on the model.";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Two sided";
settings.twoSided.help = "Faces will be visible from both sides.";
// If we colorize the inverted side of faces
settings.backface.color = "Backface color";
// Color of the inverted side of faces
settings.backface.colored = "Colored backface";
// Outline (contour highlight around the selected object)
settings.outline = "Outline";
// Outline (contour highlight around the selected object)
settings.outline.help = "Selected objects will be outlined."
settings.outline.thickness = "Thickness";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Snap cube";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "Bottom";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "Left";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Stats";
settings.stats.right = "Right";
settings.stats.all = "Show full scene";
// Grid
settings.grid = "Grid";
// Cursor
settings.cursor.whileSculpting = "Show circle while sculpting";
// A small indicator dot
settings.cursor.showDot = "Show small dot";
settings.cursor.showDot.help = "The dot can appear as the camera pivot point or when you are sculpting.";
settings.cursor.showRope = "Show rope stabilizer";
// Highlight (the object glows when we select it)
settings.highlight.selection = "Highlight selection";
// Highlight settings
settings.highlight = "Highlight";
settings.highlight.duration = "Duration";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Darken unselected objects";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Smooth shading";
// Experimental feature
settings.partialDraw = "Partial drawing";
settings.partialDraw.help = "Experimental feature!

Use it if you are sculpting a relatively small part of a high poly mesh.

It should make the sculpting smoother, but you should not enable wireframe!

Also it might add visual artefacts during the brush strokes";
settings.partialDraw.warning = "Do not forget to turn off this option if the visual artefacts are too bothersome!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Show painting";
// Display the light icons in the viewport
settings.lightIcon = "Light icons";
settings.lightIcon.help = "Display light icons on the canvas so that you can select and edit them directly.";
// Hole filling settings
settings.hole = "Hole-filling";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Fill non-manifold";
settings.hole.nonManifold.help = "Try to fill non manifold hole.
This option is not saved in the settings.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Max vertices count";
settings.multires.maxVertices.help = "Nomad doesn't perform memory check before subdivision, high poly count can easily lead to crashes.";
settings.multires.lowResVertices = "Low resolution threshold";
settings.multires.lowResVertices.help = "A lower resolution of the mesh can be displayed when you move the camera.

You can increase this value if you want to display a higher resolution of the mesh.";

// The main rendering mode
shading = "Shading";
// main render mode
shading.pbr = "Lit (PBR)";
shading.pbr.help = "In this mode you can add lights (with shadows), along with an HDR environment.

You can also paint metalness and roughness, thus allowing a finer control on the look of your material.";
shading.matcap = "MatCap";
shading.matcap.help = "Stands for MATerial CAPture, a MatCap takes care of both the lighting and material information in a single image.

This is a fast rendering mode, mostly suited for raw sculpting.";
shading.unlit = "Unlit";
shading.unlit.help = "Solid color shading mode, without lighting.";
shading.textures = "Use textures";
shading.textures.help = "At the moment, you cannot create nor edit textures inside Nomad.

But if you import a file with textures in it, it should work.

-- Supported textures --
Opacity: Lit, MatCap, Unlit
Normal: Lit, MatCap
Color: Lit, Unlit
Emissive: Lit
Roughness: Lit
Metalness: Lit";
// Lights
shading.lights = "Lights";
shading.lights.addLight = "Add light";
shading.lights.warning = "Lights requires PBR shading mode.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Environment";
shading.environmentImport = "Import HDR";
shading.environmentExposure = "Exposure";
shading.environmentBackgroundBlur = "Blur (background)";
shading.environmentRotation = "Rotation";
shading.environmentRotation.help = "You can rotate the environment by dragging 3 fingers horizontally on the viewport.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environmentAttachedToCamera = "Attached to camera";
shading.environmentAttachedToCamera.help = "Attach the environment to the camera.

It will force the lighting to be consistent, which can be useful for sculpting purposes.";
shading.matcapRotation = "Rotation";
shading.matcapRotation.help = "You can rotate the MatCap by dragging 3 fingers horizontally on the viewport.";
shading.matcapGlobal = "Use global MatCap";
shading.matcapGlobal.help = "Uncheck this option to use a different MatCap for this particular mesh.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible.short = "Mask";
shortcut.maskVisible.long = "Mask";
// bottom shortcut buttons (should be SHORT)
shortcut.solo.short = "Solo";
shortcut.solo.long = "Solo";
// bottom shortcut buttons (should be SHORT)
shortcut.voxelRemesh.short = "Voxel";
shortcut.voxelRemesh.long = "Voxel remesh";
// bottom shortcut buttons (should be SHORT)
shortcut.wireframe.short = "Wire";
shortcut.wireframe.long = "Wireframe";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraReset.short = "Reset";
shortcut.cameraReset.long = "Camera reset";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraSnap.short = "Snap";
shortcut.cameraSnap.long = "Camera snap";
// bottom shortcut buttons (should be SHORT)
shortcut.lockSelection.short = "Lock";
shortcut.lockSelection.long = "Lock selection";
shortcut.lockSelection.long.help = "When enabled, you cannot change the selection by tapping on a mesh.";
// bottom shortcut buttons (should be SHORT)
shortcut.perspective.short = "Persp";
shortcut.perspective.long = "Perspective";
// bottom shortcut buttons (should be SHORT)
shortcut.grid.short = "Grid";
shortcut.grid.long = "Grid";
// bottom shortcut buttons (should be SHORT)
shortcut.uv.short = "uv";
shortcut.uv.long = "uv";

// Memory taken by the scene
stat.ramScene = "Scene";
// Vram = Video RAM (Video Memory, the memory of the graphic card) 
stat.vramScene = "Vram Scene";
// Vram = Video RAM (Video Memory, the memory of the graphic card) 
stat.vramRender = "Vram Render";
// Vram = Video RAM (Video Memory, the memory of the graphic card) 
stat.vramTextures = "Vram Textures";
// Memory taken by the undo/redo history
stat.ramHistory = "History";
// Memory taken by other stuffs
stat.ramOther = "Other";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "Used Memory";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "Free Memory";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "Used: $0 MB";
stat.free = "Free: $0 MB";
stat.faces = "Faces";
stat.triangles = "Triangles";
stat.vertices = "Vertices";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Quads";
stat.sceneFaces = "Scene faces";
stat.sceneVertices = "Scene vertices";

// Brush stroke
stroke = "Stroke";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "World-space radius";
// The settings is shared among every tools
stroke.useWorldRadius.help = "This is shared among every tools.";
// Share the radius value among every tools.
stroke.useShareRadius = "Share radius";
stroke.useShareRadius.help = "Share the radius value among every tools.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.minSpacing = "Stroke spacing";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.minSpacing.adjustIntensity = "Adjust spacing intensity";
stroke.minSpacingAdjustIntensity.help = "Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.";
stroke.minSpacing.help = "Spacing between each stroke, relative to the tool radius.

Lower value will allow smoother stroke but performance will degrade.";
// Brush stroke smoothing
stroke.lazySmooth = "Stroke smoothing";
stroke.lazySmooth.help = "Average multiple pointer position to get a smoother stroke.

With high values, the stroke will lag behind the pointer but will eventually catch up.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Lazy rope stabilizer";
stroke.lazyRadius.help = "Strokes will lag behind the pointer position according to a certain distance.

This can be used to draw smooth lines.";
// It is not a per-tool settings
stroke.globalSettings = "This is a global setting";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Snap radius";
stroke.snapRadius.help = "Snap the stroke if the pointer lies close to the last recorded stroke.

This can be useful when drawing long continuous lines, while doing frequent pauses.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Stroke offset";
stroke.sculptOffset.help = "Apply a constant offset on the stroke.

This option is there to help for small screen when using fingers, so that your finger doesn't cover the stroke.";
stroke.accumulate = "Accumulate stroke";
stroke.accumulate.help = "If this option is enabled, there is no limit to how much matter you can add/remove per stroke.";
// The tool can use DynTopo
stroke.useDynamicTopology = "Allow dynamic topology";
// Only sculpt the part that are linked topologically
stroke.connectedTopology = "Connected topology";
stroke.connectedTopology.help = "This option will only sculpt the vertices that are linked to the picked surface.

This is typically used for the Move tool, for example if you want to exclusively move a part that self-intersect with another part.";
// Only sculpt the vertex that points toward the camera
stroke.onlyFrontFace = "Front-facing vertex only";
stroke.onlyFrontFace.help = "This option will ignore back facing vertices.

It can be useful if you want to paint part of a thin geometry without impacting the other side.

It also works for sculpting but you might experience some artefacts.";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.onlySameSide = "Same-side vertex only";
stroke.onlySameSide.help = "Ignore vertices that points in the opposite direction of the deformation.";
// Module the intensity of the sculpting operation by using a falloff curve
stroke.curveFalloff = "Falloff";
stroke.onlyLasso = "Settings only active for the lasso tool.";
// Alpha
stroke.alpha = "Alpha";
// Invert the pixel (black <-> white)
stroke.alphaInvert = "Invert pixels";
// Repeat the alpha image (pattern)
stroke.alphaWrap = "Tiling";
// No repeat pattern
stroke.alphaWrap.none = "None";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alphaWrap.repeat = "Repeat";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alphaWrap.mirror = "Mirror";
stroke.alphaProject = "Method";
// Project the alpha perpendicularly onto the surface 
stroke.alphaProject.surfaceContinuous = "Surface";
// Project the alpha onto the surface in the direction of the camera view
stroke.alphaProject.screenFixed = "Screen project";
stroke.alphaRotation = "Rotation";
// Repeat the image
stroke.alphaTiling = "Tiling";
// Scale the image (make it bigger or smaller)
stroke.alphaScale = "Scaling";
stroke.alphaScale.help = "At minimum value, the alpha square is inside the tool circle radius.";
// Middle-point value at which no deformation occurs
stroke.alphaMidValue = "Mid value";
stroke.alphaMidValue.help = "Middle-point value at which no deformation occurs.

(Mid value = 0)
- Black: no displacement
- White: positive displacement

(Mid value = 0.5)
- Black: negative displacement
- White: positive displacement

(Mid value = 1)
- Black: negative displacement
- White: no displacement";
// Stroke type
stroke.strokeType = "Stroke type";
// Sculpt and paint along the brush stroke at regular spacing
stroke.strokeTypeDot = "Dot";
// Sculpt continuously
stroke.strokeTypeDrag = "Drag";
// Lock a region and move it around
stroke.strokeTypeGrab = "Grab";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.strokeTypeGrabRadius = "Grab - dynamic radius";
// Lock a region and sculpt it by changing the tool intensity
stroke.strokeTypeGrabIntensity = "Grab - dynamic intensity";

// Symmetry
symmetry = "Symmetry";
symmetry.enable = "Enabled";
symmetry.plane.title = "Planes";
symmetry.toolIgnore = "The current tool ignores symmetry.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Radial";
symmetry.radialX = "Radial X";
symmetry.radialY = "Radial Y";
symmetry.radialZ = "Radial Z";
// method
symmetry.method = "Method:";
symmetry.method.help = "-- Local
The symmetry plane will move along the mesh when you use one of the transform tools (Gizmo or Transform).

-- World
The symmetry plane is fixed and will not move.";
// Local means: in the coordinate of the scene 
symmetry.methodWorld = "World";
// Local means: in the coordinate of the object (internal) 
symmetry.methodLocal = "Local";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Flip object";
// Mirror the mesh
symmetry.mirror = "Mirroring";
symmetry.mirror.help = "Try to re-apply the symmetry without impacting the topology.

Radial symmetry will be ignored.

If the topology can't be kept because it is not considered symmetrical, you'll get the option to enforce the mirroring.";
symmetry.mirrorLeftToRight = "Left to Right";
symmetry.mirrorRightToLeft = "Right to Left";
symmetry.mirrorFail = "Failed to apply symmetry.

Do you want to enforce symmetry by mirroring the mesh?";
symmetry.mirrorUseMasking = "Protect masked area";
symmetry.mirrorUseMasking.help = "Keep masked area intact.

This option will be ignored with non-symmetric topology (or disconnected surface, like a pair of eyes).";
// Reset the symmetry plane position
symmetry.reset = "Reset";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Object center";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "World center";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Orientation";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Show line";
// Display the symmetry plane in 3d
symmetry.showPlane = "Show plane";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Gizmo edit";
symmetry.edit.warning = "Symmetry edit is experimental.";
symmetry.edit.help = "You can freely set the symmetry plane.

This feature is a bit experimental and you should probably never use it.";

// Ideally <10 chars
tool.dynTopo = "DynTopo";
// Ideally <10 chars (Symmetry)
tool.symmetry = "Sym";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "Mirror";
// Ideally <10 chars
tool.clay = "Clay";
// Ideally <10 chars (Subtract)
tool.clay.sub = "Sub";
// Ideally <10 chars
tool.brush = "Brush";
// Ideally <10 chars
tool.move = "Move";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "Normal";
// Ideally <10 chars
tool.drag = "Drag";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "Smooth";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Relax";
// Ideally <10 chars (Paint mask)
tool.mask = "Mask";
// Ideally <10 chars
tool.mask.unmask = "Unmask";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "SelMask";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "Smudge";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "Flatten";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Fill";
// Ideally <10 chars (Layer brush)
tool.layer = "Layer";
// Ideally <10 chars
tool.crease = "Crease";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "Trim";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Split";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "Project";
// Ideally <10 chars
tool.inflate = "Inflate";
// Ideally <10 chars
tool.pinch = "Pinch";
// Ideally <10 chars
tool.nudge = "Nudge";
// Ideally <10 chars
tool.stamp = "Stamp";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "DelLayer";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.lassoSelect = "Select";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "Gizmo";
// Ideally <10 chars (Automatic)
tool.gizmo.auto = "Auto";
// Ideally <10 chars
tool.gizmo.editPivot = "Pivot";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "Snap";
// Ideally <10 chars (Local space)
tool.gizmo.local = "Local";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "Transform";
// Ideally <10 chars (Translate the object)
tool.transform.move = "Move";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "Rotate";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "Scale";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "Snap";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "Measure";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "View";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "Lathe";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "Tube";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "Insert";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "Flip";
// Ideally <10 chars (View, do nothing in particular)
tool.shape.view = "View";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "Lasso";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Curve";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Polygon";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Path";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "Rect";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "Ellipse";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "Line";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Closed";

// Popup when editing the vertical sliders on the left
tool.slider.radius = "Radius $0";
// Popup when editing the vertical sliders on the left
tool.slider.intensity = "Intensity $0 %";

tool.settings = "Settings";
tool.settings.none = "This tool doesn't have any specific settings.";

// Flatten distance offset
tool.clay.flattenOffset = "Flatten offset";
tool.crease.pinchFactor = "Pinch force";

tool.layer.removeInfluence = "Use layer data";
tool.layer.removeInfluence.help = "This option is only active when there is a layer selected.

It will use the layer data to limit the displacement over strokes.";
tool.layer.noLayerSelected = "This option is only available if a layer is selected";

tool.flatten.warning = "These options are experimental and could be removed in the future!";
tool.flatten.planeLockOrigin = "Lock plane origin";
tool.flatten.planeLockNormal = "Lock plane direction";
tool.flatten.planeAverageOrigin = "Average plane origin";
tool.flatten.planeAverageNormal = "Average plane direction";
tool.flatten.planeOffset = "Plane offset";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Sticky vertex on border";

tool.paint = "Paint";
// Erase the painting
tool.paint.erase = "Erase";
// Only paint the part of the mesh above a certain height
tool.paint.depthFilter = "Depth filtering";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Layer filtering";
tool.paint.layerFilter.help = "Use this option if you only want to repaint the already painted area of a layer.";

// Clear the painted mask
tool.mask.clear = "Clear";
// Invert the painted mask
tool.mask.invert = "Invert";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Flip connected";
// Blur the painted mask
tool.mask.blur = "Blur";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Sharpen";
// The thickness of the extracted mesh (from the painted mask)
tool.mask.thickness = "Shell thickness";
// Smooth the border of the extracted mesh (from the painted mask)
tool.mask.polish = "Border smoothness";
// Extract a new mesh from the painteed mask and carve/emboss the base mesh
tool.mask.engraveEmboss = "Engrave / Emboss";
// Extract a new mesh from the painted mask
tool.mask.extract = "Extract";
// Extract two new mesh from the painted mask and from the unmasked area
tool.mask.split = "Split";
// How should we close the topology of the extracted object
tool.mask.closeMask = "Closing action (masked):";
// How should we close the topology of the extracted object
tool.mask.closeUnmask = "Closing action (unmasked):";
// How should we close the topology of the extracted object
tool.mask.closeAction = "Closing action:";
// Do not close the mesh (leave it open)
tool.mask.closeActionNone = "None";
// Close the mesh with a hole-filling algorithm
tool.mask.closeActionFill = "Fill";
// Close the mesh by adding a thickness on the surface
tool.mask.closeActionShell = "Shell";
// Close the mesh by using the layer data as a difference thickness
tool.mask.closeActionLayer = "Layer";
tool.mask.closeAction.help = "-- None
Simply extract the part and let the extracted part opened.

-- Fill
Hole is filled and smoothed.
Do not use this option for flat surface.

-- Shell
Close the extracted shape by using the thickness value.

-- Layer
Extract the layer difference (layer sub-menu only).";

// Transform/Matrix
tool.matrix = "Matrix";
// Duplicate/Clone the mesh when interacting with the gizmo
tool.matrix.clone = "Clone";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.apply = "Target";
// Automatic
tool.matrix.apply.auto = "Auto";
// Vertex/Point of a mesh
tool.matrix.apply.vertex = "Vertex";
// Object-level transform (Matrix)
tool.matrix.apply.object = "Object";
tool.matrix.apply.help = "-- Auto
Let Nomad choose between Vertex or Object mode.
Typically, object is preferred unless symmetry is enabled or if there is masking on the mesh.

-- Vertex
Vertices are transformed individually.
Symmetry and mask are taken into account.
For primitives that are not validated, Object mode is forced.

-- Object
The object is transformed as a whole.
Symmetry and mask are ignored.
If you use non-uniform scaling, Vertex mode will be forced.";
// Operation on the mesh
tool.matrix.action = "Operation";
tool.matrix.action.help = "-- Move origin
Move the mesh to the world origin.

-- Reset
Reset the mesh transform to identity.

-- Bake
Apply the matrix to the vertex and reset the matrix. Visually, nothing should change.";
tool.matrix.translation = "Translation";
tool.matrix.rotation = "Rotation";
tool.matrix.scale = "Scale";
tool.matrix.uniformScale = "Uniform scale";
tool.matrix.uniformScale.help = "Nomad cannot support non-uniform scale as object transform, so it will be applied as a vertex transformation.";
tool.matrix.moveToOrigin = "Move origin";
tool.matrix.resetTransform = "Reset";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "Bake";

tool.transform.multiTouch = "Multi-touch";
tool.transform.multiTouch.help = "If this option is disabled, you can only use one mode (translate, rotate, scale) at a time.";
tool.transform.transformRestrictRotationY = "Y axis rotation";
tool.transform.transformRestrictRotationY.help = "Auto means the option is active only if Snap is on and the mesh has a custom gizmo pivot.";

// Size of the gizmo
tool.gizmo.size = "Widget size";
tool.gizmo.linearRollThreshold = "Tangent roll threshold";
tool.gizmo.linearRollThreshold.help = "Angle threshold to choose between linear or circular roll method.

Value above this threshold will use the circular roll.

If you prefer the linear roll (direction of the tangent), simply set this value to 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Hide on interaction";
tool.gizmo.tap = "Move custom pivot on single-tap";
tool.gizmo.tap.help = "This option is only effective in custom pivot mode (Auto disabled).

-- None
Nothing happen when tapping on the mesh.

-- First hit
Move the gizmo on the first intersection.

-- Middle stab
Move the gizmo on the average of the first two intersections.";
tool.gizmo.tapNone = "None";
tool.gizmo.tapFirstHit = "First hit";
tool.gizmo.tapMiddleStab = "Middle stab";

tool.lathe.axis = "Axis";
// The lathe generator (line) is fixed on the screen
tool.lathe.axis.fixed = "Fixed";
// synonym: Start & End, Custom
tool.lathe.axis.dynamic = "Dynamic";

tool.tube.snap = "Snapping";
// Snap everything of the tube on the surface
tool.tube.snap.all = "Every point";
// Snap only the first and last control point of the tube on the surface
tool.tube.snap.startEnd = "Start & End";

// Fill the object's hole
tool.hole = "Hole filling";
tool.hole.fillHoles = "Fill holes";
// synonym: Alternative method
tool.hole.bridges = "Screen-space boolean";
tool.hole.bridges.help = "If this option is enabled, you can punch holes in the volume.
The cut slope will also follow more closely the cutting shape.";
tool.hole.threshold = "Threshold epsilon";
tool.hole.threshold.help = "Tweaking this value might help with the hole filling algorithm.";
tool.hole.smoothing = "Hole smoothing";

tool.smudge.quality = "Quality";
tool.smudge.quality.help = "It changes the resolution of the projected pixels, lower values means faster strokes.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Shape";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Square";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Centered";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Circle";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Centered";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Rotate step";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Show golden ratio";

// Topology
topology = "Topology";
// Synynom: detail value, density
topology.dynamic.detail = "Detail";
// See glossary
topology.multires = "Multiresolution";
topology.multires.help = "Keep multiple resolution of a mesh.

If you make changes in a lower resolution, details from the higher resolutions will be reprojected when you switch back.

Layers are available on every resolution.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "Reverse";
topology.multires.reverse.confirm = "Could not create base subdivision.

The current topology is probably not a result from a subdivision.";
topology.multires.subdivide = "Subdivide";
topology.multires.subdivide.confirm = "The mesh will have $0M vertices, are you sure?";
topology.multires.deleteLower = "Delete lower";
topology.multires.deleteHigher = "Delete higher";
topology.multires.keepTriangles = "Keep triangles";
// Synonym: Flat subdivision
topology.multires.linear = "Linear subdivision";
topology.multires.linear.help = "Simply subdivide the mesh without applying any smoothing";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Voxel remeshing";
topology.voxel.help = "Remeshing by sampling the mesh on a grid.

If the object is not closed (watertight), an hole-filling algorithm will be applied first.

Layers are reprojected after remeshing but the quality will degrade.";
topology.voxel.resolution = "Resolution";
topology.voxel.remesh = "Remesh";
topology.voxel.sharp = "Keep sharp edges";
topology.voxel.sharp.help = "This option is mostly useful for simple primitive boolean operation.

It will introduce distortion in some area due to the points being snapped on the edges.";
topology.voxel.subLevel = "Build multiresolution";
topology.voxel.subLevel.help = "You can rebuild a multiresolution hierarchy from the voxel remesher output.

It will also run faster and use less memory, especially if the voxel detail value is high.
However if the voxel detail value is low and you are asking for lot of multires level, you'll lose details.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Remesh";
topology.surface.detail = "Detail";
topology.surface.detail.help = "Unlike voxel remeshing, surface remeshing doesn't require the mesh to be closed.

It can also support masking so that you can protect some part of the mesh from topology changes.

Layers are updated correctly.";
topology.surface.method = "Method";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Uniformisation";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Subdivision";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Decimation";
topology.surface.method.help = "Behavior of dynamic topology:
- Uniformisation: add and remove detail
- Subdivision: add detail
- Decimation: remove detail";
topology.surface.useMasking = "Protect masked area";
topology.surface.useMasking.help = "The masked areas will protect the topology from beging changed.";
topology.surface.extrapolate = "Vertex extrapolation";
// DynTopo
topology.dynamic = "Dynamic topology";
topology.dynamic.activate = "Enabled";
topology.dynamic.activate.help = "With dynamic topology, sculpting tools can subdivide or simplify the mesh locally in real time.

This feature can have a noticeable impact on performance.

Layers are updated correctly.";
topology.dynamic.method = "Detail based on...";
topology.dynamic.method.zoom = "Zoom";
topology.dynamic.method.radius = "Radius";
topology.dynamic.method.constant = "Constant";
topology.dynamic.method.help = "-- Zoom
The level of detail is based on how far you are from the surface.

-- Radius
The tool radius defines the amount of detail.

-- Constant
The detail is fixed, the detail value is shared with the voxel slider as well.";
topology.dynamic.quality = "Prefer...";
topology.dynamic.quality.help = "If you choose Quality, the 2 main differences are:
- refinement is applied before the sculpting operator, you will get less interpolating artefact when painting or sculpting very small details
- refinement is not applied incrementally, if you sculpt very small details or do quick strokes, the topology will always be correctly refined

For better performance, and if you plan on using this option, you might consider enabling the \"partial drawing\" option in the Settings panel.";
topology.dynamic.quality.speed = "Speed";
topology.dynamic.quality.quality = "Quality";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Use pressure on radius";
topology.dynamic.usePressure.help = "Use this option if you want the pen pressure impact on tool radius to impact the level of detail.";
// decimate
topology.decimate.title = "Decimation";
topology.decimate.title.help = "Reduce the number of polygons by trying to keep as many details as possible.

This feature can be useful if you want to export for 3d printing.
However you should probably not use it if you want to continue sculpting on it, as it can produce uneven triangles.

Note that the masked area won't be decimated.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Decimate";
topology.decimateTargetFaces = "Target triangles";
topology.decimatePaintWeight = "Preserve painting";
topology.decimatePaintWeight.help = "Higher value will try to preserve painting.

Set this value to 0 if you don't care about the painting.";
topology.decimateUniform = "Uniform faces";
topology.decimateUniform.help = "Higher value will output triangles with similar size.";
// topology.decimatePreserveBorders "Preserve borders"
// topology.decimatePreserveBorders.help "Do not decimate the border of the mesh.

// Unwrapping means compute UV (texture coordinates), it allows the object to receive on texture (wrap the texturing on the object)
topology.uv.title = "UV Auto-Unwrap";
topology.uvAtlas = "Unwrap Atlas";
topology.uvAtlas.warning = "Can be very slow, target <100k vertices!";
topology.uvBFF = "Unwrap Bff";
topology.uvBFF.warning = "Can have overlaps if mesh has handles!";
topology.uvBFFCones = "Cone count";
topology.uvBFFCones.help = "Higher value will reduce distortion for complex objects.

Higher value will means longer compute time.";
topology.uvDelete = "Delete UVs";

// Transfer the vertex painting in the texture
topology.bake = "Bake Vertex painting";
topology.bake.help = "Transfer the vertex painting to a texture.

Vertex color are resetted in the process.";
topology.bakeResolution = "Resolution";

// privacy policy
privacyPolicy.title = "Privacy Policy";
privacyPolicy.reject = "Reject";
privacyPolicy = "Hexanomad does not collect any data from Nomad Sculpt.";

// version trial
version.buyWeb = "Web version is only a demo";
version.buyFull = "Upgrade to full version";
version.restorePurchase = "Restore purchase";

version.trialHistory = "Trial version: 4 undo/redo possible";
version.trialLayer = "Trial version: 1 layer per mesh";
version.trialOneProject = "Trial version: 1 active project only";
version.trialNoImport = "Trial version: No import";
version.trialNoExport = "Trial version: No export";

version.fullFeatures = "- One time purchase
- Unlimited undo/redo
- Unlimited layers
- Save & Load
- Export & import";
