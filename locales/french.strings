// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "Confirmer ?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Oui";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "OK";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Annuler";

// common
position.top = "Haut";
position.right = "Droite";
position.left = "Gauche";
position.bottom = "Bas";
position.center = "Centré";
direction.up = "Haut";
direction.right = "Droite";
direction.left = "Gauche";
direction.down = "Bas";

// Name of an item (object, tool, etc)
item.name = "Nom";
// Add a new item (object, tool, etc)
item.new = "Nouveau";
// Rename an item (object, tool, etc)
item.rename = "Renommer";
// Add a new item (object, tool, project, etc)
item.add = "Ajouter";
// Save an item (object, tool, etc)
item.save = "Enregistrer";
item.save.confirm = "Confirmer l'enregistrement ?";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Dernier enregistrement";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "Charger le dernier enregistrement ?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Réinitialiser";
item.reset.confirm = "Confirmer la réinitialisation ?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "Instancier";
// Uninstance the object, make the object real
item.uninstance = "Désinstancier";
// Clone an item (object, tool, etc)
item.clone = "Cloner";
// Delete an item (object, tool, etc)
item.delete = "Supprimer";
item.delete.confirm = "Confirmer la suppression ?";
item.delete.confirm.yes = "Oui, supprimer";
// When we delete the item but the image is used somewhere
item.delete.imageUsed = "Image utilisée par les outils suivants :";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "En nœud";
// Item visibility (object, layer, etc)
item.visible = "Visible";
// Show an item (object, layer, etc)
item.show = "Afficher";
// Hide an item (object, layer, etc)
item.hide = "Masquer";
// Select an item (object, layer, etc)
item.select = "Sélectionner";
// Unselect an item (object, layer, etc)
item.unselect = "Désélectionner";
// Merge an item with another one below (layer)
item.mergeDown = "Fusionner avec le calque inférieur";
// The order of an item in a list
item.order = "Ordre";
// Focus on previous item
item.previous = "Précédent";
// Focus on next item
item.next = "Suivant";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "Verrouiller";
// No item selected
item.none = "Aucun";

// Search something (text entry to filter item)
search = "Rechercher";

// Three-state toggle button (Auto, Off, On)
toggle.on = "Activé";
// Three-state toggle button (Auto, Off, On)
toggle.off = "Désactivé";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "Auto";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Miniatures manquantes, retraitement des fichiers… ($0/$1)

$2";
loading.reprocess.cancel = "";

// Color of an object
material.color = "Couleur";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "Rugosité";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "Brillance";
// Whether the material is a metal or not
material.metalness = "Métallité";
// How much light a surface will reflect
material.specular = "Spéculaire";
// Light that the surface can emit (glow)
material.emissive = "Émissif";
// Normal map (synonym: detail, bump)
material.normal = "Normal";
// Ambient Occlusion (AO)
material.occlusion = "Occlusion";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "Textures";
// Textures/Image
material.texture = "";
// A warning indicating that the mesh has no UVs
material.warningNoUVs = "";
// Texture filtering https://en.wikipedia.org/wiki/Texture_filtering
material.texture.filter = "";
// Nearest Filtering (closest sample)
material.texture.nearest = "";
// Bilinear Filter
material.texture.linear = "";
// Mipmap filtering
material.texture.mipmap = "";

// Minify
about.minify = "Réduire l'interface";
about.minify.help = "Vous pouvez également toucher votre écran avec quatre doigts, si votre appareil gère cette fonctionnalité.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Plateau tournant";
// Rotation center of the turntable
about.turntable.pivot = "";
// Keep current pivot
about.turntable.pivot.keep = "";
// Turntable pivot will be at the center of the scene
about.turntable.pivot.scene = "Scène";
// Make the entire scene turn around (speed of the animation)
about.turntable.speed = "Vitesse du plateau tournant";
// Stuffs that I used to make the app
about.credits = "Crédits";
// Link to open source projects that I used for the app
about.credits.openSource = "Open Source";
// Only translate the &
about.credits.arts = "MatCaps et HDRI";
// Change languages of the app
about.languages = "Langues";
about.languages.help = "Fichiers de traduction disponibles sur $0";
// Link to the App Website
about.website = "Site Web";
// Link to the App Forum
about.forum = "Forum";
// Link to the App Manual
about.manual = "Manuel";
// Link to the App Email
about.mail = "Assistance";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";

// The user canceled an operation that was running
alert.aborted = "";
// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "L'objet n'a pas de trou !";
// No operation occured because the mesh is already manifold
alert.manifold.already = "";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "L'objet actuel est invisible !";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Rien à découper.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Abandonner la découpe : l'objet est entièrement découpé.";
// In order to extract something, the mesh needs to have painted mask
alert.mask.noExtract = "Rien à extraire !";
// In order to split something, the mesh needs to have painted mask
alert.mask.noSplit = "Rien à scinder !";
// List of disabled features when View Mode is selected
alert.view.disabled = "Fonctions désactivées en mode Consultation :";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Widgets de primitive";
// The object needs to have two parts disconnected
alert.separate.fail = "Séparation impossible : l'objet n'a qu'une seule pièce !";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "Remaillage terminé !";
alert.voxelRemesh.empty = "Abandonner le remaillage : le maillage résultant n'a pas de face.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "Entrée non valide !";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "L'objet sera dupliqué";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "L'objet sera instancié";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Modifiez le mode de pivot.";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "Modifiez le mode d'objet.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Topologie dynamique active";
// See Glossary (DynTopo)
alert.dynamic.disable = "Désactiver la topologie dynamique";
alert.colorPicker = "Faites glisser votre doigt sur l'objet pour sélectionner une couleur.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Appuyez une fois pour quitter le mode Transformation.";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "";
// Show the painted mask on the mesh
alert.mask.show = "Afficher le masque";
// Hide the painted mask on the mesh
alert.mask.hide = "Masquer le masque";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Verrouiller la sélection";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Déverrouiller la sélection";
// Hide the objects that are not selected
alert.selection.isolate = "Isoler la sélection";
// Show the objects that are hidden
alert.selection.showAll = "Tout afficher";
// Project quick saving
alert.quickSave = "Enregistrement…";
// Painting on the object was hidden but the user did paint the object
alert.forceShowPainting.fill = "Option Afficher la peinture activée, la fonction [Tout peindre] a été utilisée.";
// Painting on the object was hidden but the user started to paint on the object
alert.forceShowPainting.tool = "Option Afficher la peinture activée, l'objet a été peint.";
// See Glossary (Multiresolution)
alert.multiresLost = "La multirésolution sera perdue !";
// The user is starting an operation that can lead to a crash
alert.range.warning = "Le niveau de détail est élevé et peut nécessiter beaucoup de mémoire !";
// Autosave popup
alert.autoSave.auto = "Enregistrement automatique dans… $0 s";
// The selected object doesn't have any layers
alert.needLayer = "L'outil actuel nécessite un calque actif.";
// The user decides to hide the painting on the objects
alert.paintingHidden = "Peinture masquée : affichez-la à nouveau dans le panneau Réglages.";
// The selected object doesn't have any layers
alert.noPartialWireframe = "La fonction Dessin partiel est désactivée lorsque le filaire est affiché.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Envisagez d'utiliser une caméra orthographique si vous voulez éviter la distorsion du tronc de perspective lors de l'utilisation d'une projection vers l'écran.";
// Trial version has a limited number of undo
alert.state.trial = "Version d'essai : résiliation annulée";

background = "Arrière-plan";
// A flat color will be displayed in the background of the scene
background.color = "Couleur";
// The environment (HDRI) will be displayed in the background
background.environment = "Environnement";
background.blur = "Flou";
background.exposure = "Exposition";

// Image that the artist uses as a reference
background.imageEnable = "Image de référence";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Incrustation";
// Opposite of transparency (Alpha)
background.imageAlpha = "Opacité";
background.imageReset = "Réinitialiser les réglages";
background.imageTransform = "Transformation";
// X screen coordinate of the image reference
background.imageX = "Position X";
// Y screen coordinate of the image reference
background.imageY = "Position Y";
// Rotation of the reference image
background.imageRotation = "Rotation";
// Scale of the reference image
background.imageScale = "Mise à l'échelle";

// Camera (point of view in 3d)
camera = "Caméra";
// Copy the views
camera.updateView = "Mettre à jour le point de vue ?";
// Add a new camera
camera.addView = "Ajouter une vue";
// Focus on the camera
camera.focus = "Mise au point";
// Add on the camera camera
camera.focusOn = "Mise au point sur $0";
// Camera projection, Orthographic or Perspective
camera.projection = "Projection";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Orthographique";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Perspective";
// camera Vertical Field of View
camera.fov = "Champ de vision vertical";
// Camera Field of View hint
camera.focal = "Focale de $0 mm (capteur 35 mm)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Rotation";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "Plateau tournant";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Trackball";
camera.rotation.trackball.help = "Le trackball offre plus de liberté, car vous pouvez également faire pivoter la caméra avec deux doigts.";
// Camera interaction mode, 1st person view
camera.firstPerson = "Première personne";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Vitesse";
// Camera rotation sensitivity
camera.speed.rotation = "Rotation";
// Camera translation sensitivity
camera.speed.panning = "Translation";
// Camera zooming sensitivity
camera.speed.zooming = "Zoom";
// Reset camera position
camera.resetView = "Réinitialiser la vue";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Vue alignée";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "Caméra est alignée (orthographique)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "Alignment orthographique";
camera.snapOrthographic.help = "Cette option fonctionne également lorsque le cube d'alignment est utilisé.";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Pivot";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Double appui sur l'objet";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Double appui sur l'arrière-plan";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "Basculer";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "Sélection";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "Scène";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "Mettre à jour lors du double appui";
camera.doubleTapPivot.help = "Mettre à jour le pivot de rotation lors du double appui sur la surface de l'objet.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "Pivot aérien";
camera.airPivot.help = "Autoriser la création d'un pivot même en cas de zoom en dehors de la surface de l'objet.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "Au début du mouvement de caméra";
camera.autoPivot.help = "Mettre à jour le pivot lorsque vous commencez à interagir avec la caméra.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Mise au point";
camera.doubleTapFocus.help = "Lors d'un double appui sur l'objet, la caméra effectuera un panoramique pour se centrer sur le point choisi.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "Sélection multiple";
// There is 0 nodes/items selected
context.noSelection = "Aucune sélection";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "Préréglage";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "Spline";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "";

// Set the desired FPS (frame per second, refresh rate)
debug.targetFPS = "";
debug.targetFPS.help = "";

// Debug option, the newly created primitives will contains texture coordinates (UVs)
debug.uvPrimitive = "Conserver les UV de la primitive";
debug.uvPrimitive.warning = "Désactivez cette option si vous n'avez pas besoin des UV (mémoire supplémentaire).";
debug.uvPrimitive.help = "Pour l'instant, seuls les types Boîte et Sphère sont acceptés.

D'autres types seront gérés plus tard.";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "Normaliser les UV";
debug.uvNormalize.help = "Nomad normalisera les UV à l'intérieur du recouvrement [0-1].";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "Ajouter des UV BFF";
debug.uvBFF.help = "Ajoutez une autre méthode de dépliage (Boundary First Flattening).

Notez que BFF produira des chevauchements si la topologie de votre maillage n'est ni un disque ni une sphère.";
// Debug option, display an window with some debugging logs
debug.logs = "Logs";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Champ de hauteur";
// Debug options, graphical stuffs
debug.graphics = "Graphismes";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Générer des miniatures de boutique en ligne";

// Empty list: there is no projects
file.project.empty = "Vous n'avez pas encore enregistré de projet !";
// The current opened project has some unsaved changes
file.project.unsaved = "Modifications non enregistrées !";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "Toute modification non enregistrée sera perdue !";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Aperçu du dernier enregistrement manuel";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "Version d'essai : vous ne pourrez pas rouvrir le projet actuel !";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "Version d'essai : vous pouvez uniquement rouvrir votre projet actuel !";

file.project = "Projet";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Enregistrer";
// E.g: Save "my_project"?
file.project.save.confirm = "Enregistrer $0 ?";
// Save to another project (either new one or overriding existing one)
file.project.saveAs = "Enregistrer sous";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "Remplacer $0 ?";
// Open a project
file.project.open = "Ouvrir";
// E.g: Open "my_project"?
file.project.open.confirm = "Ouvrir $0 ?";
// Load another project and add/append all its data to the current scene
file.project.add = "Ajouter à la scène";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "Ajouter $0 à la scène ?";
// Reset the scene and create a new project
file.project.new = "Nouveau";
file.project.new.confirm = "Créer une scène ?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "Supprimer $0 ?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "Supprimer $0 ?

Il s'agit du projet actif en cours !";

// Auto save section
file.project.autoSave = "Sauvegarde automatique";
file.project.autoSave.confirm = "Désactiver la sauvegarde automatique ?";
file.project.autoSave.help = "Sauvegarde votre projet dans un fichier séparé à intervalles réguliers.
Emplacement du fichier de sauvegarde automatique :

$0";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "Délai d'affichage de la fenêtre contextuelle";
// In minutes
file.project.autoSave.minutes = "Fenêtre contextuelle du minuteur";
// Delete the current autoSave data
file.project.autoSave.delete = "Supprimer l'enregistrement automatique";

// color space (linear or srgb), do not translate linear/srgb if there is a doubt
file.colorSpace = ""
file.colorSpace.help = "";
file.colorSpace.linear = "";
file.colorSpace.srgb = "";

// Configure imports option
file.importSettings = "Options d'importation";

// Load interface preference settings when opening a scene file
file.import.guiSettings = "Conserver les réglages de l'interface graphique";
file.import.guiSettings.help = "Lors de l'ouverture ou de l'importation d'un fichier de projet, tous les réglages d'interface graphique intégrés au projet seront chargés.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.import.objSplitByGroup = "Scinder l'OBJ en groupes";
file.import.objSplitByGroup.help = "Lorsque cette option est activée, Nomad scinde les groupes OBJ en objets indépendants.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.import.mergeLayers = "Fusionner les calques";
// Ignore the textures present in the file to load
file.import.skipTextures = "Ignorer les textures";
// Do not fiddle with the object topology when loading the file
file.import.keepTopology = "Conserver la topologie";
file.import.keepTopology.help = "Utilisez cette option si vous ne voulez pas que Nomad modifie la topologie du maillage importé.

Elle désactive la réorganisation des sommets/faces, la suppression des doublons de sommets/faces et la suppression des sommets inutilisés.";


// Import file section
file.import.title = "Importer";
file.import.title.help = "Formats compatibles :
- Wavefront (.obj)
- glTF 2.0 (.glb .gltf)
- STL (.stl)";
// The user imports a scene file that will replace the current scene
file.import.open = "Ouvrir";
file.import.open.confirm = "Importer un nouveau fichier ?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Ajouter à la scène";
file.import.add.confirm = "Importer un nouveau fichier ?";

// Export scene file
file.export.title = "Exporter";

// Export the current selected objects instead of the entire scene
file.onlySelection = "Inclure uniquement les objets sélectionnés";
file.onlySelection.help = "Inclure uniquement la sélection plutôt que la scène entière.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Reconstruire le quadrilatère";
file.convertToQuad.help = "Reconstruisez les quadrilatères à partir de triangles en associant des triangles (s'ils sont adjacents dans les fichiers).";

// Whether we include the textures in the exported file
file.export.texture = "Textures";
// Baking means transfering/converting
file.export.texture.help = "Cette option ne convertit pas les couleurs des sommets dans les textures.";
// Whether we include normals vector in the exported file
file.export.normal = "Normales";
file.export.normal.help = "Cochez cette option si vous souhaitez ouvrir le fichier dans d'autres logiciels.

Nomad ignore toujours les normales, car il les recalcule.";

file.export.nomad = "";
file.export.nomad.help = "";

file.export.gltf = "Exporter en glTF 2.0";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Calques";
file.export.gltf.layer.help = "Exportez les calques sous forme de morphes. Cette fonctionnalité est officiellement gérée par le format glTF et devrait donc fonctionner aussi avec d'autres logiciels.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Peinture (calque)";
file.export.gltf.layerPaint.help = "Exportez la peinture du calque. Elle est généralement ignorée par les autres logiciels.";
// Whether we include the vertex color in the exported file
file.export.gltf.color0 = "Couleurs des sommets";
file.export.gltf.color0.help = "Exportez les couleurs des sommets. Cette fonctionnalité est officiellement gérée par le format glTF et devrait donc fonctionner aussi avec d'autres logiciels.";
// Whether we include the vertex roughness and vertex metalness in the exported file
file.export.gltf.color1 = "Peinture PBR";
file.export.gltf.color1.help = "Exportez la rugosité, la métallité et la peinture du masque. Ces informations seront ignorées par les autres logiciels.";

file.export.obj = "Exporter en OBJ";
file.export.obj.warning = "Les calques et la peinture supplémentaire (rugosité, métallité et masque) seront perdus.";
// Whether we include the vertex color in the exported file
file.export.obj.colorAppend = "Couleurs des sommets";
file.export.obj.colorAppend.help = "Permet d'ajouter les informations de couleur après les sommets.

Certains logiciels 3D pourront lire ces informations, mais pas tous.";

file.export.stl = "Exporter en STL";
file.export.stl.warning = "Les calques et la peinture supplémentaire (rugosité, métallité et masque) seront perdus.";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Couleurs des sommets";
file.export.stl.color.help = "Certains logiciels 3D pourront lire ces informations, mais pas tous.";
file.export.stl.ascii = "Par défaut, le format est binaire.

Vous pouvez opter pour une exportation au format texte (ASCII), mais le fichier sera plus volumineux.";

// Advanced settings
settings.advanced = "Avancé";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "Ces options ne sont pas enregistrées dans les réglages.";
settings.reset.title = "Réglages";
settings.reset.title.help = "Cette commande réinitialise les réglages des préférences de l'application.

Certaines ressources sont enregistrées séparément et ne seront PAS réinitialisées, dont : 
- Projets
- Liaisons clés
- Préréglages des outils
- Environnements HDR
- MatCaps
- Alphas
- Textures (pinceau)
- Images de référence

Notez que tous les réglages liés au projet resteront inchangés : éclairage, post-traitement, vues de caméra, etc.";

// Reset preference settings button
settings.reset = "Rétablir les valeurs par défaut";
settings.reset.confirm = "Réinitialiser les réglages des préférences ?";

// Render a screenshot of the scene
file.render = "Générer le rendu";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Afficher l'interface";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Rapport de rendu";
file.render.renderRatio.help = "Avec la valeur 1,0, Nomad générera le rendu à la même résolution que la taille d'image requise ci-dessous.

Utilisez cette option si vous ne pouvez pas effectuer le rendu à certaines résolutions (plantage pour cause de manque de mémoire).";
// Desired size of the exported screenshot
file.render.size = "Taille finale";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Personnalisée";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "écran";
// width of exported screenshot
file.render.width = "Largeur";
// height of exported screenshot
file.render.height = "Hauteur";
// export screenshot of the scene
file.render.export = "Exporter en PNG";
file.render.warn = "La résolution d'exportation est élevée ($0x$1) !

Pensez à enregistrer votre projet, au cas où votre appareil se trouverait à court de VRAM et planterait.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Arrière-plan transparent";
file.render.transparent.help = "Cette option peut être utile si vous voulez insérer le maillage dans un logiciel de création 2D.

La transparence partielle de l'objet n'est pas prise en charge pour le moment.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Utiliser les réglages généraux";
pressure.useGlobal.help = "Par défaut, les outils partagent les mêmes réglages de pression.

Décochez cette option si vous souhaitez définir des réglages de pression spécifiques pour cet outil.";

// Pencil pressure
pressure.title = "Pression";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "Cet outil ne tient pas compte de la pression du stylet.";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "Le type de trait Capturer ignore les réglages de pression.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Rayon";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Intensité";
// Average pencil pressure event to get smoother result
pressure.average = "";
pressure.average.help = "";

// Customize whether finger and/or stylus can move the Camera
gesture.cameraInteraction = "Caméra :";
// Customize whether finger and/or stylus can sculpt on object
gesture.sculptInteraction = "Sculpter :";
// Both the finger and the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.fingerAndStylus = "Doigt et stylet";
// Only the finger can perform a certain action (move camera, sculpt, etc)
gesture.interaction.finger = "Doigt";
// Only the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.stylus = "Stylet";
// Disable the action
gesture.interaction.none = "Aucun";
// Allow the action for any inputs
gesture.interaction.any = "Tout";

// long press to pick the color/material under the cursor
gesture.materialPicking = "Sélection de matériau";
gesture.materialPicking.help = "Pour déclencher le sélecteur de couleur/matériau, appuyez de façon prolongée sur la zone de travail.

Le sélecteur ne s'affiche que si la peinture est activée pour le pinceau actuel.";

// Three fingers on screen
gesture.three.title = "Trois doigts";
// Drag 3 fingers horizontally on the canvas to rotate the environment, lights and MatCap
gesture.fingerLighting = "Faire pivoter l'éclairage (3 doigts)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerLighting.help = "Faites glisser 3 doigts horizontalement sur la zone de travail pour faire pivoter l'environnement, les lumières et le MatCap.";
// Drag 3 fingers vertically to edit the tool radius
gesture.fingerRadius = "Modifier le rayon de l'outil (3 doigts)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerRadius.help = "Faites glisser 3 doigts verticalement sur la zone de travail pour modifier le rayon de l'outil.";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.fingerSmooth = "Lissage systématique avec le doigt";
gesture.fingerSmooth.help = "";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Autoriser les informations de pression non reconnues";
gesture.unknownPressure.help = "Cochez cette option si la pression ne fonctionne pas avec votre stylet ou si la pression du doigt doit être prise en compte.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Bouton Stylet";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Double appui avec le stylet";
gesture.pencilAction.ios.help = "Actif uniquement pour l'Apple Pencil 2e génération.";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "Aucun";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Ajouter/Soustraire";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "Raccourcis rapides";
gesture.mask.oneTap.help = "Autorisez l'accès au raccourci Masque par appui simple sur l'écran, sans qu'il soit nécessaire d'appuyer de façon prolongée sur le raccourci du bouton Masque.

Vous pourrez effectuer les gestes suivants :
- Appuyez sur l'arrière-plan pour inverser le masque.
- Appuyez sur une zone masquée pour flouter le masque.
- Appuyez sur une zone non masquée pour accentuer le masque.";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress = "Appui long (Masque ↔ MasqueSél)";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.longPress.help = "Quand l'outil Masque ou l'outil MasqueSél est actif, appuyez de façon prolongée avec le doigt pour alterner entre ces outils.

Si vous appuyez de façon prolongée sans déplacer votre doigt, le nouvel outil sera utilisé comme raccourci de masque par défaut.";
// Shortcut customization, choose the action that the shortcut will performan (select tool, etc)
gesture.shortcut = "Raccourci";

// Shortcuts to undo/redo
gesture.history = "Raccourcis de l'historique";
gesture.history.help = "- Annuler : appuyez avec deux doigts
- Rétablir : appuyez avec trois doigts
- Annuler/Rétablir : appuyez de façon prolongée avec deux/trois doigts";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Ignorer la paume";
gesture.palmRejection.confirm = "Pensez à désactiver cette option si vous rencontrez des difficultés pour interagir avec la zone de travail !";
gesture.palmRejection.help = "Permet de rejeter la saisie si la taille de la zone de contact est supérieure à cette valeur.

Cette option peut ne pas fonctionner avec tous les périphériques.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Seuil de taille max.";

// History, list of undo/redo
history = "Historique";
// First "undo" state
history.root = "Base";
history.undoConfirm = "Confirmez-vous l'annulation de toutes ces opérations ?";
history.undoWarning = "Si vous effectuez une autre modification, vous risquez de perdre beaucoup de modifications.";
// Settings concerning the history stack of undo/redo
history.stack = "Pile";
// Actions to include in the undo/redo stack
history.include = "Inclure les actions";
// include lighting editing in the undo/redo
history.includeLights = "Lumières";
history.includeLights.help = "Si cette option est désactivée, le déplacement des lumières avec l'outil Gizmo sera quand même pris en compte, car cette opération peut avoir une incidence sur d'autres objets dans la hiérarchie de la scène.";
// include postProcess editing in the undo/redo
history.includePostProcess = "Post-traitement";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCaps et HDRI";
// Can limit the stack of undo/redo size
history.limitSize = "Limite de l'historique (Mo)";
history.limitSize.help = "Taille maximale de l'historique (en Mo).

L'historique sera mis à jour à l'enregistrement de l'opération suivante.";
// Limit the number of undo in the history stack
history.limitStack = "Limite de la pile";
history.limitStack.help = "Nombre maximal d'opérations que l'application peut conserver.

L'historique sera mis à jour à l'enregistrement de la prochaine opération.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Nombre maximal d'opérations annulables";
history.rangeProtect.help = "Si vous remontez loin dans l'historique, une boîte de dialogue de confirmation s'affichera avant d'annuler de nombreuses opérations.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Restaurer la caméra";
history.restoreCamera.help = "Activez cette option pour restaurer l'angle de vue enregistré de la caméra quand vous annulez/rétablissez une action.";
// Undo
history.undo = "Annuler";
// Redo
history.redo = "Rétablir";
// Shown during undo
history.state.undo = "Annuler : $0";
// Shown during redo
history.state.redo = "Rétablir : $0";
// Shown during undo/redo
history.state.symmetrySplit = "Scission par symétrie";
// Shown during undo/redo
history.state.voxelRemesh = "Remaillage des voxels";
// Shown during undo/redo
history.state.surfaceRemesh = "Remaillage de surface";
// Shown during undo/redo
history.state.multiresLevel = "Changement de résolution";
// Shown during undo/redo
history.state.multiresToDynamic = "Multirésolution vers topologie dynamique";
// Shown during undo/redo (mesh type conversion)
history.state.meshDynamicToStatic = "TopoDyn vers Statique";
// Shown during undo/redo (mesh type conversion)
history.state.meshStaticToDynamic = "Statique vers TopoDyn";

// Debugging/Inspect object material (view channel separately color, roughness, normal, uv, etc)
inspector = "";
// Inspector but SHORT
inspector.short = "";
// Display the material channel on the background
inspector.onBackground = "";
// Display the material channel on the mesh
inspector.onMesh = "";

// Interface customization
interface = "Interface";

// UI customization: one item row will stands on one line (synonym: Inlined)
interface.compact = "";

// UI customization: each row of the list will be bigger
interface.expandList = "Interface : développer la liste";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Option d'interface facilitant la gestion des listes.";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "Ajouter des raccourcis (en bas)…";

// Interface option (main base color)
interface.colorBase = "Base de couleur";
// Interface option (accent widget color)
interface.colorSelect = "Widget de couleur";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Panneau transparent";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Intensité du flou";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Panneau de couleur";

// Interface color style
interface.preset.title = "Préréglages de couleur";
// Interface color style (original color of Nomad Sculpt)
interface.preset.classic = "Classique";
// Interface color style
interface.preset.orange = "Orange";
// Interface color style (~red)
interface.preset.cardinal = "Écarlate";
// Interface Color style (~pink)
interface.preset.mulberry = "Mûre";
// Interface color style
interface.preset.brown = "Marron";
// Interface color style (~green)
interface.preset.emerald = "Émeraude";
// Interface color style (~blue)
interface.preset.neon = "Néon";
// Interface color style
interface.preset.violet = "Violet";
// Interface color style
interface.preset.gray = "Gris";
// Interface color style
interface.preset.black = "Noir";
// Interface color style
interface.preset.white = "Blanc";

// Reset interface settings
interface.resetAll = "Réinitialiser le style";
interface.resetAll.confirm = "Réinitialiser les réglages de l'interface ?";
// Interface option (main base color)
interface.iconSupport = "";
interface.iconSupport.help = "";
// Interface customization
interface.flipTop = "Inverser la barre supérieure";
// Interface customization
interface.flipBottom = "Inverser la barre inférieure";
// Interface customization
interface.flipMiddle = "Inverser les barres latérales";
// Interface customization (preview material in the viewport when editing material color)
interface.materialPreview = "Aperçu de la couleur du matériau";
// Interface customization
interface.materialPreview.help = "Quand vous sélectionnez une couleur pour un matériau, un aperçu de ce matériau s'affiche sur l'objet actuellement sélectionné.";
interface.toolbox.hide = "Masquer la boîte à outils";
interface.toolboxHide.help = "Activez cette option pour masquer la boîte à outils.";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.maxColumn = "Nombre max. de colonnes dans la boîte à outils";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Réinitialiser l'agencement de la boîte à outils";
// Scale the interface
interface.scale = "Redimensionner l'interface";
// Spacing between widgets
interface.cursorStep = "Espacement vertical";
// Width of the interface panels
interface.panelWidth = "Largeur des menus";
// Size of fonts
interface.fontScale = "Taille de la police";
// Inset
interface.inset.title = "Décalages des bords";
interface.inset.title.help = "Ne modifiez ces valeurs que si vous rencontrez des difficultés pour interagir avec les boutons situés sur les bords de l'écran.

Si le curseur est désactivé, Nomad utilisera les valeurs de zone de sécurité renvoyées par le périphérique lui-même.";

// (see Glossary for Layer)
layer = "Calque";
// (see Glossary for Layer)
layers.lock = "Conserver les détails des calques supérieurs";
// (see Glossary for Layer)
layers.lock.yes = "Verrouiller les calques supérieurs ?";
// (see Glossary for Layer)
layers.lock.warning = "Pendant la sculpture, la déformation provenant des calques supérieurs sera ignorée.

Les détails de ces calques resteront cependant visibles. 

Cette option ne fonctionne que si les détails des calques supérieurs sont relativement petits en taille.";
// (see Glossary for Layer)
layers.addLayer = "Ajouter un calque";
// (see Glossary for Layer)
layer.factors = "Facteurs de canal";
// (see Glossary for Layer)
layer.factor = "Facteur";
// (see Glossary for Layer)
layer.offset = "Décalage";
// (see Glossary for Layer)
layers.title = "Calques";
// (see Glossary for Layer)
layers.title.help = "Les calques peuvent enregistrer les décalages de position et la peinture, ce qui peut s'avérer utile en cas de workflow non linéaire.
Vous pouvez par exemple tester différentes expressions de visage sans vous appuyer sur la pile d'historique pour annuler les modifications.

Pour les données de peinture, les calques sont triés de haut en bas, de sorte que les calques du haut masquent les calques inférieurs.

Vous pouvez effacer une partie du calque (et donc l'influence du calque) à l'aide de l'outil « SupprCalque ».";
layers.primitive = "Les calques ne sont pas disponibles pour les primitives.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "Aucun";

light = "Lumière";
// Intensity of light
light.intensity = "Intensité";
// Kelvin (the temperature unit)
light.kelvin = "";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "Température";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Fixation";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Fixe";
// The light will move along the camera
light.attachment.camera = "Caméra";
light.attachment.help = "-- Fixe
L'orientation de la lumière ne change pas.

-- Caméra
L'orientation de la lumière dépend de l'angle de la caméra.";
// Light type (directional, spot, point)
light.type = "Type";
// Directional light (synonym: sun light)
light.type.directional = "Directionnel";
light.type.directional.short = "";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Projecteur";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Point";
// Cone angle for spot angles
light.spot.angle = "Angle du cône";
// Softness of the spot light
light.spot.softness = "Douceur";
// Position of the light
light.position = "Position";
// Enable or disable shadows for a light
light.shadow.cast = "Ombre";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "La lumière de point ne gère que les ombres de l'espace écran.";
light.shadow.type = "Type d'ombre";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "Texture d'ombre";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "Espace écran";
light.shadow.type.screenspace.help = "Cette fonction est expérimentale et peut être supprimée dans une prochaine version.

Elle est destinée à être utilisée avec la fonction Douceur des ombres.";
// Adjustment to fix artefacts
light.shadow.bias = "Biais";
// How blurry the shadow is
light.shadow.softness = "Douceur";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "Contact";
light.contact.help = "Si l'option Auto est sélectionnée, seule la lumière la plus dominante aura une ombre de contact.";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "Tolérance";
// Activated the light
light.visible = "Afficher";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Recentrer";

// Object's material
material = "Matériau";
// See glossary
material.pbrRoughnessMetalness.warning = "Les fonctions Rugosité et Métallité nécessitent le mode d'ombrage PBR.";
// See glossary
material.pbrReflectance.warning = "La fonction Réflectance nécessite le mode d'ombrage PBR.";
// See glossary
material.pbrRefraction.warning = "La fonction Réfraction nécessite le mode d'ombrage PBR.";
// See glossary
material.pbrSubsurface.warning = "La fonction Transluminescence nécessite le mode d'ombrage PBR.";
// Value that says how much light will change direction when hitting the surface
material.ior = "Indice de réfraction";
// an object-level value that overrides the painting of the mesh
material.paintingOverride = "Remplacer la peinture";
// The roughness in the inside is turbidity
material.paintingOverride.help = "Deux rugosités sont définies : celle qui génère la surface et celle qui se trouve à l'intérieur.

Comme une seule d'entre elles peut être peinte, les deux duretés ont les mêmes valeurs.

Vous pouvez utiliser ce curseur pour remplacer la rugosité de la surface afin de la rendre plus brillante.";
// Glossiness is simply the opposite of roughness
material.refractionSurfaceGlossiness = "Brillance de surface";
material.refractionSurfaceGlossiness.help = "- À 0, la surface utilise la rugosité peinte
- À 1, la surface est complètement lisse";
// Synonym: turbidity
material.refractionInteriorRoughness = "Rugosité intérieure";
material.refractionInteriorRoughness.help = "- À 0, l'intérieur utilise la rugosité peinte
- À 1, l'intérieur est complètement rugueux";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Peinture brillante";
material.paintGlossy.help = "L'objet sera peint avec une rugosité et une métallité nulles, permettant ainsi une réfraction nette.

Cela revient à utiliser la commande « Tout peindre » du menu Peinture, avec les options Couleur et Métallité désactivées.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Absorption";
material.absorptionEnable.help = "Simulez la lumière absorbée lorsqu'elle traverse le volume.

Les pièces fines s'illumineront, car elles laisseront passer plus de lumière, tandis que les zones épaisses seront plus sombres.

L'effet dépend fortement de la forme de l'objet. Seule une approximation de l'épaisseur de l'objet est utilisée.";
material.absorptionFactor = "Facteur";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "Profondeur";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "Translucidité";
material.translucency.help = "Pour voir la translucidité, la lumière doit projeter des ombres.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Opacité";
// Fully opaque material
material.type.opaque = "Opaque";
// See glossary
material.type.subsurface = "Transluminescence";
material.type.subsurface.help = "Pour obtenir de bons résultats, vous pouvez passer en mode d'ombrage PBR et utiliser au moins une lumière directionnelle, idéalement dans un environnement peu éclairé.";
// Transparency mode, alpha blending
material.type.blending = "Fusion";
material.type.blending.help = "Rendez l'objet translucide en ajustant la valeur d'opacité.

Notez qu'en raison de contraintes de calcul en temps réel, des artefacts visuels peuvent être perceptibles si l'objet a une forme complexe.";
// Transparency mode
material.type.additive = "Additif";
material.type.additive.help = "Rendez l'objet translucide en ajustant la valeur d'opacité.

Cette méthode a tendance à générer moins d'artefacts que la méthode Fusion, mais l'objet sera plus lumineux.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Tramage";
material.type.dithering.help = "Rendez l'objet translucide en écartant certains pixels de manière aléatoire.";
// Simulate glass-like material
material.type.refraction = "Réfraction";
material.type.refraction.help = "Ce mode permet de simuler un matériau en verre.

En raison de contraintes de calcul en temps réel, l'auto-réfraction et la réfraction multicouches sont limitées.";
material.castShadows = "Projeter des ombres";
material.receiveShadows = "Recevoir des ombres";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Toujours éteint";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Inverser l'élimination";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Réflectance";
material.reflectance.help = "Contrôlez la quantité de reflets que le matériau recevra pour les matériaux non métalliques.

La plupart du temps, la valeur par défaut doit être utilisée (qui correspond à un reflet lumineux standard de 4 % à angle normal).";

// Menu name
menu.files = "Fichiers";
// Menu name
menu.scene = "Scène";
// Menu name
menu.multires = "Multirésolution";
// Menu name
menu.voxel = "Voxel";
// Menu name
menu.dynTopo = "TopoDyn";
// Menu name
menu.topology = "Déci/UV...";
// Menu name
menu.primitive = "Primitive";
// Menu name
menu.render = "Générer le rendu";
// Menu name
menu.material = "Matériau";
// Menu name
menu.postProcess = "Post-traitement";
// Menu name
menu.camera = "Caméra";
// Menu name
menu.background = "Arrière-plan";
// Menu name
menu.tool = "Outil";
// Menu name
menu.stroke = "Trait";
// Menu name
menu.alpha = "Alpha";
// Menu name
menu.filter = "";
// Menu name
menu.falloff = "Atténuation";
// Menu name
menu.paint = "Peinture";
// Menu name
menu.symmetry = "Symétrie";
// Menu name (pencil pressure)
menu.pressure = "Pression";
// Menu name
menu.gesture = "Geste";
// Menu name
menu.layers = "Calques";
// Menu name
menu.settings = "Réglages";
// Menu name
menu.interface = "Interface";
// Menu name
menu.bindings = "Raccourcis";
// Menu name
menu.history = "Historique";
// Menu name
menu.historySettings = "Réglages";
// Menu name
menu.about = "À propos";
// Menu name
menu.debug = "Débogage";

// Operation on the object (action)
mesh.action = "Opération";
// If the object has holes, the algorithm will close them
mesh.holeClose = "Boucher les trous";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holeDetail = "Détail";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Séparer";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "Les calques, la peinture et la multirésolution seront perdus.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Résolution";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Mettre en cube";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Convertir";
// Static object means "static topology"
mesh.typeStatic = "Maillage";
// See glossary
mesh.typeMultiresolution = "Multirésolution";
// Dynamic topology
mesh.typeDynamic = "TopoDyn";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Matériau général";
paint.useGlobal.help = "Si cette option est activée, le matériau sélectionné sera identique aux autres outils.

Notez que seuls les réglages de rugosité, de métallité et de couleur sont pris en compte.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Peinture du trait";
// Factor/Opacity of paint tool
paint.intensity = "Intensité de la peinture";
// Apply the paint on the object
paint.paintAll = "Tout peindre";
paint.paintAll.help = "Appliquez le matériau actuel à l'objet. 

La zone masquée et les canaux désactivés ne seront pas peints.";
// Apply the paint on the object but ignore painting intensity (force full intensity)
paint.paintAllForce = "Tout peindre de force";
paint.strokePainting.title = "Peinture";
// Brush stroke texture
paint.texture.warningEnable = "Pour que la projection de texture puisse fonctionner, vous devez activer la peinture du trait (voir la case en haut) !";
paint.texture.warningIgnored = "L'outil en cours ne peut pas utiliser de textures !";
// Whether the Brush Alpha will be used to modulate painting intensity
paint.useAlpha = "Utiliser l'alpha du trait";
paint.useAlpha.help = "Utilisez les valeurs alpha du menu Trait pour moduler la peinture.";
// Whether the Brush Falloff will be used to modulate painting intensity
paint.useCurve = "Utiliser l'atténuation des traits";
paint.useFalloff.help = "Utilisez les valeurs d'atténuation du menu Trait pour moduler la peinture.";
// Whether the Brush Randomize will be used to modulate painting intensity
paint.useJitter = "";
paint.useJitter.help = "";

// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "Nouveau nom";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "Nouvelle valeur";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "Nouvelle couleur (format hexadécimal)";

// Post process effect
postprocess = "Post-traitement";
// Quality vs performance
postprocess.quality = "Qualité";
postprocess.quality.help = "Activez ces options pour améliorer la qualité, au détriment des performances.";
// More samples means better quality but slower performance
postprocess.maxSamples = "Nombre max. d'échantillons";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Résolution maximale";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "Nombre max. d'images échantillonnées";
postprocess.accumulateCount.help = "Nombre maximal d'images à accumuler avant l'arrêt du rendu.

Lorsque le rendu s'arrête, Nomad ne fait rien, ce qui permet d'économiser la batterie.

De nombreuses fonctions de rendu bénéficient de l'accumulation des images, dont :
- Ombres douces
- Illumination générale
- Reflet (SSR)
- Occlusion ambiante
- Transluminescence 
- Profondeur de champ

Un nombre d'images élevé est surtout nécessaire pour les ombres douces et l'illumination générale.
Nomad peut arrêter le rendu plus tôt si les fonctions mentionnées ci-dessus sont désactivées.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Résolution de rendu";
postprocess.renderRatio.warning = "Remplacée par l'effet Pixel Art.";
postprocess.renderRatio.help = "Cette option influe significativement sur les performances.
Il est conseillé de conserver une valeur inférieure à x1,25.

Cette option n'est pas enregistrée dans les réglages.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "Anti-crénelage (TAA)";
postprocess.taa.help = "Réduit le scintillement lorsque vous déplacez la caméra.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "Reflet (SSR)";
postprocess.ssr.warning = "La fonction SSR nécessite le mode d'ombrage PBR.";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "Illumination générale (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "Tolérance";
postprocess.ssgi.experimental = "Fonction expérimentale !";
postprocess.ssgi.warning = "La fonction SSGI nécessite le mode d'ombrage PBR.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "Occlusion ambiante";
// How far the effect spreads
postprocess.ssao.radius = "Taille";
// How strong the effect is
postprocess.ssao.factor = "Force";
// Adjustment to fix artefacts
postprocess.ssao.bias = "Biais de courbure";
postprocess.ssao.bias.help = "La sensibilité de l'effet dépend de la courbure de la surface.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "Profondeur de champ";
// The blur factor behind the focused point
postprocess.dof.blurFar = "Flou lointain";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "Flou proche";
postprocess.dof.focusTip = "Appuyez sur un objet pour changer la mise au point.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "Éclat";
// Intensity of the effect
postprocess.bloom.intensity = "Intensité";
// How far the effect spreads
postprocess.bloom.radius = "Rayon";
postprocess.bloom.radius.help = "Ampleur de l'éclat.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "Seuil";
postprocess.bloom.threshold.help = "Seuil de luminosité déterminant si un pixel émet ou non un éclat.
Si la valeur est à 0, l'éclat sera général.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "Mappage tonal";
postprocess.tone.exposure = "Exposition";
postprocess.tone.contrast = "Contraste";
postprocess.tone.saturation = "Saturation";
// No tonemapping operator is used
postprocess.tone.mapping.none = "Aucun";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "Neutre";
// Color curves
postprocess.curve = "Étalonnage";
// Curve for pixel luminance
postprocess.curve.luminance = "Principale";
postprocess.curve.red = "Rouge";
postprocess.curve.green = "Vert";
postprocess.curve.blue = "Bleu";
postprocess.curve.reset = "Réinitialiser";
// Reset color grading curves
postprocess.curve.resetAll = "Tout réinitialiser";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "Aberration chromatique";
postprocess.chromatic.factor = "Force";
// Darking on the edges
postprocess.vignette = "Vignetage";
// How far the effect spreads
postprocess.vignette.size = "Taille";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "Dureté";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "Netteté";
postprocess.sharpness.factor = "Force";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "Grain";
postprocess.grain.factor = "Force";
// Accentuate the edges of the model
postprocess.curvature = "Courbure";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "Creux";
// Color/Strength of convex curvature
postprocess.curvature.bump = "Bosse";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "Pixel Art";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "Autoriser l'échantillonnage des images";
// Simulate scanline rendering (horizonal line)
postprocess.scanline = "Scanline";
postprocess.scanline.factor = "Facteur";
// Spacing between lines
postprocess.scanline.spacing = "Espacement";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Primitive";
primitive.box = "Boîte";
primitive.sphereCube = "Sphère";
primitive.sphereUV = "Sphère UV";
primitive.icosahedron = "Icosaèdre";
primitive.cylinder = "Cylindre";
primitive.cone = "Cône";
primitive.torus = "Tore";
primitive.lathe = "Tour";
primitive.tube = "Tube";
primitive.plane = "Plan";
primitive.triplanar = "Triplanaire";
primitive.faceXYZ = "Face XYZ";
primitive.faceXYZ.help = "Maillage de base UV déplié fourni par https://texturing.xyz/";
primitive.needValidate = "Les primitives doivent être validées pour pouvoir être sculptées.";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Modifier";
primitive.edit.help = "Autoriser l'édition 3D dans la fenêtre d'affichage.

Vous pouvez désactiver cette fonction si vous souhaitez interagir avec l'outil Gizmo ou l'outil Transformation sans modifier la primitive.";

// Primitive configuration
primitive.mainConfig = "Paramètre";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Topologie";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Géométrie";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Valider";
// Maximum number of faces of the primitives
primitive.maxFaces = "Nombre max. de faces";
primitive.maxFaces.help = "Nombre maximal de faces dans une primitive.

Cette limite n'est active que tant que la primitive n'a pas été validée. Ensuite, elle n'est plus respectée.";
// Synonym: Flat subdivision
primitive.linear = "Subdivision linéaire";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Subdivision secondaire";

// Radius (of a sphere, torus, etc)
primitive.radius = "Rayon";
// Size (of cube x dimension)
primitive.size = "Taille";
primitive.sizeX = "Taille X";
primitive.sizeY = "Taille Y";
primitive.sizeZ = "Taille Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "Division";
primitive.divisionX = "Division X";
primitive.divisionY = "Division Y";
primitive.divisionZ = "Division Z";
// Angle of torus, etc
primitive.angleX = "Angle X";
primitive.angleY = "Angle Y";
primitive.angleZ = "Angle Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Densité constante";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Projeter sur une sphère";
primitive.projectOnSphere.help = "Permet d'aligner les points sur une sphère parfaite.";

// triplanar
primitive.triplanar.title = "Triplanaire";
primitive.triplanar.title.help = "La fonction Triplanaire utilise les informations de masque de trois plans pour remplir une grille de voxels qui est ensuite polygonisée.

Si vous interagissez avec les curseurs de division ou de taille, les informations de peinture seront réinitialisées (le lissage restera inchangé).

Vous devrez probablement désactiver la symétrie, car elle peut générer des résultats inattendus.

Vous pouvez utiliser l'option « Liés par topologie » dans le panneau de masque pour peindre un plan influant sur les autres plans.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanarSameSize = "Taille identique (cube)";
primitive.triplanarPolish = "Lissage";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanarResetMask = "Réinitialiser le masque";
// One side of a cube (the back plane)
primitive.isolate.back = "Retour";
// One side of a cube (the right plane)
primitive.isolate.right = "Droite";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Bas";
// Plane
primitive.planeSameSize = "Taille identique (carré)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "Disque";
// Box
primitive.boxRegular = "Taille identique (cube)";
// Distance to the snapping point
primitive.tubeSnapOffset = "Décalage de calage";
primitive.tubeSnapOffset.help = "La valeur 1,0 est égale au rayon du tube.";
// Radius of the tube (starting end-point of the tube)
primitive.tubeThicknessStart = "Début du rayon";
// Radius of the tube (ending end-point of the tube)
primitive.tubeThicknessEnd = "Fin du rayon";
primitive.tubeTwist = "Torsion";
primitive.tubeTwistRotate = "Rotation";
primitive.tubeTwistRadius = "Amplitude";
primitive.tubeTwistOffset = "Décalage";
primitive.tubeSnap = "Aligner";
primitive.torusRadiusOuter = "Rayon extérieur";
primitive.torusRadiusInner = "Rayon intérieur";
primitive.torusAngle = "Angle";
primitive.torusAngleOffset = "Décalage d'angle";
primitive.cylinderHeight = "Hauteur";
primitive.coneRadius = "Rayon";
primitive.coneHeight = "Hauteur";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Trou";
// Make a hole in the primtive to make it hollow
primitive.hasHole = "Comporte un trou";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radiusSync = "Même rayon";
primitive.radiusStart = "Début du rayon";
primitive.radiusEnd = "Fin du rayon";

// Singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "";
// All the new items will be inserted inside the bound rather than outside
repeater.array.fitInside = "";
// The object will follow the curve
repeater.curve.align = "";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Importer…";
// iOS Photos gallery
resource.import.ios.photos = "";
// iOS Files App
resource.import.ios.files = "";

scene.title = "Scène";
scene.title.help = "Lorsque vous utilisez les boutons Visible/Sélectionner, appuyez de façon prolongée pour sélectionner facilement d'autres objets.

Vous pouvez également appuyer de façon prolongée sur les boutons Visible/Sélectionner pour influer sur les enfants.";
// The view will focus on the item when we click on it
scene.focus = "Mise au point sur l'élément";
// Add new object on gizmo position
scene.addOnGizmo = "";
scene.addOnGizmo.help = "";
// Select the gizmo tool after adding a new object
scene.addSelectGizmo = "";
scene.addSelectGizmo.help = "";
// Icon size in pixel (min/max)
scene.iconSize = "";
// Min size of icon
scene.iconSize.min = "Min";
// Max size of icon
scene.iconSize.max = "Max";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "";
scene.showHierarchy.help = "";
scene.showHierarchyNomadPivot = "";
scene.showHierarchyNomadPivot.help = "";
// The view will focus on the item when we click on it
scene.syncVisible = "";
scene.syncVisible.help = "";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "Lier";
// Group the selected object with a new created Empty Node as a parent
scene.group = "Groupe";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "Miroir";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "Courve";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "Matrice";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "Radiale";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "";
scene.repeaters.help = "";
// Validate button
scene.validateGroup = "Valider";
// Keep instances in the scene
scene.validateGroup.keepInstances = "";
// If we should join children
scene.validateGroup.joinChildren = "Lier les enfants";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Fusion de voxels";
scene.voxelResolution = "Résolution";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Soustraction : masquer l'objet (icône en forme d'œil)";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Intersection : tous les objets sont masqués";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "Aucun objet sélectionné, veuillez sélectionner au moins un objet.";
// Need to select one object only
scene.noneButNeedOne = "Aucun objet sélectionné, veuillez sélectionner un objet.";
// Need to select one object only
scene.onlyOneObject = "Plusieurs objets sont sélectionnés, veuillez ne sélectionner qu'un seul objet.";

// General scene display settings
settings.display.title = "Réglages d'affichage";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Filaire";
// Display the material texture
settings.debugChannel = "";
// Display the material texture in the background
settings.debugChannel.onBackground = "";
// Display the material texture on the mesh
settings.debugChannel.onMesh = "";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Recto verso";
settings.twoSided.help = "Les faces seront visibles des deux côtés.";
// If we colorize the inverted side of faces
settings.backface.color = "Couleur de la face arrière";
// Color of the inverted side of faces
settings.backface.colored = "Face arrière colorée";
// Outline (contour highlight around the selected object)
settings.outline = "Contour";
// Outline (contour highlight around the selected object)
settings.outline.help = "Les objets sélectionnés seront entourés.";
settings.outline.thickness = "Épaisseur";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Cube d'alignement";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "En bas";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "A gauche";
// Alignment (can be auto/on/off)
settings.snapCube.align = "";
settings.snapCube.align.help = "";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Statistiques";
settings.stats.right = "Droite";
settings.stats.all = "Afficher la scène complète";
// Grid
settings.grid = "Grille";
// Cursor
settings.cursor.whileSculpting = "Afficher un cercle pendant la sculpture";
// A small indicator dot
settings.cursor.showDot = "Afficher le petit point";
settings.cursor.showDot.help = "Le point peut s'afficher comme point de pivot de la caméra ou quand vous sculptez.";
settings.cursor.showRope = "Afficher le stabilisateur de corde";
// Highlight (the object glows when we select it)
settings.highlight.selection = "Mettre la sélection en surbrillance";
// Highlight settings
settings.highlight = "Surbrillance";
settings.highlight.duration = "Durée";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Assombrir les objets non sélectionnés";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Ombrage lisse";
// Experimental feature
settings.partialDraw = "Dessin partiel";
settings.partialDraw.help = "Fonction expérimentale !

Utilisez-la si vous sculptez une partie relativement petite d'un maillage comportant de nombreux polygones.

Elle devrait permettre de lisser la sculpture, mais n'activez pas le filaire !

Elle risque également d'ajouter des artefacts visuels pendant les coups de pinceau.";
settings.partialDraw.warning = "N'oubliez pas de désactiver cette option si les artefacts visuels sont trop gênants !";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Afficher la peinture";
// Display the light icons in the viewport
settings.lightIcon = "Icônes d'éclairage";
// Display the camera icons in the viewport
settings.cameraIcon = "Icônes de caméra";
// Show icon on the canvas
settings.icon = "Icône";
// Show icons on the canvas
settings.icons = "Icônes";
// Tooltip
settings.icons.help = "Affichez une icône sur la zone de travail pour pouvoir les sélectionner et les modifier directement.";
// Hole filling settings
settings.hole = "Remplissage des trous";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Remplir les trous non-variété";
settings.hole.nonManifold.help = "Essayer de remplir le trou non-variété.
Cette option n'est pas enregistrée dans les réglages.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Nombre max. de sommets";
settings.multires.maxVertices.help = "Nomad ne contrôle pas la mémoire avant la subdivision. Des plantages peuvent facilement survenir en présence de nombreux polygones.";
settings.multires.lowResVertices = "Seuil de basse résolution";
settings.multires.lowResVertices.help = "Le maillage peut être affiché dans une résolution inférieure quand vous déplacez la caméra.

Vous pouvez augmenter cette valeur pour afficher le maillage dans une résolution plus élevée.";

// The main rendering mode
shading = "Ombrage";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "Allumé (PBR)";
shading.pbr.help = "Dans ce mode, vous pouvez ajouter des lumières (avec des ombres), ainsi qu'un environnement HDR.

Vous pouvez également peindre la métallité et la rugosité, et ainsi contrôler plus finement de l'aspect de votre matériau.";
// Fast rendering mode for sculpting purpose (do not translate)
shading.matcap = "MatCap";
shading.matcap.help = "Abréviation de MATerial CAPture, un MatCap gère à la fois les informations d'éclairage et de matériau d'une image. 

Ce mode de rendu rapide est avant tout adapté à la sculpture brute.";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "Éteint";
shading.unlit.help = "Mode d'ombrage avec couleur unie, sans éclairage.";
// Helper rendering mode that display a (do not translate)
shading.id = "ID";
shading.id.help = "Mode de rendu Éteint, avec attribution d'une couleur aléatoire à chaque objet.

Ce mode est particulièrement utile pour les scènes comportant beaucoup d'objets.";
// Randomize colors
shading.id.randomize = "ID aléatoire";
shading.textures = "Utiliser des textures";
shading.textures.help = "Pour le moment, vous ne pouvez pas créer ni modifier de textures dans Nomad.

Vous devriez en revanche pouvoir importer un fichier contenant des textures.

-- Textures acceptées --
Opacité : Allumé, MatCap, Éteint
Normal : Allumé, MatCap
Couleur: Allumé, Éteint
Émissif : Allumé
Rugosité : Allumé
Métallité : Allumé";
// Lights
shading.lights = "Lumières";
shading.lights.addLight = "Ajouter une lumière";
shading.lights.warning = "La fonction Lumières nécessite le mode d'ombrage PBR.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Environnement";
shading.environment.import = "Importer HDR";
shading.environment.exposure = "Exposition";
shading.environment.backgroundBlur = "Flou (arrière-plan)";
shading.environment.rotation = "Rotation";
shading.environment.rotation.help = "Vous pouvez faire pivoter l'environnement en faisant glisser trois doigts horizontalement sur la fenêtre d'affichage.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "Fixé à la caméra";
shading.environment.attachedToCamera.help = "Fixez l'environnement à la caméra.

L'éclairage sera ainsi constant, ce qui peut être utile pour la sculpture.";
shading.matcap.rotation = "Rotation";
shading.matcap.rotation.help = "Vous pouvez faire pivoter le MatCap en faisant glisser trois doigts horizontalement sur la fenêtre d'affichage.";
shading.matcap.global = "Utiliser un MatCap général";
shading.matcap.global.help = "Décochez cette option si vous souhaitez utiliser un autre MatCap pour ce maillage particulier.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible = "Masquer";
shortcut.maskVisible.short = "Masquer";
// bottom shortcut buttons (should be SHORT)
shortcut.solo = "Solo";
shortcut.solo.short = "Solo";
// bottom shortcut buttons (should be SHORT)
shortcut.voxelRemesh = "Remaillage des voxels";
shortcut.voxelRemesh.short = "Voxel";
// bottom shortcut buttons (should be SHORT)
shortcut.wireframe = "Filaire";
shortcut.wireframe.short = "Fil";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraReset = "Réinitialisation de la caméra";
shortcut.cameraReset.short = "Réinitialiser";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraSnap = "Calage de caméra";
shortcut.cameraSnap.short = "Aligner";
// bottom shortcut buttons (should be SHORT)
shortcut.lockSelection = "Verrouiller la sélection";
shortcut.lockSelection.short = "Verrouiller";
shortcut.lockSelection.help = "Quand cette option est activée, vous ne pouvez pas modifier la sélection en appuyant sur un maillage.";
// bottom shortcut buttons (should be SHORT)
shortcut.perspective = "Perspective";
shortcut.perspective.short = "Persp";
// bottom shortcut buttons (should be SHORT)
shortcut.grid = "Grille";
shortcut.grid.short = "Grille";

// Memory taken by the scene
stat.ramScene = "Scène";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Scène VRAM";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "Rendu VRAM";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "Textures VRAM";
// Memory taken by the undo/redo history
stat.ramHistory = "Historique";
// Memory taken by other stuffs
stat.ramOther = "Autre";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "Mémoire utilisée";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "Mémoire libre";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "Utilisée : $0 Mo";
stat.free = "Libre : $0 Mo";
stat.faces = "Visages";
stat.triangles = "Triangles";
stat.vertices = "Sommets";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Quadrilatères";
stat.sceneFaces = "Faces de la scène";
stat.sceneVertices = "Sommets de la scène";

// Brush stroke
stroke = "Trait";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "Rayon de l'espace global";
// The settings is shared among every tools
stroke.useWorldRadius.help = "Ce réglage est partagé par tous les outils.";
// Share the radius value among every tools.
stroke.useShareRadius = "Partager le rayon";
stroke.useShareRadius.help = "Partagez la valeur du rayon entre tous les outils.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.spacing = "Espacement des traits";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.spacing.adjust = "Ajuster l'intensité de l'espacement";
stroke.minSpacingAdjustIntensity.help = "Réglez l'intensité du pinceau pour que la déformation reste constante en fonction de l'espacement des traits.";
stroke.minSpacing.help = "Espacement entre chaque trait, par rapport au rayon de l'outil.

Avec des valeurs basses, les traits sont plus lisses, au détriment des performances.";
// Brush stroke smoothing
stroke.lazySmooth = "Lissage des traits";
stroke.lazySmooth.help = "Faire la moyenne de plusieurs positions de pointeur pour obtenir un trait plus lisse.

Avec des valeurs élevées, le trait a du retard sur le pointeur, mais il finit par rattraper son retard.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Stabilisateur de corde molle";
stroke.lazyRadius.help = "Les traits sont en retard d'une certaine distance par rapport à la position du pointeur.

Cette fonction peut être utilisée pour tracer des lignes lisses.";
// It is not a per-tool settings
stroke.globalSettings = "Ce réglage est général";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Rayon d'alignment'";
stroke.snapRadius.help = "Aligner le tracé si le pointeur se trouve près du dernier tracé enregistré.

Cette fonction peut être utile lorsque vous dessinez de longs traits continus tout en faisant des pauses fréquentes.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Décalage de trait";
stroke.sculptOffset.help = "Appliquez un décalage constant au trait.

Cette option facilite l'utilisation des gestes tactiles sur les petits écrans, de sorte que votre doigt ne recouvre pas le trait.";
stroke.accumulate = "Accumuler les traits";
stroke.accumulate.help = "Si cette option est activée, vous pouvez ajouter/supprimer autant de mouvements que vous le souhaitez pour chaque trait.";
// The tool can use DynTopo
stroke.useDynamicTopology = "Autoriser la topologie dynamique";
// Only sculpt the part that are linked topologically
stroke.connected = "Topologie connectée";
stroke.connected.help = "Cette option sculptera uniquement les sommets reliés à la surface sélectionnée.

Elle s'utilise généralement avec l'outil Déplacer, par exemple si vous voulez déplacer seulement une pièce qui s'entrecroise avec une autre pièce.";
// Only sculpt the vertex that points toward the camera
stroke.culling = "Sommet orienté vers l'avant uniquement";
stroke.culling.help = "Cette option ignore les sommets de la face arrière.

Elle peut être utile si vous voulez peindre une partie d'une géométrie mince sans toucher à l'autre côté.

Elle fonctionne également pour la sculpture, mais risque de générer quelques artefacts.";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.sameSide = "Sommet du même côté uniquement";
stroke.sameSide.help = "Ignorez les sommets qui sont dans la direction opposée à la déformation.";
// Module the intensity of the sculpting operation by using a falloff curve
menu.falloff = "Atténuation";
stroke.onlyLasso = "Réglages actifs uniquement pour l'outil Lasso.";
// Alpha
menu.alpha = "Alpha";
// Invert the pixel (black <-> white)
stroke.alphaInvert = "Inverser les pixels";
// Repeat the alpha image (pattern)
stroke.alphaWrap = "Recouvrement";
// No repeat pattern
stroke.alphaWrap.none = "Aucun";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alphaWrap.repeat = "Répéter";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alphaWrap.mirror = "Miroir";
stroke.alphaFetch = "Méthode";
// Project the alpha perpendicularly onto the surface
stroke.alphaFetch.surface = "Surface";
// Project the alpha onto the surface in the direction of the camera view
stroke.alphaFetch.screen = "Projet vers l'écran";
stroke.alphaRotation = "Rotation";
stroke.alphaRotation.lock.help = "";
// Repeat the image
stroke.alphaTiling = "Recouvrement";
// Scale the image (make it bigger or smaller)
stroke.alphaScale = "Mise à l'échelle";
stroke.alphaScale.help = "À la valeur minimale, le carré alpha se trouve à l'intérieur du rayon du cercle de l'outil.";
// Middle-point value at which no deformation occurs
stroke.alphaMidValue = "Valeur moyenne";
stroke.alphaMidValue.help = "Valeur intermédiaire à laquelle aucune déformation ne se produit.

(Valeur moyenne = 0)
- Noir : pas de déplacement
- Blanc : déplacement positif

(Valeur moyenne = 0,5)
- Noir : déplacement négatif
- Blanc : déplacement positif

(Valeur moyenne = 1)
- Noir : déplacement négatif
- Blanc : pas de déplacement";
// Synonymous: Scatter/Jitter/Randomize
stroke.jitter = "";
// Sculpt and paint along the brush stroke at regular spacing
stroke.strokeTypeDot = "Point";
// Sculpt continuously
stroke.strokeTypeDrag = "Glisser";
// Lock a region and move it around
stroke.strokeTypeGrab = "Capturer";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.strokeTypeGrabRadius = "Capturer - Rayon dynamique";
// Lock a region and sculpt it by changing the tool intensity
stroke.strokeTypeGrabIntensity = "Capturer - Intensité dynamique";

// Symmetry
symmetry = "Symétrie";
symmetry.enable = "Activée";
// Display a warning (the feature is only available for mesh object)
symmetry.primitiveWarning = "La symétrie de pinceau n'est disponible que pour les primitives validées, sauf pour la primitive triplanaire.";
symmetry.plane.title = "Plans";
symmetry.toolIgnore = "L'outil actuel ignore la symétrie.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Radiale";
symmetry.radialX = "Radiale X";
symmetry.radialY = "Radiale Y";
symmetry.radialZ = "Radiale Z";
// A warning indicating that we limit the number of repetitions ($0 is a number)
symmetry.limited = "";
// Synonym: Offset
symmetry.offset.title = "Décalage";
symmetry.offsetX = "Décalage X";
symmetry.offsetY = "Décalage Y";
symmetry.offsetZ = "Décalage Z";
// Number of clones
symmetry.count.title = "Nombre";
symmetry.countX = "Nombre X";
symmetry.countY = "Nombre Y";
symmetry.countZ = "Nombre Z";
// method
symmetry.method = "Méthode :";
symmetry.method.help = "-- Local
Le plan de symétrie se déplace le long du maillage lorsque vous utilisez l'un des outils de transformation (Gizmo ou Transformation). 

-- Global
Le plan de symétrie est fixe et ne se déplace pas.";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.method.world = "Global";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.method.local = "Local";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Inverser l'objet";
// Mirror the mesh
symmetry.mirror = "Miroir";
symmetry.mirror.help = "Essayez de réappliquer la symétrie sans affecter la topologie.

La symétrie radiale sera ignorée.

Si la topologie ne peut pas être conservée car elle n'est pas considérée comme symétrique, vous aurez la possibilité d'appliquer une symétrie en miroir.";
symmetry.mirrorLeftToRight = "De gauche à droite";
symmetry.mirrorRightToLeft = "De droite à gauche";
symmetry.mirrorFail = "Impossible d'appliquer la symétrie.

Voulez-vous appliquer la symétrie en mettant le maillage en miroir ?";
symmetry.mirrorUseMasking = "Protéger la zone masquée";
symmetry.mirrorUseMasking.help = "Gardez la zone masquée intacte.

Cette option sera ignorée avec une topologie non symétrique (ou une surface déconnectée, comme une paire d'yeux).";
// Reset the symmetry plane position
symmetry.reset = "Réinitialiser";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Centre de l'objet";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "Centre de la scene";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Orientation";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Afficher la ligne";
// Display the symmetry plane in 3d
symmetry.showPlane = "Afficher le plan";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Modification Gizmo";
symmetry.edit.warning = "La fonction de modification de symétrie est expérimentale.";
symmetry.edit.help = "Vous pouvez définir librement le plan de symétrie.

Cette fonctionnalité est expérimentale et nous vous déconseillons de l'utiliser.";

// Ideally <10 chars
tool.dynTopo = "TopoDyn";
// Ideally <10 chars (Symmetry)
tool.symmetry = "Sym";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "Miroir";
// Ideally <10 chars
tool.clay = "Argile";
// Ideally <10 chars (Subtract)
tool.clay.sub = "Soustraire";
// Ideally <10 chars
tool.brush = "Pinceau";
// Ideally <10 chars
tool.move = "Déplacer";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "Normal";
// Ideally <10 chars
tool.drag = "Glisser";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "Lisser";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Relâcher";
// Ideally <10 chars (Paint mask)
tool.mask = "Masquer";
// Ideally <10 chars
tool.mask.unmask = "Démasquer";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "MasqueSél";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "Doigt";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "Aplatir";
// Ideally <10 chars (Flatten the surface, more strongly than Flatten)
tool.planar = "";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Remplir";
// Ideally <10 chars (Layer brush)
tool.layer = "Calque";
// Ideally <10 chars
tool.crease = "Plier";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "Découper";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Scinder";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "Projeter";
// Ideally <10 chars
tool.inflate = "Gonfler";
// Ideally <10 chars
tool.pinch = "Pincer";
// Ideally <10 chars
tool.nudge = "Décaler";
// Ideally <10 chars
tool.stamp = "Tampon";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "SupprCalque";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.select = "Sélectionner";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "Gizmo";
// Ideally <10 chars
tool.gizmo.editPivot = "Pivot";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "Caler";
// Ideally <10 chars (Snap translation)
tool.gizmo.moveSnap = "Caler";
// Ideally <10 chars (Local/Relative space)
tool.gizmo.local = "Local";
// Ideally <10 chars (Align/Snap the gizmo to world axis)
tool.gizmo.align = "";
// Ideally <10 chars (Pin the gizmo, so that it stays in place when switching between objects)
tool.gizmo.pin = "";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "Transformation";
// Ideally <10 chars (Translate the object)
tool.transform.move = "Déplacer";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "Pivoter";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "Échelle";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "Caler";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "Mesurer";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "Vue";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "Tour";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "Tube";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "Insérer";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "Retourner";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "Vue";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "Lasso";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Courbe";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Polygone";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Tracé";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "Rect";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "Ellipse";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "Ligne";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Fermé";

// Radius of the tool (size)
tool.radius = "Rayon";
// Intensity of the tool (force)
tool.intensity = "Intensité";

tool.settings = "Réglages";
tool.settings.none = "Cet outil n'a pas de réglages spécifiques.";

// Flatten distance offset
tool.clay.flattenOffset = "Décalage d'aplatissement";
tool.crease.pinchFactor = "Force de pincement";

tool.layer.removeInfluence = "Utiliser les données du calque";
tool.layer.removeInfluence.help = "Cette option n'est active que lorsqu'un calque est sélectionné.

Elle utilise les données du calque pour limiter le déplacement sur les traits.";
tool.layer.noLayerSelected = "Cette option n'est disponible que si un calque est sélectionné";

tool.flatten.warning = "Ces options sont expérimentales et peuvent à tout moment être supprimées !";
tool.flatten.planeLockOrigin = "Verrouiller l'origine du plan";
tool.flatten.planeLockNormal = "Verrouiller la direction du plan";
tool.flatten.planeAverageOrigin = "Faire la moyenne de l'origine du plan";
tool.flatten.planeAverageNormal = "Faire la moyenne de la direction du plan";
tool.flatten.planeOffset = "Décalage du plan";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "";
tool.syncInstance.message = "";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Sommet collant sur la bordure";

tool.paint = "Peinture";
// Erase the painting
tool.paint.erase = "Effacer";
// Only paint the part of the mesh above a certain height
tool.paint.depthFilter = "Filtrage par profondeur";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Filtrage par calque";
tool.paint.layerFilter.help = "Utilisez cette option si vous souhaitez uniquement repeindre la zone déjà peinte d'un calque.";

// Clear the painted mask
tool.mask.clear = "Effacer";
// Invert the painted mask
tool.mask.invert = "Inverser";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Inverser le masque (connecté)";
// Blur the painted mask
tool.mask.blur = "Flou";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Netteté";
// The thickness of the extracted mesh (from the painted mask)
tool.mask.thickness = "Épaisseur de la coque";
// Smooth the border of the extracted mesh (from the painted mask)
tool.mask.polish = "Lissage des bordures";
// Extract a new mesh from the painteed mask and carve/emboss the base mesh
tool.mask.engraveEmboss = "Graver/Creuser";
// Extract a new mesh from the painted mask
tool.mask.extract = "Extraire";
// Extract two new mesh from the painted mask and from the unmasked area
tool.mask.split = "Scinder";
// How should we close the topology of the extracted object
tool.mask.closeMask = "Action de fermeture (avec masque) :";
// How should we close the topology of the extracted object
tool.mask.closeUnmask = "Action de fermeture (sans masque) :";
// How should we close the topology of the extracted object
tool.mask.closeAction = "Action de fermeture :";
// Do not close the mesh (leave it open)
tool.mask.closeActionNone = "Aucune";
// Close the mesh with a hole-filling algorithm
tool.mask.closeActionFill = "Remplir";
// Close the mesh by adding a thickness on the surface
tool.mask.closeActionShell = "Coque";
// Close the mesh by using the layer data as a difference thickness
tool.mask.closeActionLayer = "Calque";
tool.mask.closeAction.help = "-- Aucune
Extraire simplement la pièce et laisser la pièce extraite ouverte.

-- Remplir
Le trou est rempli et lissé.
N'utilisez pas cette option pour une surface plane.

-- Coque
Fermer la forme extraite en utilisant la valeur d'épaisseur.

-- Couche
Extraire la différence entre les calques (sous-menu Calque uniquement).";

// Transform/Matrix
tool.matrix = "Matrice";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.apply = "Cible";
// Automatic
tool.matrix.apply.auto = "Auto";
// Transform the object alone (the children stands still)
tool.matrix.apply.object = "Objet";
// Auto apply the transform on the vertices
tool.matrix.apply.vertex = "Sommet";
// Transform the object and its children
tool.matrix.apply.group = "Groupe";
tool.matrix.apply.help = "-- Auto
Par défaut, le résultat est le même qu'avec l'option Groupe.
Si le maillage comporte un masque ou si la symétrie du gizmo est activée, cette option fonctionne de la même manière que l'option Sommet.

-- Sommet
Essayez d'appliquer la transformation aux sommets. Elle ne fonctionnera pas sur les primitives non validées.
Les instances seront également affectées.

-- Objet
Déplacez seulement l'objet en ignorant la symétrie et le masquage.
Seul le nœud modifié sera déplacé. Les enfants resteront à la même place.

-- Groupe
Déplacez le nœud en ignorant la symétrie et le masquage. Le reste de la hiérarchie sera également transformé.";
// Operation on the mesh
tool.matrix.action = "Opération";
tool.matrix.action.help = "-- Déplacer l'origine
Déplacez le maillage vers l'origine de de la scène.

- Réinitialiser
Réinitialisez la transformation de maillage à l'identique.

-- Appliquer
Appliquez la matrice au sommet et réinitialisez la matrice. Visuellement, rien ne devrait changer.";
tool.matrix.translation = "Translation";
tool.matrix.rotation = "Rotation";
tool.matrix.scale = "Échelle";
// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "Cisaillement";
tool.matrix.uniformScale = "Échelle uniforme";
tool.matrix.moveToOrigin = "Déplacer l'origine";
tool.matrix.resetTransform = "Réinitialiser";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "Appliquer";

tool.transform.tip = "";

// Size of the gizmo
tool.gizmo.size = "Taille du widget";
// If true, there is less spacing between gizmo handlers (rotate, scale, etc)
tool.gizmo.compact = "";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "Saisie numérique";
tool.gizmo.allowInput.help = "Autoriser la saisie numérique lors de l'appui sur l'un des widgets de gizmo";
// Angle threshold
tool.gizmo.linearRollThreshold = "Seuil de roulis tangent";
tool.gizmo.linearRollThreshold.help = "Seuil d'angle déterminant le choix entre la méthode de roulis linéaire et la méthode de roulis circulaire.

Au-delà de ce seuil, le roulis sera circulaire.

Si vous préférez utiliser le roulis linéaire (direction de la tangente), réglez cette valeur à 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Masquer lors des interactions";
tool.gizmo.tap = "Appui simple";
tool.gizmo.tap.help = "Cette option ne fonctionne qu'en mode de pivot personnalisé.

-- Aucun
Rien ne se passe lorsque vous appuyez sur le maillage.

-- Aligner
Déplace le gizmo sur la première intersection et aligne le gizmo suivant la normale de la surface.

-- Premier coup
Déplace le gizmo sur la première intersection.

-- Mi-chemin
Déplace le gizmo sur la moyenne des deux premières intersections.";
tool.gizmo.tap.none = "Aucun";
tool.gizmo.tap.align = "Aligner";
tool.gizmo.tap.first = "Premier coup";
tool.gizmo.tap.medial = "Mi-chemin";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "Fixe";

// Fill the object's hole
tool.hole = "Remplissage du trou";
tool.hole.fillHoles = "Remplir les trous";
// synonym: Alternative method
tool.hole.bridges = "Booléen espace écran";
tool.hole.bridges.help = "Si cette option est activée, vous pouvez faire des trous dans le volume.
La pente de découpe suit également de plus près la forme de la découpe.";
tool.hole.threshold = "Epsilon seuil";
tool.hole.threshold.help = "L'ajustement de cette valeur peut améliorer le fonctionnement de l'algorithme de remplissage de trous.";
tool.hole.smoothing = "Lissage des trous";

tool.smudge.quality = "Qualité";
tool.smudge.quality.help = "Cette option modifie la résolution des pixels projetés. Avec des valeurs basses, les traits sont plus rapides.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Forme";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Carré";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Centré";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Cercle";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Centré";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Rotation par pas";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Afficher le nombre d'or";


// Always display the camera shortcut buttons on the viewport
tool.view.stickyCamera = "";

// Topology
topology = "Topologie";
// Synynom: detail value, density
topology.dynamic.detail = "Détail";
// See glossary
topology.multires = "Multirésolution";
topology.multires.help = "Conservez plusieurs résolutions d'un même maillage.

Si vous effectuez des modifications dans une résolution basse, les détails des résolutions supérieures seront reprojetés lorsque vous changerez de résolution.

Les calques sont disponibles dans chaque résolution.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "Inverser";
topology.multires.reverse.confirm = "Impossible de créer la subdivision de base.

La topologie actuelle n'est probablement pas le résultat d'une subdivision.";
topology.multires.subdivide = "Subdiviser";
topology.multires.subdivide.confirm = "Le maillage aura $0 millions de sommets. Voulez-vous continuer ?";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "Limite de subdivision dépassée, voir $0";
topology.multires.deleteLower = "Supprimer la basse résolution";
topology.multires.deleteHigher = "Supprimer la haute résolution";
topology.multires.keepTriangles = "Conserver les triangles";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "";
// Synonym: Flat subdivision
topology.multires.linear = "Subdivision linéaire";
topology.multires.linear.help = "Subdivisez simplement le maillage sans appliquer de lissage.";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Remaillage des voxels";
topology.voxel.help = "Remaillage par échantillonnage du maillage sur une grille.

Si l'objet n'est pas fermé (étanche), un algorithme de remplissage de trou sera appliqué au préalable.

Les calques sont reprojetés après le remaillage, mais la qualité sera dégradée.";
topology.voxel.resolution = "Résolution";
topology.voxel.remesh = "Remailler";
topology.voxel.sharp = "Conserver des arêtes vives";
topology.voxel.sharp.help = "Cette option est surtout utile pour les opérations booléennes simples sur les primitives.

Elle génère une distorsion dans certaines zones, car les points sont alignés sur les arêtes.";
topology.voxel.subLevel = "Construire une multirésolution";
topology.voxel.subLevel.help = "Vous pouvez reconstruire une hiérarchie multirésolution à partir du résultat obtenu après remaillage des voxels. 

Elle fonctionnera également plus rapidement et consommera moins de mémoire, surtout si le niveau de détail des voxels est élevé.
Cependant, si le niveau de détail est faible et que vous demandez beaucoup de niveaux de multirésolution, vous perdrez en détails.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Remailler";
topology.surface.detail = "Détail";
topology.surface.detail.help = "Contrairement au remaillage de voxels, le remaillage de surface ne nécessite pas de fermer le maillage.

Cette fonction peut également gérer le masquage afin de protéger une partie du maillage contre les changements de topologie.

Les calques sont correctement mis à jour.";
topology.surface.method = "Méthode";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Uniformisation";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Subdivision";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Décimation";
topology.surface.method.help = "Comportement de la topologie dynamique :
- Uniformisation : ajout et suppression de détails
- Subdivision : ajout de détails
- Décimation : suppression de détails";
topology.surface.useMasking = "Protéger la zone masquée";
topology.surface.useMasking.help = "Les zones masquées empêcheront la modification de la topologie.";
topology.surface.extrapolate = "Extrapolation du sommet";
// DynTopo
topology.dynamic = "Topologie dynamique";
topology.dynamic.activate = "Activée";
topology.dynamic.activate.help = "Avec la topologie dynamique, les outils de sculpture peuvent subdiviser ou simplifier le maillage localement en temps réel.

Cette fonction peut avoir un impact notable sur les performances.

Les calques sont correctement mis à jour.";
topology.dynamic.method = "Détail basé sur…";
topology.dynamic.method.zoom = "Zoom";
topology.dynamic.method.radius = "Rayon";
topology.dynamic.method.constant = "Constante";
topology.dynamic.method.help = "-- Zoom
Le niveau de détail est basé sur la distance à laquelle vous vous trouvez par rapport à la surface.

-- Rayon
Le rayon de l'outil définit la quantité de détails.

-- Constante
Le détail est fixe, et la valeur de détail est également partagée avec le curseur de voxel.";
topology.dynamic.quality = "Préférer…";
topology.dynamic.quality.help = "Le mode Qualité présente deux différences principales :
- L'affinage est appliqué avant l'opérateur de sculpture . Vous obtiendrez moins d'artefacts d'interpolation lorsque vous peindrez ou sculpterez de très petits détails.
- L'affinage n'est pas appliqué de manière incrémentielle. Si vous sculptez de très petits détails ou faites des traits rapides, la topologie sera toujours affinée correctement.

Pour profiter de meilleures performances, si vous prévoyez d'utiliser cette option, envisagez d'activer l'option « Dessin partiel » dans le panneau Réglages.";
topology.dynamic.quality.speed = "Vitesse";
topology.dynamic.quality.quality = "Qualité";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Modifier le rayon selon la pression";
topology.dynamic.usePressure.help = "Utilisez cette option si vous souhaitez que l'incidence du niveau de pression du stylet sur le rayon de l'outil influe sur le niveau de détail.";
// Decimate
topology.decimate.title = "Décimation";
topology.decimate.title.help = "Réduisez le nombre de polygones en essayant de conserver autant de détails que possible.

Cette fonction peut être utile pour exporter votre création en vue d'une impression 3D.
Nous vous déconseillons en revanche de l'utiliser si vous voulez continuer à modifier la sculpture, car elle risque de générer des triangles déséquilibrés.

Notez que la zone masquée ne sera pas décimée.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Décimer";
topology.decimateTargetFaces = "Triangles cibles";
topology.decimatePaintWeight = "Préserver la peinture";
topology.decimatePaintWeight.help = "Saisissez une valeur élevée pour essayer de préserver la peinture.

Si la peinture vous importe peu, saisissez 0.";
topology.decimateUniform = "Faces uniformes";
topology.decimateUniform.help = "Saisissez une valeur élevée pour générer des triangles de même taille.";
topology.decimatePreserveBorders = "";
topology.decimatePreserveBorders.help = "";

// Unwrapping means compute UV (texture coordinates), it allows the object to receive on texture (wrap the texturing on the object)
topology.uv.title = "Dépliage auto UV";
// UV Unwrapping
topology.uvAtlas = "Dépliage Atlas";
// The operation can be very slow
topology.uvAtlas.warning = "L'opération peut être très lente, ciblez moins de 100 000 sommets !";
// UV Unwrapping (BFF best left untranslated, stands for Boundary First Flattening)
topology.uvBFF = "Dépliage BFF";
// Handles are topological holes (synonym: genus, hole)
topology.uvBFF.warning = "Des chevauchements peuvent se produire si le maillage comporte des poignées !";
// Synonym: Point count? Singularity count ?
topology.uvBFFCones = "Nombre de cônes";
topology.uvBFFCones.help = "Saisissez une valeur élevée pour limiter la distorsion des objets complexes.

Plus la valeur est élevée, plus le temps de calcul sera long.";
topology.uvDelete = "Supprimer les UV";

// Transfer the vertex painting in the texture, bake means "create texture (from mesh data)"
topology.bake.title = "Peinture -> Texture";
// Bake here means "create texture (from mesh data)"
topology.bake.title.help = "";
// Bake here means "create texture (from mesh data)"
topology.bakeSelf = "";
// Bake here means "create texture (from another mesh data)"
topology.bakeHires = "";
topology.bakeResolution = "Résolution";
// Cage is a specific term, synonyom: "Bake offset"
topology.bakeOffset = "";
// Bake opacity (from mask data)
topology.bake.opacityFromMask = "";

// project a high resolution mesh details onto another
topology.reproject.title = "";
topology.reproject.title.help = "";
// tweaking value
topology.reproject.rayBias = "";
topology.reproject.rayBias.help = "";
// number of iteration the algorithm will take
topology.reproject.iterations = "";

topology.forceManifold = "";
topology.forceManifold.help = "";

// Reset key-bindings/shortcuts
binding.reset = "Réinitialiser les raccourcis";
// Binding option
binding.toggleTool = "";
binding.toggleTool.help = "";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.materialPicker = "Sélecteur de matériau";
// Edit the tool brush size/radius
binding.editRadius = "Rayon de l'outil";
// Edit the tool brush size/radius
binding.editIntensity = "Intensité de l'outil";
// Snap the camera
binding.viewFront = "Vue avant";
// Snap the camera
binding.viewLeft = "Vue de gauche";
// Snap the camera
binding.viewTop = "Vue du dessus";
// Move/Translate the view
binding.panLeft = "Panoramique gauche (vue)";
// Move/Translate the view
binding.panRight = "Panoramique droit (vue)";
// Move/Translate the view
binding.panForward = "Panoramique avant (vue)";
// Move/Translate the view
binding.panBackward = "Panoramique arrière (vue)";
// Move/Translate the view
binding.panUp = "Panoramique haut (vue)";
// Move/Translate the view
binding.panDown = "Panoramique bas (vue)";
// Snap the view (while rotating)
binding.snapViewOnRotate = "Aligner la vue (pendant la rotation)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "Ouvrir (projet)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "Ajouter (projet)";
// Import an external scene file (replace current scene)
binding.import.open = "Ouvrir (importer)";
// Import an external scene file (add it to the current scene)
binding.import.add = "Ajouter (importer)";
// Select all the objects in the scene
binding.selectAll = "Tout sélectionner";
// Rotate environment and the lighting
binding.rotateLighting = "Faire pivoter l'éclairage";

// Privacy policy
privacyPolicy.title = "Règles de confidentialité";
privacyPolicy.reject = "Rejeter";
// Hexanomad is the company name
privacyPolicy = "Hexanomad ne collecte aucune donnée via Nomad Sculpt.";

// Color disc mode
widget.color.disc = "";
// Color square mode
widget.color.square = "";

// version trial
version.buyWeb = "La version Web n'est qu'une démo";
version.buyFull = "Passer à la version complète";
version.restorePurchase = "Restaurer un achat";

version.trialHistory = "Version d'essai : 4 opérations Annuler/Rétablir possibles";
version.trialLayer = "Version d'essai : 1 calque par maillage";
version.trialOneProject = "Version d'essai : 1 seul projet actif";
version.trialNoImport = "Version d'essai : pas d'importation";
version.trialNoExport = "Version d'essai : pas d'exportation";

version.fullFeatures = "- Achat définitif
- Opérations Annuler/Rétablir illimitées
- Calques illimités
- Enregistrement et chargement
- Exportation et importation";
