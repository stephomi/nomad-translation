// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "Confirmer ?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Oui";
// Answer to a question (Are you sure you want to do that? [yes, no, cancel])
confirm.no = "Non";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "OK";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Annuler";

// Experimental feature
experimental = "Fonction expérimentale !";

status.exit = "Changements non enregistrés ! Enregistrer avant de fermer ?";
status.exit.yes = "Enregistrer";
status.exit.no = "Ne pas enregistrer";

// On single tap (should be short)
ontap = "Click";

all = "Tout";
error = "Erreur";

reset = "Réinitialiser";
resetOrder = "Réinitialiser l'ordre";

clipboard = "Presse-papiers";
clipboard.copy = "Copier";
clipboard.paste = "Coller";

// memory size
bytes = "octet";
kB = "ko";
MB = "Mo";
GB = "Go";
TB = "To";

// Noun
instance = "Instance";
object = "Objet";

// Same value (usually for axis, e.g: x == y == z)
uniform = "Uniforme";

sync = "Synchroniser";

// position
position.top = "Haut";
position.bottom = "Bas";
position.left = "Gauche";
position.right = "Droite";
position.center = "Centré";
// direction
direction.up = "Haut";
direction.down = "Bas";
direction.left = "Gauche";
direction.right = "Droite";
// 3D cube
cube.top = "Dessus";
cube.bottom = "Dessous";
cube.left = "Gauche";
cube.right = "Droite";
cube.front = "Devant";
cube.back = "Arrière";

// Name of an item (object, tool, etc)
item.name = "Nom";
// Add a new item (object, tool, etc)
item.new = "Nouveau";
// Rename an item (object, tool, etc)
item.rename = "Renommer";
// Add a new item (object, tool, project, etc)
item.add = "Ajouter";
// Update an item image with a new image (synonym: Update)
item.replace = "Remplacer";
// Save an item (object, tool, etc)
item.save = "Enregistrer";
item.save.confirm = "Confirmer l'enregistrement ?";
// Update an item (update camera view point, etc)
item.update = "Mettre à jour";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Dernier enregistrement";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "Charger le dernier enregistrement ?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Réinitialiser";
item.reset.confirm = "Confirmer la réinitialisation ?";
// Make an item instance, similar to clone but keeps the underlying geometry (Synonym: link? soft clone?)
item.instance = "Instancier";
// Uninstance the object, make the object real
item.uninstance = "Désinstancier";
// Clone an item (object, tool, etc)
item.clone = "Cloner";
// Delete an item (object, tool, etc)
item.delete = "Supprimer";
item.delete.confirm = "Confirmer la suppression ?";
item.delete.confirm.yes = "Oui, supprimer";
// When we delete the item but the image is used somewhere
item.delete.used = "Image utilisée";
// Convert the item type (mesh, light) to a simple Node type
item.toNode = "En nœud";
// Item visibility (object, layer, etc)
item.visible = "Visible";
// Show an item (object, layer, etc)
item.show = "Afficher";
// Hide an item (object, layer, etc)
item.hide = "Masquer";
// Select an item (object, layer, etc)
item.select = "Sélectionner";
// Unselect an item (object, layer, etc)
item.unselect = "Désélectionner";
// Merge an item with another one below (layer)
item.mergeDown = "Fusionner avec le calque inférieur";
// The order of an item in a list
item.order = "Ordre";
// Focus on previous item
item.previous = "Précédent";
// Focus on next item
item.next = "Suivant";
// The item is locked (either it cannot be selected, edited, or we preserve its details)
item.lock = "Verrouiller";
// No item selected
item.none = "Aucun";
// Draggable, moveable
item.draggable = "";

// Search something (text entry to filter item)
search = "Rechercher";

// Three-state toggle button (Auto, Off, On)
toggle.on = "Activé";
// Three-state toggle button (Auto, Off, On)
toggle.off = "Désactivé";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "Auto";

// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Miniatures manquantes, retraitement des fichiers…";
loading.reprocess.cancel = "Générer les miniatures ?";

access.title = "Accessibilité";
access.window = "Fenêtre d'assistance";
access.pinch = "Pincer";
access.drag = "Glisser";
access.rotate = "Pivoter";
access.roll = "Rouler";

// Color of an object
material.color = "Couleur";
// Defines how blurry or sharp the reflection on a material is (opposite of glossiness)
material.roughness = "Rugosité";
// Defines how blurry or sharp the reflection on a material is (opposite of roughness)
material.glossiness = "Brillance";
// Whether the material is a metal or not
material.metalness = "Métallité";
// How much light a surface will reflect
material.specular = "Spéculaire";
// Light that the surface can emit (glow)
material.emissive = "Émissif";
// Normal map (synonym: detail, bump)
material.normal = "Normal";
// flip y coordinate
material.normal.flipY = "Inverser Y";
// Ambient Occlusion (AO)
material.occlusion = "Occlusion";
// Textures, basically images wrapped on models (synonym: Maps, Texture maps)
material.textures = "Textures";
// Textures/Image
material.texture = "Texture";
// A warning indicating that the mesh has no UVs
material.warningNoUVs = "Pas de UV !";
// Texture filtering https://en.wikipedia.org/wiki/Texture_filtering
material.texture.filter = "Filtrage";
// Nearest Filtering (closest sample)
material.texture.nearest = "Proche";
// Bilinear Filter
material.texture.linear = "Linéaire";
// Mipmap filtering
material.texture.mipmap = "Mipmap";
// Triplanar mapping
material.projection = "Projection";
material.projection.triplanar = "Triplanaire";

// Prefer low power
about.lowPower = "GPU basse puissance";
about.lowPower.confirm = "Après avoir changé cette valeur, vous devez redémarrer Nomad.";
// Wintab wacom API
about.wintab = "Utiliser WinTab";
about.wintab.help = "Si WinTab est activé, vous devriez probablement désactiver Windows Ink dans vos paramètres Wacom.

De même, si WinTab est désactivé, alors Windows Ink devrait être activé dans les paramètres Wacom.";
// Prefer low power
about.fullScreen = "Plein écran";
// Minify
about.minify = "Réduire l'interface";
about.minify.help = "Vous pouvez également toucher votre écran avec quatre doigts, si votre appareil gère cette fonctionnalité.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Plateau tournant";
// Rotation center of the turntable
about.turntable.pivot = "Centre de rotation";
// Keep current pivot
about.turntable.pivot.keep = "Conserver l'actuel";
// Turntable pivot will be at the center of the scene
about.turntable.pivot.scene = "Scène";
// Make the entire scene turn around (speed of the animation)
about.turntable.speed = "Vitesse";
// Stuffs that I used to make the app
about.credits = "Crédits";
// Link to open source projects that I used for the app
about.credits.openSource = "Open Source";
// Only translate the &
about.credits.arts = "MatCaps et HDRI";
// Change languages of the app
about.languages = "Langues";
about.languages.help = "Fichiers de traduction disponibles sur $0";
// Link to the App Website
about.website = "Site Web";
// Link to the App Forum
about.forum = "Forum";
// Link to the App Manual
about.manual = "Manuel";
// Link to the App Email
about.mail = "Assistance";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";
// Link to the App Threads account
about.threads = "Threads";

// The user canceled an operation that was running
alert.aborted = "Opération annulée !";
// Empty mesh
alert.mirror.empty = "Sortie vide!";
// Mesh already mirrored
alert.mirror.same = "Même sortie!";
// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "L'objet n'a pas de trou !";
// No operation occured because the mesh is already manifold
alert.manifold.already = "Le maillage est déjà manifold !";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "L'objet actuel est invisible !";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Rien à découper.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Abandonner la découpe : l'objet est entièrement découpé.";
// In order to extract something, the mesh needs to have painted mask
alert.extract.none = "Rien à extraire !";
// In order to split something, the mesh needs to have painted mask
alert.extract.split.none = "Rien à scinder !";
// List of disabled features when View Mode is selected
alert.view.disabled = "Fonctions désactivées en mode Consultation :";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Widgets de primitive";
// The object needs to have two parts disconnected
alert.separate.fail = "Séparation impossible : l'objet n'a qu'une seule pièce !";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "Remaillage terminé !";
alert.voxelRemesh.empty = "Abandonner le remaillage : le maillage résultant n'a pas de face.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "Entrée non valide !";
// Helper popup to tell the users the object will cloned
alert.matrix.clone = "L'objet sera dupliqué";
// Helper popup to tell the users the object will cloned
alert.matrix.instance = "L'objet sera instancié";
// A pivot refers the gizmo 3D position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Modifiez le mode de pivot.";
alert.mask.full = "Masquer = 100%!";
// A pivot refers the gizmo 3D position
alert.gizmo.editObject = "Modifiez le mode d'objet.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Topologie dynamique active";
// See Glossary (DynTopo)
alert.dynamic.disable = "Désactiver la topologie dynamique";
alert.colorPicker = "Faites glisser votre doigt sur l'objet pour sélectionner une couleur.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Appuyez une fois pour quitter le mode Transformation.";
// Edit the symmetry plane with the gizmo
alert.editSymmetry = "Appuyez simplement pour quitter le mode d'édition de la symétrie.";
// Show the painted mask on the mesh
alert.mask.show = "Afficher le masque";
// Hide the painted mask on the mesh
alert.mask.hide = "Masquer le masque";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Verrouiller la sélection";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Déverrouiller la sélection";
// Hide the objects that are not selected
alert.selection.isolate = "Isoler la sélection";
// Show the objects that are hidden
alert.selection.showAll = "Tout afficher";
// Project quick saving
alert.quickSave = "Enregistrement…";
// Painting on the object was hidden but the user did paint the object
alert.forcePainting.fill = "Option Afficher la peinture activée, la fonction [Tout peindre] a été utilisée.";
// Painting on the object was hidden but the user started to paint on the object
alert.forcePainting.tool = "Option Afficher la peinture activée, l'objet a été peint.";
// See Glossary (Multiresolution)
alert.multiresLost = "La multirésolution sera perdue !";
// Boolean cut mode will ignore some features
alert.booleanIgnored = "Le mode de découpe Boolean ignorera les zones masquées ou cachées !";
// The user is starting an operation that can lead to a crash
alert.range.warning = "Le niveau de détail est élevé et peut nécessiter beaucoup de mémoire !";
// Autosave popup
alert.autoSave.auto = "Enregistrement automatique dans… $0 s";
// The selected object doesn't have any layers
alert.needLayer = "L'outil actuel nécessite un calque actif.";
// The user decided to hide the painting on the objects
alert.paintingHidden = "Peinture masquée!";
// The user decided to hide the masking on the objects
alert.maskingHidden = "Le masque est caché !";
// The user decided to display hidden faces
alert.hideIgnored = "Masquer est ignoré !";
// The selected object doesn't have any layers
alert.noPartialWireframe = "La fonction Dessin partiel est désactivée lorsque le filaire est affiché.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Envisagez d'utiliser une caméra orthographique si vous voulez éviter la distorsion du tronc de perspective lors de l'utilisation d'une projection vers l'écran.";
// Trial version has a limited number of undo
alert.state.trial = "Version d'essai : résiliation annulée";

background = "Arrière-plan";
// A flat color will be displayed in the background of the scene
background.color = "Couleur";
// 2 color with rotation
background.gradient = "Gradient";
// The environment (HDRI) will be displayed in the background
background.environment = "Environnement";
background.blur = "Flou";
background.exposure = "Exposition";

// Image that the artist uses as a reference
background.imageEnable = "Image de référence";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Incrustation";
// Opposite of transparency (Alpha)
background.imageAlpha = "Opacité";
background.imageReset = "Réinitialiser les réglages";
background.imageTransform = "Transformation";
// X screen coordinate of the image reference
background.imageX = "Position X";
// Y screen coordinate of the image reference
background.imageY = "Position Y";
// Rotation of the reference image
background.imageRotation = "Rotation";
// Scale of the reference image
background.imageScale = "Mise à l'échelle";
// Auto adjust the reference when moving the camera
background.syncLock = "Synchroniser avec le verrouillage de la caméra";

// Blend: normal
blend.normal = "Normale";
// Blend: darker
blend.darker = "Plus sombre";
blend.darker.darken = "Assombrir";
blend.darker.multiply = "Multiplier";
blend.darker.linearBurn = "Brûlure linéaire";
blend.darker.colorBurn = "Intensifier les couleurs";
// Blend: lighter
blend.lighter = "Plus clair";
blend.lighter.lighten = "Éclaircir";
blend.lighter.screen = "Écran";
blend.lighter.linearDodge = "Dodge linéaire";
blend.lighter.colorDodge = "Densité de couleur";
// Blend: contrast
blend.contrast = "Contraste";
blend.contrast.hardLight = "Lumière intense";
blend.contrast.softLight = "Lumière douce";
blend.contrast.overlay = "Incrustation";
blend.contrast.hardMix = "Mixte dur";
blend.contrast.linearLight = "Lumière linéaire";
blend.contrast.vividLight = "Lumière vive";
blend.contrast.average = "Moyenne";
// Blend: inversion
blend.inversion = "Inversion";
blend.inversion.exclusion = "Exclusion";
blend.inversion.difference = "Différence";
// Blend: cancelation
blend.cancelation = "Annulation";
blend.cancelation.divide = "Division";
blend.cancelation.subtract = "Soustraire";
// Blend: component
blend.component = "Composant";
blend.component.luminosity = "Luminosité";

// Camera (point of view in 3D)
camera = "Caméra";
cameras = "Caméras";
camera.view = "Vue";
// Copy the views
camera.updateView = "Mettre à jour le point de vue ?";
// Add a new camera
camera.addView = "Ajouter une vue";
// Focus on the camera
camera.focus = "Mise au point";
// Add on the camera camera
camera.focusOn = "Mise au point sur $0";
// Camera projection, Orthographic or Perspective
camera.projection = "Projection";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Orthographique";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Perspective";
// camera Vertical Field of View
camera.fov = "Champ de vision vertical";
// Camera Field of View hint
camera.focal = "Focale de $0 mm (capteur 35 mm)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Rotation";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "Plateau tournant";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Trackball";
camera.rotation.trackball.help = "Le trackball offre plus de liberté, car vous pouvez également faire pivoter la caméra avec deux doigts.";
// Camera interaction mode, 1st person view
camera.firstPerson = "Première personne";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Vitesse";
// Camera rotation sensitivity
camera.speed.rotation = "Rotation";
// Camera translation sensitivity
camera.speed.panning = "Translation";
// Camera zooming sensitivity
camera.speed.zooming = "Zoom";
// Reset camera position
camera.resetView = "Réinitialiser la vue";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Vue alignée";
// Warning (camera is snapped and it switched to orthographic)
camera.snapOrthographic.warning = "Caméra est alignée (orthographique)";
// Switch to orthographic view when the view is snapped
camera.snapOrthographic = "Alignment orthographique";
camera.snapOrthographic.help = "Cette option fonctionne également lorsque le cube d'alignment est utilisé.";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Pivot";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Double appui sur l'objet";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Double appui sur l'arrière-plan";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackgroundFocus.toggle = "Basculer";
// Focus on the selection
camera.doubleTapBackgroundFocus.selection = "Sélection";
// Focus on the entire scene
camera.doubleTapBackgroundFocus.scene = "Scène";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "Mettre à jour lors du double appui";
camera.doubleTapPivot.help = "Mettre à jour le pivot de rotation lors du double appui sur la surface de l'objet.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "Pivot aérien";
camera.airPivot.help = "Autoriser la création d'un pivot même en cas de zoom en dehors de la surface de l'objet.";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "Au début du mouvement de caméra";
camera.autoPivot.help = "Mettre à jour le pivot lorsque vous commencez à interagir avec la caméra.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Mise au point";
camera.doubleTapFocus.help = "Lors d'un double appui sur l'objet, la caméra effectuera un panoramique pour se centrer sur le point choisi.";
// Disable XY panning when unzomming
camera.centerZoomOut = "Centrer la vue lors du zoom arrière";
camera.panZoomOut.help = "Lorsque cette option est désactivée, cette position de pivot sera préservée.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "Sélection multiple";
// There is 0 nodes/items selected
context.noSelection = "Aucune sélection";

// Curve type, presets lets the user chooses between predefined curves
curve.preset = "Préréglage";
// Quick curve x side shift
curve.shift = "Majuscule";
// Curve type, https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
curve.catmull = "Catmull-Rom";
// Curve curve, https://en.wikipedia.org/wiki/Spline_(mathematics)
curve.spline = "Spline";
curve.bspline = "B-spline";
curve.precision = "Précision";
// merge or collapse 1 point into another
curve.merge = "Fusionner";
// snap
curve.snap = "Aligner";
curve.snap.offset = "Décalage";
curve.snap.offset.help = "La valeur 100% est égale au rayon du tube.";
curve.snap.surface = "Surface";
curve.snap.vertex = "Sommet";
curve.snap.grid = "Grille (si calé)";
// Regular spaced sampling
curve.uniform = "Uniforme";
curve.uniform.help = "La courbe sera échantillonnée à intervalles réguliers, pour assurer une densité uniforme.

Vous pouvez désactiver cette option pour contrôler un peu les boucles de bord en ajoutant de nouveaux points de contrôle sur la courbe.";
// Display the falloff curve in a symmetric way
curve.symmetric.help = "Afficher l'atténuation de manière symétrique.

Cette option est seulement un indice visuel, elle n'affecte pas l'atténuation lui-même";
curve.radius = "Rayon";
curve.twist = "Torsion";
curve.spiral = "Spirale";
curve.spiral.twist = "Angle de torsion";
curve.spiral.scale = "Échelle";
curve.spiral.offset = "Décalage";
curve.spiral.angle = "Décalage d'angle";
curve.pivot = "Pivot";
curve.pivot.self = "Courbe";
curve.pivot.children = "Enfants";

// Set the desired FPS (frame per second, refresh rate)
debug.limitFps = "IPS cible";
debug.limitFps.help = "Lorsqu'il est désactivé, la valeur par défaut signifie qu'il se synchronisera avec le taux de rafraîchissement de l'affichage.";

// Warning about UVs (using extra memory)
debug.uvPrimitive.warning = "Désactivez cette option si vous n'avez pas besoin des UV (mémoire supplémentaire).";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "Normaliser les UV";
debug.uvNormalize.help = "Nomad normalisera les UV à l'intérieur du recouvrement [0-1].";

// Debug option, display an window with some debugging logs
debug.logs = "Logs";
// Model shortcut window
debug.shortcut = "Fenêtre de raccourci";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Champ de hauteur";
// Debug options, graphical stuffs
debug.graphics = "Graphismes";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Générer des miniatures de boutique en ligne";

// Open file explorer
file.explore = "Explorer";
// Empty list: there is no projects
file.project.load = "Recharger le projet au démarrage";
// Empty list: there is no projects
file.project.empty = "Vous n'avez pas encore enregistré de projet !";
// The current opened project has some unsaved changes
file.project.unsaved = "Modifications non enregistrées !";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "Toute modification non enregistrée sera perdue !";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Aperçu du dernier enregistrement manuel";

file.project = "Projet";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Enregistrer";
// E.g: Save "my_project"?
file.project.save.confirm = "Enregistrer $0 ?";
// Make a copy
file.project.saveAs = "Enregistrer sous";
// Overwrite another project
file.project.overwrite = "Remplacer";
// E.g: Overwrite "my_other_project"?
file.project.overwrite.confirm = "Remplacer $0 ?";
// Open a project
file.project.open = "Ouvrir";
// E.g: Open "my_project"?
file.project.open.confirm = "Ouvrir $0 ?";
// E.g: Clone "my_project"?
file.project.clone.confirm = "Cloner $0 ?";
// Load another project and add/append all its data to the current scene
file.project.add = "Ajouter à la scène";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "Ajouter $0 à la scène ?";
// Reset the scene and create a new project
file.project.new = "Nouveau";
file.project.new.confirm = "Créer une scène ?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "Supprimer $0 ?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "Supprimer $0 ?

Il s'agit du projet actif en cours !";

// Auto save section
file.autoSave = "Sauvegarde automatique";
file.autoSave.confirm = "Désactiver la sauvegarde automatique ?";
file.autoSave.help = "Sauvegarde votre projet dans un fichier séparé à intervalles réguliers.

Emplacement du fichier de sauvegarde automatique :";
// Interval in minutes in which the auto save popup will appear
file.autoSave.popup = "Délai d'affichage de la fenêtre contextuelle";
// In minutes
file.autoSave.minutes = "Fenêtre contextuelle du minuteur";
// Delete the current autoSave data
file.autoSave.delete = "Supprimer l'enregistrement automatique";
// Open the outdated auto save
file.autoSave.open.manual = "Ouvrir la sauvegarde manuelle obsolète";
file.autoSave.open.auto = "Ouvrir la sauvegarde automatique obsolète";

// color space (linear or srgb), do not translate linear/srgb if there is a doubt
file.colorSpace = "Espace de couleur";
file.colorSpace.help = "Essayez d'activer cette option si les couleurs vous semblent incorrectes.";
file.colorSpace.linear = "Linéaire";
file.colorSpace.srgb = "sRGB";

// Configure imports option
file.importSettings = "Options d'importation";

// Load interface preference settings when opening a scene file
file.import.guiSettings = "Conserver les réglages de l'interface graphique";
file.import.guiSettings.help = "Lors de l'ouverture ou de l'importation d'un fichier de projet, tous les réglages d'interface graphique intégrés au projet seront chargés.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.import.obj.splitByGroup = "Scinder l'OBJ en groupes";
file.import.obj.splitByGroup.help = "Lorsque cette option est activée, Nomad scinde les groupes OBJ en objets indépendants.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.import.mergeLayers = "Fusionner les calques";
// Ignore the textures present in the file to load
file.import.skipTextures = "Ignorer les textures";
// Do not fiddle with the object topology when loading the file
file.import.keepTopology = "Conserver la topologie";
file.import.keepTopology.help = "Utilisez cette option si vous ne voulez pas que Nomad modifie la topologie du maillage importé.

Elle désactive la réorganisation des sommets/faces, la suppression des doublons de sommets/faces et la suppression des sommets inutilisés.";

// Import file section
file.import.title = "Importer";
file.import.title.help = "Formats compatibles :";
// The user imports a scene file that will replace the current scene
file.import.open = "Ouvrir";
file.import.open.confirm = "Importer un nouveau fichier ?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Ajouter à la scène";
file.import.add.confirm = "Importer un nouveau fichier ?";

// Export scene file
file.export = "Exporter";

// Filter nodes that we want to export
file.select.include = "Inclure";
file.select.all = "Tout";
file.select.visible = "Visible";
file.select.selected = "Sélectionné";
file.select.unselected = "Non sélectionné";

// Export each node in a separate file
file.export.separate = "Un fichier par objet";

// Export the current selected objects instead of the entire scene
file.onlySelection = "Inclure uniquement les objets sélectionnés";
file.onlySelection.help = "Inclure uniquement la sélection plutôt que la scène entière.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Reconstruire le quadrilatère";
file.convertToQuad.help = "Reconstruisez les quadrilatères à partir de triangles en associant des triangles (s'ils sont adjacents dans les fichiers).";
// ----------------------------------------------
// Whether we include the textures in the exported file
file.export.texture = "Textures";
// Baking means transfering/converting
file.export.texture.help = "Cette option ne convertit pas les couleurs des sommets dans les textures.";
// ----------------------------------------------
file.export.color0 = "Couleurs des sommets";
file.export.color1 = "Peinture PBR";
file.export.color1.help = "Exportez la rugosité, la métallité et la peinture du masque. Ces informations seront ignorées par les autres logiciels.";
// ----------------------------------------------
// Whether we include normals vector in the exported file
file.export.normal = "Normales";
file.export.normal.help = "Cochez cette option si vous souhaitez ouvrir le fichier dans d'autres logiciels.

Nomad ignore toujours les normales, car il les recalcule.";
// ----------------------------------------------
file.export.tangent = "Tangentes";
file.export.tangent.help = "Cochez cette option si vous souhaitez ouvrir le fichier dans d'autres logiciels.

Les tangentes sont uniquement utilisées si le modèle possède une carte normale.

Nomad ignore toujours les tangentes car il les recalcule.";
// ----------------------------------------------
file.export.nomad.help = "Format de fichier interne Nomad Sculpt.

Ce format ne se chargera pas sur d'autres logiciels, il est surtout destiné à la réimportation.";
// ----------------------------------------------
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Calques";
file.export.gltf.layer.help = "Exportez les calques sous forme de morphes. Cette fonctionnalité est officiellement gérée par le format glTF et devrait donc fonctionner aussi avec d'autres logiciels.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Peinture (calque)";
file.export.gltf.layerPaint.help = "Exportez la peinture du calque. Elle est généralement ignorée par les autres logiciels.";
// ----------------------------------------------
file.export.obj.warning = "Les calques et la peinture supplémentaire (rugosité, métallité et masque) seront perdus.";
// Whether we include the vertex color in the exported file
file.export.obj.color = "Couleurs des sommets";
file.export.obj.color.help = "Permet d'ajouter les informations de couleur après les sommets.";
file.export.obj.color.help.append = "Permet d'ajouter les informations de couleur après les sommets.";
file.export.obj.color.help.hexa = "Une autre manière de coder la couleur. Elle prend également en charge les données de masque.";
file.export.obj.faceGroup = "Groupe de faces";
file.export.obj.object = "Écrire les objets";
file.export.obj.object.help = "Garder les objets séparés.

Désactiver cette option exportera tout comme une seule entité.
Vous devez désactiver cette option si vous souhaitez utiliser la fonction 'ID de maille / Polygroupe' de Substance Painter.";
file.export.obj.archive = "Type";
file.export.obj.archive.folder = "Dossier";
file.export.obj.archive.zip = "Zip";
file.export.obj.archive.help = "Certaines applications (Google Drive, One Drive, etc.) ne prennent pas en charge l'importation de dossiers, vous pouvez donc utiliser Zip à la place.";
// ----------------------------------------------
file.export.ply.warning = "Les calques et la peinture supplémentaire (rugosité, métallité et masque) seront perdus.";
// ----------------------------------------------
file.export.stl.warning = "Les calques et la peinture supplémentaire (rugosité, métallité et masque) seront perdus.";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Couleurs des sommets";
file.export.stl.color.help = "Certains logiciels 3D pourront lire ces informations, mais pas tous.";
// ----------------------------------------------
file.export.usd.skew = "Autoriser l'inclinaison";
file.export.usd.skew.help = "Autoriser l'inclinaison dans les transformations matricielles.

Lorsqu'il est désactivé, Nomad divisera les matrices d'inclinaison en deux transformations séparées de mise à l'échelle et de rotation.";
// ----------------------------------------------
// Advanced settings
settings.advanced = "Avancé";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "Ces options ne sont pas enregistrées dans les réglages.";
settings.reset.title = "Réglages";
settings.reset.title.help = "Cette commande réinitialise les réglages des préférences de l'application.

Certaines ressources sont enregistrées séparément et ne seront PAS réinitialisées, dont : 
• Projets
• Liaisons clés
• Préréglages des outils
• Environnements HDR
• MatCaps
• Alphas
• Textures (pinceau)
• Images de référence

Notez que tous les réglages liés au projet resteront inchangés : éclairage, post-traitement, vues de caméra, etc.";

// Reset preference settings button
settings.reset = "Rétablir les valeurs par défaut";
settings.reset.confirm = "Réinitialiser les réglages des préférences ?";

// Render a screenshot of the scene
file.render = "Générer le rendu";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Afficher l'interface";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Rapport de rendu";
file.render.renderRatio.help = "Avec la valeur 1,0, Nomad générera le rendu à la même résolution que la taille d'image requise ci-dessous.

Utilisez cette option si vous ne pouvez pas effectuer le rendu à certaines résolutions (plantage pour cause de manque de mémoire).";
// Desired size of the exported screenshot
file.render.size = "Taille finale";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Personnalisée";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "Écran";
// width of exported screenshot
file.render.width = "Largeur";
// height of exported screenshot
file.render.height = "Hauteur";
// export screenshot of the scene
file.render.warn = "La résolution d'exportation est élevée ($0x$1) !

Pensez à enregistrer votre projet, au cas où votre appareil se trouverait à court de VRAM et planterait.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Arrière-plan transparent";
file.render.transparent.help = "Cette option peut être utile si vous voulez insérer le maillage dans un logiciel de création 2D.

La transparence partielle de l'objet n'est pas prise en charge pour le moment.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Utiliser les réglages généraux";
pressure.useGlobal.help = "Par défaut, les outils partagent les mêmes réglages de pression.

Décochez cette option si vous souhaitez définir des réglages de pression spécifiques pour cet outil.";

// Pencil pressure
pressure.title = "Pression";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "Cet outil ne tient pas compte de la pression du stylet.";
// The tool can support pressure but its selected stroke type will ignore it
pressure.noGrab = "Le type de trait Capturer ignore les réglages de pression.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Rayon";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Intensité";
// Average pencil pressure event to get smoother result
pressure.average = "Lissage de la pression";
pressure.average.help = "Moyennez les événements de pression du crayon pour des résultats plus doux.";
// Limit pressure to 100%
pressure.limit = "Limiter la pression à 100%";
pressure.limit.help = "Il s'agit d'un réglage global.

Utilisez cette option pour garantir que la pression du stylo ne dépasse jamais 100 %.";

// list of inputs allowing camera interaction
gesture.camera = "Caméra";
// list of inputs allowing sculpting interaction
gesture.sculpt = "Sculpter";
// Select object
gesture.select = "Sélectionner l'objet";
// Finger/Touch input
gesture.finger = "Doigt";
// Stylus/Pencil
gesture.stylus = "Stylet";
// Mouse/Trackpad
gesture.mouse = "Souris";

// long press to pick the color/material under the cursor
gesture.dropper = "Sélection de matériau";
gesture.dropper.help = "Pour déclencher le sélecteur de couleur/matériau, appuyez de façon prolongée sur la zone de travail.

Le sélecteur ne s'affiche que si la peinture est activée pour le pinceau actuel.";

camera.airStroke = "Autoriser le coup d'air";
camera.airStroke.help = "Permettre au coup de sculpture de commencer même si le curseur initial manque la maille.

Cette option est active uniquement pour les entrées avec la sculpture activée et la caméra désactivée.";

// Three fingers on screen
gesture.three.title = "Trois doigts";
gesture.three.light = "Faire pivoter l'éclairage";
gesture.three.light.help = "Pivote l'environnement, les lumières et le MatCap.";
gesture.three.radius = "Rayon de l'outil";
gesture.three.intensity = "Intensité de l'outil";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.finger.smooth = "Lissage systématique avec le doigt";
gesture.finger.smooth.help = "Cette option est active uniquement si un outil de sculpture est actif.";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Autoriser les informations de pression non reconnues";
gesture.unknownPressure.help = "Cochez cette option si la pression ne fonctionne pas avec votre stylet ou si la pression du doigt doit être prise en compte.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Bouton Stylet";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Double appui avec le stylet";
gesture.pencilAction.ios.help = "Actif uniquement pour l'Apple Pencil 2e génération.";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "Aucun";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Ajouter/Soustraire";

// Enable Mask gesture by tapping once on the screen
gesture.mask.oneTap = "Raccourcis rapides";
gesture.mask.oneTap.help = "Autorisez l'accès au raccourci Masque par appui simple sur l'écran, sans qu'il soit nécessaire d'appuyer de façon prolongée sur le raccourci du bouton Masque.

Vous pourrez effectuer les gestes suivants :
• Appuyez sur l'arrière-plan pour inverser le masque.
• Appuyez sur une zone masquée pour flouter le masque.
• Appuyez sur une zone non masquée pour accentuer le masque.";
// Hold the finger on screen to toggle between two tools: Mask and SelMask
gesture.mask.holdStroke = "Trait";
gesture.mask.holdStroke.help = "Un appui long basculera entre Masque et SelMasque et commencera un nouveau trait.

À la fin du trait, l'outil précédent est sélectionné de nouveau.";
gesture.mask.holdIdle = "Outil";
gesture.mask.holdIdle.help = "Appuyez longuement et relâchez sans bouger pour basculer entre Masque et SelMasque.";

// Shortcut customization, choose the action that the shortcut will performan (select tool, etc)
gesture.shortcut = "Raccourci";

// Shortcuts to undo/redo
gesture.history = "Raccourcis de l'historique";
gesture.history.help = "• Annuler : appuyez avec deux doigts
• Rétablir : appuyez avec trois doigts";
gesture.history.hold = "Appui long";
gesture.history.hold.help = "Appuyez de façon prolongée avec deux/trois doigts.";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Ignorer la paume";
gesture.palmRejection.confirm = "Pensez à désactiver cette option si vous rencontrez des difficultés pour interagir avec la zone de travail !";
gesture.palmRejection.help = "Permet de rejeter la saisie si la taille de la zone de contact est supérieure à cette valeur.

Cette option peut ne pas fonctionner avec tous les périphériques.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Seuil de taille max.";

// Smoothing strategy
extract.polish.all = "Tout";
extract.polish.sharp = "Bord net";
extract.polish.border = "Uniquement les bords";
// Smooth the border in a way that it matches completely with its dual
extract.polish.syncBorder = "Synchroniser le bord";
// topology of extracted mesh
extract.edgeLoop = "Boucle de bord (côté)";
extract.edgeLoop.auto = "Boucle de bord automatique";
extract.edgeLoop.division = "Division";
// The thickness of the extracted mesh (from the painted mask)
extract.thickness = "Épaisseur";
// Carve the mask into the surface
extract.carve = "Creuser";
// Extract a new mesh from the painted mask
extract = "Extraire";
// Preview extract
extract.preview = "Aperçu";
// Extract two new mesh from the painted mask and from the unmasked area
extract.split = "Scinder";
// How should we close the topology of the extracted object
extract.action = "Action de fermeture :";
extract.action.help = "• Aucune
Extraire simplement la pièce et laisser la pièce extraite ouverte.

• Remplir
Le trou est rempli et lissé.
N'utilisez pas cette option pour une surface plane.

• Coque
Fermer la forme extraite en utilisant la valeur d'épaisseur.

• Couche
Extraire la différence entre les calques (sous-menu Calque uniquement).";
// Do not close the mesh (leave it open)
extract.action.none = "Aucune";
// Close the mesh with a hole-filling algorithm
extract.action.fill = "Remplir";
// Close the mesh by adding a thickness on the surface
extract.action.shell = "Coque";
// Close the mesh by using the layer data as a difference thickness
extract.action.layer = "Calque";

// uv part of revolution surface
genus.main = "Principale";
genus.hole = "Trou";
genus.bottom = "Bas";
genus.top = "Haut";

// History, list of undo/redo
history = "Historique";
// First "undo" state
history.root = "Base";
history.undoConfirm = "Confirmez-vous l'annulation de toutes ces opérations ?";
history.undoWarning = "Si vous effectuez une autre modification, vous risquez de perdre beaucoup de modifications.";
// Settings concerning the history stack of undo/redo
history.stack = "Pile";
// Actions to include in the undo/redo stack
history.include = "Inclure les actions";
// include lighting editing in the undo/redo
history.includeLights = "Lumières";
history.includeLights.help = "Si cette option est désactivée, le déplacement des lumières avec l'outil Gizmo sera quand même pris en compte, car cette opération peut avoir une incidence sur d'autres objets dans la hiérarchie de la scène.";
// include postProcess editing in the undo/redo
history.includePostProcess = "Post-traitement";
// include shading parameters (MatCap & HDRIs) editing in the undo/redo
history.includeShading = "MatCaps et HDRI";
// Can limit the stack of undo/redo size
history.limitSize = "Limite de l'historique";
history.limitSize.help = "Taille maximale de l'historique.

L'historique sera mis à jour à l'enregistrement de l'opération suivante.";
// Limit the number of undo in the history stack
history.limitStack = "Limite de la pile";
history.limitStack.help = "Nombre maximal d'opérations que l'application peut conserver.

L'historique sera mis à jour à l'enregistrement de la prochaine opération.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Nombre maximal d'opérations annulables";
history.rangeProtect.help = "Si vous remontez loin dans l'historique, une boîte de dialogue de confirmation s'affichera avant d'annuler de nombreuses opérations.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Restaurer la caméra";
history.restoreCamera.help = "Activez cette option pour restaurer l'angle de vue enregistré de la caméra quand vous annulez/rétablissez une action.";
// Undo
history.undo = "Annuler";
// Redo
history.redo = "Rétablir";
// Shown during undo
history.state.undo = "Annuler : $0";
// Shown during redo
history.state.redo = "Rétablir : $0";
// Shown during undo/redo
history.state.voxelRemesh = "Remaillage des voxels";
// Shown during undo/redo
history.state.surfaceRemesh = "Remaillage de surface";
// Shown during undo/redo
history.state.multiresLevel = "Changement de résolution";

// Debugging/Inspect object material (view channel separately color, roughness, normal, uv, etc)
inspect = "Inspecteur";
// Inspector but SHORT
inspect.short = "Inspecter";
// Display the material channel on the background
inspect.onBackground = "Sur l'arrière-plan";
// Display the material channel on the mesh
inspect.onMesh = "Sur le maillage";
// Show UV seams
inspect.seams = "Coutures";

// Interface customization
interface = "Interface";

// Resize window (should be short)
interface.resize = "Redimensionner";

// UI customization: one item row will stands on one line (synonym: Inlined)
interface.compact = "IU : Compacte";

// UI customization: each row of the list will be bigger
interface.expandList = "Interface : développer la liste";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Option d'interface facilitant la gestion des listes.";

// Add shortcuts buttons to the bottom of the screen
interface.shortcut.bottom = "Ajouter des raccourcis (en bas)…";
// Floating window
interface.shortcut.float = "Ajouter des raccourcis (fenêtre)…";

// Interface option (main base color)
interface.colorBase = "Base de couleur";
// Interface option (accent widget color)
interface.colorSelect = "Widget de couleur";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Panneau transparent";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Intensité du flou";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Panneau de couleur";

// Interface color style
interface.preset.title = "Préréglages";

// Reset interface settings
interface.resetAll = "Réinitialiser le style";
interface.resetAll.confirm = "Réinitialiser les réglages de l'interface ?";
// help popup when hovering
interface.hoverHelp = "Aide contextuelle au survol";
// Interface option (main base color)
interface.iconSupport = "Bouton à fort contraste";
interface.iconSupport.help = "Un style alternatif pour les boutons qui les rend plus visibles lorsqu'ils sont activés.

Si réglé sur Auto, Nomad utilisera ce mode lorsque le contraste de couleur de l'UI entre activé/désactivé est faible.";
// Interface customization
interface.flipTop = "Inverser la barre supérieure";
// Interface customization
interface.flipBottom = "Inverser la barre inférieure";
// Interface customization
interface.flipMiddle = "Inverser les barres latérales";
// list of tools
interface.toolbox = "Boîte à outils";
// hide toolbox by default
interface.toolbox.hide = "Cachée";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.columns = "Colonnes";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.rows = "Rangées";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Réinitialiser l'ordre";
// Colored text and icon
interface.toolbox.color = "Coloré";
// Top bar
interface.top.title = "Barre supérieure";
interface.top.responsive = "Adaptatif";
interface.top.responsive.help = "Cette option est principalement pertinente pour les petits écrans.";
interface.top.responsive.multiline = "Multiligne";
interface.top.responsive.scroll = "Défilement";
interface.top.responsive.collapse = "Réduire";
interface.top.alt = "Ordre alternatif";
interface.top.alt.help = "Icône d'ordre alternatif pour le menu supérieur.

Les menus relatifs à l'édition de maillage sont principalement du côté opposé du menu de la scène, ce qui peut aider dans l'édition de scène.";
// Scale the interface
interface.scale = "Redimensionner l'interface";
// Spacing between widgets
interface.cursorStep = "Espacement vertical";
// Width of the interface panels
interface.panelWidth = "Largeur des menus";
// Size of fonts
interface.fontScale = "Taille de la police";
// Inset
interface.inset.title = "Décalages des bords";
interface.inset.title.help = "Ne modifiez ces valeurs que si vous rencontrez des difficultés pour interagir avec les boutons situés sur les bords de l'écran.

Si le curseur est désactivé, Nomad utilisera les valeurs de zone de sécurité renvoyées par le périphérique lui-même.";

// (see Glossary for Layer)
layer = "Calque";
layers.syncTransform = "Synchroniser la transformation";
layers.syncTransform.help = "Si activé, toutes les couches non sélectionnées seront ajustées en fonction de la rotation, de l'échelle et de l'inclinaison de la transformation.

Désactivez cette option si les autres couches doivent être utilisées sans la nouvelle transformation que vous appliquez.

Lorsqu'elle est réglée sur automatique, seules les couches visibles seront ajustées.";
// (see Glossary for Layer)
layers.lock = "Conserver les détails des calques supérieurs";
// (see Glossary for Layer)
layers.lock.yes = "Verrouiller les calques supérieurs ?";
// (see Glossary for Layer)
layers.lock.warning = "Pendant la sculpture, la déformation provenant des calques supérieurs sera ignorée.

Les détails de ces calques resteront cependant visibles. 

Cette option ne fonctionne que si les détails des calques supérieurs sont relativement petits en taille.";
// (see Glossary for Layer)
layers.addLayer = "Ajouter un calque";
// (see Glossary for Layer)
layer.factors = "Facteurs de canal";
// (see Glossary for Layer)
layer.factor = "Facteur";
// (see Glossary for Layer)
layer.offset = "Décalage";
// Layer blend mode
layer.blendMode = "Fusion";
// (see Glossary for Layer)
layer.base = "Base";
layer.base.nothing = "Rien à extraire !";
layer.base.background = "Matériel d'arrière-plan";
layer.base.background.help = "Si actif, seules les valeurs du matériel qui diffèrent du matériel d'arrière-plan seront extraites.";
// (see Glossary for Layer)
layers = "Calques";
layers.title = "Calques";
// (see Glossary for Layer)
layers.title.help = "Les calques peuvent enregistrer les décalages de position et la peinture, ce qui peut s'avérer utile en cas de workflow non linéaire.
Vous pouvez par exemple tester différentes expressions de visage sans vous appuyer sur la pile d'historique pour annuler les modifications.

Pour les données de peinture, les calques sont triés de haut en bas, de sorte que les calques du haut masquent les calques inférieurs.

Vous pouvez effacer une partie du calque (et donc l'influence du calque) à l'aide de l'outil « SupprCalque ».";
layers.primitive = "Les calques ne sont pas disponibles pour les primitives.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "Aucun";

light = "Lumière";
lights = "Lumières";
// Intensity of light
light.intensity = "Intensité";
// Color of light
light.color = "Couleur";
// Kelvin (the temperature unit)
light.kelvin = "Kelvin";
// Temperature in Kelvin (Alternative way to compute the color of the light)
light.temperature = "Température";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Fixation";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Fixe";
// The light will move along the camera
light.attachment.camera = "Caméra";
light.attachment.help = "• Fixe
L'orientation de la lumière ne change pas.

• Caméra
L'orientation de la lumière dépend de l'angle de la caméra.";
// Light type (directional, spot, point)
light.type = "Type";
// Directional light (synonym: sun light)
light.type.directional = "Directionnel";
light.type.sun = "Soleil";
// Directional light (synonym: sun light)
light.type.environment = "Environnement";
light.type.hdri = "HDRI";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Projecteur";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Point";
// For directional light (angle jitter)
light.angle = "Angle";
// For point/spot light (offset jitter)
light.size = "Taille";
// Cone angle for spot angles
light.spot.angle = "Angle du cône";
// Softness of the spot light
light.spot.softness = "Douceur";
// Position of the light
light.position = "Position";
// Enable or disable shadows for a light
light.shadow.cast = "Ombre";
// Point light only works with "screenspace" shadow type (not "shadow map")
light.shadow.pointTip = "La lumière de point ne gère que les ombres de l'espace écran.";
light.shadow.type = "Type d'ombre";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadow.type.shadowMap = "Texture d'ombre";
// Shadows computed with only the information visible on screen
light.shadow.type.screenspace = "Espace écran";
light.shadow.type.screenspace.help = "Cette fonction est expérimentale et peut être supprimée dans une prochaine version.

Elle est destinée à être utilisée avec la fonction Douceur des ombres.";
// Adjustment to fix artefacts
light.shadow.bias = "Biais";
// How blurry the shadow is
light.shadow.softness = "Douceur";
// Contact shadows are more precise shadows on small distance (synonym: cavity shadows?)
light.contact = "Contact";
light.contact.help = "Si l'option Auto est sélectionnée, seule la lumière la plus dominante aura une ombre de contact.";
// Thickness threshold for screen-space shadows (synonym: threshold, bias)
light.shadow.tolerance = "Tolérance";
// Activated the light
light.visible = "Afficher";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Recentrer";

// Object's material
material = "Matériau";
// See glossary
material.pbrRoughnessMetalness.warning = "Les fonctions Rugosité et Métallité nécessitent le mode d'ombrage PBR.";
// See glossary
material.pbrReflectance.warning = "La fonction Réflectance nécessite le mode d'ombrage PBR.";
// See glossary
material.pbrRefraction.warning = "La fonction Réfraction nécessite le mode d'ombrage PBR.";
// See glossary
material.pbrSubsurface.warning = "La fonction Transluminescence nécessite le mode d'ombrage PBR.";
// Value that says how much light will change direction when hitting the surface
material.ior = "Indice de réfraction";
// an object-level value that overrides the roughness interior/surface of the mesh
material.paintingOverride = "Remplacer la peinture";
// The roughness in the inside is turbidity
material.paintingOverride.help = "Deux rugosités sont définies : celle qui génère la surface et celle qui se trouve à l'intérieur.

Comme une seule d'entre elles peut être peinte, les deux duretés ont les mêmes valeurs.";
// Glossiness is simply the opposite of roughness
material.refraction.surface = "Surface";
// Synonym: turbidity
material.refraction.interior = "Intérieure";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Peinture brillante";
material.paintGlossy.help = "L'objet sera peint avec une rugosité et une métallité nulles, permettant ainsi une réfraction nette.

Cela revient à utiliser la commande « Tout peindre » du menu Peinture, avec la couleur désactivée.";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Absorption";
material.absorptionEnable.help = "Simulez la lumière absorbée lorsqu'elle traverse le volume.

Les pièces fines s'illumineront, car elles laisseront passer plus de lumière, tandis que les zones épaisses seront plus sombres.

L'effet dépend fortement de la forme de l'objet. Seule une approximation de l'épaisseur de l'objet est utilisée.";
material.absorptionFactor = "Facteur";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "Profondeur";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "Translucidité";
material.translucency.help = "Pour voir la translucidité, la lumière doit projeter des ombres.";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Opacité";
// Fully opaque material
material.type.opaque = "Opaque";
material.type.opaque.help = "Ceci est le type de matériau par défaut.

L'alpha du sommet peint, la texture d'opacité ou le canal alpha du canal de couleur seront toujours pris en compte via le tramage.

Seul le curseur principal d'opacité sera ignoré.";
// Fully opaque material
material.type.shadowCatcher = "Piège à ombres";
material.type.shadowCatcher.help = "Rendre l'objet complètement transparent, sauf pour les ombres projetées par les lumières.

Ce mode est généralement utilisé sur la géométrie plane.";
material.type.shadowCatcher.warning = "Il n'y a pas de lumières avec des ombres dans votre scène, le Lancer d'Ombres sera inactif. 

Sinon, si le capteur d'ombre est entièrement métallique, il peut refléter la scène si le Traitement Après Coup (Reflection) est activé.";
// See glossary
material.type.subsurface = "Transluminescence";
material.type.subsurface.help = "Pour obtenir de bons résultats, vous pouvez passer en mode d'ombrage PBR et utiliser au moins une lumière directionnelle, idéalement dans un environnement peu éclairé.";
// Transparency mode, alpha blendingd
material.type.blending = "Fusion";
material.type.blending.help = "Rendez l'objet translucide en ajustant la valeur d'opacité.

Notez qu'en raison de contraintes de calcul en temps réel, des artefacts visuels peuvent être perceptibles si l'objet a une forme complexe.";
// Transparency mode
material.type.additive = "Additif";
material.type.additive.help = "Rendez l'objet translucide en ajustant la valeur d'opacité.

Cette méthode a tendance à générer moins d'artefacts que la méthode Fusion, mais l'objet sera plus lumineux.";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Tramage";
material.type.dithering.help = "Rendez l'objet translucide en écartant certains pixels de manière aléatoire.";
// Simulate glass-like material
material.type.refraction = "Réfraction";
material.type.refraction.help = "Ce mode permet de simuler un matériau en verre.

En raison de contraintes de calcul en temps réel, l'auto-réfraction et la réfraction multicouches sont limitées.";
material.castShadows = "Projeter des ombres";
material.receiveShadows = "Recevoir des ombres";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Toujours éteint";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Inverser l'élimination";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Réflectance";
material.reflectance.help = "Contrôlez la quantité de reflets que le matériau recevra pour les matériaux non métalliques.

La plupart du temps, la valeur par défaut doit être utilisée (qui correspond à un reflet lumineux standard de 4 % à angle normal).";
// Material preview in the viewport
material.preview = "Aperçu de la couleur du matériau";
material.preview.help = "Lorsque vous modifiez un matériau, un aperçu sera affiché dans le viewport sur l'objet sélectionné.

L'aperçu est montré pendant que vous interagissez avec les curseurs de couleur, de rugosité, de métallicité, d'opacité et d'intensité.";
// Menu name
menu.files = "Fichiers";
// Menu name
menu.scene = "Scène";
// Menu name
menu.multires = "Multirésolution";
// Menu name
menu.voxel = "Voxel";
// Menu name
menu.dynamic = "DynTopo";
// Menu name (Synonym: Misc, Other)
menu.topology = "Divers";
// Menu name
menu.primitive = "Primitive";
// Menu name
menu.render = "Générer le rendu";
// Menu name
menu.material = "Matériau";
// Menu name
menu.postprocess = "Post-traitement";
// Menu name
menu.camera = "Caméra";
// Menu name
menu.background = "Arrière-plan";
// Menu name
menu.tool = "Outil";
// Menu name
menu.stroke = "Pinceau";
// Menu name
menu.alpha = "Alpha";
// Menu name
menu.filter = "Filtre";
// Menu name
menu.falloff = "Atténuation";
// Menu name
menu.paint = "Peinture";
// Menu name
menu.symmetry = "Symétrie";
// Menu name
menu.operation = "Opération";
// Menu name (pencil pressure)
menu.pressure = "Pression";
// Menu name
menu.gesture = "Geste";
// Menu name
menu.layers = "Calques";
// Menu name
menu.settings = "Réglages";
// Menu name
menu.interface = "Interface";
// Menu name
menu.bindings = "Raccourcis";
// Menu name
menu.history = "Historique";
// Menu name
menu.historySettings = "Réglages";
// Menu name
menu.about = "À propos";
// Menu name
menu.debug = "Débogage";

// Operation on the object (action)
mesh.holes = "Trous";
// If the object has holes, the algorithm will close them
mesh.holes.close = "Boucher les trous";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holes.detail = "Détail";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Séparer";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "Les calques, la peinture et la multirésolution seront perdus.";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Résolution";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Mettre en cube";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Convertir";
// Static object means "static topology"
mesh.static = "Maillage";
// See glossary
mesh.multires = "Multires";
// Dynamic topology
mesh.dynamic = "DynTopo";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Matériau général";
paint.useGlobal.help = "Si cette option est activée, le matériau sélectionné sera identique aux autres outils.

Notez que seuls les réglages de rugosité, de métallité et de couleur sont pris en compte.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Peinture sur pinceau";
// If true save the textures data into
paint.preset.embed = "Incorporer des textures";
paint.preset.embed.help = "Les textures se trouvent dans le dossier Nomad textures/.
Les préréglages de matériaux se trouvent dans le dossier Nomad materials/.

Lorsque cette option est désactivée, le préréglage de matériau ne fait que référencer la texture contenue dans le dossier textures/.

Vous pouvez activer cette option pour faire une copie des textures à l'intérieur du préréglage de matériau.
Cela peut être utile si vous souhaitez partager un préréglage texturé sans fournir les textures associées.";
paint.preset.embed.apply = "Appliquer à tous les matériaux";
// Factor/Opacity of paint tool
paint.intensity = "Intensité de la peinture";
// Apply the paint on the object
paint.paintAll = "Tout peindre";
paint.paintAll.help = "Appliquez le matériau actuel à l'objet.";
paint.paintAll.help.mask = "La zone masquée ne sera pas affectée.";
paint.paintAll.help.hide = "La zone cachée ne sera pas affectée.";
paint.paintAll.help.opacity = "Utilisez le facteur de peinture de l'outil ci-dessus.";
paint.paintAll.help.layer = "La zone non peinte d'une couche ne sera pas affectée.";
paint.strokePainting.title = "Peinture";
// Brush stroke texture
paint.texture.warningEnable = "Pour que la projection de texture puisse fonctionner, vous devez activer la peinture sur pinceau (case du haut) !";
paint.texture.warningIgnored = "L'outil en cours ne peut pas utiliser de textures !";
// use stencil mode
paint.stencil = "Pochoir";
// Inherit stroke falloff option for the painting
paint.tool.help = "Utilisez l'alpha, l'atténuation et l'aléatoire de l'outil pour moduler l'intensité du pinceau.

Ces options sont ignorées pour la fonctionnalité de peinture complète, mais l'alpha est prise en compte pour la variante triplanar.";
// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "Nouveau nom";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "Nouvelle valeur";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "Nouvelle couleur (format hexadécimal)";

// Post process effect
postprocess = "Post-traitement";
// Denoise
postprocess.denoise = "Filtre anti-bruit";
postprocess.denoise.help = "Appliquez un passage de débruitage après que tous les cadres sont accumulés.";
postprocess.denoise.warning = "C'est une opération coûteuse, n'activez cet effet que si l'image est bruitée.";
// Quality vs performance
postprocess.quality = "Qualité";
postprocess.quality.help = "Activez ces options pour améliorer la qualité, au détriment des performances.";
// More samples means better quality but slower performance
postprocess.maxSamples = "Nombre max. d'échantillons";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Résolution maximale";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "Nombre max. d'images échantillonnées";
postprocess.accumulateCount.help = "Nombre maximal d'images à accumuler avant l'arrêt du rendu.

Lorsque le rendu s'arrête, Nomad ne fait rien, ce qui permet d'économiser la batterie.

De nombreuses fonctions de rendu bénéficient de l'accumulation des images, dont :
• Ombres douces
• Illumination générale
• Reflet (SSR)
• Occlusion ambiante
• Transluminescence 
• Profondeur de champ

Un nombre d'images élevé est surtout nécessaire pour les ombres douces et l'illumination générale.
Nomad peut arrêter le rendu plus tôt si les fonctions mentionnées ci-dessus sont désactivées.";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Résolution de rendu";
postprocess.renderRatio.warning = "Remplacée par l'effet Pixel Art.";
postprocess.renderRatio.help = "Cette option influe significativement sur les performances.
Il est conseillé de conserver une valeur inférieure à x1,25.

Cette option n'est pas enregistrée dans les réglages.";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taa = "Anti-crénelage (TAA)";
postprocess.taa.help = "Réduit le scintillement lorsque vous déplacez la caméra.";
// Ditherhing pixel
postprocess.dithering = "Tramage";
postprocess.dithering.help = "Dither les pixels pour réduire les artefacts de banding.";
// Screen-Space Reflection (no need to translate "SSR")
postprocess.ssr = "Reflet (SSR)";
postprocess.ssr.warning = "La fonction SSR nécessite le mode d'ombrage PBR.";
// Screen-Space Global Illumination (no need to translate "SSGI")
postprocess.ssgi = "Illumination générale (SSGI)";
// Thickness threshold for ssgi tracing algorithm (synonym: threshold, bias)
postprocess.ssgi.tolerance = "Tolérance";
postprocess.ssgi.warning = "La fonction SSGI nécessite le mode d'ombrage PBR.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssao = "Occlusion ambiante";
// How far the effect spreads
postprocess.ssao.radius = "Taille";
// How strong the effect is
postprocess.ssao.factor = "Force";
// Adjustment to fix artefacts
postprocess.ssao.bias = "Biais de courbure";
postprocess.ssao.bias.help = "La sensibilité de l'effet dépend de la courbure de la surface.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dof = "Profondeur de champ";
// The blur factor behind the focused point
postprocess.dof.blurFar = "Flou lointain";
// The blur factor in front of the focused point
postprocess.dof.blurNear = "Flou proche";
postprocess.dof.focusTip = "Appuyez sur un objet pour changer la mise au point.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloom = "Éclat";
// Intensity of the effect
postprocess.bloom.intensity = "Intensité";
// How far the effect spreads
postprocess.bloom.radius = "Rayon";
postprocess.bloom.radius.help = "Ampleur de l'éclat.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloom.threshold = "Seuil";
postprocess.bloom.threshold.help = "Seuil de luminosité déterminant si un pixel émet ou non un éclat.
Si la valeur est à 0, l'éclat sera général.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.tone = "Mappage tonal";
postprocess.tone.exposure = "Exposition";
postprocess.tone.contrast = "Contraste";
postprocess.tone.saturation = "Saturation";
postprocess.tone.hue = "Teinte";
// No tonemapping operator is used
postprocess.tone.mapping.none = "Aucun";
// A neutral tonemapping is used
postprocess.tone.mapping.neutral = "Neutre";
// Color curves
postprocess.curve = "Étalonnage";
// Curve for pixel luminance
postprocess.curve.luminance = "Principale";
postprocess.curve.red = "Rouge";
postprocess.curve.green = "Vert";
postprocess.curve.blue = "Bleu";
// Reset color grading curves
postprocess.curve.resetAll = "Tout réinitialiser";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromatic = "Aberration chromatique";
postprocess.chromatic.factor = "Force";
// Darking on the edges
postprocess.vignette = "Vignetage";
// How far the effect spreads
postprocess.vignette.size = "Taille";
// How sharp the edge of the effect is
postprocess.vignette.hardness = "Dureté";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpness = "Netteté";
postprocess.sharpness.factor = "Force";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grain = "Grain";
postprocess.grain.factor = "Force";
// Accentuate the edges of the model
postprocess.curvature = "Courbure";
// main strength of curvatre
postprocess.curvature.factor = "Facteur";
// Color/Strength of concave curvature
postprocess.curvature.cavity = "Creux";
// Color/Strength of convex curvature
postprocess.curvature.bump = "Bosse";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArt = "Pixel Art";
// Override frame accumulation feature
postprocess.pixelArt.allowAccumulate = "Autoriser l'échantillonnage des images";
// Simulate scanline rendering (horizontal line)
postprocess.scanline = "Scanline";
postprocess.scanline.factor = "Facteur";
// Spacing between lines
postprocess.scanline.spacing = "Espacement";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Primitive";
primitive.box = "Boîte";
primitive.sphereCube = "Sphère Quad";
primitive.sphereUV = "Sphère UV";
primitive.icosahedron = "Icosaèdre";
primitive.cylinder = "Cylindre";
primitive.cone = "Cône";
primitive.torus = "Tore";
primitive.lathe = "Tour";
primitive.tube = "Tube";
primitive.plane = "Plan";
primitive.triplanar = "Triplanaire";
primitive.needValidate = "La primitive doit être validée!";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Modifier";
primitive.edit.help = "Autoriser l'édition 3D dans la fenêtre d'affichage.

Vous pouvez désactiver cette fonction si vous souhaitez interagir avec l'outil Gizmo ou l'outil Transformation sans modifier la primitive.";

// Primitive configuration
primitive.mainConfig = "Paramètre";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Topologie";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Géométrie";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Valider";
// Maximum number of faces of the primitives
primitive.maxFaces = "Nombre max. de faces";
primitive.maxFaces.help = "Nombre maximal de faces dans une primitive.

Cette limite n'est active que tant que la primitive n'a pas été validée. Ensuite, elle n'est plus respectée.";
// Synonym: Flat subdivision
primitive.linear = "Subdivision linéaire";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Subdivision secondaire";

// Radius (of a sphere, torus, etc)
primitive.radius = "Rayon";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radius.sync = "Même rayon";
primitive.radius.start = "Début du rayon";
primitive.radius.end = "Fin du rayon";
// Size (of cube x dimension)
primitive.size = "Taille";
primitive.sizeX = "Taille X";
primitive.sizeY = "Taille Y";
primitive.sizeZ = "Taille Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "Division";
primitive.divisionX = "Division X";
primitive.divisionY = "Division Y";
primitive.divisionZ = "Division Z";
// Angle of torus, etc
primitive.angleX = "Angle X";
primitive.angleY = "Angle Y";
primitive.angleZ = "Angle Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Densité constante";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Projeter sur une sphère";
primitive.projectOnSphere.help = "Permet d'aligner les points sur une sphère parfaite.";

// triplanar
primitive.triplanar.title = "Triplanaire";
primitive.triplanar.title.help = "La fonction Triplanaire utilise les informations de masque de trois plans pour remplir une grille de voxels qui est ensuite polygonisée.

Si vous interagissez avec les curseurs de division ou de taille, les informations de peinture seront réinitialisées (le lissage restera inchangé).

Vous devrez probablement désactiver la symétrie, car elle peut générer des résultats inattendus.

Vous pouvez utiliser l'option « Liés par topologie » dans le panneau de masque pour peindre un plan influant sur les autres plans.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanar.sameSize = "Taille identique (cube)";
primitive.triplanar.polish = "Lissage";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanar.resetMask = "Réinitialiser le masque";
// One side of a cube (the back plane)
primitive.isolate.back = "Retour";
// One side of a cube (the right plane)
primitive.isolate.right = "Droite";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Bas";
// Plane
primitive.planeSameSize = "Taille identique (carré)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "Disque";
// Box
primitive.boxRegular = "Taille identique (cube)";
// Torus
primitive.torus.radiusOuter = "Rayon extérieur";
primitive.torus.radiusInner = "Rayon intérieur";
primitive.torus.angle = "Angle";
primitive.torus.angleOffset = "Décalage d'angle";
// Cylinder
primitive.cylinder.height = "Hauteur";
// Cone
primitive.cone.radius = "Rayon";
primitive.cone.height = "Hauteur";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Trou";
// Make a hole in the primitive to make it hollow
primitive.hasHole = "Comporte un trou";
// Curve profile (synonym: profile, curve)
primitive.profile = "Profil";
primitive.profile.viewport = "Afficher dans le viewport";
// If the revolution surface has caps (E.g: cylinder)
primitive.cap = "Capuchon";

// Singular of Repeaters (Nodes that make many copies of its children (type of mirror/curve/array/radial))
repeater = "Répéteur";
// All the new items will be inserted inside the bound rather than outside
repeater.array.fitInside = "Adapter à l'intérieur";
// The object will follow the curve
repeater.curve.align = "Aligner";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Importer…";
// iOS Photos gallery
resource.import.ios.photos = "Photos";
// iOS Files App
resource.import.ios.files = "Fichiers";

scene.title = "Scène";
scene.title.help = "Lorsque vous utilisez les boutons Visible/Sélectionner, appuyez de façon prolongée pour sélectionner facilement d'autres objets.

Vous pouvez également appuyer de façon prolongée sur les boutons Visible/Sélectionner pour influer sur les enfants.";
// The view will focus on the item when we click on it
scene.focus = "IU : Se concentrer sur l'élément lors du double tap";
// Add new object on gizmo position
scene.addOnGizmo = "Sur le gizmo";
scene.addOnGizmo.help = "Déplacer le nœud sur la position du gizmo (si l'outil gizmo est sélectionné)";
// Select the gizmo tool after adding a new object
scene.addSelectGizmo = "Sélectionner le gizmo";
scene.addSelectGizmo.help = "Sélectionnez l'outil gizmo lors de l'ajout d'un nouveau nœud";
// Icon size in pixel (min/max)
scene.iconSize = "Taille d'icône";
// Min size of icon
scene.iconSize.min = "Min";
// Max size of icon
scene.iconSize.max = "Max";
// display hierarchy lines (visibility helper)
scene.showHierarchy = "Lignes hiérarchiques";
scene.showHierarchy.help = "Afficher une ligne entre le parent et ses enfants dans le viewport.";
scene.showHierarchyNomadPivot = "Utiliser le pivot Nomad";
scene.showHierarchyNomadPivot.help = "Le pivot Nomad est le pivot utilisé par les outils de Transformation et Gizmo.

Si cette option est désactivée, il utilisera le pivot de base naturel.
Dans certains cas, ce pivot de base peut être loin du centre de l'objet lui-même!";
// The view will focus on the item when we click on it
scene.syncVisible = "Synchroniser la visibilité";
scene.syncVisible.help = "Lorsqu'activé, utiliser l'icône visible (œil) impactera tous les éléments sélectionnés.";
// Merge 2 objects without modifying the geometry or the topology
scene.join = "Lier";
// Group the selected object with a new created Empty Node as a parent
scene.group = "Groupe";
// Move the item outside its parent (synonym: ungroup)
scene.unparent = "Dégrouper";
// Mirror node type, a node that make many copies of its children (mirror symmetry)
scene.mirror = "Miroir";
// Curve node type, a node that make many copies of its children (along a curve)
scene.curve = "Courbe";
// Array node type, a node that make many copies of its children (grid repetition pattern)
scene.array = "Matrice";
// Radial node type, a node that make many copies of its children (radial symmetry)
scene.radial = "Radiale";
// Nodes that make many copies of its children (type of mirror/curve/array/radial)
scene.repeaters = "Répéteurs";
scene.repeaters.help = "Nœuds répéteurs qui font des instances de toutes les géométries en dessous dans la hiérarchie de la scène.";
// Validate button
scene.validateGroup = "Valider";
// Keep instances in the scene
scene.validateGroup.keepInstances = "Conserver les instances";
// If we should join children
scene.validateGroup.joinChildren = "Lier les enfants";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Fusion de voxels";
scene.voxelResolution = "Résolution";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Soustraction : masquer l'objet";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Intersection : tous les objets sont masqués";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "Aucun objet sélectionné, veuillez sélectionner au moins un objet.";
// Need to select one object only
scene.noneButNeedOne = "Aucun objet sélectionné, veuillez sélectionner un objet.";
// Need to select one object only
scene.onlyOneObject = "Plusieurs objets sont sélectionnés, veuillez ne sélectionner qu'un seul objet.";
// Boolean operation
scene.boolean = "Booléen";
scene.boolean.help = "Fusionnez, soustrayez ou intersectez des objets en effectuant une opération booléenne.

L'opération peut échouer si certains objets ne sont pas des variétés ou ne sont pas étanches.

Si l'opération booléenne échoue, vous pouvez toujours utiliser le remaillage voxel sur l'objet problématique pour garantir qu'il soit une variété étanche.";
// Weld intersection
scene.boolean.mergeIntersection = "Souder l'intersection";

// General scene display settings
settings.display.title = "Réglages d'affichage";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Filaire";
// Display the material texture
settings.debugChannel = "Afficher la Texture";
// Display the material texture in the background
settings.debugChannel.onBackground = "En Arrière-plan";
// Display the material texture on the mesh
settings.debugChannel.onMesh = "Sur le maillage";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Recto verso";
settings.twoSided.help = "Les faces seront visibles des deux côtés.";
// If we colorize the inverted side of faces
settings.backface.color = "Couleur de la face arrière";
// Color of the inverted side of faces
settings.backface.colored = "Face arrière colorée";
// Outline (contour highlight around the selected object)
settings.outline = "Contour";
// Outline (contour highlight around the selected object)
settings.outline.help = "Les objets sélectionnés seront entourés.";
settings.outline.thickness = "Épaisseur";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Cube d'alignement";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "En bas";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "A gauche";
// Flip the camera (rotate 180° to see the other side)
settings.snapCube.flip = "Retourner 180°";
settings.snapCube.flip.help = "Retourner la vue si elle est déjà ancrée.";
// Alignment (can be auto/on/off)
settings.snapCube.align = "Restreindre l'alignement";
settings.snapCube.align.help = "Aligner les vues sur l'axe du monde. Si activé, seulement 6 vues d'ancrage sont possibles.

En Auto, la restriction ne se produira que si la caméra est en mode Orbite.";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Statistiques";
settings.stats.right = "Droite";
settings.stats.all = "Afficher la scène complète";
// Grid
settings.grid = "Grille";
// Cursor
settings.cursor.title = "Curseur";
settings.cursor.whileSculpting = "Afficher un cercle pendant la sculpture";
// A small indicator dot
settings.cursor.showDot = "Afficher le petit point";
settings.cursor.showDot.help = "Le point peut s'afficher comme point de pivot de la caméra ou quand vous sculptez.";
settings.cursor.showRope = "Afficher le stabilisateur de corde";
// indicator
settings.indicator.title = "Indicateur";
settings.indicator.title.help = "Afficher un indicateur visuel (tutoriels, capture d'écran, etc).";
settings.indicator.size = "Taille";
// Highlight (the object glows when we select it)
settings.highlight.selection = "Mettre la sélection en surbrillance";
// Highlight settings
settings.highlight = "Surbrillance";
settings.highlight.duration = "Durée";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Assombrir les objets non sélectionnés";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Ombrage lisse";
// Experimental feature
settings.partialDraw = "Dessin partiel";
settings.partialDraw.help = "Fonction expérimentale !

Utilisez-la si vous sculptez une partie relativement petite d'un maillage comportant de nombreux polygones.

Elle devrait permettre de lisser la sculpture, mais n'activez pas le filaire !

Elle risque également d'ajouter des artefacts visuels pendant les coups de pinceau.";
settings.partialDraw.warning = "N'oubliez pas de désactiver cette option si les artefacts visuels sont trop gênants !";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Afficher la peinture";
// Show and use the masking on the mesh
settings.showMasking = "Afficher le masque";
// Disable this option to force show the hidden faces
settings.showDiscard = "Utiliser Masquer";
// Show icon on the canvas
settings.icon = "Icône";
// Show icons on the canvas
settings.icons = "Icônes";
// Tooltip
settings.icons.help = "Affichez une icône sur la zone de travail pour pouvoir les sélectionner et les modifier directement.";
// Hole filling settings
settings.hole = "Remplissage des trous";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Remplir les trous non-variété";
settings.hole.nonManifold.help = "Essayer de remplir le trou non-variété.
Cette option n'est pas enregistrée dans les réglages.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Nombre max. de sommets";
settings.multires.maxVertices.help = "Nomad ne contrôle pas la mémoire avant la subdivision. Des plantages peuvent facilement survenir en présence de nombreux polygones.";
settings.multires.lowResVertices = "Seuil de basse résolution";
settings.multires.lowResVertices.help = "Le maillage peut être affiché dans une résolution inférieure quand vous déplacez la caméra.

Vous pouvez augmenter cette valeur pour afficher le maillage dans une résolution plus élevée.";

// The main rendering mode
shading = "Ombrage";
// Main rendering mode (PBR stands for Physically Based Rendering)
shading.pbr = "Allumé (PBR)";
shading.pbr.help = "Dans ce mode, vous pouvez ajouter des lumières (avec des ombres), ainsi qu'un environnement HDR.

Vous pouvez également peindre la métallité et la rugosité, et ainsi contrôler plus finement de l'aspect de votre matériau.";
// Fast rendering mode for sculpting purpose
shading.matcap = "MatCap";
shading.matcap.help = "Abréviation de MATerial CAPture, un MatCap gère à la fois les informations d'éclairage et de matériau d'une image. 

Ce mode de rendu rapide est avant tout adapté à la sculpture brute.";
// Unlit rendering mode, it simply displays a solid/flat color
shading.unlit = "Éteint";
shading.unlit.help = "Mode d'ombrage avec couleur unie, sans éclairage.";
// Helper rendering mode that display solid colors
shading.object = "Objet ID";
shading.object.help = "Mode de rendu Éteint, avec attribution d'une couleur aléatoire à chaque objet.

Ce mode est particulièrement utile pour les scènes comportant beaucoup d'objets.";
// Helper rendering mode that display solid colors
shading.instance = "Instance ID";
shading.instance.help = "Identique à ID d'objet, mais les instances auront la même couleur.";
// Helper rendering mode that display solid colors
shading.material = "ID de matériau";
shading.material.help = "Afficher une couleur uniforme pour chaque instance de matériau.";
// Randomize colors
shading.id.randomize = "ID aléatoire";
shading.textures = "Utiliser des textures";
shading.textures.help = "Pour le moment, vous ne pouvez pas créer ni modifier de textures dans Nomad.

Vous devriez en revanche pouvoir importer un fichier contenant des textures.

• Textures acceptées
Opacité : Allumé, MatCap, Éteint
Normal : Allumé, MatCap
Couleur: Allumé, Éteint
Émissif : Allumé
Rugosité : Allumé
Métallité : Allumé";
// Lights
shading.lights = "Lumières";
shading.lights.addLight = "Ajouter une lumière";
shading.lights.warning = "La fonction Lumières nécessite le mode d'ombrage PBR.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Environnement";
shading.environment.import = "Importer HDR";
shading.environment.exposure = "Exposition";
shading.environment.backgroundBlur = "Flou (arrière-plan)";
shading.environment.rotation = "Rotation";
shading.environment.rotation.help = "Vous pouvez faire pivoter l'environnement en faisant glisser trois doigts horizontalement sur la fenêtre d'affichage.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environment.attachedToCamera = "Fixé à la caméra";
shading.environment.attachedToCamera.help = "Fixez l'environnement à la caméra.

L'éclairage sera ainsi constant, ce qui peut être utile pour la sculpture.";
shading.matcap.rotation = "Rotation";
shading.matcap.rotation.help = "Vous pouvez faire pivoter le MatCap en faisant glisser trois doigts horizontalement sur la fenêtre d'affichage.";
shading.matcap.global = "Utiliser un MatCap général";
shading.matcap.global.help = "Décochez cette option si vous souhaitez utiliser un autre MatCap pour ce maillage particulier.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible = "Masquer";
shortcut.solo = "Solo";
shortcut.xray = "Rayons X";
shortcut.voxelRemesh = "Voxel";
shortcut.wireframe = "Fil";
shortcut.cameraReset = "Réinitialiser";
shortcut.cameraSnap = "Aligner";
shortcut.lockSelection = "Verrouiller";
shortcut.lockSelection.help = "Quand cette option est activée, vous ne pouvez pas modifier la sélection en appuyant sur un maillage.";
shortcut.grid = "Grille";

// Memory taken by the scene
stat.ramScene = "Scène";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramScene = "Scène VRAM";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramRender = "Rendu VRAM";
// Vram = Video RAM (Video Memory, the memory of the graphic card)
stat.vramTextures = "Textures VRAM";
// Memory taken by the undo/redo history
stat.ramHistory = "Historique";
// Memory taken by other stuffs
stat.ramOther = "Autre";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "Mémoire utilisée";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "Mémoire libre";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "Utilisée : $0";
stat.free = "Libre : $0";
stat.faces = "Visages";
stat.triangles = "Triangles";
stat.vertices = "Sommets";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Quadrilatères";
stat.vertex = "Sommet";
stat.scene.face = "Faces de la scène";
stat.scene.vertex = "Sommets de la scène";

// Brush stroke
stroke = "Trait";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "Rayon de l'espace global";
// The settings is shared among every tools
stroke.useWorldRadius.help = "Ce réglage est partagé par tous les outils.";
// Share the radius value among every tools.
stroke.useShareRadius = "Partager le rayon";
stroke.useShareRadius.help = "Partagez la valeur du rayon entre tous les outils.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.spacing = "Espacement des traits";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.spacing.adjust = "Ajuster l'intensité de l'espacement";
stroke.minSpacingAdjustIntensity.help = "Réglez l'intensité du pinceau pour que la déformation reste constante en fonction de l'espacement des traits.";
stroke.minSpacing.help = "Espacement entre chaque trait, par rapport au rayon de l'outil.

Avec des valeurs basses, les traits sont plus lisses, au détriment des performances.";
// Brush stroke smoothing
stroke.lazySmooth = "Lissage des traits";
stroke.lazySmooth.help = "Faire la moyenne de plusieurs positions de pointeur pour obtenir un trait plus lisse.

Avec des valeurs élevées, le trait a du retard sur le pointeur, mais il finit par rattraper son retard.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Stabilisateur de corde molle";
stroke.lazyRadius.help = "Les traits sont en retard d'une certaine distance par rapport à la position du pointeur.

Cette fonction peut être utilisée pour tracer des lignes lisses.";
// It is not a per-tool settings
stroke.globalSettings = "Ce réglage est général";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Rayon d'alignment'";
stroke.snapRadius.help = "Aligner le tracé si le pointeur se trouve près du dernier tracé enregistré.

Cette fonction peut être utile lorsque vous dessinez de longs traits continus tout en faisant des pauses fréquentes.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Décalage de trait";
stroke.sculptOffset.help = "Appliquez un décalage constant au trait.

Cette option facilite l'utilisation des gestes tactiles sur les petits écrans, de sorte que votre doigt ne recouvre pas le trait.";
stroke.accumulate = "Accumuler les traits";
stroke.accumulate.help = "Si cette option est activée, vous pouvez ajouter/supprimer autant de mouvements que vous le souhaitez pour chaque trait.";
// The tool can use DynTopo
stroke.useDynamic = "Autoriser la topologie dynamique";
// Only sculpt the part that are linked topologically
stroke.connect = "Topologie connectée";
stroke.connect.help = "Cette option sculptera uniquement les sommets reliés à la surface sélectionnée.

Elle s'utilise généralement avec l'outil Déplacer, par exemple si vous voulez déplacer seulement une pièce qui s'entrecroise avec une autre pièce.";
stroke.connect.short = "Connectée";
// sculpt on hide or mask
stroke.protect = "Protéger la zone";
stroke.protect.hide.help = "Lorsque l'option est réglée sur auto, les faces cachées seront modifiées si le maillage sur les faces cachées est visible (voir menu maillage).";
// Only sculpt the vertex that points toward the camera
stroke.culling = "Sommet orienté vers l'avant uniquement";
stroke.culling.help = "Cette option ignore les sommets de la face arrière.

Elle peut être utile si vous voulez peindre une partie d'une géométrie mince sans toucher à l'autre côté.

Elle fonctionne également pour la sculpture, mais risque de générer quelques artefacts.";
// Infinite depth, move everything under the circle, disregarding depth
stroke.silhouette = "Silhouette";
stroke.silhouette.view = "Vue";
stroke.silhouette.snapped = "Si ancré";
stroke.silhouette.closest = "Le plus proche";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.sameSide = "Sommet du même côté uniquement";
stroke.sameSide.help = "Ignorez les sommets qui sont dans la direction opposée à la déformation.";
// determine normal direction
stroke.normal.direction = "";
stroke.normal.direction.help = "";
stroke.normal.direction.normal = "";
stroke.normal.direction.normal.help = "";
stroke.normal.direction.screen = "";
stroke.normal.direction.screen.help = "";
stroke.normal.direction.auto = "";
stroke.normal.direction.auto.help = "";
stroke.normal.direction.auto.threshold = "";
stroke.normal.direction.auto.threshold.help = "";
// small tip/warning
stroke.onlyLasso = "Réglages actifs uniquement pour l'outil Lasso.";

// Here sampling refers to the app gathering information under the mouse
stroke.area = "Échantillonnage de zone";
stroke.area.help = "Certains pinceaux ou options de trait nécessitent un plan normal à la surface pour fonctionner.
Vous pouvez contrôler comment calculer ce plan moyen en réglant la zone d'échantillonnage comme un ratio du rayon de l'outil.

À 100%, tous les points à l'intérieur du cercle de sélection sont pris en compte.
À 0%, seul le sommet ou le triangle le plus proche est pris en compte.";
// Sampling radius size (percent)
stroke.area.normal.radius = "Rayon normal";
// Sampling radius size (percent)
stroke.area.point.radius = "Rayon de position";
// Sampling averaging
stroke.area.normal.average = "Moyenne normale";
// Sampling averaging
stroke.area.point.average = "Moyenne de position";
// Keep sharp edges
stroke.normalFilter = "Filtre de normal";
stroke.normalFilter.help = "
Filtrage par profondeur";

// Only paint the part of the mesh above a certain height
stroke.depthFilter = "Masquage par profondeur";
stroke.depthFilter.help = "Exclure les points qui sont au-dessus ou en dessous d'une certaine distance du plan calculé (Échantillonnage de zone).

Par exemple, cela peut être utilisé pour peindre des bosses ou des cavités.";
stroke.depthFilter.max = "Zone supérieure";
stroke.depthFilter.min = "Zone inférieure";
stroke.depthFilter.offset = "Décalage en hauteur";

// Invert the pixel (black <-> white)
stroke.alpha.invert = "Inverser les pixels";
// Repeat the alpha image (pattern)
stroke.alpha.wrap = "Recouvrement";
// No repeat pattern
stroke.alpha.wrap.none = "Aucun";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alpha.wrap.repeat = "Répéter";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alpha.wrap.mirror = "Miroir";
// Tight fit when using tiling
stroke.alpha.fit = "Adapter à l'intérieur";
stroke.alpha.fit.help = "Cette option est uniquement pertinente si les textures alpha et les brosses ne sont pas carrées.

Lorsqu'activée, chaque image se carrelera de manière indépendante sans espacement.
Vous pouvez désactiver cette option si vous souhaitez synchroniser les images alpha et autres, dans le cas où leurs ratios ne seraient pas les mêmes.";
// Alpha rotation
stroke.alpha.rotation = "Rotation";
stroke.alpha.rotation.lock.help = "Verrouiller l'orientation alpha.

Si la rotation est déverrouillée, l'orientation suivra la direction du trait en temps réel.";
// Repeat the image
stroke.alpha.tiling = "Recouvrement";
// Scale the image (make it bigger or smaller)
stroke.alpha.scale = "Mise à l'échelle";
stroke.alpha.scale.help = "À la valeur minimale, le carré alpha se trouve à l'intérieur du rayon du cercle de l'outil.";
// Middle-point value at which no deformation occurs
stroke.alpha.midValue = "Valeur moyenne";
stroke.alpha.midValue.help = "Valeur intermédiaire à laquelle aucune déformation ne se produit.

(Valeur moyenne = 0)
• Noir : pas de déplacement
• Blanc : déplacement positif

(Valeur moyenne = 0,5)
• Noir : déplacement négatif
• Blanc : déplacement positif

(Valeur moyenne = 1)
• Noir : déplacement négatif
• Blanc : pas de déplacement";
// Synonymous: Scatter/Jitter/Randomize
stroke.jitter = "Aléatoire";
// Sculpt and paint along the brush stroke at regular spacing
stroke.type.dot = "Point";
// Sculpt and paint along with alpha spaced by brush radius
stroke.type.roll = "Rôle";
// Sculpt and paint with alpha projected on screen stencil
stroke.type.tile = "Carreau";
// Sculpt and paint with alpha projected on 3 axis
stroke.type.triplanar = "Triplanaire";
// Sculpt continuously
stroke.type.drag = "Glisser";
// Lock a region and move it around
stroke.type.grab = "Capturer";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.type.grabRadius = "Capturer • Rayon dynamique";
// Lock a region and sculpt it by changing the tool intensity
stroke.type.grabIntensity = "Capturer • Intensité dynamique";

stroke.falloffProject = "Influence";
stroke.falloffProject.help = "• Sphère (3d)
L'influence est calculée en prenant la distance du sommet au centre de la brosse.

• Cercle (2d)
Le sommet est d'abord projeté sur le plan de la zone, avant de prendre sa distance au centre de la brosse.
Cela est similaire à la façon dont les alphas sont échantillonnés.";
stroke.falloffProject.sphere = "Sphère";
stroke.falloffProject.circle = "Cercle";
stroke.falloffProject.cylinder = "Cylindre";

// Symmetry
symmetry = "Symétrie";
symmetry.enable = "Activée";
symmetry.primitiveWarning = "La symétrie de pinceau n'est disponible que pour les primitives validées, sauf pour la primitive triplanaire.";
symmetry.plane.title = "Plans";
symmetry.toolIgnore = "L'outil actuel ignore la symétrie.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Radiale";
symmetry.radialX = "Radiale X";
symmetry.radialY = "Radiale Y";
symmetry.radialZ = "Radiale Z";
// A warning indicating that we limit the number of repetitions ($0 is a number)
symmetry.limited = "Nombre de répétitions limité à $0!";
// Synonym: Offset
symmetry.offset.title = "Décalage";
symmetry.offsetX = "Décalage X";
symmetry.offsetY = "Décalage Y";
symmetry.offsetZ = "Décalage Z";
// Number of clones
symmetry.count.title = "Nombre";
symmetry.countX = "Nombre X";
symmetry.countY = "Nombre Y";
symmetry.countZ = "Nombre Z";
// method
symmetry.method = "Méthode :";
symmetry.method.help = "• Local
Le plan de symétrie se déplace le long du maillage lorsque vous utilisez l'un des outils de transformation (Gizmo ou Transformation). 

• Global
Le plan de symétrie est fixe et ne se déplace pas.";
// Local means: in the coordinate of the scene (synonym: absolute)
symmetry.method.world = "Global";
// Local means: in the coordinate of the object (synonym: relative)
symmetry.method.local = "Local";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Inverser l'objet";
// Cut half of the mesh
symmetry.cut = "Couper";
// after mirroring, separate into multiple output (synonym: split, separate)
symmetry.split = "Scinder";
// Reapply the mesh mirror, does not impact the topology
symmetry.mirror = "Miroir";
symmetry.mirror.help = "Essayez de réappliquer la symétrie sans affecter la topologie.

La symétrie radiale sera ignorée.

Si la topologie ne peut pas être conservée car elle n'est pas considérée comme symétrique, vous aurez la possibilité d'appliquer une symétrie en miroir.";
// indicate that applying the mirror will keep the mesh topology
symmetry.mirror.keepTopology = "conserver la topologie";
symmetry.mirrorFail = "Impossible d'appliquer la symétrie.

Voulez-vous appliquer la symétrie en mettant le maillage en miroir ?";
symmetry.mirrorUseMasking = "Protéger la zone masquée";
symmetry.mirrorUseMasking.help = "Gardez la zone masquée intacte.

Cette option sera ignorée avec une topologie non symétrique (ou une surface déconnectée, comme une paire d'yeux).";
// Reset the symmetry plane position
symmetry.reset = "Réinitialiser";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Centre de l'objet";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "Centre de la scene";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Orientation";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Afficher la ligne";
// Display the symmetry plane in 3D
symmetry.showPlane = "Afficher le plan";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Modification Gizmo";
symmetry.edit.warning = "La fonction de modification de symétrie est expérimentale.";
symmetry.edit.help = "Vous pouvez définir librement le plan de symétrie.

Cette fonctionnalité est expérimentale et nous vous déconseillons de l'utiliser.";

// Ideally <10 chars
tool.dynamic = "DynTopo";
// Ideally <10 chars (Symmetry)
tool.symmetry = "Sym";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "Miroir";
// Ideally <10 chars
tool.clay = "Argile";
// Ideally <10 chars (Subtract)
tool.clay.sub = "Soustraire";
// Ideally <10 chars
tool.brush = "Pinceau";
// Ideally <10 chars
tool.move = "Déplacer";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "Normale";
// Ideally <10 chars
tool.drag = "Glisser";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "Lisser";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Relâcher";
// Ideally <10 chars (Paint mask)
tool.mask = "Masquer";
// Ideally <10 chars
tool.mask.unmask = "Démasquer";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "MasqueSél";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "Estomper";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "Aplatir";
// Ideally <10 chars (Flatten the surface, more strongly than Flatten)
tool.planar = "Plan";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Remplir";
// Ideally <10 chars (Layer brush)
tool.layer = "Calque";
// Ideally <10 chars
tool.crease = "Plier";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "Découper";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Scinder";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "Projeter";
// Ideally <10 chars
tool.inflate = "Gonfler";
// Ideally <10 chars
tool.pinch = "Pincer";
// Ideally <10 chars
tool.nudge = "Décaler";
// Ideally <10 chars
tool.stamp = "Tampon";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "SupprCalque";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.select = "Sélectionner";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "Gizmo";
// Ideally <10 chars
tool.gizmo.editPivot = "Pivot";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "Caler";
// Ideally <10 chars (Snap translation)
tool.gizmo.moveSnap = "Caler";
// Ideally <10 chars (Local/Relative space)
tool.gizmo.local = "Local";
// Ideally <10 chars (Align/Snap the gizmo to world axis)
tool.gizmo.align = "Aligner";
// Ideally <10 chars (Pin the gizmo, so that it stays in place when switching between objects)
tool.gizmo.pin = "Épingler";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "Transformation";
// Ideally <10 chars (Translate the object)
tool.transform.move = "Déplacer";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "Pivoter";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "Échelle";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "Caler";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "Mesurer";
// Ideally <10 chars (Lattice, deformer)
tool.lattice = "Treillis";
// If an option is shared among the tools
tool.all = "Tout";
// Ideally <10 chars (Quad Remesher)
tool.remesh = "Quad Remesher";
tool.remesh.guides = "Guides";
tool.remesh.density = "Densité";
tool.remesh.same = "Identique";
tool.remesh.half = "Moitié";
// Ideally <10 chars (FaceGroup)
tool.faceGroup = "Groupe de faces";
tool.faceGroup.autoPick = "Sélection auto";
tool.faceGroup.flush = "Supprimer inutilisés";
tool.faceGroup.skip = "Ignorer les petits groupes basés sur :";
tool.faceGroup.skipFace = "Nombre de faces";
tool.faceGroup.skipFace.help = "Ne créez pas un nouveau groupe si le nombre de faces est inférieur ou égal à ce seuil.";
tool.faceGroup.skipArea = "Surface";
tool.faceGroup.skipArea.help = "Ne créez pas un nouveau groupe si la surface du nouveau groupe est inférieure à ce seuil.

Le seuil est donné en pourcentage de la surface totale de l'objet.";
// Ideally <10 chars (Hide)
tool.hide = "Masquer";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "Vue";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "Tour";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "Tube";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "Insérer";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "Retourner";
// Ideally <10 chars (No shape selected, same as Camera mode, does nothing in particular)
tool.shape.view = "Vue";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "Lasso";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Courbe";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Polygone";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Tracé";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "Rect";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "Ellipse";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "Ligne";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Fermé";

// Radius of the tool (size)
tool.radius = "Rayon";
// Intensity of the tool (force)
tool.intensity = "Intensité";

tool.settings = "Réglages";
tool.settings.none = "Cet outil n'a pas de réglages spécifiques.";

tool.crease.pinchFactor = "Force de pincement";
tool.crease.offsetFactor = "Facteur de décalage";

tool.layer.removeInfluence = "Utiliser les données du calque";
tool.layer.removeInfluence.help = "Cette option n'est active que lorsqu'un calque est sélectionné.

Elle utilise les données du calque pour limiter le déplacement sur les traits.";
tool.layer.noLayerSelected = "Cette option n'est disponible que si un calque est sélectionné";

tool.flatten.planeLockOrigin = "Verrouiller l'origine du plan";
tool.flatten.planeLockNormal = "Verrouiller la direction du plan";

// Option for Tube, Lathe and Insert tool
tool.syncInstance = "Synchroniser";
tool.syncInstance.message = "Le nouvel objet sera ajouté sur toutes les autres instances !";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Sommet collant sur la bordure";
tool.smooth.screen = "Lissage de l'écran";
tool.smooth.screen.help = "Utilisez cette option pour obtenir un lissage indépendant de la topologie, même sur des polygones élevés.";
tool.smooth.screen.samples = "Échantillons de l'écran";
tool.smooth.stable = "Lissage stable";
tool.smooth.stable.help = "Essaie de rendre le lissage indépendant de la topologie.

Ce mode fonctionne mieux avec une densité de topologie variable et avec une valeur élevée d'intensité de lissage.";

tool.paint = "Peinture";
// Erase the painting
tool.paint.erase = "Effacer";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Filtrage par calque";
tool.paint.layerFilter.help = "Utilisez cette option si vous souhaitez uniquement repeindre la zone déjà peinte d'un calque.";

// Clear the painted mask
tool.mask.clear = "Effacer";
tool.mask.clearAll = "Tout effacer";
// Invert the painted mask
tool.mask.invert = "Inverser";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Inverser le masque (connecté)";
// Blur the painted mask
tool.mask.blur = "Flou";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Netteté";
// Transform/Matrix
tool.matrix = "Matrice";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.target = "Cible";
// Automatic
tool.matrix.target.auto = "Auto";
tool.matrix.target.auto.help = "Par défaut, le résultat est le même qu'avec l'option Groupe.
Si le maillage comporte un masque ou si la symétrie est activée, cette option fonctionne de la même manière que l'option Sommet.";
// Auto apply the transform on the vertices
tool.matrix.target.vertex = "Sommet";
tool.matrix.target.vertex.help = "Essayez d'appliquer la transformation aux sommets. Elle ne fonctionnera pas sur les primitives non validées.
Les instances seront également affectées.";
// Transform the object alone (the children stands still)
tool.matrix.target.object = "Objet";
tool.matrix.target.object.help = "Déplacez seulement l'objet en ignorant la symétrie et le masquage.
Seul le nœud modifié sera déplacé. Les enfants resteront à la même place.";
// Transform the object and its children
tool.matrix.target.group = "Groupe";
tool.matrix.target.group.help = "Déplacez le nœud en ignorant la symétrie et le masquage.
Le reste de la hiérarchie sera également transformé.";
// Operation on the mesh
tool.matrix.action = "Opération";
tool.matrix.action.origin = "Déplacer l'origine";
tool.matrix.action.origin.help = "Déplacez le maillage vers l'origine de de la scène.";
tool.matrix.action.bake = "Appliquer";
tool.matrix.action.bake.help = "Appliquez la matrice au sommet et réinitialisez la matrice. Visuellement, rien ne devrait changer.";
tool.matrix.action.reset = "Réinitialiser";
tool.matrix.action.reset.help = "Réinitialisez la transformation de maillage à l'identique.";

// Synonym: shear, https://en.wikipedia.org/wiki/Shear_matrix or https://en.wikipedia.org/wiki/Shear_mapping
tool.matrix.skew = "Cisaillement";
tool.matrix.translation = "Translation";
tool.matrix.rotation = "Rotation";
tool.matrix.scale = "Échelle";
tool.matrix.uniformScale = "Échelle uniforme";

tool.transform.tip = "Appuyez une fois avec un deuxième doigt pour changer de mode";

// Size of the gizmo
tool.gizmo.size = "Taille du widget";
// If true, there is less spacing between gizmo handlers (rotate, scale, etc)
tool.gizmo.compact = "Compact";
// When enabled, tapping one the gizmo widget will open a numerical input popup
tool.gizmo.allowInput = "Saisie numérique";
tool.gizmo.allowInput.help = "Autoriser la saisie numérique lors de l'appui sur l'un des widgets de gizmo";
// Angle threshold
tool.gizmo.linearRollThreshold = "Seuil de roulis tangent";
tool.gizmo.linearRollThreshold.help = "Seuil d'angle déterminant le choix entre la méthode de roulis linéaire et la méthode de roulis circulaire.

Au-delà de ce seuil, le roulis sera circulaire.

Si vous préférez utiliser le roulis linéaire (direction de la tangente), réglez cette valeur à 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Masquer lors des interactions";
tool.gizmo.tap = "Appui simple";
tool.gizmo.tap.help = "Cette option ne fonctionne qu'en mode de pivot personnalisé.";
tool.gizmo.tap.none = "Aucun";
tool.gizmo.tap.none.help = "Rien ne se passe lorsque vous appuyez sur le maillage.";
tool.gizmo.tap.normal = "Normale";
tool.gizmo.tap.normal.help = "Déplace le gizmo sur la première intersection et aligne le gizmo suivant la normale de la surface.";
tool.gizmo.tap.first = "Premier coup";
tool.gizmo.tap.first.help = "Déplace le gizmo sur la première intersection.";
tool.gizmo.tap.medial = "Mi-chemin";
tool.gizmo.tap.medial.help = "Déplace le gizmo sur la moyenne des deux premières intersections.";

// The lathe generator is a vertical line and cannot be rotated
tool.lathe.axisFixed = "Fixe";
tool.lathe.axisOnly = "Uniquement l'axe";
tool.lathe.stable = "Stable";
tool.lathe.axis = "Axe";

// Fill the object's hole
tool.hole = "Remplissage du trou";
tool.hole.fillHoles = "Remplir les trous";
// synonym: Alternative method
tool.hole.method.fill = "Remplir";
tool.hole.method.legacy = "Legacy";
tool.hole.method.boolean = "Booléen";
tool.hole.bridges = "Booléen espace écran";
tool.hole.bridges.help = "Si cette option est activée, vous pouvez faire des trous dans le volume.
La pente de découpe suit également de plus près la forme de la découpe.";
tool.hole.threshold = "Epsilon seuil";
tool.hole.threshold.help = "L'ajustement de cette valeur peut améliorer le fonctionnement de l'algorithme de remplissage de trous.";
tool.hole.smoothing = "Lissage des trous";

tool.smudge.quality = "Qualité";
tool.smudge.quality.help = "Cette option modifie la résolution des pixels projetés. Avec des valeurs basses, les traits sont plus rapides.";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Forme";
// Auto-validate the drawn shape
tool.shape.autoValidate = "Validation auto";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Carré";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Centré";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Cercle";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Centré";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Rotation par pas";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Nombre d'or";
// volume of a mesh
tool.measure.volume = "Volume de maillage";
// Surface of a mesh
tool.measure.surface = "Surface";

// Always display the camera shortcut buttons on the viewport
tool.view.stickyCamera = "Raccourci caméra (toujours)";

// Topology
topology = "Topologie";
// Synynom: detail value, density
topology.dynamic.detail = "Détail";
// See glossary
topology.multires = "Multirésolution";
topology.multires.help = "Conservez plusieurs résolutions d'un même maillage.

Si vous effectuez des modifications dans une résolution basse, les détails des résolutions supérieures seront reprojetés lorsque vous changerez de résolution.

Les calques sont disponibles dans chaque résolution.";
// Synonym: Unsubdivide, Un-subdivide
topology.multires.reverse = "Inverser";
topology.multires.reverse.confirm = "Impossible de créer la subdivision de base.

La topologie actuelle n'est probablement pas le résultat d'une subdivision.";
topology.multires.subdivide = "Subdiviser";
topology.multires.subdivide.confirm = "Le maillage aura $0 millions de sommets. Voulez-vous continuer ?";
// Prevents the user from subdivide the object again, a warning is displayed (with a UI link to increase this limit)
topology.multires.subdivide.limit = "Limite de subdivision dépassée, voir $0";
topology.multires.deleteLower = "Supprimer la basse résolution";
topology.multires.deleteHigher = "Supprimer la haute résolution";
topology.multires.keepTriangles = "Conserver les triangles";
topology.multires.lock = "Verrouiller (LV0)";
// Navigate toward multiple resolutions (go to higher level)
topology.multires.up = "Niveau Multires →";
// Navigate toward multiple resolutions (go to lower level)
topology.multires.down = "Niveau Multires ←";
// Synonym: Flat subdivision
topology.multires.linear = "Subdivision linéaire";
topology.multires.linear.help = "Subdivisez simplement le maillage sans appliquer de lissage.";
// Only show the lowest resolution wireframe
topology.multires.minWireframe = "Niveau 0 uniquement";
// Create a new object by recomputing a new topology
topology.remesh = "Remailler";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Remaillage des voxels";
topology.voxel.help = "Remaillage par échantillonnage du maillage sur une grille.

Si l'objet n'est pas fermé (étanche), un algorithme de remplissage de trou sera appliqué au préalable.

Les calques sont reprojetés après le remaillage, mais la qualité sera dégradée.";
topology.voxel.resolution = "Résolution";
topology.voxel.sharp = "Conserver les arêtes";
topology.voxel.sharp.help = "Cette option est surtout utile pour les opérations booléennes simples sur les primitives.

Elle génère une distorsion dans certaines zones, car les points sont alignés sur les arêtes.";
topology.voxel.subLevel = "Construire une multirésolution";
topology.voxel.subLevel.help = "Vous pouvez reconstruire une hiérarchie multirésolution à partir du résultat obtenu après remaillage des voxels. 

Elle fonctionnera également plus rapidement et consommera moins de mémoire, surtout si le niveau de détail des voxels est élevé.
Cependant, si le niveau de détail est faible et que vous demandez beaucoup de niveaux de multirésolution, vous perdrez en détails.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Remailler";
topology.surface.detail = "Détail";
topology.surface.detail.help = "Contrairement au remaillage de voxels, le remaillage de surface ne nécessite pas de fermer le maillage.

Cette fonction peut également gérer le masquage afin de protéger une partie du maillage contre les changements de topologie.

Les calques sont correctement mis à jour.";
topology.surface.method = "Méthode";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Uniformisation";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Subdivision";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Décimation";
topology.surface.method.help = "Comportement de la topologie dynamique :
• Uniformisation : ajout et suppression de détails
• Subdivision : ajout de détails
• Décimation : suppression de détails";
topology.surface.useMasking = "Protéger la zone masquée";
topology.surface.useMasking.help = "Les zones masquées empêcheront la modification de la topologie.";
topology.surface.extrapolate = "Extrapolation du sommet";
// DynTopo
topology.dynamic = "Topologie dynamique";
topology.dynamic.global = "Global activé/désactivé";
topology.dynamic.activate = "Activée";
topology.dynamic.activate.help = "Avec la topologie dynamique, les outils de sculpture peuvent subdiviser ou simplifier le maillage localement en temps réel.

Cette fonction peut avoir un impact notable sur les performances.

Les calques sont correctement mis à jour.";
topology.dynamic.method = "Détail basé sur…";
topology.dynamic.method.screen = "Écran";
topology.dynamic.method.radius = "Rayon";
topology.dynamic.method.constant = "Constante";
topology.dynamic.method.help = "• Zoom
Le niveau de détail est basé sur la distance à laquelle vous vous trouvez par rapport à la surface.

• Rayon
Le rayon de l'outil définit la quantité de détails.

• Constante
Le détail est fixe, et la valeur de détail est également partagée avec le curseur de voxel.";
topology.dynamic.quality = "Préférer…";
topology.dynamic.quality.help = "Le mode Qualité présente deux différences principales :
• L'affinage est appliqué avant l'opérateur de sculpture. Vous obtiendrez moins d'artefacts d'interpolation lorsque vous peindrez ou sculpterez de très petits détails.
• L'affinage n'est pas appliqué de manière incrémentielle. Si vous sculptez de très petits détails ou faites des traits rapides, la topologie sera toujours affinée correctement.";
topology.dynamic.quality.speed = "Vitesse";
topology.dynamic.quality.quality = "Qualité";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Modifier le rayon selon la pression";
topology.dynamic.usePressure.help = "Utilisez cette option si vous souhaitez que l'incidence du niveau de pression du stylet sur le rayon de l'outil influe sur le niveau de détail.";
topology.dynamic.useFalloff = "Utiliser l'atténuation des traits";
// Decimate
topology.decimate.title = "Décimation";
topology.decimate.title.help = "Réduisez le nombre de polygones en essayant de conserver autant de détails que possible.

Cette fonction peut être utile pour exporter votre création en vue d'une impression 3D.
Nous vous déconseillons en revanche de l'utiliser si vous voulez continuer à modifier la sculpture, car elle risque de générer des triangles déséquilibrés.

Notez que la zone masquée ne sera pas décimée.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Décimer";
topology.decimatePaintWeight = "Préserver la peinture";
topology.decimatePaintWeight.help = "Saisissez une valeur élevée pour essayer de préserver la peinture.

Si la peinture vous importe peu, saisissez 0.";
topology.decimateUniform = "Faces uniformes";
topology.decimateUniform.help = "Saisissez une valeur élevée pour générer des triangles de même taille.";
topology.decimatePreserveBorders = "Préserver les bordures";
topology.decimatePreserveBorders.help = "Ne pas décimer la bordure du maillage.";
// Target a certain number of triangles, faces and vertices
topology.target.triangles = "Triangles cibles";
topology.target.faces = "Faces cibles";
topology.target.quads = "Quadrangles cibles";
topology.target.points = "Points cibles";
// Quad remesher
topology.qremesh = "Quad Remesh";
topology.qremesh.angle = "Angle de pli";
topology.qremesh.border = "Préserver les bordures";
topology.qremesh.onlyQuad = "Uniquement des quads";
topology.qremesh.hole = "Max remplissage de trou";
topology.qremesh.hole.help = "
Dépliage UV";

// Unwrapping means compute UV (texture coordinates), with uvs you can appliy (wrap) a texture onto the model
topology.uv.title = "Déplier UV";
// UV Unwrap but as a Verb
topology.uv.unwrap = "Déplier";
// The operation can be very slow
topology.uv.atlas.warning = "L'opération peut être très lente, ciblez moins de 100 000 sommets !";
// Handles are topological holes (synonym: genus, hole)
topology.uv.bff.warning = "Des chevauchements peuvent se produire si le maillage comporte des poignées !";
// Solo patch
topology.uv.bff.seamless = "Patches sans jointure";
topology.uv.bff.seamless.help = "Cette option peut introduire une distorsion importante.

Typiquement, elle peut être utilisée lorsque les groupes de visages sont soigneusement configurés.";
// Synonym: Point count? Singularity count ?
topology.uv.bff.cones = "Nombre de cônes";
topology.uv.bff.help = "Saisissez une valeur élevée pour limiter la distorsion des objets complexes.

Plus la valeur est élevée, plus le temps de calcul sera long.";
topology.uv.delete = "Supprimer les UV";

// Transfer the vertex painting in the texture, bake means "create texture (from mesh data)"
topology.bake.title = "Appliquer";
// Bake here means "create texture (from mesh data)"
topology.bake.title.help = "La cuisson de textures va créer des textures en projetant d'autres objets visibles dans la scène.

Voici le flux de travail typique pour la cuisson :
• Vous avez un maillage avec des détails fins et de la peinture
• Clonez-le
• Dégradez-le (réglez `Préserver la peinture` à 0 !)
• Dépliez-le UV
• Cuisson !

Vous devriez maintenant avoir un maillage basse résolution qui conserve la plupart de la peinture et des détails de votre objet précédent.

Après l'opération, les couleurs des sommets seront déplacées dans une nouvelle couche désactivée, afin qu'elles soient ignorées au lieu d'être multipliées contre la texture colorée.

Afin de choisir quels objets sont utilisés pour le baking, la logique suivante s'appliquera :
- tous les objets sélectionnés et l'objet principal sélectionné seront cuits (la surbrillance la plus forte dans le menu de scène)
- s'il n'y a qu'un seul objet sélectionné, alors Nomad considérera tous les objets visibles à la place
- sinon, si tous les objets sont cachés (par exemple en utilisant Solo), alors l'ensemble de la scène sera pris en compte";
// Bake here means "create texture (from mesh data)"
topology.bake.self = "D'elle-même";
// Bake here means "create texture (from another mesh data)"
topology.bake.other = "De haute résolution";
topology.bake.resolution = "Résolution";
// Cage is a specific term, synonyom: "Bake offset"
topology.bake.offset = "Décalage de rayon";
topology.bake.radius = "Rayon de cage";
// Bake opacity (from mask data)
topology.bake.opacityFromMask = "Masque -> Opacité";
topology.bake.backup = "Sauvegarde";

// project a high resolution mesh details onto another
topology.reproject.title = "Reprojeter";
topology.reproject.title.help = "Projetez les détails sculptés, la peinture et les couches des objets visibles les plus proches.

Ceci est principalement destiné à être utilisé également sur un maillage haute résolution, typiquement avec une topologie propre.";
// tweaking value
topology.reproject.rayBias = "Biais de rayon";
topology.reproject.rayBias.help = "Deux méthodes sont utilisées pour la reprojection :
• le plus proche : le point le plus proche de la surface
• rayon : point d'intersection à travers la direction normale

Des valeurs de biais plus élevées favoriseront l'intersection de rayon plutôt que la surface la plus proche.";
topology.reproject.normalOffset = "Décalage normal";
topology.reproject.shpereCast = "Solution de secours par lancer de sphère";
topology.reproject.shpereCast.help = "Si la reprojection par rayon normal échoue, Nomad utilisera la solution de l'intersection de surface la plus proche.";
// number of iteration the algorithm will take
topology.reproject.iterations = "Itérations";
topology.reproject.relax = "Relâcher";
topology.reproject.relax.help = "Relax devrait être préféré lorsque le maillage est à faible poly.";
topology.reproject.layers.help = "Transférer les autres couches sur le maillage sélectionné.";

topology.manifold = "Variété";
topology.nonManifold = "Non-variété";
topology.manifold.clean = "Nettoyer";
topology.manifold.collapse = "Supprimer les petites faces";
topology.manifold.title = "Forcer la variété";
topology.manifold.title.help = "Essaie de nettoyer l'arête non variété.

Cela peut être utile pour les logiciels externes qui ne prennent pas en charge les arêtes qui ont plus de 2 faces en commun.";

// Reset key-bindings/shortcuts
binding.reset = "Réinitialiser les raccourcis";
// Add node in a sync mode (synchronize instance)
binding.addSync = "Synchroniser";
binding.addSync.help = "Par défaut, il utilisera la valeur de synchronisation définie dans le menu de la scène.";
// Binding option
binding.context.toggle = "Basculer le contexte";
binding.toggleTool = "Basculer les raccourcis d'outil";
binding.toggleTool.help = "Lors de l'utilisation de l'un des raccourcis d'outil, l'outil précédent sera sélectionné si l'outil de raccourci actuel est actif.";
// When the key is tap once, the value will be toggled
binding.toggleTap = "Basculer le raccourci à la frappe de touche";
// The binding force camera movement
binding.forceCamera = "Forcer la caméra";
binding.forceCamera.help = "Forcer l'interaction de la caméra en cas de conflit avec un autre raccourci.

Cela peut généralement se produire si le même raccourci est attribué à un outil ou à un ajout/soustraction.";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickMaterial = "Sélecteur de matériau";
// Same as Color Picker but it pick the material (color, roughness, metalness, etc)
binding.pickFaceGroup = "Sélectionner le groupe de faces";
// Edit the tool brush size/radius
binding.editRadius = "Rayon de l'outil";
// Edit the tool brush size/radius
binding.editIntensity = "Intensité de l'outil";
// Controller dead zone
binding.joystick = "Joystick";
binding.controller.deadZone = "Zone morte du stick";
binding.controller.deadZone.help = "Augmentez cette valeur si la caméra bouge même si le stick du contrôleur reste intact.";
// Snap the camera
binding.view.front = "Vue de Face";
binding.view.left = "Vue de Gauche";
binding.view.top = "Vue de Dessus";
// Move/Translate the view
binding.pan.left = "Déplacer à Gauche";
binding.pan.right = "Panoramique droit (vue";
binding.pan.forward = "Panoramique avant";
binding.pan.backward = "Panoramique arrière";
binding.pan.up = "Panoramique haut";
binding.pan.down = "Panoramique bas";
// Snap the view (while rotating)
binding.snapViewOnRotate = "Aligner la vue (pendant la rotation)";
// Open a Nomad internal project (replace current scene)
binding.project.open = "Ouvrir (projet)";
// Open a Nomad internal project (add it to the current scene)
binding.project.add = "Ajouter (projet)";
// Select all the objects in the scene
binding.selectAll = "Tout sélectionner";
// Rotate environment and the lighting
binding.rotateLighting = "Faire pivoter l'éclairage";
// The Camera pivot is the point around which the camera rotates
binding.updatePivot = "Pivot";

quadremesh.adaptQuadCount = "Nombre de quadrilatères adaptatifs";
quadremesh.curvatureAdaptivness = "Taille adaptative";
quadremesh.curvatureAdaptivness.help = "À 100%, la taille des quadrilatères variera en fonction de la courbure de l'objet, permettant des quadrilatères plus petits sur une courbure élevée.
À 0%, la taille des quadrilatères sera uniforme.";
quadremesh.useVertexColors = "Préserver la peinture";
quadremesh.autoDetectHardEdges = "Détection automatique des arêtes dures";
quadremesh.autoDetectHardEdges.short = "Bords Durs";
quadremesh.reprojectVertex = "Reprojeter le Sommet";
quadremesh.reprojectVertex.short = "Reprojeter le Sommet";
quadremesh.reprojectVertex.label = "Lorsque activé, Nomad reprojètera la position sur le maillage précédent.

Notez que si le maillage a des couches, la reprojection sera toujours utilisée.";

// Privacy policy
privacyPolicy.title = "Règles de confidentialité";
privacyPolicy.reject = "Rejeter";
// Hexanomad is the company name
privacyPolicy = "Hexanomad ne collecte aucune donnée via Nomad Sculpt.";

sonar.disconnect = "Déconnecter SonarPen";
sonar.connect = "Connecter SonarPen";
sonar.connect.confirm = "Connecter SonarPen ?";
sonar.connect.confirm.warning = "Sonar Pen utilisera le microphone (boucle audio) pour détecter la pression du stylet.";

// Color disc mode
widget.color.disc = "Disque";
widget.color.ring = "Anneau";
widget.color.square = "Carré";

nomad.mainFolder = "Dossier principal de Nomad";
nomad.mainFolder.warning = "Les fichiers sont laissés intacts.
Ils ne sont ni copiés, ni supprimés, ni déplacés.";
nomad.mainFolder.error = "Une fois que vous avez sélectionné oui, Nomad se fermera et vous pourrez simplement le relancer.";

license.title = "Licence";
license.retry = "Réessayer";
license.key = "Clé de licence";
license.activate = "Activer la licence";
// ----------------------------------------------
license.newest = "Nouvelle version disponible !";
license.encrypt.error = "Impossible à crypter!";
// ----------------------------------------------
license.grace = "Hors ligne - Période de grâce restante :";
license.grace.hours = "heures";
license.grace.days = "jour";
// ----------------------------------------------
license.portal.title = "Utilisateurs existants";
license.portal.label = "Portail de licence";
// ----------------------------------------------
license.checkout.title = "Nouveaux utilisateurs";
license.checkout.label = "Acheter Nomad";
// ----------------------------------------------
license.device.error = "Impossible d'obtenir l'identifiant de l'appareil.";
license.device.mismatch = "Identification de l'appareil inadéquate !";
// ----------------------------------------------
license.error429 = "Trop de demandes (attendez).";
// ----------------------------------------------
license.validate.error404 = "La clé de licence n’a pas été trouvée.";
license.validate.error422 = "Entité non traitable.";
// ----------------------------------------------
license.activate.error403 = "Nombre maximum d'appareils atteint !
Vous pouvez désactiver un autre appareil sur votre portail de licence.";
license.activate.error404 = "La clé de licence n’a pas été trouvée.";
license.activate.error422 = "Entité non traitable.";
// ----------------------------------------------
// version
version.update = "Mise à jour disponible!";
version.restore = "Restaurer l'achat";
version.buyWeb = "La version Web n'est qu'une démo";
version.buyFull = "Passer à la version complète";
// ----------------------------------------------
// QuadRemesh
version.qr.unlock = "Débloquer (acheter, restaurer, essai)";
version.qr.desktop = "Sur le bureau, le QuadRemesher est distribué par Hexanomad, mais Hexanomad ne gère pas les ventes ou les licences.
Toute la gestion des licences est effectuée par Exoside.";
version.qr.buy = "Acheter";
version.qr.promo = "
Le Quad Remesher est un algorithme qui produit un maillage principalement composé de quadrilatères.
La répartition des quadrilatères tentera de suivre la courbure naturelle de l'objet.

L'algorithme peut également adapter la taille des quadrilatères en fonction de la courbure locale.

Vous pouvez également guider la topologie résultante avec :

• Groupe de faces $0 (assurez-vous de lisser leurs bords pour de meilleurs résultats !)

• Symétrie planaire X/Y/Z $1

• Guides de courbe $2

• Peinture de densité $3

Le Quad Remesher est développé par https://exoside.com/.";
// ----------------------------------------------
version.trialLayer = "Version d'essai : 1 calque par maillage";
version.trialNoExport = "Version d'essai : pas d'exportation";
// ----------------------------------------------
version.fullFeatures = "• Achat définitif
• Opérations Annuler/Rétablir illimitées
• Calques illimités
• Exportation et importation";
// ----------------------------------------------
version.demo.purpose = "Cette version a été créée spécifiquement à des fins de démonstration.";
version.demo.disable = "Fonctionnalité non disponible pour cette démo.";
// ----------------------------------------------
version.demo = "Test de Démo";
version.demo.sculpt = "Sculpter";
version.demo.sculpt.help = "Toutes les brosses sont disponibles, mais vous ne pouvez pas sauvegarder ou exporter.

Ce mode est principalement destiné à expérimenter avec les brosses ou tester le support de pression.

D'autres fonctionnalités peuvent également être limitées (historique, couches).";
version.demo.file = "Importation & Exportation";
version.demo.file.help = "Vous pouvez importer et exporter le modèle, mais les brosses de sculpture sont désactivées.

Ce mode est surtout utile pour les utilisateurs mobiles qui ne peuvent pas ouvrir de gros projets .nom en raison des contraintes de mémoire mobile.";
// ----------------------------------------------
// app store main page
store.name = "Nomad Sculpt";
store.headline = "Sculpture et peinture 3D";
store.tag = "sculpt, 3d, nomad, paint, modeling, sculpter, peindre, modélisation";
// ----------------------------------------------
store.description.sculpt = "• Outils de Sculpture
Clay, aplatir, lisser, masque et de nombreux autres pinceaux vous permettront de façonner votre création.
Vous pouvez également utiliser l'outil de découpe boolean trim avec lasso, rectangle et d'autres formes, pour le hardsurface.";
// ----------------------------------------------
store.description.stroke = "• Personnalisation de tracé
Falloff, alphas, pavages, pression du crayon et d'autres paramètres de tracé peuvent être personnalisés.
Vous pouvez également sauvegarder et charger votre préréglage d'outils.";
// ----------------------------------------------
store.description.paint = "• Outils de peinture
Peinture de sommet avec couleur, roughness et metalness.
Vous pouvez également gérer facilement tous vos préréglages de matériaux.";
// ----------------------------------------------
store.description.layer = "• Calques
Enregistrez vos opérations de sculpture et de peinture dans des calques séparés pour faciliter l'itération pendant le processus de création.
Les changements de sculpture et de peinture sont enregistrés.";
// ----------------------------------------------
store.description.multires = "• Sculpture multirésolution
Naviguez entre plusieurs résolutions de votre maillage pour un flux de travail flexible.";
// ----------------------------------------------
store.description.voxel = "• Voxel remeshing
Remailler rapidement votre mesh pour obtenir un niveau de détail uniforme.
Cela peut être utilisé pour esquisser rapidement une forme grossière au début du processus de création.";
// ----------------------------------------------
store.description.dynamic = "• Topologie dynamique
Affinez localement votre mesh sous votre pinceau pour obtenir un niveau de détail automatique.
Vous pouvez aussi conserver vos calques, car ils seront automatiquement mis à jour !";
// ----------------------------------------------
store.description.topology = "• Décimer
Réduisez le nombre de polygones tout en conservant autant de détails que possible.";
// ----------------------------------------------
store.description.group = "• Face Group
Segmentez votre mesh en sous-groupes avec l'outil de face group.";
// ----------------------------------------------
store.description.unwrap = "• Dépliage UV automatique
Le dépliage UV automatique peut utiliser les face groups pour contrôler le processus de dépliage.";
// ----------------------------------------------
store.description.baking = "• Baking
Vous pouvez transférer les données de sommet telles que la couleur, roughness, metalness et les détails de petite échelle dans des textures.
Vous pouvez également faire l'inverse, transférant les données de textures dans les données de sommet ou calques.";
// ----------------------------------------------
store.description.primitive = "• Forme primitive
Cylindre, torus, tube, tour et d'autres primitives peuvent être utilisées pour commencer rapidement de nouvelles formes à partir de zéro.";
// ----------------------------------------------
store.description.rendering = "• Rendu PBR
Beau rendu PBR par défaut, avec éclairage et ombres.
Vous pouvez toujours passer en MatCap pour un ombrage plus standard pour des fins de sculpture.";
// ----------------------------------------------
store.description.postprocess = "• Post-process
Screen Space Reflection, Depth of Field, Ambient Occlusion, Tone mapping, etc";
// ----------------------------------------------
store.description.files = "• Export et Import
Les formats pris en charge incluent les fichiers glTF, OBJ, STL ou PLY.";
// ----------------------------------------------
store.description.interface = "• Interface
Interface facile à utiliser, conçue pour l'expérience mobile.
La personnalisation est possible également !";
// ----------------------------------------------
store.description.remesher = "• Quad Remesher (achat in-app séparé uniquement)
Remesh automatiquement votre objet avec un mesh dominant en quads qui suit les courbures du mesh.
Il prend en charge les guides, les face groups et la peinture de densité.";
// ----------------------------------------------